[
    {
        "repo_name": "Alluxio/alluxio",
        "commit_id": "c1daabcbd9a604557d7ca3d05d3d8a63f95d2885",
        "commit_url": "https://github.com/Alluxio/alluxio/commit/c1daabcbd9a604557d7ca3d05d3d8a63f95d2885",
        "focal_db": {
            "id": "237961",
            "rel_path": "core/common/src/main/java/alluxio/util/SecurityUtils.java",
            "method_src": "public static String getGroupFromGrpcClient() {\n    try {\n      User user = AuthenticatedClientUser.get();\n      if (user == null) {\n        return \"\";\n      }\n      return CommonUtils.getPrimaryGroupName(user.getName());\n    } catch (IOException e) {\n      return \"\";\n    }\n  }",
            "method_tgt": "public static String getGroupFromGrpcClient(AlluxioConfiguration conf) {\n    try {\n      User user = AuthenticatedClientUser.get(conf);\n      if (user == null) {\n        return \"\";\n      }\n      return CommonUtils.getPrimaryGroupName(user.getName(), conf);\n    } catch (IOException e) {\n      return \"\";\n    }\n  }"
        },
        "test_db": {
            "id": "238019",
            "rel_path": "core/common/src/test/java/alluxio/util/SecurityUtilsTest.java",
            "method_src": "@Test\n  public void getGroupFromGrpcClient() throws Exception {\n    // When security is not enabled, user and group are not set\n    Configuration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.NOSASL.getAuthName());\n    Assert.assertEquals(\"\", SecurityUtils.getGroupFromGrpcClient());\n\n    Configuration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());\n    Configuration.set(PropertyKey.SECURITY_GROUP_MAPPING_CLASS,\n        IdentityUserGroupsMapping.class.getName());\n    AuthenticatedClientUser.set(\"test_client_user\");\n    Assert.assertEquals(\"test_client_user\", SecurityUtils.getGroupFromGrpcClient());\n  }",
            "method_tgt": "@Test\n  public void getGroupFromGrpcClient() throws Exception {\n    // When security is not enabled, user and group are not set\n    mConfiguration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.NOSASL.getAuthName());\n    Assert.assertEquals(\"\", SecurityUtils.getGroupFromGrpcClient(mConfiguration));\n\n    mConfiguration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());\n    mConfiguration.set(PropertyKey.SECURITY_GROUP_MAPPING_CLASS,\n        IdentityUserGroupsMapping.class.getName());\n    AuthenticatedClientUser.set(\"test_client_user\");\n    Assert.assertEquals(\"test_client_user\", SecurityUtils.getGroupFromGrpcClient(mConfiguration));\n  }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        }
    },
    {
        "repo_name": "Alluxio/alluxio",
        "commit_id": "c1daabcbd9a604557d7ca3d05d3d8a63f95d2885",
        "commit_url": "https://github.com/Alluxio/alluxio/commit/c1daabcbd9a604557d7ca3d05d3d8a63f95d2885",
        "focal_db": {
            "id": "237961",
            "rel_path": "core/common/src/main/java/alluxio/util/CommonUtils.java",
            "method_src": "public static String getTmpDir() {\n    Preconditions.checkState(!TMP_DIRS.isEmpty(), \"No temporary directories configured\");\n    if (TMP_DIRS.size() == 1) {\n      return TMP_DIRS.get(0);\n    }\n    // Use existing random instead of ThreadLocal because contention is not expected to be high.\n    return TMP_DIRS.get(RANDOM.nextInt(TMP_DIRS.size()));\n  }",
            "method_tgt": "public static String getTmpDir(List<String> tmpDirs) {\n    Preconditions.checkState(!tmpDirs.isEmpty(), \"No temporary directories available\");\n    if (tmpDirs.size() == 1) {\n      return tmpDirs.get(0);\n    }\n    // Use existing random instead of ThreadLocal because contention is not expected to be high.\n    return tmpDirs.get(RANDOM.nextInt(tmpDirs.size()));\n  }"
        },
        "test_db": {
            "id": "238019",
            "rel_path": "core/common/src/test/java/alluxio/util/CommonUtilsTest.java",
            "method_src": "@Test\n  public void getTmpDir() {\n    // Test single tmp dir\n    String singleDir = \"/tmp\";\n    Whitebox.setInternalState(CommonUtils.class, \"TMP_DIRS\", Collections.singletonList(singleDir));\n    assertEquals(singleDir, CommonUtils.getTmpDir());\n    // Test multiple tmp dir\n    List<String> multiDirs = Arrays.asList(\"/tmp1\", \"/tmp2\", \"/tmp3\");\n    Whitebox.setInternalState(CommonUtils.class, \"TMP_DIRS\", multiDirs);\n    Set<String> results = new HashSet<>();\n    for (int i = 0; i < 100 || results.size() != multiDirs.size(); i++) {\n      results.add(CommonUtils.getTmpDir());\n    }\n    assertEquals(new HashSet<>(multiDirs), results);\n    Whitebox.setInternalState(CommonUtils.class, \"TMP_DIRS\",\n        Configuration.getList(PropertyKey.TMP_DIRS, \",\"));\n  }",
            "method_tgt": "@Test\n  public void getTmpDir() {\n\n    // Test single tmp dir\n    String singleDir = \"/tmp\";\n    List<String> singleDirList = Arrays.asList(\"/tmp\");\n    assertEquals(singleDir, CommonUtils.getTmpDir(singleDirList));\n    // Test multiple tmp dir\n    List<String> multiDirs = Arrays.asList(\"/tmp1\", \"/tmp2\", \"/tmp3\");\n    Set<String> results = new HashSet<>();\n    for (int i = 0; i < 100 || results.size() != multiDirs.size(); i++) {\n      results.add(CommonUtils.getTmpDir(multiDirs));\n    }\n    assertEquals(new HashSet<>(multiDirs), results);\n  }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 1
    },
    {
        "repo_name": "Alluxio/alluxio",
        "commit_id": "2f929cf48cb17c26ade7bbdd2a75fc10af514b04",
        "commit_url": "https://github.com/Alluxio/alluxio/commit/2f929cf48cb17c26ade7bbdd2a75fc10af514b04",
        "focal_db": {
            "id": "256727",
            "rel_path": "core/common/src/main/java/alluxio/util/FormatUtils.java",
            "method_src": "public static String formatPermission(short permission, boolean isDirectory) {\n    StringBuffer permissionStr = new StringBuffer();\n    if (isDirectory) {\n      permissionStr.append(\"d\");\n    } else {\n      permissionStr.append(\"-\");\n    }\n    permissionStr.append(new Mode(permission).toString());\n    return permissionStr.toString();\n  }",
            "method_tgt": "public static String formatMode(short mode, boolean directory) {\n    StringBuffer str = new StringBuffer();\n    if (directory) {\n      str.append(\"d\");\n    } else {\n      str.append(\"-\");\n    }\n    str.append(new Mode(mode).toString());\n    return str.toString();\n  }"
        },
        "test_db": {
            "id": "256736",
            "rel_path": "core/common/src/test/java/alluxio/util/FormatUtilsTest.java",
            "method_src": "@Test\n  public void formatPermissionTest() {\n    Assert.assertEquals(\"-rw-rw-rw-\", FormatUtils.formatPermission((short) 0666, false));\n    Assert.assertEquals(\"drw-rw-rw-\", FormatUtils.formatPermission((short) 0666, true));\n    Assert.assertEquals(\"-rwxrwxrwx\", FormatUtils.formatPermission((short) 0777, false));\n    Assert.assertEquals(\"drwxrwxrwx\", FormatUtils.formatPermission((short) 0777, true));\n    Assert.assertEquals(\"-r--r--r--\", FormatUtils.formatPermission((short) 0444, false));\n    Assert.assertEquals(\"dr--r--r--\", FormatUtils.formatPermission((short) 0444, true));\n    Assert.assertEquals(\"-r-xr-xr-x\", FormatUtils.formatPermission((short) 0555, false));\n    Assert.assertEquals(\"dr-xr-xr-x\", FormatUtils.formatPermission((short) 0555, true));\n    Assert.assertEquals(\"-rwxr-xr--\", FormatUtils.formatPermission((short) 0754, false));\n    Assert.assertEquals(\"drwxr-xr--\", FormatUtils.formatPermission((short) 0754, true));\n  }",
            "method_tgt": "@Test\n  public void formatPermissionTest() {\n    Assert.assertEquals(\"-rw-rw-rw-\", FormatUtils.formatMode((short) 0666, false));\n    Assert.assertEquals(\"drw-rw-rw-\", FormatUtils.formatMode((short) 0666, true));\n    Assert.assertEquals(\"-rwxrwxrwx\", FormatUtils.formatMode((short) 0777, false));\n    Assert.assertEquals(\"drwxrwxrwx\", FormatUtils.formatMode((short) 0777, true));\n    Assert.assertEquals(\"-r--r--r--\", FormatUtils.formatMode((short) 0444, false));\n    Assert.assertEquals(\"dr--r--r--\", FormatUtils.formatMode((short) 0444, true));\n    Assert.assertEquals(\"-r-xr-xr-x\", FormatUtils.formatMode((short) 0555, false));\n    Assert.assertEquals(\"dr-xr-xr-x\", FormatUtils.formatMode((short) 0555, true));\n    Assert.assertEquals(\"-rwxr-xr--\", FormatUtils.formatMode((short) 0754, false));\n    Assert.assertEquals(\"drwxr-xr--\", FormatUtils.formatMode((short) 0754, true));\n  }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 1,
            "param_types": 0,
            "throw_types": 0
        }
    },
    {
        "repo_name": "Alluxio/alluxio",
        "commit_id": "c0cccaeef8defb2dc464452ec4f68c07f96f067d",
        "commit_url": "https://github.com/Alluxio/alluxio/commit/c0cccaeef8defb2dc464452ec4f68c07f96f067d",
        "focal_db": {
            "id": "259110",
            "rel_path": "core/common/src/main/java/alluxio/security/authorization/PermissionStatus.java",
            "method_src": "public PermissionStatus applyUMask(FileSystemPermission umask, Configuration configuration) {\n    if (!SecurityUtils.isAuthorizationEnabled(configuration)) {\n      return new PermissionStatus(mUserName, mGroupName, mPermission);\n    }\n    FileSystemPermission newFileSystemPermission = mPermission.applyUMask(umask);\n    return new PermissionStatus(mUserName, mGroupName, newFileSystemPermission);\n  }",
            "method_tgt": "public PermissionStatus applyUMask(FileSystemPermission umask) {\n    FileSystemPermission newFileSystemPermission = mPermission.applyUMask(umask);\n    return new PermissionStatus(mUserName, mGroupName, newFileSystemPermission);\n  }"
        },
        "test_db": {
            "id": "259113",
            "rel_path": "core/common/src/test/java/alluxio/security/authorization/PermissionStatusTest.java",
            "method_src": "@Test\n  public void applyUMaskTest() {\n    FileSystemPermission umaskPermission = new FileSystemPermission((short) 0022);\n    PermissionStatus permissionStatus =\n        new PermissionStatus(\"user1\", \"group1\", FileSystemPermission.getDefault());\n    Configuration conf = new Configuration();\n    conf.set(Constants.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());\n    conf.set(Constants.SECURITY_AUTHORIZATION_PERMISSION_ENABLED, \"true\");\n    permissionStatus = permissionStatus.applyUMask(umaskPermission, conf);\n\n    Assert.assertEquals(FileSystemAction.ALL, permissionStatus.getPermission().getUserAction());\n    Assert.assertEquals(FileSystemAction.READ_EXECUTE,\n        permissionStatus.getPermission().getGroupAction());\n    Assert.assertEquals(FileSystemAction.READ_EXECUTE,\n        permissionStatus.getPermission().getOtherAction());\n    Assert.assertEquals(0755, permissionStatus.getPermission().toShort());\n  }",
            "method_tgt": "@Test\n  public void applyUMaskTest() {\n    FileSystemPermission umaskPermission = new FileSystemPermission((short) 0022);\n    PermissionStatus permissionStatus =\n        new PermissionStatus(\"user1\", \"group1\", FileSystemPermission.getDefault());\n    permissionStatus = permissionStatus.applyUMask(umaskPermission);\n\n    Assert.assertEquals(FileSystemAction.ALL, permissionStatus.getPermission().getUserAction());\n    Assert.assertEquals(FileSystemAction.READ_EXECUTE,\n        permissionStatus.getPermission().getGroupAction());\n    Assert.assertEquals(FileSystemAction.READ_EXECUTE,\n        permissionStatus.getPermission().getOtherAction());\n    Assert.assertEquals(0755, permissionStatus.getPermission().toShort());\n  }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        }
    },
    {
        "repo_name": "Alluxio/alluxio",
        "commit_id": "8cc5a292f4c6e38ed0066ce5bd700cc946dc3803",
        "commit_url": "https://github.com/Alluxio/alluxio/commit/8cc5a292f4c6e38ed0066ce5bd700cc946dc3803",
        "focal_db": {
            "id": "236947",
            "rel_path": "core/client/fs/src/main/java/alluxio/client/file/BaseFileSystem.java",
            "method_src": "@Override\n  public void mount(AlluxioURI alluxioPath, AlluxioURI ufsPath, MountOptions options)\n      throws IOException, AlluxioException {\n    checkUri(alluxioPath);\n    FileSystemMasterClient masterClient = mFileSystemContext.acquireMasterClient();\n    try {\n      // TODO(calvin): Make this fail on the master side\n      masterClient.mount(alluxioPath, ufsPath, options);\n      LOG.info(\"Mount \" + ufsPath.toString() + \" to \" + alluxioPath.getPath());\n    } catch (UnavailableException e) {\n      throw e;\n    } catch (AlluxioStatusException e) {\n      throw e.toAlluxioException();\n    } finally {\n      mFileSystemContext.releaseMasterClient(masterClient);\n    }\n  }",
            "method_tgt": "@Override\n  public void mount(AlluxioURI alluxioPath, AlluxioURI ufsPath, MountPOptions options)\n      throws IOException, AlluxioException {\n    checkUri(alluxioPath);\n    FileSystemMasterClient masterClient = mFileSystemContext.acquireMasterClient();\n    try {\n      // TODO(calvin): Make this fail on the master side\n      masterClient.mount(alluxioPath, ufsPath, options);\n      LOG.info(\"Mount \" + ufsPath.toString() + \" to \" + alluxioPath.getPath());\n    } catch (UnavailableException e) {\n      throw e;\n    } catch (AlluxioStatusException e) {\n      throw e.toAlluxioException();\n    } finally {\n      mFileSystemContext.releaseMasterClient(masterClient);\n    }\n  }"
        },
        "test_db": {
            "id": "236990",
            "rel_path": "core/client/fs/src/test/java/alluxio/client/file/BaseFileSystemTest.java",
            "method_src": "@Test\n  public void mount() throws Exception {\n    AlluxioURI alluxioPath = new AlluxioURI(\"/t\");\n    AlluxioURI ufsPath = new AlluxioURI(\"/u\");\n    MountOptions mountOptions = MountOptions.defaults();\n    doNothing().when(mFileSystemMasterClient).mount(alluxioPath, ufsPath, mountOptions);\n    mFileSystem.mount(alluxioPath, ufsPath, mountOptions);\n    verify(mFileSystemMasterClient).mount(alluxioPath, ufsPath, mountOptions);\n\n    verifyFilesystemContextAcquiredAndReleased();\n  }",
            "method_tgt": "@Test\n  public void mount() throws Exception {\n    AlluxioURI alluxioPath = new AlluxioURI(\"/t\");\n    AlluxioURI ufsPath = new AlluxioURI(\"/u\");\n    MountPOptions mountOptions = MountPOptions.getDefaultInstance();\n    doNothing().when(mFileSystemMasterClient).mount(alluxioPath, ufsPath, mountOptions);\n    mFileSystem.mount(alluxioPath, ufsPath, mountOptions);\n    verify(mFileSystemMasterClient).mount(alluxioPath, ufsPath, mountOptions);\n\n    verifyFilesystemContextAcquiredAndReleased();\n  }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 0
    },
    {
        "repo_name": "Alluxio/alluxio",
        "commit_id": "8cc5a292f4c6e38ed0066ce5bd700cc946dc3803",
        "commit_url": "https://github.com/Alluxio/alluxio/commit/8cc5a292f4c6e38ed0066ce5bd700cc946dc3803",
        "focal_db": {
            "id": "236947",
            "rel_path": "core/server/master/src/main/java/alluxio/master/block/DefaultBlockMaster.java",
            "method_src": "@Override\n  public void workerRegister(long workerId, List<String> storageTiers,\n      Map<String, Long> totalBytesOnTiers, Map<String, Long> usedBytesOnTiers,\n      Map<String, List<Long>> currentBlocksOnTiers,\n      RegisterWorkerTOptions options) throws NotFoundException {\n\n    MasterWorkerInfo worker = mWorkers.getFirstByField(ID_INDEX, workerId);\n\n    if (worker == null) {\n      worker = findUnregisteredWorker(workerId);\n    }\n\n    if (worker == null) {\n      throw new NotFoundException(ExceptionMessage.NO_WORKER_FOUND.getMessage(workerId));\n    }\n\n    // Gather all blocks on this worker.\n    HashSet<Long> blocks = new HashSet<>();\n    for (List<Long> blockIds : currentBlocksOnTiers.values()) {\n      blocks.addAll(blockIds);\n    }\n\n    synchronized (worker) {\n      worker.updateLastUpdatedTimeMs();\n      // Detect any lost blocks on this worker.\n      Set<Long> removedBlocks = worker.register(mGlobalStorageTierAssoc, storageTiers,\n          totalBytesOnTiers, usedBytesOnTiers, blocks);\n      processWorkerRemovedBlocks(worker, removedBlocks);\n      processWorkerAddedBlocks(worker, currentBlocksOnTiers);\n      processWorkerOrphanedBlocks(worker);\n    }\n    if (options.isSetConfigList()) {\n      List<alluxio.wire.ConfigProperty> wireConfigList = options.getConfigList()\n          .stream().map(alluxio.wire.ConfigProperty::fromThrift)\n          .collect(Collectors.toList());\n      for (BiConsumer<Address, List<ConfigProperty>> function : mWorkerRegisteredListeners) {\n        WorkerNetAddress workerAddress = worker.getWorkerAddress();\n        function.accept(new Address(workerAddress.getHost(), workerAddress.getRpcPort()),\n            wireConfigList);\n      }\n    }\n\n    registerWorkerInternal(workerId);\n\n    LOG.info(\"registerWorker(): {}\", worker);\n  }",
            "method_tgt": "@Override\n  public void workerRegister(long workerId, List<String> storageTiers,\n      Map<String, Long> totalBytesOnTiers, Map<String, Long> usedBytesOnTiers,\n      Map<String, List<Long>> currentBlocksOnTiers,\n      RegisterWorkerPOptions options) throws NotFoundException {\n\n    MasterWorkerInfo worker = mWorkers.getFirstByField(ID_INDEX, workerId);\n\n    if (worker == null) {\n      worker = findUnregisteredWorker(workerId);\n    }\n\n    if (worker == null) {\n      throw new NotFoundException(ExceptionMessage.NO_WORKER_FOUND.getMessage(workerId));\n    }\n\n    // Gather all blocks on this worker.\n    HashSet<Long> blocks = new HashSet<>();\n    for (List<Long> blockIds : currentBlocksOnTiers.values()) {\n      blocks.addAll(blockIds);\n    }\n\n    synchronized (worker) {\n      worker.updateLastUpdatedTimeMs();\n      // Detect any lost blocks on this worker.\n      Set<Long> removedBlocks = worker.register(mGlobalStorageTierAssoc, storageTiers,\n          totalBytesOnTiers, usedBytesOnTiers, blocks);\n      processWorkerRemovedBlocks(worker, removedBlocks);\n      processWorkerAddedBlocks(worker, currentBlocksOnTiers);\n      processWorkerOrphanedBlocks(worker);\n    }\n    if (options.getConfigsCount() > 0) {\n      for (BiConsumer<Address, List<ConfigProperty>> function : mWorkerRegisteredListeners) {\n        WorkerNetAddress workerAddress = worker.getWorkerAddress();\n        function.accept(new Address(workerAddress.getHost(), workerAddress.getRpcPort()),\n            options.getConfigsList());\n      }\n    }\n\n    registerWorkerInternal(workerId);\n\n    LOG.info(\"registerWorker(): {}\", worker);\n  }"
        },
        "test_db": {
            "id": "236990",
            "rel_path": "core/server/master/src/test/java/alluxio/master/block/BlockMasterTest.java",
            "method_src": "@Test\n  public void countBytes() throws Exception {\n    // Register two workers\n    long worker1 = mBlockMaster.getWorkerId(NET_ADDRESS_1);\n    long worker2 = mBlockMaster.getWorkerId(NET_ADDRESS_2);\n    List<String> tiers = Arrays.asList(\"MEM\", \"SSD\");\n    Map<String, Long> worker1TotalBytesOnTiers = ImmutableMap.of(\"MEM\", 10L, \"SSD\", 20L);\n    Map<String, Long> worker2TotalBytesOnTiers = ImmutableMap.of(\"MEM\", 1000L, \"SSD\", 2000L);\n    Map<String, Long> worker1UsedBytesOnTiers = ImmutableMap.of(\"MEM\", 1L, \"SSD\", 2L);\n    Map<String, Long> worker2UsedBytesOnTiers = ImmutableMap.of(\"MEM\", 100L, \"SSD\", 200L);\n    mBlockMaster.workerRegister(worker1, tiers, worker1TotalBytesOnTiers, worker1UsedBytesOnTiers,\n        NO_BLOCKS_ON_TIERS, new RegisterWorkerTOptions());\n    mBlockMaster.workerRegister(worker2, tiers, worker2TotalBytesOnTiers, worker2UsedBytesOnTiers,\n        NO_BLOCKS_ON_TIERS, new RegisterWorkerTOptions());\n\n    // Check that byte counts are summed correctly.\n    assertEquals(3030, mBlockMaster.getCapacityBytes());\n    assertEquals(303L, mBlockMaster.getUsedBytes());\n    assertEquals(ImmutableMap.of(\"MEM\", 1010L, \"SSD\", 2020L),\n        mBlockMaster.getTotalBytesOnTiers());\n    assertEquals(ImmutableMap.of(\"MEM\", 101L, \"SSD\", 202L),\n        mBlockMaster.getUsedBytesOnTiers());\n  }",
            "method_tgt": "@Test\n  public void countBytes() throws Exception {\n    // Register two workers\n    long worker1 = mBlockMaster.getWorkerId(NET_ADDRESS_1);\n    long worker2 = mBlockMaster.getWorkerId(NET_ADDRESS_2);\n    List<String> tiers = Arrays.asList(\"MEM\", \"SSD\");\n    Map<String, Long> worker1TotalBytesOnTiers = ImmutableMap.of(\"MEM\", 10L, \"SSD\", 20L);\n    Map<String, Long> worker2TotalBytesOnTiers = ImmutableMap.of(\"MEM\", 1000L, \"SSD\", 2000L);\n    Map<String, Long> worker1UsedBytesOnTiers = ImmutableMap.of(\"MEM\", 1L, \"SSD\", 2L);\n    Map<String, Long> worker2UsedBytesOnTiers = ImmutableMap.of(\"MEM\", 100L, \"SSD\", 200L);\n    mBlockMaster.workerRegister(worker1, tiers, worker1TotalBytesOnTiers, worker1UsedBytesOnTiers,\n        NO_BLOCKS_ON_TIERS, RegisterWorkerPOptions.getDefaultInstance());\n    mBlockMaster.workerRegister(worker2, tiers, worker2TotalBytesOnTiers, worker2UsedBytesOnTiers,\n        NO_BLOCKS_ON_TIERS, RegisterWorkerPOptions.getDefaultInstance());\n\n    // Check that byte counts are summed correctly.\n    assertEquals(3030, mBlockMaster.getCapacityBytes());\n    assertEquals(303L, mBlockMaster.getUsedBytes());\n    assertEquals(ImmutableMap.of(\"MEM\", 1010L, \"SSD\", 2020L),\n        mBlockMaster.getTotalBytesOnTiers());\n    assertEquals(ImmutableMap.of(\"MEM\", 101L, \"SSD\", 202L),\n        mBlockMaster.getUsedBytesOnTiers());\n  }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 1
    },
    {
        "repo_name": "Alluxio/alluxio",
        "commit_id": "e2d4f90be1bd523215bcb099361f5305f7d78a0d",
        "commit_url": "https://github.com/Alluxio/alluxio/commit/e2d4f90be1bd523215bcb099361f5305f7d78a0d",
        "focal_db": {
            "id": "255326",
            "rel_path": "core/common/src/main/java/alluxio/security/authorization/Permission.java",
            "method_src": "public Permission setUserFromThriftClient(Configuration conf) throws IOException {\n    if (!SecurityUtils.isAuthenticationEnabled(conf)) {\n      // no authentication, no user to set\n      return this;\n    }\n    // get the username through the authentication mechanism\n    User user = AuthenticatedClientUser.get(conf);\n    Preconditions.checkNotNull(user, ExceptionMessage.AUTHORIZED_CLIENT_USER_IS_NULL.getMessage());\n    mUserName = user.getName();\n    mGroupName = CommonUtils.getPrimaryGroupName(conf, user.getName());\n    return this;\n  }",
            "method_tgt": "public Permission setUserFromThriftClient() throws IOException {\n    if (!SecurityUtils.isAuthenticationEnabled()) {\n      // no authentication, no user to set\n      return this;\n    }\n    // get the username through the authentication mechanism\n    User user = AuthenticatedClientUser.get();\n    Preconditions.checkNotNull(user, ExceptionMessage.AUTHORIZED_CLIENT_USER_IS_NULL.getMessage());\n    mUserName = user.getName();\n    mGroupName = CommonUtils.getPrimaryGroupName(user.getName());\n    return this;\n  }"
        },
        "test_db": {
            "id": "255385",
            "rel_path": "core/common/src/test/java/alluxio/security/authorization/PermissionTest.java",
            "method_src": "@Test\n  public void setUserFromLoginModuleTest() throws Exception {\n    Configuration conf = new Configuration();\n    Permission permission = Permission.defaults();\n\n    // When security is not enabled, user and group are not set\n    conf.set(Constants.SECURITY_AUTHENTICATION_TYPE, AuthType.NOSASL.getAuthName());\n    permission.setUserFromThriftClient(conf);\n    verifyPermission(\"\", \"\", (short) 0777, permission);\n\n    // When authentication is enabled, user and group are inferred from login module\n    conf.set(Constants.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());\n    conf.set(Constants.SECURITY_LOGIN_USERNAME, \"test_login_user\");\n    conf.set(Constants.SECURITY_GROUP_MAPPING, IdentityUserGroupsMapping.class.getName());\n    Whitebox.setInternalState(LoginUser.class, \"sLoginUser\", (String) null);\n\n    permission.setUserFromLoginModule(conf);\n    verifyPermission(\"test_login_user\", \"test_login_user\", (short) 0777, permission);\n  }",
            "method_tgt": "@Test\n  public void setUserFromLoginModuleTest() throws Exception {\n    Configuration.defaultInit();\n    Permission permission = Permission.defaults();\n\n    // When security is not enabled, user and group are not set\n    Configuration.set(Constants.SECURITY_AUTHENTICATION_TYPE, AuthType.NOSASL.getAuthName());\n    permission.setUserFromThriftClient();\n    verifyPermission(\"\", \"\", (short) 0777, permission);\n\n    // When authentication is enabled, user and group are inferred from login module\n    Configuration.set(Constants.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());\n    Configuration.set(Constants.SECURITY_LOGIN_USERNAME, \"test_login_user\");\n    Configuration.set(Constants.SECURITY_GROUP_MAPPING, IdentityUserGroupsMapping.class.getName());\n    Whitebox.setInternalState(LoginUser.class, \"sLoginUser\", (String) null);\n\n    permission.setUserFromLoginModule();\n    verifyPermission(\"test_login_user\", \"test_login_user\", (short) 0777, permission);\n  }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        }
    },
    {
        "repo_name": "Alluxio/alluxio",
        "commit_id": "c1daabcbd9a604557d7ca3d05d3d8a63f95d2885",
        "commit_url": "https://github.com/Alluxio/alluxio/commit/c1daabcbd9a604557d7ca3d05d3d8a63f95d2885",
        "focal_db": {
            "id": "237969",
            "rel_path": "core/common/src/main/java/alluxio/util/io/FileUtils.java",
            "method_src": "public static void createBlockPath(String path) throws IOException {\n    try {\n      createStorageDirPath(PathUtils.getParent(path));\n    } catch (InvalidPathException e) {\n      throw new IOException(\"Failed to create block path, get parent path of \" + path + \"failed\",\n          e);\n    } catch (IOException e) {\n      throw new IOException(\"Failed to create block path \" + path, e);\n    }\n  }",
            "method_tgt": "public static void createBlockPath(String path, String workerDataFolderPermissions)\n      throws IOException {\n    try {\n      createStorageDirPath(PathUtils.getParent(path), workerDataFolderPermissions);\n    } catch (InvalidPathException e) {\n      throw new IOException(\"Failed to create block path, get parent path of \" + path + \"failed\",\n          e);\n    } catch (IOException e) {\n      throw new IOException(\"Failed to create block path \" + path, e);\n    }\n  }"
        },
        "test_db": {
            "id": "238021",
            "rel_path": "core/common/src/test/java/alluxio/util/io/FileUtilsTest.java",
            "method_src": "@Test\n  public void createBlockPath() throws IOException {\n    String absolutePath = PathUtils.concatPath(mTestFolder.getRoot(), \"tmp\", \"bar\");\n    File tempFile = new File(absolutePath);\n    FileUtils.createBlockPath(tempFile.getAbsolutePath());\n    assertTrue(FileUtils.exists(tempFile.getParent()));\n  }",
            "method_tgt": "@Test\n  public void createBlockPath() throws IOException {\n    String absolutePath = PathUtils.concatPath(mTestFolder.getRoot(), \"tmp\", \"bar\");\n    File tempFile = new File(absolutePath);\n    FileUtils.createBlockPath(tempFile.getAbsolutePath(), mWorkerDataFolderPerms);\n    assertTrue(FileUtils.exists(tempFile.getParent()));\n  }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        }
    },
    {
        "repo_name": "BaseXdb/basex",
        "commit_id": "ae7bbc6d0228b9f64cc30c7f2bbb4a18531d07c3",
        "commit_url": "https://github.com/BaseXdb/basex/commit/ae7bbc6d0228b9f64cc30c7f2bbb4a18531d07c3",
        "focal_db": {
            "id": "4664486",
            "rel_path": "src/main/java/org/basex/query/util/ItemList.java",
            "method_src": "public Item[] toArray() {\n    return Arrays.copyOf(values, size());\n  }",
            "method_tgt": "public Item[] finish() {\n    assert size > 0 : \"List is empty.\";\n    \n    Item[] its = new Item[size];\n    System.arraycopy(values, 0, its, 0, size);\n    values = new Item[CAP];\n    size = 0;\n    return its;\n  }"
        },
        "test_db": {
            "id": "4664487",
            "rel_path": "src/test/java/org/basex/test/util/ItemListTest.java",
            "method_src": "@Test \n  public final void testToArray() {\n    ItemList il = new ItemList(Itr.ZERO);\n    for(int i = 0; i < CAP - 1; i++) {\n      il.add(Itr.ZERO);\n    }\n    assertEquals(CAP, il.toArray().length); \n    assertEquals(il.size(), il.toArray().length);\n  }",
            "method_tgt": "@Test \n  public final void testToArray() {\n    ItemList il = new ItemList(Itr.ZERO);\n    for(int i = 0; i < CAP - 1; i++) {\n      il.add(Itr.ZERO);\n    }\n    assertEquals(CAP, il.finish().length); \n  }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 1,
            "param_types": 0,
            "throw_types": 0
        }
    },
    {
        "repo_name": "CorfuDB/CorfuDB",
        "commit_id": "4802caf05280aae3584bcbb531aab1eee99b934b",
        "commit_url": "https://github.com/CorfuDB/CorfuDB/commit/4802caf05280aae3584bcbb531aab1eee99b934b",
        "focal_db": {
            "id": "1711883",
            "rel_path": "runtime/src/main/java/org/corfudb/runtime/clients/ManagementClient.java",
            "method_src": "public CompletableFuture<Boolean> handleFailure(Map nodes) {\n        return router.sendMessageAndGetCompletable(CorfuMsgType.MANAGEMENT_FAILURE_DETECTED.payloadMsg(new FailureDetectorMsg(nodes)));\n    }",
            "method_tgt": "public CompletableFuture<Boolean> handleFailure(Set nodes) {\n        return router.sendMessageAndGetCompletable(CorfuMsgType.MANAGEMENT_FAILURE_DETECTED.payloadMsg(new FailureDetectorMsg(nodes)));\n    }"
        },
        "test_db": {
            "id": "1711887",
            "rel_path": "test/src/test/java/org/corfudb/runtime/clients/ManagementClientTest.java",
            "method_src": "@Test\n    public void handleFailure()\n            throws Exception {\n\n        // Since the servers are started as single nodes thus already bootstrapped.\n        Map map = new HashMap<String, Boolean>();\n        map.put(\"Key\", true);\n        assertThat(client.handleFailure(map).get()).isEqualTo(true);\n    }",
            "method_tgt": "@Test\n    public void handleFailure()\n            throws Exception {\n\n        // Since the servers are started as single nodes thus already bootstrapped.\n        Set<String> set = new HashSet<>();\n        set.add(\"Key\");\n        assertThat(client.handleFailure(set).get()).isEqualTo(true);\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        }
    },
    {
        "repo_name": "CorfuDB/CorfuDB",
        "commit_id": "4802caf05280aae3584bcbb531aab1eee99b934b",
        "commit_url": "https://github.com/CorfuDB/CorfuDB/commit/4802caf05280aae3584bcbb531aab1eee99b934b",
        "focal_db": {
            "id": "1711883",
            "rel_path": "infrastructure/src/main/java/org/corfudb/infrastructure/PeriodicPollPolicy.java",
            "method_src": "@Override\n    public HashMap<String, Boolean> getServerStatus() {\n\n        HashMap<String, Boolean> status_change = new HashMap<>();\n        long newCorrectEpoch = -1;\n        if (historyPollCount > 3) {\n            Boolean is_up;\n\n            // Simple failure detector: Is there a change in health?\n            for (int i = 0; i < historyServers.length; i++) {\n                // TODO: Be a bit smarter than 'more than 2 failures in a row'\n\n                // Block until we complete the previous polling round.\n                try {\n                    pollCompletableFutures[i].get();\n                } catch (InterruptedException | ExecutionException e) {\n                    log.error(\"Error in polling task for server {} : {}\", historyServers[i], e);\n                }\n\n                is_up = !(historyPollFailures[i] >= failedPollLimit);\n                if (is_up != historyStatus.get(historyServers[i])) {\n                    log.debug(\"Change of status: \" + historyServers[i] + \" \" +\n                            historyStatus.get(historyServers[i]) + \" -> \" + is_up);\n                    status_change.put(historyServers[i], is_up);\n\n                    // Resetting the failure counter.\n                    historyPollFailures[i] = 0;\n                }\n                if (historyPollEpochExceptions[i] != -1) {\n                    newCorrectEpoch = newCorrectEpoch < historyPollEpochExceptions[i] ? historyPollEpochExceptions[i] : newCorrectEpoch;\n                    // Reset epoch exception value.\n                    historyPollEpochExceptions[i] = -1;\n                }\n            }\n        }\n        if (newCorrectEpoch == -1 && status_change.isEmpty()) {\n            return null;\n        }\n        return status_change;\n    }",
            "method_tgt": "@Override\n    public PollReport getServerStatus() {\n\n        Set<String> failingNodes = new HashSet<>();\n        HashMap<String, Long> outOfPhaseEpochNodes = new HashMap<>();\n\n        long newCorrectEpoch = -1;\n        if (historyPollCount > 3) {\n            Boolean is_up;\n\n            // Simple failure detector: Is there a change in health?\n            for (int i = 0; i < historyServers.length; i++) {\n                // TODO: Be a bit smarter than 'more than 2 failures in a row'\n\n                // Block until we complete the previous polling round.\n                try {\n                    pollCompletableFutures[i].get();\n                } catch (InterruptedException | ExecutionException e) {\n                    log.error(\"Error in polling task for server {} : {}\", historyServers[i], e);\n                }\n\n                // The count remains within the interval 0 <= failureCount <= failedPollLimit(3)\n                is_up = !(historyPollFailures[i] >= failedPollLimit);\n                // Toggle if server was up and now not responding\n                if (!is_up) {\n                    log.debug(\"Change of status: \" + historyServers[i] + \" \" +\n                            historyStatus.get(historyServers[i]) + \" -> \" + is_up);\n                    failingNodes.add(historyServers[i]);\n                    historyStatus.put(historyServers[i], is_up);\n                    historyPollFailures[i]--;\n                } else if (!historyStatus.get(historyServers[i])) {\n                    // If server was down but now responsive so wait till reaches lower watermark (0).\n                    if (historyPollFailures[i] > 0) {\n                        if (--historyPollFailures[i] == 0) {\n                            log.debug(\"Change of status: \" + historyServers[i] + \" \" +\n                                    historyStatus.get(historyServers[i]) + \" -> \" + true);\n                            historyStatus.put(historyServers[i], true);\n                        } else {\n                            // Server still down\n                            failingNodes.add(historyServers[i]);\n                        }\n                    }\n                }\n                if (historyPollEpochExceptions[i] != -1) {\n                    outOfPhaseEpochNodes.put(historyServers[i], historyPollEpochExceptions[i]);\n                    // Reset epoch exception value.\n                    historyPollEpochExceptions[i] = -1;\n                }\n            }\n        }\n        return new PollReport.PollReportBuilder()\n                .setFailingNodes(failingNodes)\n                .setOutOfPhaseEpochNodes(outOfPhaseEpochNodes)\n                .build();\n    }"
        },
        "test_db": {
            "id": "1711887",
            "rel_path": "test/src/test/java/org/corfudb/infrastructure/PeriodicPollPolicyTest.java",
            "method_src": "@Test\n    public void successfulPolling() throws InterruptedException {\n\n        for (int i = 0; i < PARAMETERS.CONCURRENCY_SOME; i++) {\n            failureDetectorPolicy.executePolicy(layout, corfuRuntime);\n            Thread.sleep(PARAMETERS.TIMEOUT_VERY_SHORT.toMillis());\n        }\n\n        // A little more than responseTimeout for periodicPolling\n        Thread.sleep(PARAMETERS.TIMEOUT_SHORT.toMillis());\n        Map<String, Boolean> result = failureDetectorPolicy.getServerStatus();\n        assertThat(result).isNull();\n\n    }",
            "method_tgt": "@Test\n    public void successfulPolling() throws InterruptedException {\n\n        for (int i = 0; i < PARAMETERS.CONCURRENCY_SOME; i++) {\n            failureDetectorPolicy.executePolicy(layout, corfuRuntime);\n            Thread.sleep(PARAMETERS.TIMEOUT_VERY_SHORT.toMillis());\n        }\n\n        // A little more than responseTimeout for periodicPolling\n        Thread.sleep(PARAMETERS.TIMEOUT_SHORT.toMillis());\n        PollReport result = failureDetectorPolicy.getServerStatus();\n        assertThat(result.getIsFailurePresent()).isFalse();\n\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 0,
            "param_types": 0,
            "throw_types": 0
        },
        "aug": 1
    },
    {
        "repo_name": "CorfuDB/CorfuDB",
        "commit_id": "4802caf05280aae3584bcbb531aab1eee99b934b",
        "commit_url": "https://github.com/CorfuDB/CorfuDB/commit/4802caf05280aae3584bcbb531aab1eee99b934b",
        "focal_db": {
            "id": "1711883",
            "rel_path": "infrastructure/src/main/java/org/corfudb/infrastructure/PeriodicPollPolicy.java",
            "method_src": "@Override\n    public HashMap<String, Boolean> getServerStatus() {\n\n        HashMap<String, Boolean> status_change = new HashMap<>();\n        long newCorrectEpoch = -1;\n        if (historyPollCount > 3) {\n            Boolean is_up;\n\n            // Simple failure detector: Is there a change in health?\n            for (int i = 0; i < historyServers.length; i++) {\n                // TODO: Be a bit smarter than 'more than 2 failures in a row'\n\n                // Block until we complete the previous polling round.\n                try {\n                    pollCompletableFutures[i].get();\n                } catch (InterruptedException | ExecutionException e) {\n                    log.error(\"Error in polling task for server {} : {}\", historyServers[i], e);\n                }\n\n                is_up = !(historyPollFailures[i] >= failedPollLimit);\n                if (is_up != historyStatus.get(historyServers[i])) {\n                    log.debug(\"Change of status: \" + historyServers[i] + \" \" +\n                            historyStatus.get(historyServers[i]) + \" -> \" + is_up);\n                    status_change.put(historyServers[i], is_up);\n\n                    // Resetting the failure counter.\n                    historyPollFailures[i] = 0;\n                }\n                if (historyPollEpochExceptions[i] != -1) {\n                    newCorrectEpoch = newCorrectEpoch < historyPollEpochExceptions[i] ? historyPollEpochExceptions[i] : newCorrectEpoch;\n                    // Reset epoch exception value.\n                    historyPollEpochExceptions[i] = -1;\n                }\n            }\n        }\n        if (newCorrectEpoch == -1 && status_change.isEmpty()) {\n            return null;\n        }\n        return status_change;\n    }",
            "method_tgt": "@Override\n    public PollReport getServerStatus() {\n\n        Set<String> failingNodes = new HashSet<>();\n        HashMap<String, Long> outOfPhaseEpochNodes = new HashMap<>();\n\n        long newCorrectEpoch = -1;\n        if (historyPollCount > 3) {\n            Boolean is_up;\n\n            // Simple failure detector: Is there a change in health?\n            for (int i = 0; i < historyServers.length; i++) {\n                // TODO: Be a bit smarter than 'more than 2 failures in a row'\n\n                // Block until we complete the previous polling round.\n                try {\n                    pollCompletableFutures[i].get();\n                } catch (InterruptedException | ExecutionException e) {\n                    log.error(\"Error in polling task for server {} : {}\", historyServers[i], e);\n                }\n\n                // The count remains within the interval 0 <= failureCount <= failedPollLimit(3)\n                is_up = !(historyPollFailures[i] >= failedPollLimit);\n                // Toggle if server was up and now not responding\n                if (!is_up) {\n                    log.debug(\"Change of status: \" + historyServers[i] + \" \" +\n                            historyStatus.get(historyServers[i]) + \" -> \" + is_up);\n                    failingNodes.add(historyServers[i]);\n                    historyStatus.put(historyServers[i], is_up);\n                    historyPollFailures[i]--;\n                } else if (!historyStatus.get(historyServers[i])) {\n                    // If server was down but now responsive so wait till reaches lower watermark (0).\n                    if (historyPollFailures[i] > 0) {\n                        if (--historyPollFailures[i] == 0) {\n                            log.debug(\"Change of status: \" + historyServers[i] + \" \" +\n                                    historyStatus.get(historyServers[i]) + \" -> \" + true);\n                            historyStatus.put(historyServers[i], true);\n                        } else {\n                            // Server still down\n                            failingNodes.add(historyServers[i]);\n                        }\n                    }\n                }\n                if (historyPollEpochExceptions[i] != -1) {\n                    outOfPhaseEpochNodes.put(historyServers[i], historyPollEpochExceptions[i]);\n                    // Reset epoch exception value.\n                    historyPollEpochExceptions[i] = -1;\n                }\n            }\n        }\n        return new PollReport.PollReportBuilder()\n                .setFailingNodes(failingNodes)\n                .setOutOfPhaseEpochNodes(outOfPhaseEpochNodes)\n                .build();\n    }"
        },
        "test_db": {
            "id": "1711887",
            "rel_path": "test/src/test/java/org/corfudb/infrastructure/PeriodicPollPolicyTest.java",
            "method_src": "@Test\n    public void failedPolling() throws InterruptedException {\n\n        addServerRule(SERVERS.PORT_0, new TestRule().always().drop());\n        addServerRule(SERVERS.PORT_1, new TestRule().always().drop());\n        addServerRule(SERVERS.PORT_2, new TestRule().always().drop());\n\n        Map<String, Boolean> expectedResult = new HashMap<>();\n        expectedResult.put(getEndpoint(SERVERS.PORT_0), false);\n        expectedResult.put(getEndpoint(SERVERS.PORT_1), false);\n        expectedResult.put(getEndpoint(SERVERS.PORT_2), false);\n\n        pollAndMatchExpectedResult(expectedResult);\n\n        /*\n         * Restarting the server SERVERS.PORT_0. Pings should work normally now.\n         * This is also to demonstrate that we no longer receive the failed\n         * nodes' status in the result map for SERVERS.PORT_0.\n         */\n\n        clearServerRules(SERVERS.PORT_0);\n        // Has only SERVERS.PORT_1 & SERVERS.PORT_2\n        expectedResult.remove(getEndpoint(SERVERS.PORT_0));\n\n        pollAndMatchExpectedResult(expectedResult);\n\n    }",
            "method_tgt": "@Test\n    public void failedPolling() throws InterruptedException {\n\n        addServerRule(SERVERS.PORT_0, new TestRule().always().drop());\n        addServerRule(SERVERS.PORT_1, new TestRule().always().drop());\n        addServerRule(SERVERS.PORT_2, new TestRule().always().drop());\n\n        Set<String> expectedResult = new HashSet<>();\n        expectedResult.add(getEndpoint(SERVERS.PORT_0));\n        expectedResult.add(getEndpoint(SERVERS.PORT_1));\n        expectedResult.add(getEndpoint(SERVERS.PORT_2));\n\n        pollAndMatchExpectedResult(expectedResult);\n\n        /*\n         * Restarting the server SERVERS.PORT_0. Pings should work normally now.\n         * This is also to demonstrate that we no longer receive the failed\n         * nodes' status in the result map for SERVERS.PORT_0.\n         */\n\n        clearServerRules(SERVERS.PORT_0);\n        // Has only SERVERS.PORT_1 & SERVERS.PORT_2\n        expectedResult.remove(getEndpoint(SERVERS.PORT_0));\n\n        pollAndMatchExpectedResult(expectedResult);\n\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 0,
            "param_types": 0,
            "throw_types": 0
        },
        "aug": 2
    },
    {
        "repo_name": "DSpace/DSpace",
        "commit_id": "87cd7145c9d24bcc1812ae200012e875fc61aff2",
        "commit_url": "https://github.com/DSpace/DSpace/commit/87cd7145c9d24bcc1812ae200012e875fc61aff2",
        "focal_db": {
            "id": "1813285",
            "rel_path": "dspace-api/src/main/java/org/dspace/content/MetadataValue.java",
            "method_src": "public int getItemId()\n    {\n        return itemId;\n    }",
            "method_tgt": "public int getResourceId() {\n        return resourceId;\n    }"
        },
        "test_db": {
            "id": "1813343",
            "rel_path": "dspace-api/src/test/java/org/dspace/content/MetadataValueTest.java",
            "method_src": "@Test\n    public void testGetItemId() \n    {\n        assertTrue(\"testGetItemId 0\", mv.getItemId() >= 0);\n    }",
            "method_tgt": "@Test\n    public void testGetItemId() \n    {\n        assertTrue(\"testGetItemId 0\", mv.getResourceId() >= 0);\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 1,
            "param_types": 0,
            "throw_types": 0
        }
    },
    {
        "repo_name": "DSpace/DSpace",
        "commit_id": "87cd7145c9d24bcc1812ae200012e875fc61aff2",
        "commit_url": "https://github.com/DSpace/DSpace/commit/87cd7145c9d24bcc1812ae200012e875fc61aff2",
        "focal_db": {
            "id": "1813285",
            "rel_path": "dspace-api/src/main/java/org/dspace/content/MetadataValue.java",
            "method_src": "public void setItemId(int itemId)\n    {\n        this.itemId = itemId;\n    }",
            "method_tgt": "public void setResourceId(int resourceId) {\n        this.resourceId = resourceId;\n    }"
        },
        "test_db": {
            "id": "1813343",
            "rel_path": "dspace-api/src/test/java/org/dspace/content/MetadataValueTest.java",
            "method_src": "@Test\n    public void testSetItemId()\n    {\n        int itemId = 55;\n        mv.setItemId(itemId);\n        assertThat(\"testSetItemId 0\", mv.getItemId(), equalTo(itemId));\n    }",
            "method_tgt": "@Test\n    public void testSetItemId()\n    {\n        int itemId = 55;\n        mv.setResourceId(itemId);\n        mv.setResourceTypeId(Constants.ITEM);\n        assertThat(\"testSetItemId 0\", mv.getResourceId(), equalTo(itemId));\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 1,
            "param_types": 0,
            "throw_types": 0
        },
        "aug": 1
    },
    {
        "repo_name": "DSpace/DSpace",
        "commit_id": "54222f3c1d3c63bd03af263703a950e9cfad7439",
        "commit_url": "https://github.com/DSpace/DSpace/commit/54222f3c1d3c63bd03af263703a950e9cfad7439",
        "focal_db": {
            "id": "1811381",
            "rel_path": "dspace-api/src/main/java/org/dspace/content/Bitstream.java",
            "method_src": "public BitstreamFormat getFormat()\n    {\n        return bitstreamFormat;\n    }",
            "method_tgt": "public BitstreamFormat getFormat(Context context) throws SQLException\n    {\n        return getBitstreamService().getFormat(context, this);\n    }"
        },
        "test_db": {
            "id": "1811813",
            "rel_path": "dspace-api/src/test/java/org/dspace/content/BitstreamTest.java",
            "method_src": "@Test\n    public void testGetFormat() throws SQLException\n    {\n        assertThat(\"testGetFormat 0\", bs.getFormat(), notNullValue());\n        assertThat(\"testGetFormat 1\", bs.getFormat(), equalTo(BitstreamFormat.findUnknown(context)));\n    }",
            "method_tgt": "@Test\n    public void testGetFormat() throws SQLException\n    {\n        assertThat(\"testGetFormat 0\", bs.getFormat(context), notNullValue());\n        assertThat(\"testGetFormat 1\", bs.getFormat(context), equalTo(bitstreamFormatService.findUnknown(context)));\n    }"
        },
        "syn_diff": {
            "overall": 2,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 1
        }
    },
    {
        "repo_name": "DSpace/DSpace",
        "commit_id": "8db0faed33f145488aea23efbb30ab5a732a8572",
        "commit_url": "https://github.com/DSpace/DSpace/commit/8db0faed33f145488aea23efbb30ab5a732a8572",
        "focal_db": {
            "id": "1808884",
            "rel_path": "dspace-api/src/main/java/org/dspace/content/MetadataValue.java",
            "method_src": "public int getValueId()\n    {\n        return valueId;\n    }",
            "method_tgt": "public Integer getID()\n    {\n        return id;\n    }"
        },
        "test_db": {
            "id": "1808913",
            "rel_path": "dspace-api/src/test/java/org/dspace/content/MetadataValueTest.java",
            "method_src": "@Test\n    public void testGetValueId() \n    {\n        assertThat(\"testGetValueId 0\",mv.getValueId(), notNullValue());\n    }",
            "method_tgt": "@Test\n    public void testGetValueId() \n    {\n        assertThat(\"testGetValueId 0\",mv.getID(), notNullValue());\n    }"
        },
        "syn_diff": {
            "overall": 2,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 1,
            "param_types": 0,
            "throw_types": 0
        }
    },
    {
        "repo_name": "GoogleContainerTools/jib",
        "commit_id": "3030cde3f4790c06b87062215a19ad0219442d0f",
        "commit_url": "https://github.com/GoogleContainerTools/jib/commit/3030cde3f4790c06b87062215a19ad0219442d0f",
        "focal_db": {
            "id": "5062009",
            "rel_path": "jib-core/src/main/java/com/google/cloud/tools/jib/registry/ErrorResponseUtil.java",
            "method_src": "public static ErrorCodes getErrorCode(HttpResponseException responseException)\n      throws HttpResponseException {\n    // Obtain the error response code.\n    String errorContent = responseException.getContent();\n    if (errorContent == null) {\n      throw responseException;\n    }\n\n    try {\n      ErrorResponseTemplate errorResponse =\n          JsonTemplateMapper.readJson(errorContent, ErrorResponseTemplate.class);\n      List<ErrorEntryTemplate> errors = errorResponse.getErrors();\n      // There may be multiple error objects\n      if (errors.size() == 1) {\n        String errorCodeString = errors.get(0).getCode();\n        // May not get an error code back.\n        if (errorCodeString != null) {\n          // throws IllegalArgumentException if unknown error code\n          return ErrorCodes.valueOf(errorCodeString);\n        }\n      }\n\n    } catch (IOException | IllegalArgumentException ex) {\n      // Parse exception: either isn't an error object or unknown error code\n    }\n\n    // rethrow the original exception\n    throw responseException;\n  }",
            "method_tgt": "public static ErrorCodes getErrorCode(ResponseException responseException)\n      throws ResponseException {\n    // Obtain the error response code.\n    String errorContent = responseException.getContent();\n    if (errorContent == null) {\n      throw responseException;\n    }\n\n    try {\n      ErrorResponseTemplate errorResponse =\n          JsonTemplateMapper.readJson(errorContent, ErrorResponseTemplate.class);\n      List<ErrorEntryTemplate> errors = errorResponse.getErrors();\n      // There may be multiple error objects\n      if (errors.size() == 1) {\n        String errorCodeString = errors.get(0).getCode();\n        // May not get an error code back.\n        if (errorCodeString != null) {\n          // throws IllegalArgumentException if unknown error code\n          return ErrorCodes.valueOf(errorCodeString);\n        }\n      }\n\n    } catch (IOException | IllegalArgumentException ex) {\n      // Parse exception: either isn't an error object or unknown error code\n    }\n\n    // rethrow the original exception\n    throw responseException;\n  }"
        },
        "test_db": {
            "id": "5062018",
            "rel_path": "jib-core/src/test/java/com/google/cloud/tools/jib/registry/ErrorResponseUtilTest.java",
            "method_src": "@Test\n  public void testGetErrorCode_invalidErrorObject() {\n    Mockito.when(responseException.getContent())\n        .thenReturn(\"{\\\"type\\\":\\\"other\\\",\\\"message\\\":\\\"some other object\\\"}\");\n    try {\n      ErrorResponseUtil.getErrorCode(responseException);\n      Assert.fail();\n    } catch (HttpResponseException ex) {\n      Assert.assertSame(responseException, ex);\n    }\n  }",
            "method_tgt": "@Test\n  public void testGetErrorCode_invalidErrorObject() {\n    Mockito.when(responseException.getContent())\n        .thenReturn(\"{\\\"type\\\":\\\"other\\\",\\\"message\\\":\\\"some other object\\\"}\");\n    try {\n      ErrorResponseUtil.getErrorCode(responseException);\n      Assert.fail();\n    } catch (ResponseException ex) {\n      Assert.assertSame(responseException, ex);\n    }\n  }"
        },
        "syn_diff": {
            "overall": 2,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 1
        }
    },
    {
        "repo_name": "GoogleContainerTools/jib",
        "commit_id": "3030cde3f4790c06b87062215a19ad0219442d0f",
        "commit_url": "https://github.com/GoogleContainerTools/jib/commit/3030cde3f4790c06b87062215a19ad0219442d0f",
        "focal_db": {
            "id": "5062009",
            "rel_path": "jib-core/src/main/java/com/google/cloud/tools/jib/registry/ErrorResponseUtil.java",
            "method_src": "public static ErrorCodes getErrorCode(HttpResponseException responseException)\n      throws HttpResponseException {\n    // Obtain the error response code.\n    String errorContent = responseException.getContent();\n    if (errorContent == null) {\n      throw responseException;\n    }\n\n    try {\n      ErrorResponseTemplate errorResponse =\n          JsonTemplateMapper.readJson(errorContent, ErrorResponseTemplate.class);\n      List<ErrorEntryTemplate> errors = errorResponse.getErrors();\n      // There may be multiple error objects\n      if (errors.size() == 1) {\n        String errorCodeString = errors.get(0).getCode();\n        // May not get an error code back.\n        if (errorCodeString != null) {\n          // throws IllegalArgumentException if unknown error code\n          return ErrorCodes.valueOf(errorCodeString);\n        }\n      }\n\n    } catch (IOException | IllegalArgumentException ex) {\n      // Parse exception: either isn't an error object or unknown error code\n    }\n\n    // rethrow the original exception\n    throw responseException;\n  }",
            "method_tgt": "public static ErrorCodes getErrorCode(ResponseException responseException)\n      throws ResponseException {\n    // Obtain the error response code.\n    String errorContent = responseException.getContent();\n    if (errorContent == null) {\n      throw responseException;\n    }\n\n    try {\n      ErrorResponseTemplate errorResponse =\n          JsonTemplateMapper.readJson(errorContent, ErrorResponseTemplate.class);\n      List<ErrorEntryTemplate> errors = errorResponse.getErrors();\n      // There may be multiple error objects\n      if (errors.size() == 1) {\n        String errorCodeString = errors.get(0).getCode();\n        // May not get an error code back.\n        if (errorCodeString != null) {\n          // throws IllegalArgumentException if unknown error code\n          return ErrorCodes.valueOf(errorCodeString);\n        }\n      }\n\n    } catch (IOException | IllegalArgumentException ex) {\n      // Parse exception: either isn't an error object or unknown error code\n    }\n\n    // rethrow the original exception\n    throw responseException;\n  }"
        },
        "test_db": {
            "id": "5062018",
            "rel_path": "jib-core/src/test/java/com/google/cloud/tools/jib/registry/ErrorResponseUtilTest.java",
            "method_src": "@Test\n  public void testGetErrorCode_knownErrorCode() throws HttpResponseException {\n    Mockito.when(responseException.getContent())\n        .thenReturn(\n            \"{\\\"errors\\\":[{\\\"code\\\":\\\"MANIFEST_INVALID\\\",\\\"message\\\":\\\"manifest invalid\\\",\\\"detail\\\":{}}]}\");\n\n    Assert.assertSame(\n        ErrorCodes.MANIFEST_INVALID, ErrorResponseUtil.getErrorCode(responseException));\n  }",
            "method_tgt": "@Test\n  public void testGetErrorCode_knownErrorCode() throws ResponseException {\n    Mockito.when(responseException.getContent())\n        .thenReturn(\n            \"{\\\"errors\\\":[{\\\"code\\\":\\\"MANIFEST_INVALID\\\",\\\"message\\\":\\\"manifest invalid\\\",\\\"detail\\\":{}}]}\");\n\n    Assert.assertSame(\n        ErrorCodes.MANIFEST_INVALID, ErrorResponseUtil.getErrorCode(responseException));\n  }"
        },
        "syn_diff": {
            "overall": 2,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 1
        },
        "aug": 1
    },
    {
        "repo_name": "Hive2Hive/Hive2Hive",
        "commit_id": "07eb8f0dad0707bdc53b3f49794d942756230d96",
        "commit_url": "https://github.com/Hive2Hive/Hive2Hive/commit/07eb8f0dad0707bdc53b3f49794d942756230d96",
        "focal_db": {
            "id": "2242335",
            "rel_path": "org.hive2hive.core/src/org/hive2hive/core/network/data/DataManager.java",
            "method_src": "public FuturePut changeProtectionKey(Number160 locationKey, Number160 domainKey, Number160 contentKey,\n\t\t\tint ttl, KeyPair oldProtectionKey, KeyPair newProtectionKey) {\n\t\tlogger.debug(String.format(\n\t\t\t\t\"change protection key; location key = '%s' domain key = '%s' content key = '%s'\",\n\t\t\t\tlocationKey, domainKey, contentKey));\n\t\ttry {\n\n\t\t\tif (newProtectionKey == null) {\n\t\t\t\tlogger.error(\"Cannot change the protection key to null value\");\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\t// create dummy object to change the protection key\n\t\t\t\tData data = new Data();\n\t\t\t\tdata.ttlSeconds(ttl);\n\n\t\t\t\t// create a meta duplicate\n\t\t\t\tdata = data.setProtectedEntry().sign(newProtectionKey, signatureFactory).duplicateMeta();\n\n\t\t\t\t// the content will be protected after this put\n\t\t\t\tif (oldProtectionKey == null) {\n\t\t\t\t\t// the content is protected for the first time\n\t\t\t\t\treturn getPeer().put(locationKey).setData(contentKey, data).setDomainKey(domainKey)\n\t\t\t\t\t\t\t.keyPair(newProtectionKey).start();\n\t\t\t\t} else {\n\t\t\t\t\t// change the protection keys\n\t\t\t\t\treturn getPeer().put(locationKey).setData(contentKey, data).setDomainKey(domainKey)\n\t\t\t\t\t\t\t.keyPair(oldProtectionKey).start();\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException | InvalidKeyException | SignatureException e) {\n\t\t\tlogger.error(String\n\t\t\t\t\t.format(\"Change the protection key failed. location key = '%s' domain key = '%s' content key = '%s' exception = '%s'\",\n\t\t\t\t\t\t\tlocationKey, domainKey, contentKey, e.getMessage()));\n\t\t\treturn null;\n\t\t}\n\t}",
            "method_tgt": "public FuturePut changeProtectionKey(Number160 locationKey, Number160 domainKey, Number160 contentKey,\n\t\t\tNumber160 versionKey, Number160 basedOnKey, int ttl, KeyPair oldProtectionKey,\n\t\t\tKeyPair newProtectionKey, byte[] hash) {\n\t\tlogger.debug(String\n\t\t\t\t.format(\"change content protection key location key = '%s' domain key = '%s' content key = '%s' version key '%s'\",\n\t\t\t\t\t\tlocationKey, domainKey, contentKey, versionKey));\n\t\ttry {\n\t\t\t// create dummy object to change the protection key\n\t\t\tData data = new Data().ttlSeconds(ttl).basedOn(basedOnKey);\n\n\t\t\t// encrypt hash with new key pair to get the new signature (without having the data object)\n\t\t\tCipher rsa = Cipher.getInstance(\"RSA\");\n\t\t\trsa.init(Cipher.ENCRYPT_MODE, newProtectionKey.getPrivate());\n\t\t\tbyte[] newSignature = rsa.doFinal(hash);\n\n\t\t\t// sign duplicated meta (don't forget to set signed flag)\n\t\t\tdata = data.signature(signatureCodec.decode(newSignature)).signed(true).duplicateMeta();\n\n\t\t\t// change the protection key through a put meta\n\t\t\treturn getPeer().put(locationKey).setDomainKey(domainKey).putMeta().setData(contentKey, data)\n\t\t\t\t\t.setVersionKey(versionKey).keyPair(oldProtectionKey).start();\n\t\t} catch (IOException | InvalidKeyException | NoSuchAlgorithmException | NoSuchPaddingException\n\t\t\t\t| IllegalBlockSizeException | BadPaddingException e) {\n\t\t\tlogger.error(String\n\t\t\t\t\t.format(\"Change protection key failed. location key = '%s' domain key = '%s' content key = '%s' version key = '%s' exception = '%s'\",\n\t\t\t\t\t\t\tlocationKey, domainKey, contentKey, versionKey, e.getMessage()));\n\t\t\treturn null;\n\t\t}\n\t}"
        },
        "test_db": {
            "id": "2242334",
            "rel_path": "org.hive2hive.core.test/src/org/hive2hive/core/test/network/data/DataManagerTest.java",
            "method_src": "@Test\n\tpublic void testChangeProtectionKey() throws NoPeerConnectionException, IOException {\n\t\tKeyPair keypair1 = EncryptionUtil.generateRSAKeyPair();\n\t\tKeyPair keypair2 = EncryptionUtil.generateRSAKeyPair();\n\n\t\tNumber160 locationKey = Number160.createHash(NetworkTestUtil.randomString());\n\t\tNumber160 domainKey = H2HConstants.TOMP2P_DEFAULT_KEY;\n\t\tNumber160 contentKey = Number160.createHash(NetworkTestUtil.randomString());\n\n\t\tNetworkManager node = network.get(random.nextInt(networkSize));\n\n\t\t// put some initial data with keypair1\n\t\tH2HTestData data1v0 = new H2HTestData(NetworkTestUtil.randomString());\n\t\tdata1v0.generateVersionKey();\n\t\tdata1v0.setBasedOnKey(Number160.ZERO);\n\t\tFuturePut putFuture1 = node.getDataManager().put(locationKey, domainKey, contentKey, data1v0,\n\t\t\t\tkeypair1);\n\t\tputFuture1.awaitUninterruptibly();\n\t\tAssert.assertTrue(putFuture1.isSuccess());\n\n\t\t// put 1st version with keypair 1\n\t\tH2HTestData data1v1 = new H2HTestData(NetworkTestUtil.randomString());\n\t\tdata1v1.generateVersionKey();\n\t\tdata1v1.setBasedOnKey(data1v0.getVersionKey());\n\t\tFuturePut putFuture2 = node.getDataManager().put(locationKey, domainKey, contentKey, data1v1,\n\t\t\t\tkeypair1);\n\t\tputFuture2.awaitUninterruptibly();\n\t\tAssert.assertTrue(putFuture2.isSuccess());\n\n\t\t// change protection key (during putting a new version)\n\t\tH2HTestData data1v2 = new H2HTestData(NetworkTestUtil.randomString());\n\t\tdata1v2.generateVersionKey();\n\t\tdata1v2.setBasedOnKey(data1v1.getVersionKey());\n\t\tFuturePut changeFuture1 = node.getDataManager().changeProtectionKey(locationKey, domainKey,\n\t\t\t\tcontentKey, data1v2.getTimeToLive(), keypair1, keypair2);\n\t\tchangeFuture1.awaitUninterruptibly();\n\t\tAssert.assertTrue(changeFuture1.isSuccess());\n\n\t\t// try to put a new version with the old protection key\n\t\tH2HTestData data1v3 = new H2HTestData(NetworkTestUtil.randomString());\n\t\tdata1v3.generateVersionKey();\n\t\tdata1v3.setBasedOnKey(data1v2.getVersionKey());\n\t\tFuturePut changeFuture2 = node.getDataManager().put(locationKey, domainKey, contentKey, data1v3,\n\t\t\t\tkeypair1);\n\t\tchangeFuture2.awaitUninterruptibly();\n\t\tAssert.assertFalse(changeFuture2.isSuccess());\n\t}",
            "method_tgt": "@Test\n\tpublic void testChangeProtectionKey() throws NoPeerConnectionException, IOException, InvalidKeyException,\n\t\t\tSignatureException {\n\t\tKeyPair keypairOld = EncryptionUtil.generateRSAKeyPair();\n\t\tKeyPair keypairNew = EncryptionUtil.generateRSAKeyPair();\n\n\t\tNumber160 locationKey = Number160.createHash(NetworkTestUtil.randomString());\n\t\tNumber160 domainKey = H2HConstants.TOMP2P_DEFAULT_KEY;\n\t\tNumber160 contentKey = Number160.createHash(NetworkTestUtil.randomString());\n\n\t\tNetworkManager node = network.get(random.nextInt(networkSize));\n\n\t\t// put some initial data\n\t\tH2HSharableTestData data = new H2HSharableTestData(NetworkTestUtil.randomString());\n\t\tdata.generateVersionKey();\n\t\tdata.setBasedOnKey(Number160.ZERO);\n\t\tFuturePut putFuture1 = node.getDataManager()\n\t\t\t\t.put(locationKey, domainKey, contentKey, data, keypairOld);\n\t\tputFuture1.awaitUninterruptibly();\n\t\tAssert.assertTrue(putFuture1.isSuccess());\n\n\t\t// change content protection key\n\t\tFuturePut changeFuture = node.getDataManager().changeProtectionKey(locationKey, domainKey,\n\t\t\t\tcontentKey, data.getVersionKey(), data.getBasedOnKey(), data.getTimeToLive(), keypairOld,\n\t\t\t\tkeypairNew, data.getHash());\n\t\tchangeFuture.awaitUninterruptibly();\n\t\tAssert.assertTrue(changeFuture.isSuccess());\n\n\t\t// verify if content protection key has been changed\n\t\tData resData = node.getDataManager().get(locationKey, domainKey, contentKey, data.getVersionKey())\n\t\t\t\t.awaitUninterruptibly().getData();\n\t\tAssert.assertTrue(resData.verify(keypairNew.getPublic(), new H2HSignatureFactory()));\n\t}"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        }
    },
    {
        "repo_name": "Netflix/genie",
        "commit_id": "0b31c45e751c14038306945966d40952bf1ea180",
        "commit_url": "https://github.com/Netflix/genie/commit/0b31c45e751c14038306945966d40952bf1ea180",
        "focal_db": {
            "id": "2858318",
            "rel_path": "genie-common/src/main/java/com/netflix/genie/common/model/Command.java",
            "method_src": "@PrePersist\n    @PreUpdate\n    protected void onCreateOrUpdateCommand() throws GenieException {\n        validate(this.status, this.executable);\n        // Add the id to the tags\n        if (this.tags == null) {\n           this.tags = new HashSet<>();\n        }\n        this.tags.add(this.getId());\n        this.tags.add(this.getName());\n    }",
            "method_tgt": "@PrePersist\n    @PreUpdate\n    protected void onCreateOrUpdateCommand() throws GeniePreconditionException {\n        validate(this.status, this.executable, null);\n        // Add the id to the tags\n        if (this.tags == null) {\n           this.tags = new HashSet<>();\n        }\n        this.tags.add(this.getId());\n        this.tags.add(this.getName());\n    }"
        },
        "test_db": {
            "id": "2858391",
            "rel_path": "genie-common/src/test/java/com/netflix/genie/common/model/TestCommand.java",
            "method_src": "@Test\n    public void testOnCreateOrUpdateCommand() throws GenieException {\n        this.c = new Command(NAME, USER, CommandStatus.ACTIVE, EXECUTABLE, VERSION);\n        this.c.onCreateOrUpdateCommand();\n    }",
            "method_tgt": "@Test\n    public void testOnCreateOrUpdateCommand() throws GeniePreconditionException {\n        this.c = new Command(NAME, USER, CommandStatus.ACTIVE, EXECUTABLE, VERSION);\n        this.c.onCreateOrUpdateCommand();\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 0,
            "throw_types": 1
        }
    },
    {
        "repo_name": "RUB-NDS/TLS-Attacker",
        "commit_id": "4e9caa656ef763e6e770a3af6b9ce66410d90012",
        "commit_url": "https://github.com/RUB-NDS/TLS-Attacker/commit/4e9caa656ef763e6e770a3af6b9ce66410d90012",
        "focal_db": {
            "id": "3399976",
            "rel_path": "TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/crypto/HKDFunction.java",
            "method_src": "public static byte[] deriveSecret(String macAlgorithm, byte[] prk, String labelIn, byte[] hashValue) {\n        try {\n            int outLen = Mac.getInstance(macAlgorithm).getMacLength();\n            byte[] info = labelEncoder(hashValue, labelIn, outLen);\n            byte[] result = expand(macAlgorithm, prk, info, outLen);\n            return result;\n        } catch (NoSuchAlgorithmException ex) {\n            throw new CryptoException(\"Could not initialize HKDF\", ex);\n        }\n    }",
            "method_tgt": "public static byte[] deriveSecret(String macAlgorithm, String hashAlgorithm, byte[] prk, String labelIn,\n            byte[] toHash) {\n        try {\n            MessageDigest hashFunction = MessageDigest.getInstance(hashAlgorithm);\n            hashFunction.update(toHash);\n            byte[] hashValue = hashFunction.digest();\n            int outLen = Mac.getInstance(macAlgorithm).getMacLength();\n            return expandLabel(macAlgorithm, prk, labelIn, hashValue, outLen);\n        } catch (NoSuchAlgorithmException ex) {\n            throw new CryptoException(\"Could not initialize HKDF\", ex);\n        }\n    }"
        },
        "test_db": {
            "id": "3399978",
            "rel_path": "TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/crypto/HKDFunctionTest.java",
            "method_src": "@Test\n    public void testDeriveSecret() {\n        String macAlgorithm = HKDFAlgorithm.TLS_HKDF_SHA256.getMacAlgorithm().getJavaName();\n        byte[] prk = ArrayConverter\n                .hexStringToByteArray(\"31168cad69862a80c6f6bfd42897d0fe23c406a12e652a8d3ae4217694f49844\");\n        byte[] hashValue = ArrayConverter\n                .hexStringToByteArray(\"52c04472bdfe929772c98b91cf425f78f47659be9d4a7d68b9e29d162935e9b9\");\n        String labelIn = \"client handshake traffic secret\";\n\n        byte[] result = HKDFunction.deriveSecret(macAlgorithm, prk, labelIn, hashValue);\n        byte[] resultCorrect = ArrayConverter\n                .hexStringToByteArray(\"6c6f274b1eae09b8bbd2039b7eb56147201a5e19288a3fd504fa52b1178a6e93\");\n        assertArrayEquals(result, resultCorrect);\n    }",
            "method_tgt": "@Test\n    public void testDeriveSecret() {\n        String macAlgorithm = HKDFAlgorithm.TLS_HKDF_SHA256.getMacAlgorithm().getJavaName();\n        String hashAlgorithm = DigestAlgorithm.SHA256.getJavaName();\n        byte[] prk = ArrayConverter.hexStringToByteArray(\"33AD0A1C607EC03B09E6CD9893680CE210ADF300AA1F2660E1B22E10F170F92A\");\n        byte[] toHash = ArrayConverter.hexStringToByteArray(\"\");\n        String labelIn = HKDFunction.DERIVED;\n\n        byte[] result = HKDFunction.deriveSecret(macAlgorithm, hashAlgorithm, prk, labelIn, toHash);\n        byte[] resultCorrect = ArrayConverter.hexStringToByteArray(\"6F2615A108C702C5678F54FC9DBAB69716C076189C48250CEBEAC3576C3611BA\");\n        assertArrayEquals(result, resultCorrect);\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        },
        "comment": "[Hard] Input value changes in the ground truth"
    },
    {
        "repo_name": "ThreeTen/threetenbp",
        "commit_id": "fdb5b74a414b8224943302209a86d1771c59d0db",
        "commit_url": "https://github.com/ThreeTen/threetenbp/commit/fdb5b74a414b8224943302209a86d1771c59d0db",
        "focal_db": {
            "id": "3681512",
            "rel_path": "src/main/java/javax/time/calendrical/DateTimeAdjusters.java",
            "method_src": "public static DateTimeAdjuster next(DayOfWeek dow) {\n        if (dow == null) {\n            throw new NullPointerException(\"DayOfWeek must not be null\");\n        }\n        return new RelativeDayOfWeek(2, dow);\n    }",
            "method_tgt": "public static WithAdjuster next(DayOfWeek dow) {\n        if (dow == null) {\n            throw new NullPointerException(\"DayOfWeek must not be null\");\n        }\n        return new RelativeDayOfWeek(2, dow);\n    }"
        },
        "test_db": {
            "id": "3681539",
            "rel_path": "src/test/java/javax/time/calendrical/TestDateTimeAdjusters.java",
            "method_src": "@Test(groups={\"tck\"})\n    public void test_next_serialization() throws IOException, ClassNotFoundException {\n        DateTimeAdjuster next = DateTimeAdjusters.next(SUNDAY);\n        assertTrue(next instanceof Serializable);\n\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(baos);\n        oos.writeObject(next);\n        oos.close();\n\n        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(\n                baos.toByteArray()));\n        assertEquals(ois.readObject(), next);\n    }",
            "method_tgt": "@Test(groups={\"tck\"})\n    public void test_next_serialization() throws IOException, ClassNotFoundException {\n        WithAdjuster next = DateTimeAdjusters.next(SUNDAY);\n        assertTrue(next instanceof Serializable);\n\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(baos);\n        oos.writeObject(next);\n        oos.close();\n\n        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(\n                baos.toByteArray()));\n        assertEquals(ois.readObject(), next);\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 0,
            "param_types": 0,
            "throw_types": 0
        }
    },
    {
        "repo_name": "ThreeTen/threetenbp",
        "commit_id": "296627779ebd984570bb68f7d409b2be1dc35dae",
        "commit_url": "https://github.com/ThreeTen/threetenbp/commit/296627779ebd984570bb68f7d409b2be1dc35dae",
        "focal_db": {
            "id": "3684841",
            "rel_path": "src-standard/main/java/javax/time/format/DateTimeFormatter.java",
            "method_src": "public CalendricalEngine parseToEngine(CharSequence text) {\n        DateTimes.checkNotNull(text, \"Text must not be null\");\n        String str = text.toString();  // parsing whole String, so this makes sense\n        ParsePosition pos = new ParsePosition(0);\n        DateTimeParseContext result = parseToContext(str, pos);\n        if (pos.getErrorIndex() >= 0 || pos.getIndex() < str.length()) {\n            String abbr = str.toString();\n            if (abbr.length() > 64) {\n                abbr = abbr.substring(0, 64) + \"...\";\n            }\n            if (pos.getErrorIndex() >= 0) {\n                throw new CalendricalParseException(\"Text '\" + abbr + \"' could not be parsed at index \" +\n                        pos.getErrorIndex(), str, pos.getErrorIndex());\n            } else {\n                throw new CalendricalParseException(\"Text '\" + abbr + \"' could not be parsed, unparsed text found at index \" +\n                        pos.getIndex(), str, pos.getIndex());\n            }\n        }\n        return result.toCalendricalEngine();\n    }",
            "method_tgt": "public DateTimeBuilder parseToBuilder(CharSequence text) {\n        DateTimes.checkNotNull(text, \"Text must not be null\");\n        String str = text.toString();  // parsing whole String, so this makes sense\n        ParsePosition pos = new ParsePosition(0);\n        DateTimeParseContext result = parseToContext(str, pos);\n        if (pos.getErrorIndex() >= 0 || pos.getIndex() < str.length()) {\n            String abbr = str.toString();\n            if (abbr.length() > 64) {\n                abbr = abbr.substring(0, 64) + \"...\";\n            }\n            if (pos.getErrorIndex() >= 0) {\n                throw new CalendricalParseException(\"Text '\" + abbr + \"' could not be parsed at index \" +\n                        pos.getErrorIndex(), str, pos.getErrorIndex());\n            } else {\n                throw new CalendricalParseException(\"Text '\" + abbr + \"' could not be parsed, unparsed text found at index \" +\n                        pos.getIndex(), str, pos.getIndex());\n            }\n        }\n        return result.toBuilder();\n    }"
        },
        "test_db": {
            "id": "3684888",
            "rel_path": "src-standard/test/java/javax/time/format/TestDateTimeFormatter.java",
            "method_src": "@Test(groups={\"tck\"})\n    public void test_parseToEngine_String() throws Exception {\n        DateTimeFormatter test = new DateTimeFormatter(Locale.ENGLISH, DateTimeFormatSymbols.STANDARD, compPP);\n        CalendricalEngine result = test.parseToEngine(\"ONE30\");\n        assertEquals(result.getInput().size(), 1);\n        assertEquals(result.getInput().get(0), DAY_OF_MONTH.field(30L));\n    }",
            "method_tgt": "@Test(groups={\"tck\"})\n    public void test_parseToEngine_String() throws Exception {\n        DateTimeFormatter test = new DateTimeFormatter(Locale.ENGLISH, DateTimeFormatSymbols.STANDARD, compPP);\n        CalendricalEngine result = test.parseToBuilder(\"ONE30\");\n        assertEquals(result.getInput().size(), 1);\n        assertEquals(result.getInput().get(0), DAY_OF_MONTH.field(30L));\n    }"
        },
        "syn_diff": {
            "overall": 2,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 1,
            "param_types": 0,
            "throw_types": 0
        }
    },
    {
        "repo_name": "ThreeTen/threetenbp",
        "commit_id": "fdb5b74a414b8224943302209a86d1771c59d0db",
        "commit_url": "https://github.com/ThreeTen/threetenbp/commit/fdb5b74a414b8224943302209a86d1771c59d0db",
        "focal_db": {
            "id": "3681515",
            "rel_path": "src/main/java/javax/time/calendrical/DateTimeAdjusters.java",
            "method_src": "public static DateTimeAdjuster firstDayOfMonth() {\n        return Impl.FIRST_DAY_OF_MONTH;\n    }",
            "method_tgt": "public static WithAdjuster firstDayOfMonth() {\n        return Impl.FIRST_DAY_OF_MONTH;\n    }"
        },
        "test_db": {
            "id": "3681534",
            "rel_path": "src/test/java/javax/time/calendrical/TestDateTimeAdjusters.java",
            "method_src": "@Test(groups={\"tck\"})\n    public void test_firstDayOfMonth_serialization() throws IOException, ClassNotFoundException {\n        DateTimeAdjuster firstDayOfMonth = DateTimeAdjusters.firstDayOfMonth();\n        assertTrue(firstDayOfMonth instanceof Serializable);\n        \n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(baos);\n        oos.writeObject(firstDayOfMonth);\n        oos.close();\n        \n        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()));\n        assertSame(ois.readObject(), firstDayOfMonth);\n    }",
            "method_tgt": "@Test(groups={\"tck\"})\n    public void test_firstDayOfMonth_serialization() throws IOException, ClassNotFoundException {\n        WithAdjuster firstDayOfMonth = DateTimeAdjusters.firstDayOfMonth();\n        assertTrue(firstDayOfMonth instanceof Serializable);\n        \n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(baos);\n        oos.writeObject(firstDayOfMonth);\n        oos.close();\n        \n        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()));\n        assertSame(ois.readObject(), firstDayOfMonth);\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 0,
            "param_types": 0,
            "throw_types": 0
        }
    },
    {
        "repo_name": "ThreeTen/threetenbp",
        "commit_id": "9288df05f95a647a80b66b4f0f3424fd1ad1a8db",
        "commit_url": "https://github.com/ThreeTen/threetenbp/commit/9288df05f95a647a80b66b4f0f3424fd1ad1a8db",
        "focal_db": {
            "id": "3677880",
            "rel_path": "src/main/java/org/threeten/bp/format/DateTimeFormatter.java",
            "method_src": "public String print(DateTimeAccessor dateTime) {\n        StringBuilder buf = new StringBuilder(32);\n        printTo(dateTime, buf);\n        return buf.toString();\n    }",
            "method_tgt": "public String print(TemporalAccessor dateTime) {\n        StringBuilder buf = new StringBuilder(32);\n        printTo(dateTime, buf);\n        return buf.toString();\n    }"
        },
        "test_db": {
            "id": "3677972",
            "rel_path": "src/test/java/org/threeten/bp/format/TCKDateTimeFormatter.java",
            "method_src": "@Test(expectedExceptions=NullPointerException.class, groups={\"tck\"})\n    public void test_print_Calendrical_null() throws Exception {\n        DateTimeFormatter test = fmt.withLocale(Locale.ENGLISH).withSymbols(DateTimeFormatSymbols.STANDARD);\n        test.print((DateTimeAccessor) null);\n    }",
            "method_tgt": "@Test(expectedExceptions=NullPointerException.class, groups={\"tck\"})\n    public void test_print_Calendrical_null() throws Exception {\n        DateTimeFormatter test = fmt.withLocale(Locale.ENGLISH).withSymbols(DateTimeFormatSymbols.STANDARD);\n        test.print((TemporalAccessor) null);\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 0
    },
    {
        "repo_name": "ThreeTen/threetenbp",
        "commit_id": "9288df05f95a647a80b66b4f0f3424fd1ad1a8db",
        "commit_url": "https://github.com/ThreeTen/threetenbp/commit/9288df05f95a647a80b66b4f0f3424fd1ad1a8db",
        "focal_db": {
            "id": "3677880",
            "rel_path": "src/main/java/org/threeten/bp/format/DateTimeFormatter.java",
            "method_src": "public String print(DateTimeAccessor dateTime) {\n        StringBuilder buf = new StringBuilder(32);\n        printTo(dateTime, buf);\n        return buf.toString();\n    }",
            "method_tgt": "public String print(TemporalAccessor dateTime) {\n        StringBuilder buf = new StringBuilder(32);\n        printTo(dateTime, buf);\n        return buf.toString();\n    }"
        },
        "test_db": {
            "id": "3677972",
            "rel_path": "src/test/java/org/threeten/bp/format/TCKDateTimeFormatter.java",
            "method_src": "@Test(groups={\"tck\"})\n    public void test_print_Calendrical() throws Exception {\n        DateTimeFormatter test = fmt.withLocale(Locale.ENGLISH).withSymbols(DateTimeFormatSymbols.STANDARD);\n        String result = test.print(LocalDate.of(2008, 6, 30));\n        assertEquals(result, \"ONE30\");\n    }",
            "method_tgt": "@Test(groups={\"tck\"})\n    public void test_print_Calendrical() throws Exception {\n        DateTimeFormatter test = fmt.withLocale(Locale.ENGLISH).withSymbols(DateTimeFormatSymbols.STANDARD);\n        String result = test.print(LocalDate.of(2008, 6, 30));\n        assertEquals(result, \"ONE30\");\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 1,
        "comment": "focal diff same as aug0, but no need to update"
    },
    {
        "repo_name": "ThreeTen/threetenbp",
        "commit_id": "9288df05f95a647a80b66b4f0f3424fd1ad1a8db",
        "commit_url": "https://github.com/ThreeTen/threetenbp/commit/9288df05f95a647a80b66b4f0f3424fd1ad1a8db",
        "focal_db": {
            "id": "3677880",
            "rel_path": "src/main/java/org/threeten/bp/format/DateTimeFormatter.java",
            "method_src": "public DateTimeAccessor parseBest(CharSequence text, Class<?>... types) {\n        Objects.requireNonNull(text, \"text\");\n        Objects.requireNonNull(types, \"types\");\n        if (types.length < 2) {\n            throw new IllegalArgumentException(\"At least two types must be specified\");\n        }\n        String str = text.toString();  // parsing whole String, so this makes sense\n        try {\n            DateTimeBuilder builder = parseToBuilder(str).resolve();\n            for (Class<?> type : types) {\n                try {\n                    return (DateTimeAccessor) builder.build(type);\n                } catch (RuntimeException ex) {\n                    // continue\n                }\n            }\n            throw new DateTimeException(\"Unable to convert parsed text to any specified type: \" + Arrays.toString(types));\n        } catch (DateTimeParseException ex) {\n            throw ex;\n        } catch (RuntimeException ex) {\n            throw createError(str, ex);\n        }\n    }",
            "method_tgt": "public TemporalAccessor parseBest(CharSequence text, Class<?>... types) {\n        Objects.requireNonNull(text, \"text\");\n        Objects.requireNonNull(types, \"types\");\n        if (types.length < 2) {\n            throw new IllegalArgumentException(\"At least two types must be specified\");\n        }\n        String str = text.toString();  // parsing whole String, so this makes sense\n        try {\n            DateTimeBuilder builder = parseToBuilder(str).resolve();\n            for (Class<?> type : types) {\n                try {\n                    return (TemporalAccessor) builder.build(type);\n                } catch (RuntimeException ex) {\n                    // continue\n                }\n            }\n            throw new DateTimeException(\"Unable to convert parsed text to any specified type: \" + Arrays.toString(types));\n        } catch (DateTimeParseException ex) {\n            throw ex;\n        } catch (RuntimeException ex) {\n            throw createError(str, ex);\n        }\n    }"
        },
        "test_db": {
            "id": "3677972",
            "rel_path": "src/test/java/org/threeten/bp/format/TCKDateTimeFormatter.java",
            "method_src": "@Test(groups={\"tck\"})\n    public void test_parseBest_firstOption() throws Exception {\n        DateTimeFormatter test = DateTimeFormatters.pattern(\"yyyy-MM-dd[ZZZ]\");\n        DateTimeAccessor result = test.parseBest(\"2011-06-30+03:00\", OffsetDate.class, LocalDate.class);\n        assertEquals(result, OffsetDate.of(2011, 6, 30, ZoneOffset.ofHours(3)));\n    }",
            "method_tgt": "@Test(groups={\"tck\"})\n    public void test_parseBest_firstOption() throws Exception {\n        DateTimeFormatter test = DateTimeFormatters.pattern(\"yyyy-MM-dd[ZZZ]\");\n        TemporalAccessor result = test.parseBest(\"2011-06-30+03:00\", OffsetDate.class, LocalDate.class);\n        assertEquals(result, OffsetDate.of(2011, 6, 30, ZoneOffset.ofHours(3)));\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 0,
            "param_types": 0,
            "throw_types": 0
        },
        "aug": 2
    },
    {
        "repo_name": "ThreeTen/threetenbp",
        "commit_id": "d3a73e13cdb051f9de9dfa2fb03452c87452ef1e",
        "commit_url": "https://github.com/ThreeTen/threetenbp/commit/d3a73e13cdb051f9de9dfa2fb03452c87452ef1e",
        "focal_db": {
            "id": "3686572",
            "rel_path": "src/main/java/javax/time/calendrical/DateTimeField.java",
            "method_src": "public boolean matchesCalendrical(Calendrical calendrical) {\n        return this.equals(calendrical.get(rule));\n    }",
            "method_tgt": "public boolean matches(Calendrical calendrical) {\n        return this.equals(calendrical.get(rule));\n    }"
        },
        "test_db": {
            "id": "3686590",
            "rel_path": "src/test/java/javax/time/calendrical/TestDateTimeField.java",
            "method_src": "@Test(groups={\"tck\"})\n    public void test_matchesCalendrical_ymd_date() {\n        LocalDate date = LocalDate.of(2008, 6, 30);\n        assertEquals(DateTimeField.of(YEAR, 2008).matchesCalendrical(date), true);\n        assertEquals(DateTimeField.of(YEAR, 2006).matchesCalendrical(date), false);\n        assertEquals(DateTimeField.of(MONTH_OF_YEAR, 6).matchesCalendrical(date), true);\n        assertEquals(DateTimeField.of(MONTH_OF_YEAR, 7).matchesCalendrical(date), false);\n        assertEquals(DateTimeField.of(MONTH_OF_YEAR, -1).matchesCalendrical(date), false);\n        assertEquals(DateTimeField.of(DAY_OF_MONTH, 30).matchesCalendrical(date), true);\n        assertEquals(DateTimeField.of(DAY_OF_MONTH, 12).matchesCalendrical(date), false);\n        assertEquals(DateTimeField.of(DAY_OF_WEEK, 1).matchesCalendrical(date), true);\n        assertEquals(DateTimeField.of(DAY_OF_WEEK, 2).matchesCalendrical(date), false);\n        assertEquals(DateTimeField.of(HOUR_OF_DAY, 2).matchesCalendrical(date), false);\n    }",
            "method_tgt": "@Test(groups={\"tck\"})\n    public void test_matches() {\n        LocalDate date = LocalDate.of(2008, 6, 30);\n        assertEquals(DateTimeField.of(YEAR, 2008).matches(DateTimeField.of(YEAR, 2008)), true);\n        assertEquals(DateTimeField.of(YEAR, 2008).matches(DateTimeField.of(YEAR, 2012)), false);\n        assertEquals(DateTimeField.of(YEAR, 2008).matches(DateTimeField.of(MONTH_OF_YEAR, 2008)), false);\n        assertEquals(DateTimeField.of(YEAR, 2008).matches(date), true);\n        assertEquals(DateTimeField.of(YEAR, 2012).matches(date), false);\n        assertEquals(DateTimeField.of(MONTH_OF_YEAR, 6).matches(date), true);\n        assertEquals(DateTimeField.of(MONTH_OF_YEAR, 7).matches(date), false);\n        assertEquals(DateTimeField.of(MONTH_OF_YEAR, -1).matches(date), false);\n        assertEquals(DateTimeField.of(DAY_OF_MONTH, 30).matches(date), true);\n        assertEquals(DateTimeField.of(DAY_OF_MONTH, 12).matches(date), false);\n        assertEquals(DateTimeField.of(DAY_OF_WEEK, 1).matches(date), true);\n        assertEquals(DateTimeField.of(DAY_OF_WEEK, 2).matches(date), false);\n        assertEquals(DateTimeField.of(HOUR_OF_DAY, 2).matches(date), false);\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 1,
            "param_types": 0,
            "throw_types": 0
        },
        "comment": "New assertions are added."
    },
    {
        "repo_name": "ThreeTen/threetenbp",
        "commit_id": "7138c860e24d6d38bdea9d31c5510aa79a3c1d82",
        "commit_url": "https://github.com/ThreeTen/threetenbp/commit/7138c860e24d6d38bdea9d31c5510aa79a3c1d82",
        "focal_db": {
            "id": 3675645,
            "rel_path": "src/main/java/org/threeten/bp/format/DateTimeFormatterBuilder.java",
            "method_src": "public DateTimeFormatterBuilder appendValueReduced(\n            TemporalField field, int width, int baseValue) {\n        Objects.requireNonNull(field, \"field\");\n        ReducedPrinterParser pp = new ReducedPrinterParser(field, width, baseValue);\n        appendFixedWidth(width, pp);\n        return this;\n    }",
            "method_tgt": "public DateTimeFormatterBuilder appendValueReduced(TemporalField field,\n            int width, int maxWidth, int baseValue) {\n        Objects.requireNonNull(field, \"field\");\n        ReducedPrinterParser pp = new ReducedPrinterParser(field, width, maxWidth, baseValue);\n        if (width == maxWidth) {\n            appendFixedWidth(width, pp);\n        } else {\n            appendInternal(pp);\n        }\n        return this;\n    }"
        },
        "test_db": {
            "id": 3675646,
            "rel_path": "src/test/java/org/threeten/bp/format/TestDateTimeFormatterBuilder.java",
            "method_src": "@Test(expectedExceptions=NullPointerException.class)\n    public void test_appendValueReduced_null() throws Exception {\n        builder.appendValueReduced(null, 2, 2000);\n    }",
            "method_tgt": "@Test(expectedExceptions=NullPointerException.class)\n    public void test_appendValueReduced_null() throws Exception {\n        builder.appendValueReduced(null, 2, 2, 2000);\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        }
    },
    {
        "repo_name": "ThreeTen/threetenbp",
        "commit_id": "7138c860e24d6d38bdea9d31c5510aa79a3c1d82",
        "commit_url": "https://github.com/ThreeTen/threetenbp/commit/7138c860e24d6d38bdea9d31c5510aa79a3c1d82",
        "focal_db": {
            "id": "3675645",
            "rel_path": "src/main/java/org/threeten/bp/format/DateTimeFormatterBuilder.java",
            "method_src": "public DateTimeFormatterBuilder appendValueReduced(\n            TemporalField field, int width, int baseValue) {\n        Objects.requireNonNull(field, \"field\");\n        ReducedPrinterParser pp = new ReducedPrinterParser(field, width, baseValue);\n        appendFixedWidth(width, pp);\n        return this;\n    }",
            "method_tgt": "public DateTimeFormatterBuilder appendValueReduced(TemporalField field,\n            int width, int maxWidth, int baseValue) {\n        Objects.requireNonNull(field, \"field\");\n        ReducedPrinterParser pp = new ReducedPrinterParser(field, width, maxWidth, baseValue);\n        if (width == maxWidth) {\n            appendFixedWidth(width, pp);\n        } else {\n            appendInternal(pp);\n        }\n        return this;\n    }"
        },
        "test_db": {
            "id": "3675646",
            "rel_path": "src/test/java/org/threeten/bp/format/TestDateTimeFormatterBuilder.java",
            "method_src": "@Test\n    public void test_appendValueReduced() throws Exception {\n        builder.appendValueReduced(YEAR, 2, 2000);\n        DateTimeFormatter f = builder.toFormatter();\n        assertEquals(f.toString(), \"ReducedValue(Year,2,2000)\");\n        TemporalAccessor cal = f.parseUnresolved(\"12\", new ParsePosition(0));\n        assertEquals(cal.get(YEAR), 2012);\n    }",
            "method_tgt": "@Test\n    public void test_appendValueReduced() throws Exception {\n        builder.appendValueReduced(YEAR, 2, 2, 2000);\n        DateTimeFormatter f = builder.toFormatter();\n        assertEquals(f.toString(), \"ReducedValue(Year,2,2000)\");\n        TemporalAccessor cal = f.parseUnresolved(\"12\", new ParsePosition(0));\n        assertEquals(cal.get(YEAR), 2012);\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 1
    },
    {
        "repo_name": "ThreeTen/threetenbp",
        "commit_id": "33479dae9ec62edc08bb7683f8fa003e7b58e183",
        "commit_url": "https://github.com/ThreeTen/threetenbp/commit/33479dae9ec62edc08bb7683f8fa003e7b58e183",
        "focal_db": {
            "id": "3678468",
            "rel_path": "src/main/java/javax/time/zone/ZoneRulesProvider.java",
            "method_src": "public static Set<String> getAvailableGroupIds() {\n        return new HashSet<>(GROUPS.keySet());\n    }",
            "method_tgt": "public static Set<String> getAvailableZoneIds() {\n        return new HashSet<>(ZONES.keySet());\n    }"
        },
        "test_db": {
            "id": "3678470",
            "rel_path": "src/tck/java/javax/time/zone/TCKZoneRulesProvider.java",
            "method_src": "@Test(groups={\"tck\"})\n    public void test_getAvailableGroupIds() {\n        Set<String> groups = ZoneRulesProvider.getAvailableGroupIds();\n        assertEquals(groups.contains(\"TZDB\"), true);\n        groups.clear();\n        assertEquals(groups.size(), 0);\n        Set<String> groups2 = ZoneRulesProvider.getAvailableGroupIds();\n        assertEquals(groups2.contains(\"TZDB\"), true);\n    }",
            "method_tgt": "@Test(groups={\"tck\"})\n    public void test_getAvailableGroupIds() {\n        Set<String> zoneIds = ZoneRulesProvider.getAvailableZoneIds();\n        assertEquals(zoneIds.contains(\"Europe/London\"), true);\n        zoneIds.clear();\n        assertEquals(zoneIds.size(), 0);\n        Set<String> zoneIds2 = ZoneRulesProvider.getAvailableZoneIds();\n        assertEquals(zoneIds2.contains(\"Europe/London\"), true);\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 1,
            "param_types": 0,
            "throw_types": 0
        },
        "comment": "[Hard] Assertion result value changes in the ground truth"
    },
    {
        "repo_name": "Waffle/waffle",
        "commit_id": "9ec9ef591f45b0af49046e8a459905ac929967e3",
        "commit_url": "https://github.com/Waffle/waffle/commit/9ec9ef591f45b0af49046e8a459905ac929967e3",
        "focal_db": {
            "id": "3853576",
            "rel_path": "Source/JNA/waffle-jna/src/main/java/waffle/util/AuthorizationHeader.java",
            "method_src": "public boolean isSPNegoMessage() {\n\n        if (this.isNull()) {\n            return false;\n        }\n\n        final byte[] tokenBytes = this.getTokenBytes();\n        return SPNegoMessage.isSPNegoMessage(tokenBytes);\n    }",
            "method_tgt": "public boolean isSPNegTokenInitMessage() {\n\n        if (this.isNull()) {\n            return false;\n        }\n\n        final byte[] tokenBytes = this.getTokenBytes();\n        return SPNegoMessage.isNegTokenInit(tokenBytes);\n    }"
        },
        "test_db": {
            "id": "3853578",
            "rel_path": "Source/JNA/waffle-tests/src/test/java/waffle/util/AuthorizationHeaderTests.java",
            "method_src": "@Test\n    public void testIsSPNegoMessage() {\n        final SimpleHttpRequest request = new SimpleHttpRequest();\n        final AuthorizationHeader header = new AuthorizationHeader(request);\n        Assert.assertFalse(header.isSPNegoMessage());\n        request.addHeader(\"Authorization\", \"\");\n        Assert.assertFalse(header.isSPNegoMessage());\n        request.addHeader(\n                \"Authorization\",\n                \"Negotiate YHYGBisGAQUFAqBsMGqgMDAuBgorBgEEAYI3AgIKBgkqhkiC9xIBAgIGCSqGSIb3EgECAgYKKwYBBAGCNwICHqI2BDROVExNU1NQAAEAAACXsgjiAwADADEAAAAJAAkAKAAAAAYBsR0AAAAPR0xZQ0VSSU5FU0FE\");\n        Assert.assertTrue(header.isSPNegoMessage());\n    }",
            "method_tgt": "@Test\n    public void testIsSPNegTokenInitMessage() {\n        final SimpleHttpRequest request = new SimpleHttpRequest();\n        final AuthorizationHeader header = new AuthorizationHeader(request);\n        Assert.assertFalse(header.isSPNegTokenInitMessage());\n        request.addHeader(\"Authorization\", \"\");\n        Assert.assertFalse(header.isSPNegTokenInitMessage());\n        request.addHeader(\n                \"Authorization\",\n                \"Negotiate YHYGBisGAQUFAqBsMGqgMDAuBgorBgEEAYI3AgIKBgkqhkiC9xIBAgIGCSqGSIb3EgECAgYKKwYBBAGCNwICHqI2BDROVExNU1NQAAEAAACXsgjiAwADADEAAAAJAAkAKAAAAAYBsR0AAAAPR0xZQ0VSSU5FU0FE\");\n        Assert.assertTrue(header.isSPNegTokenInitMessage());\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 1,
            "param_types": 0,
            "throw_types": 0
        }
    },
    {
        "repo_name": "apache/ambari",
        "commit_id": "746df034c630081df187dd442fb460596568113f",
        "commit_url": "https://github.com/apache/ambari/commit/746df034c630081df187dd442fb460596568113f",
        "focal_db": {
            "id": "420776",
            "rel_path": "ambari-server/src/main/java/org/apache/ambari/server/orm/dao/HostVersionDAO.java",
            "method_src": "@RequiresSession\n  public List<HostVersionEntity> findByClusterStackAndVersion(String clusterName, String stack, String version) {\n    final TypedQuery<HostVersionEntity> query = entityManagerProvider.get().createNamedQuery(\"hostVersionByClusterAndStackAndVersion\", HostVersionEntity.class);\n    query.setParameter(\"clusterName\", clusterName);\n    query.setParameter(\"stack\", stack);\n    query.setParameter(\"version\", version);\n\n    return daoUtils.selectList(query);\n  }",
            "method_tgt": "@RequiresSession\n  public List<HostVersionEntity> findByClusterStackAndVersion(\n      String clusterName, StackId stackId, String version) {\n    final TypedQuery<HostVersionEntity> query = entityManagerProvider.get().createNamedQuery(\"hostVersionByClusterAndStackAndVersion\", HostVersionEntity.class);\n    query.setParameter(\"clusterName\", clusterName);\n    query.setParameter(\"stackName\", stackId.getStackName());\n    query.setParameter(\"stackVersion\", stackId.getStackVersion());\n    query.setParameter(\"version\", version);\n\n    return daoUtils.selectList(query);\n  }"
        },
        "test_db": {
            "id": "420808",
            "rel_path": "ambari-server/src/test/java/org/apache/ambari/server/orm/dao/HostVersionDAOTest.java",
            "method_src": "@Test\n  public void testFindByClusterStackAndVersion() {\n    Assert.assertEquals(3, hostVersionDAO.findByClusterStackAndVersion(\"test_cluster1\", \"HDP-2.2\", \"2.2.0.0-995\").size());\n    Assert.assertEquals(3, hostVersionDAO.findAll().size());\n\n    addMoreVersions();\n\n    Assert.assertEquals(3, hostVersionDAO.findByClusterStackAndVersion(\"test_cluster1\", \"HDP-2.2\", \"2.2.0.1-996\").size());\n    Assert.assertEquals(3, hostVersionDAO.findByClusterStackAndVersion(\"test_cluster1\", \"HDP-2.2\", \"2.2.1.0-500\").size());\n    Assert.assertEquals(9, hostVersionDAO.findAll().size());\n  }",
            "method_tgt": "@Test\n  public void testFindByClusterStackAndVersion() {\n    Assert.assertEquals(3, hostVersionDAO.findByClusterStackAndVersion(\"test_cluster1\", HDP_22_STACK, \"2.2.0.0-995\").size());\n    Assert.assertEquals(3, hostVersionDAO.findAll().size());\n\n    addMoreVersions();\n\n    Assert.assertEquals(3, hostVersionDAO.findByClusterStackAndVersion(\"test_cluster1\", HDP_22_STACK, \"2.2.0.1-996\").size());\n    Assert.assertEquals(3, hostVersionDAO.findByClusterStackAndVersion(\"test_cluster1\", HDP_22_STACK, \"2.2.1.0-500\").size());\n    Assert.assertEquals(9, hostVersionDAO.findAll().size());\n  }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        }
    },
    {
        "repo_name": "apache/ambari",
        "commit_id": "746df034c630081df187dd442fb460596568113f",
        "commit_url": "https://github.com/apache/ambari/commit/746df034c630081df187dd442fb460596568113f",
        "focal_db": {
            "id": "420776",
            "rel_path": "ambari-server/src/main/java/org/apache/ambari/server/orm/dao/RepositoryVersionDAO.java",
            "method_src": "@RequiresSession\n  public List<RepositoryVersionEntity> findByStack(String stack) {\n    final TypedQuery<RepositoryVersionEntity> query = entityManagerProvider.get().createNamedQuery(\"repositoryVersionByStack\", RepositoryVersionEntity.class);\n    query.setParameter(\"stack\", stack);\n    return daoUtils.selectList(query);\n  }",
            "method_tgt": "@RequiresSession\n  public List<RepositoryVersionEntity> findByStack(StackId stackId) {\n    final TypedQuery<RepositoryVersionEntity> query = entityManagerProvider.get().createNamedQuery(\"repositoryVersionByStack\", RepositoryVersionEntity.class);\n    query.setParameter(\"stackName\", stackId.getStackName());\n    query.setParameter(\"stackVersion\", stackId.getStackVersion());\n    return daoUtils.selectList(query);\n  }"
        },
        "test_db": {
            "id": "420808",
            "rel_path": "ambari-server/src/test/java/org/apache/ambari/server/orm/dao/RepositoryVersionDAOTest.java",
            "method_src": "@Test\n  public void testFindByStack() {\n    createSingleRecord();\n    Assert.assertEquals(0, repositoryVersionDAO.findByStack(\"non existing\").size());\n    Assert.assertEquals(1, repositoryVersionDAO.findByStack(\"stack\").size());\n  }",
            "method_tgt": "@Test\n  public void testFindByStack() {\n    createSingleRecord();\n    Assert.assertEquals(0, repositoryVersionDAO.findByStack(BAD_STACK).size());\n    Assert.assertEquals(1, repositoryVersionDAO.findByStack(HDP_206).size());\n  }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 1
    },
    {
        "repo_name": "apache/commons-lang",
        "commit_id": "ff5b829efdb1f4ba42f516a030faf40a923da779",
        "commit_url": "https://github.com/apache/commons-lang/commit/ff5b829efdb1f4ba42f516a030faf40a923da779",
        "focal_db": {
            "id": "577329",
            "rel_path": "src/main/java/org/apache/commons/lang3/Conversion.java",
            "method_src": "public static boolean[] hexDigitToBoolArray(char hexDigit) {\n        switch (hexDigit) {\n        case '0':\n            return new boolean[]{false, false, false, false};\n        case '1':\n            return new boolean[]{true, false, false, false};\n        case '2':\n            return new boolean[]{false, true, false, false};\n        case '3':\n            return new boolean[]{true, true, false, false};\n        case '4':\n            return new boolean[]{false, false, true, false};\n        case '5':\n            return new boolean[]{true, false, true, false};\n        case '6':\n            return new boolean[]{false, true, true, false};\n        case '7':\n            return new boolean[]{true, true, true, false};\n        case '8':\n            return new boolean[]{false, false, false, true};\n        case '9':\n            return new boolean[]{true, false, false, true};\n        case 'a':// fall through\n        case 'A':\n            return new boolean[]{false, true, false, true};\n        case 'b':// fall through\n        case 'B':\n            return new boolean[]{true, true, false, true};\n        case 'c':// fall through\n        case 'C':\n            return new boolean[]{false, false, true, true};\n        case 'd':// fall through\n        case 'D':\n            return new boolean[]{true, false, true, true};\n        case 'e':// fall through\n        case 'E':\n            return new boolean[]{false, true, true, true};\n        case 'f':// fall through\n        case 'F':\n            return new boolean[]{true, true, true, true};\n        default:\n            throw new IllegalArgumentException(\"Cannot interpret '\"\n                + hexDigit\n                + \"' as a hexadecimal digit\");\n        }\n    }",
            "method_tgt": "public static boolean[] hexDigitToBinary(char hexDigit) {\n        switch (hexDigit) {\n        case '0':\n            return new boolean[]{false, false, false, false};\n        case '1':\n            return new boolean[]{true, false, false, false};\n        case '2':\n            return new boolean[]{false, true, false, false};\n        case '3':\n            return new boolean[]{true, true, false, false};\n        case '4':\n            return new boolean[]{false, false, true, false};\n        case '5':\n            return new boolean[]{true, false, true, false};\n        case '6':\n            return new boolean[]{false, true, true, false};\n        case '7':\n            return new boolean[]{true, true, true, false};\n        case '8':\n            return new boolean[]{false, false, false, true};\n        case '9':\n            return new boolean[]{true, false, false, true};\n        case 'a':// fall through\n        case 'A':\n            return new boolean[]{false, true, false, true};\n        case 'b':// fall through\n        case 'B':\n            return new boolean[]{true, true, false, true};\n        case 'c':// fall through\n        case 'C':\n            return new boolean[]{false, false, true, true};\n        case 'd':// fall through\n        case 'D':\n            return new boolean[]{true, false, true, true};\n        case 'e':// fall through\n        case 'E':\n            return new boolean[]{false, true, true, true};\n        case 'f':// fall through\n        case 'F':\n            return new boolean[]{true, true, true, true};\n        default:\n            throw new IllegalArgumentException(\"Cannot interpret '\"\n                + hexDigit\n                + \"' as a hexadecimal digit\");\n        }\n    }"
        },
        "test_db": {
            "id": "577334",
            "rel_path": "src/test/java/org/apache/commons/lang3/ConversionTest.java",
            "method_src": "@Test\n    public void testHexDigitToBoolArray() {\n        assertBoolArrayEquals(\n            new boolean[]{false, false, false, false}, Conversion.hexDigitToBoolArray('0'));\n        assertBoolArrayEquals(\n            new boolean[]{true, false, false, false}, Conversion.hexDigitToBoolArray('1'));\n        assertBoolArrayEquals(\n            new boolean[]{false, true, false, false}, Conversion.hexDigitToBoolArray('2'));\n        assertBoolArrayEquals(\n            new boolean[]{true, true, false, false}, Conversion.hexDigitToBoolArray('3'));\n        assertBoolArrayEquals(\n            new boolean[]{false, false, true, false}, Conversion.hexDigitToBoolArray('4'));\n        assertBoolArrayEquals(\n            new boolean[]{true, false, true, false}, Conversion.hexDigitToBoolArray('5'));\n        assertBoolArrayEquals(\n            new boolean[]{false, true, true, false}, Conversion.hexDigitToBoolArray('6'));\n        assertBoolArrayEquals(\n            new boolean[]{true, true, true, false}, Conversion.hexDigitToBoolArray('7'));\n        assertBoolArrayEquals(\n            new boolean[]{false, false, false, true}, Conversion.hexDigitToBoolArray('8'));\n        assertBoolArrayEquals(\n            new boolean[]{true, false, false, true}, Conversion.hexDigitToBoolArray('9'));\n        assertBoolArrayEquals(\n            new boolean[]{false, true, false, true}, Conversion.hexDigitToBoolArray('A'));\n        assertBoolArrayEquals(\n            new boolean[]{false, true, false, true}, Conversion.hexDigitToBoolArray('a'));\n        assertBoolArrayEquals(\n            new boolean[]{true, true, false, true}, Conversion.hexDigitToBoolArray('B'));\n        assertBoolArrayEquals(\n            new boolean[]{true, true, false, true}, Conversion.hexDigitToBoolArray('b'));\n        assertBoolArrayEquals(\n            new boolean[]{false, false, true, true}, Conversion.hexDigitToBoolArray('C'));\n        assertBoolArrayEquals(\n            new boolean[]{false, false, true, true}, Conversion.hexDigitToBoolArray('c'));\n        assertBoolArrayEquals(\n            new boolean[]{true, false, true, true}, Conversion.hexDigitToBoolArray('D'));\n        assertBoolArrayEquals(\n            new boolean[]{true, false, true, true}, Conversion.hexDigitToBoolArray('d'));\n        assertBoolArrayEquals(\n            new boolean[]{false, true, true, true}, Conversion.hexDigitToBoolArray('E'));\n        assertBoolArrayEquals(\n            new boolean[]{false, true, true, true}, Conversion.hexDigitToBoolArray('e'));\n        assertBoolArrayEquals(\n            new boolean[]{true, true, true, true}, Conversion.hexDigitToBoolArray('F'));\n        assertBoolArrayEquals(\n            new boolean[]{true, true, true, true}, Conversion.hexDigitToBoolArray('f'));\n        try {\n            Conversion.hexDigitToBoolArray('G');\n            fail(\"Thrown \" + IllegalArgumentException.class.getName() + \" expected\");\n        } catch (final IllegalArgumentException e) {\n            // OK\n        }\n    }",
            "method_tgt": "@Test\n    public void testHexDigitToBinary() {\n        assertBinaryEquals(\n            new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0'));\n        assertBinaryEquals(\n            new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1'));\n        assertBinaryEquals(\n            new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2'));\n        assertBinaryEquals(\n            new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3'));\n        assertBinaryEquals(\n            new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4'));\n        assertBinaryEquals(\n            new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5'));\n        assertBinaryEquals(\n            new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6'));\n        assertBinaryEquals(\n            new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7'));\n        assertBinaryEquals(\n            new boolean[]{false, false, false, true}, Conversion.hexDigitToBinary('8'));\n        assertBinaryEquals(\n            new boolean[]{true, false, false, true}, Conversion.hexDigitToBinary('9'));\n        assertBinaryEquals(\n            new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('A'));\n        assertBinaryEquals(\n            new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('a'));\n        assertBinaryEquals(\n            new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('B'));\n        assertBinaryEquals(\n            new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('b'));\n        assertBinaryEquals(\n            new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('C'));\n        assertBinaryEquals(\n            new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('c'));\n        assertBinaryEquals(\n            new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('D'));\n        assertBinaryEquals(\n            new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('d'));\n        assertBinaryEquals(\n            new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('E'));\n        assertBinaryEquals(\n            new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('e'));\n        assertBinaryEquals(\n            new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('F'));\n        assertBinaryEquals(\n            new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('f'));\n        try {\n            Conversion.hexDigitToBinary('G');\n            fail(\"Thrown \" + IllegalArgumentException.class.getName() + \" expected\");\n        } catch (final IllegalArgumentException e) {\n            // OK\n        }\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 1,
            "param_types": 0,
            "throw_types": 0
        }
    },
    {
        "repo_name": "apache/flink",
        "commit_id": "30c4bc847ade8cf0ae5c3ef6a6f8debdf72ddd61",
        "commit_url": "https://github.com/apache/flink/commit/30c4bc847ade8cf0ae5c3ef6a6f8debdf72ddd61",
        "focal_db": {
            "id": "621743",
            "rel_path": "flink-runtime/src/main/java/org/apache/flink/runtime/net/SSLUtils.java",
            "method_src": "private static SSLEngineFactory createSSLEngineFactory(\n\t\t\tfinal Configuration config,\n\t\t\tfinal boolean clientMode) throws Exception {\n\n\t\tfinal SSLContext sslContext = clientMode ?\n\t\t\tcreateSSLClientContext(config) :\n\t\t\tcreateSSLServerContext(config);\n\n\t\tcheckState(sslContext != null, \"%s it not enabled\", SecurityOptions.SSL_ENABLED.key());\n\n\t\treturn new SSLEngineFactory(\n\t\t\tsslContext,\n\t\t\tgetEnabledProtocols(config),\n\t\t\tgetEnabledCipherSuites(config),\n\t\t\tclientMode);\n\t}",
            "method_tgt": "public static SSLEngineFactory createInternalServerSSLEngineFactory(final Configuration config) throws Exception {\n\t\tSSLContext sslContext = createInternalSSLContext(config);\n\t\tif (sslContext == null) {\n\t\t\tthrow new IllegalConfigurationException(\"SSL is not enabled for internal communication.\");\n\t\t}\n\n\t\treturn new SSLEngineFactory(\n\t\t\t\tsslContext,\n\t\t\t\tgetEnabledProtocols(config),\n\t\t\t\tgetEnabledCipherSuites(config),\n\t\t\t\tfalse);\n\t}"
        },
        "test_db": {
            "id": "621751",
            "rel_path": "flink-runtime/src/test/java/org/apache/flink/runtime/net/SSLUtilsTest.java",
            "method_src": "@Test\n\tpublic void testCreateSSLEngineFactory() throws Exception {\n\t\tConfiguration serverConfig = new Configuration();\n\t\tserverConfig.setBoolean(SecurityOptions.SSL_ENABLED, true);\n\t\tserverConfig.setString(SecurityOptions.SSL_KEYSTORE, \"src/test/resources/local127.keystore\");\n\t\tserverConfig.setString(SecurityOptions.SSL_KEYSTORE_PASSWORD, \"password\");\n\t\tserverConfig.setString(SecurityOptions.SSL_KEY_PASSWORD, \"password\");\n\t\tserverConfig.setString(SecurityOptions.SSL_PROTOCOL, \"TLSv1\");\n\t\tserverConfig.setString(SecurityOptions.SSL_ALGORITHMS, \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA,TLS_DHE_RSA_WITH_AES_128_CBC_SHA256\");\n\n\t\tfinal SSLEngineFactory serverSSLEngineFactory = SSLUtils.createServerSSLEngineFactory(serverConfig);\n\t\tfinal SSLEngine sslEngine = serverSSLEngineFactory.createSSLEngine();\n\n\t\tassertThat(\n\t\t\tArrays.asList(sslEngine.getEnabledProtocols()),\n\t\t\tcontains(\"TLSv1\"));\n\t\tassertThat(\n\t\t\tArrays.asList(sslEngine.getEnabledCipherSuites()),\n\t\t\tcontainsInAnyOrder(\"TLS_DHE_RSA_WITH_AES_128_CBC_SHA\", \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA256\"));\n\t}",
            "method_tgt": "@Test\n\tpublic void testCreateSSLEngineFactory() throws Exception {\n\t\tConfiguration serverConfig = createInternalSslConfigWithKeyAndTrustStores();\n\n\t\t// set custom protocol and cipher suites\n\t\tserverConfig.setString(SecurityOptions.SSL_PROTOCOL, \"TLSv1\");\n\t\tserverConfig.setString(SecurityOptions.SSL_ALGORITHMS, \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA,TLS_DHE_RSA_WITH_AES_128_CBC_SHA256\");\n\n\t\tfinal SSLEngineFactory serverSSLEngineFactory = SSLUtils.createInternalServerSSLEngineFactory(serverConfig);\n\t\tfinal SSLEngine sslEngine = serverSSLEngineFactory.createSSLEngine();\n\n\t\tassertEquals(1, sslEngine.getEnabledProtocols().length);\n\t\tassertEquals(\"TLSv1\", sslEngine.getEnabledProtocols()[0]);\n\n\t\tassertEquals(2, sslEngine.getEnabledCipherSuites().length);\n\t\tassertThat(sslEngine.getEnabledCipherSuites(), arrayContainingInAnyOrder(\n\t\t\t\t\"TLS_DHE_RSA_WITH_AES_128_CBC_SHA\", \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA256\"));\n\t}"
        },
        "syn_diff": {
            "overall": 3,
            "modifiers": 1,
            "type_params": 0,
            "type": 0,
            "name": 1,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 1,
        "comment": "[Hard] Semantic breaking changes are introduced"
    },
    {
        "repo_name": "apache/flink",
        "commit_id": "5f0d6769051be8db8ee12659e13d22e5c5fd2f2d",
        "commit_url": "https://github.com/apache/flink/commit/5f0d6769051be8db8ee12659e13d22e5c5fd2f2d",
        "focal_db": {
            "id": "631014",
            "rel_path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointStatsTracker.java",
            "method_src": "public JobSnapshottingSettings getSnapshottingSettings() {\n\t\treturn jobSnapshottingSettings;\n\t}",
            "method_tgt": "public JobCheckpointingSettings getSnapshottingSettings() {\n\t\treturn jobCheckpointingSettings;\n\t}"
        },
        "test_db": {
            "id": "631022",
            "rel_path": "flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointStatsTrackerTest.java",
            "method_src": "@Test\n\tpublic void testGetSnapshottingSettings() throws Exception {\n\t\tExecutionJobVertex jobVertex = mock(ExecutionJobVertex.class);\n\t\twhen(jobVertex.getJobVertexId()).thenReturn(new JobVertexID());\n\t\twhen(jobVertex.getParallelism()).thenReturn(1);\n\n\t\tJobSnapshottingSettings snapshottingSettings = new JobSnapshottingSettings(\n\t\t\tCollections.singletonList(new JobVertexID()),\n\t\t\tCollections.singletonList(new JobVertexID()),\n\t\t\tCollections.singletonList(new JobVertexID()),\n\t\t\t181238123L,\n\t\t\t19191992L,\n\t\t\t191929L,\n\t\t\t123,\n\t\t\tExternalizedCheckpointSettings.none(),\n\t\t\tnull,\n\t\t\tfalse);\n\n\t\tCheckpointStatsTracker tracker = new CheckpointStatsTracker(\n\t\t\t0,\n\t\t\tCollections.singletonList(jobVertex),\n\t\t\tsnapshottingSettings,\n\t\t\tnew UnregisteredMetricsGroup());\n\n\t\tassertEquals(snapshottingSettings, tracker.getSnapshottingSettings());\n\t}",
            "method_tgt": "@Test\n\tpublic void testGetSnapshottingSettings() throws Exception {\n\t\tExecutionJobVertex jobVertex = mock(ExecutionJobVertex.class);\n\t\twhen(jobVertex.getJobVertexId()).thenReturn(new JobVertexID());\n\t\twhen(jobVertex.getParallelism()).thenReturn(1);\n\n\t\tJobCheckpointingSettings snapshottingSettings = new JobCheckpointingSettings(\n\t\t\tCollections.singletonList(new JobVertexID()),\n\t\t\tCollections.singletonList(new JobVertexID()),\n\t\t\tCollections.singletonList(new JobVertexID()),\n\t\t\t181238123L,\n\t\t\t19191992L,\n\t\t\t191929L,\n\t\t\t123,\n\t\t\tExternalizedCheckpointSettings.none(),\n\t\t\tnull,\n\t\t\tfalse);\n\n\t\tCheckpointStatsTracker tracker = new CheckpointStatsTracker(\n\t\t\t0,\n\t\t\tCollections.singletonList(jobVertex),\n\t\t\tsnapshottingSettings,\n\t\t\tnew UnregisteredMetricsGroup());\n\n\t\tassertEquals(snapshottingSettings, tracker.getSnapshottingSettings());\n\t}"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 0,
            "param_types": 0,
            "throw_types": 0
        },
        "checkpoint": 1
    },
    {
        "repo_name": "apache/flink",
        "commit_id": "10eca13a563c3f5cfbdc755a086a89a69d7664f1",
        "commit_url": "https://github.com/apache/flink/commit/10eca13a563c3f5cfbdc755a086a89a69d7664f1",
        "focal_db": {
            "id": "655898",
            "rel_path": "sopremo/sopremo-common/src/main/java/eu/stratosphere/sopremo/Operator.java",
            "method_src": "public List<Output> getInputs() {\n\t\treturn new ArrayList<Output>(this.inputs);\n\t}",
            "method_tgt": "public List<Operator<?>.Output> getInputs() {\n\t\treturn new ArrayList<Operator<?>.Output>(this.inputs);\n\t}"
        },
        "test_db": {
            "id": "655921",
            "rel_path": "sopremo/sopremo-common/src/test/java/eu/stratosphere/sopremo/OperatorTest.java",
            "method_src": "@Test\n\tpublic void testGetInputs() {\n\t\tfinal Operator input1 = new OpImpl(0);\n\t\tfinal Operator input2 = new OpImpl(1);\n\t\tfinal Operator fixture = new OpImpl(0).withInputs(input1, input2);\n\n\t\tfinal List<Operator.Output> result = fixture.getInputs();\n\n\t\tassertNotNull(result);\n\t\tassertEquals(2, result.size());\n\t\tassertEquals(Arrays.asList(input1.getOutput(0), input2.getOutput(0)), result);\n\t}",
            "method_tgt": "@Test\n\tpublic void testGetInputs() {\n\t\tfinal Operator<?> input1 = new OpImpl(0);\n\t\tfinal Operator<?> input2 = new OpImpl(1);\n\t\tfinal Operator<?> fixture = new OpImpl(0).withInputs(input1, input2);\n\n\t\tfinal List<Operator<?>.Output> result = fixture.getInputs();\n\n\t\tassertNotNull(result);\n\t\tassertEquals(2, result.size());\n\t\tassertEquals(Arrays.asList(input1.getOutput(0), input2.getOutput(0)), result);\n\t}"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 0,
            "param_types": 0,
            "throw_types": 0
        }
    },
    {
        "repo_name": "apache/flink",
        "commit_id": "5b24aa0302074a5eaf6c1b47c2764e9883b674ab",
        "commit_url": "https://github.com/apache/flink/commit/5b24aa0302074a5eaf6c1b47c2764e9883b674ab",
        "focal_db": {
            "id": "615422",
            "rel_path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/mailbox/MailboxImpl.java",
            "method_src": "@Override\n\tpublic void clearAndPut(@Nonnull Runnable shutdownAction) {\n\t\tlock.lock();\n\t\ttry {\n\t\t\tint localCount = count;\n\t\t\twhile (localCount > 0) {\n\t\t\t\tringBuffer[headIndex] = null;\n\t\t\t\theadIndex = increaseIndexWithWrapAround(headIndex);\n\t\t\t\t--localCount;\n\t\t\t}\n\t\t\tcount = 0;\n\t\t\tputInternal(shutdownAction);\n\t\t} finally {\n\t\t\tlock.unlock();\n\t\t}\n\t}",
            "method_tgt": "@Nonnull\n\t@Override\n\tpublic List<Runnable> clearAndPut(@Nonnull Runnable priorityLetter) throws MailboxStateException {\n\t\tArrayList<Runnable> droppedLetters = new ArrayList<>(capacity());\n\n\t\tlock.lock();\n\t\ttry {\n\t\t\t// check state first to avoid loosing any letters forever through exception\n\t\t\tcheckPutStateConditions();\n\t\t\tdropAllLetters(droppedLetters);\n\t\t\tputTailInternal(priorityLetter);\n\t\t} finally {\n\t\t\tlock.unlock();\n\t\t}\n\n\t\treturn droppedLetters;\n\t}"
        },
        "test_db": {
            "id": "615430",
            "rel_path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/mailbox/MailboxImplTest.java",
            "method_src": "@Test\n\tpublic void testClearAndPut() {\n\t\tfor (int i = 0; i < CAPACITY; ++i) {\n\t\t\tAssert.assertTrue(mailbox.tryPutMail(() -> {}));\n\t\t}\n\n\t\tmailbox.clearAndPut(POISON_LETTER);\n\n\t\tAssert.assertTrue(mailbox.hasMail());\n\t\tAssert.assertEquals(POISON_LETTER, mailbox.tryTakeMail().get());\n\t\tAssert.assertFalse(mailbox.hasMail());\n\t}",
            "method_tgt": "@Test\n\tpublic void testClearAndPut() throws Exception {\n\n\t\tRunnable letterInstance = () -> {};\n\n\t\tfor (int i = 0; i < CAPACITY; ++i) {\n\t\t\tAssert.assertTrue(mailbox.tryPutMail(letterInstance));\n\t\t}\n\n\t\tList<Runnable> droppedLetters = mailbox.clearAndPut(POISON_LETTER);\n\n\t\tAssert.assertTrue(mailbox.hasMail());\n\t\tAssert.assertEquals(POISON_LETTER, mailbox.tryTakeMail().get());\n\t\tAssert.assertFalse(mailbox.hasMail());\n\t\tAssert.assertEquals(CAPACITY, droppedLetters.size());\n\t}"
        },
        "syn_diff": {
            "overall": 3,
            "modifiers": 1,
            "type_params": 0,
            "type": 1,
            "name": 0,
            "param_types": 0,
            "throw_types": 1
        },
        "aug": 0
    },
    {
        "repo_name": "apache/incubator-heron",
        "commit_id": "a905adde3888f508dfd6c9b57e1959f093810674",
        "commit_url": "https://github.com/apache/incubator-heron/commit/a905adde3888f508dfd6c9b57e1959f093810674",
        "focal_db": {
            "id": "1049786",
            "rel_path": "heron/common/src/java/com/twitter/heron/common/basics/SysUtils.java",
            "method_src": "public static void sleep(long millis) {\n    try {\n      Thread.sleep(millis);\n    } catch (InterruptedException e) {\n      throw new RuntimeException(e);\n    }\n  }",
            "method_tgt": "public static void sleep(Duration duration) {\n    try {\n      Thread.sleep(duration.toMillis());\n    } catch (InterruptedException e) {\n      throw new RuntimeException(e);\n    }\n  }"
        },
        "test_db": {
            "id": "1049789",
            "rel_path": "heron/common/tests/java/com/twitter/heron/common/basics/SysUtilsTest.java",
            "method_src": "@Test\n  public void testSleep() throws Exception {\n    for (int i = 0; i < NUM_ATTEMPTS; i++) {\n      // The value can not be negative\n      long expectedSleepTimeMs = new Random().nextInt(100);\n      long start = System.currentTimeMillis();\n      SysUtils.sleep(expectedSleepTimeMs);\n      long end = System.currentTimeMillis();\n      Assert.assertTrue((end - start) >= expectedSleepTimeMs);\n    }\n  }",
            "method_tgt": "@Test\n  public void testSleep() throws Exception {\n    for (int i = 0; i < NUM_ATTEMPTS; i++) {\n      // The value can not be negative\n      Duration expectedSleepTime = Duration.ofMillis(new Random().nextInt(100));\n      long start = System.currentTimeMillis();\n      SysUtils.sleep(expectedSleepTime);\n      long end = System.currentTimeMillis();\n      Assert.assertTrue((end - start) >= expectedSleepTime.toMillis());\n    }\n  }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 1
    },
    {
        "repo_name": "apache/incubator-heron",
        "commit_id": "dc4c733afc92bec8c68e7e11a9050433346327ef",
        "commit_url": "https://github.com/apache/incubator-heron/commit/dc4c733afc92bec8c68e7e11a9050433346327ef",
        "focal_db": {
            "id": "1047713",
            "rel_path": "heron/packing/src/java/org/apache/heron/packing/builder/PackingPlanBuilder.java",
            "method_src": "@VisibleForTesting\n  static Map<Integer, Container> getContainers(\n      PackingPlan currentPackingPlan, int paddingPercentage,\n      Map<String, TreeSet<Integer>> componentIndexes, TreeSet<Integer> taskIds)\n      throws ResourceExceededException {\n    Map<Integer, Container> containers = new HashMap<>();\n\n    Resource capacity = currentPackingPlan.getMaxContainerResources();\n    for (PackingPlan.ContainerPlan currentContainerPlan : currentPackingPlan.getContainers()) {\n      Container container =\n          new Container(currentContainerPlan.getId(), capacity, paddingPercentage);\n      for (PackingPlan.InstancePlan instancePlan : currentContainerPlan.getInstances()) {\n        try {\n          addToContainer(container, instancePlan, componentIndexes, taskIds);\n        } catch (ResourceExceededException e) {\n          throw new ResourceExceededException(String.format(\n              \"Insufficient container resources to add instancePlan %s to container %s\",\n              instancePlan, container), e);\n        }\n      }\n      containers.put(currentContainerPlan.getId(), container);\n    }\n    return containers;\n  }",
            "method_tgt": "@VisibleForTesting\n  static Map<Integer, Container> getContainers(\n      PackingPlan currentPackingPlan, Resource maxContainerResource, Resource padding,\n      Map<String, TreeSet<Integer>> componentIndexes, TreeSet<Integer> taskIds) {\n    Map<Integer, Container> containers = new HashMap<>();\n\n    Resource capacity = maxContainerResource;\n    for (PackingPlan.ContainerPlan currentContainerPlan : currentPackingPlan.getContainers()) {\n      Container container =\n          new Container(currentContainerPlan.getId(), capacity, padding);\n      for (PackingPlan.InstancePlan instancePlan : currentContainerPlan.getInstances()) {\n        addToContainer(container, instancePlan, componentIndexes, taskIds);\n      }\n      containers.put(currentContainerPlan.getId(), container);\n    }\n    return containers;\n  }"
        },
        "test_db": {
            "id": "1047850",
            "rel_path": "heron/packing/tests/java/org/apache/heron/packing/builder/PackingPlanBuilderTest.java",
            "method_src": "@Test\n  public void testGetContainers() throws ResourceExceededException {\n\n    int paddingPercentage = 10;\n    Map<Integer, List<InstanceId>> packing = new HashMap<>();\n    packing.put(7, Arrays.asList(\n        new InstanceId(\"spout\", 1, 0),\n        new InstanceId(\"bolt\", 2, 0)));\n    packing.put(3, Arrays.asList(\n        new InstanceId(\"spout\", 3, 0),\n        new InstanceId(\"bolt\", 4, 0)));\n\n    PackingPlan packingPlan = generatePacking(packing);\n    Map<Integer, Container> containers = PackingPlanBuilder.getContainers(\n        packingPlan, paddingPercentage,\n        new HashMap<String, TreeSet<Integer>>(), new TreeSet<Integer>());\n    assertEquals(packing.size(), containers.size());\n    for (Integer containerId : packing.keySet()) {\n      Container foundContainer = containers.get(containerId);\n      assertEquals(paddingPercentage, foundContainer.getPaddingPercentage());\n      assertEquals(packingPlan.getMaxContainerResources(), foundContainer.getCapacity());\n      assertEquals(2, foundContainer.getInstances().size());\n    }\n  }",
            "method_tgt": "@Test\n  public void testGetContainers() {\n    Resource padding = new Resource(1.0, ByteAmount.fromGigabytes(1), ByteAmount.fromGigabytes(1));\n    Map<Integer, List<InstanceId>> packing = new HashMap<>();\n    packing.put(7, Arrays.asList(\n        new InstanceId(\"spout\", 1, 0),\n        new InstanceId(\"bolt\", 2, 0)));\n    packing.put(3, Arrays.asList(\n        new InstanceId(\"spout\", 3, 0),\n        new InstanceId(\"bolt\", 4, 0)));\n\n    PackingPlan packingPlan = generatePacking(packing);\n    Map<Integer, Container> containers = PackingPlanBuilder.getContainers(\n        packingPlan, packingPlan.getMaxContainerResources(), padding,\n        new HashMap<String, TreeSet<Integer>>(), new TreeSet<Integer>());\n    assertEquals(packing.size(), containers.size());\n    for (Integer containerId : packing.keySet()) {\n      Container foundContainer = containers.get(containerId);\n      assertEquals(padding, foundContainer.getPadding());\n      assertEquals(packingPlan.getMaxContainerResources(), foundContainer.getCapacity());\n      assertEquals(2, foundContainer.getInstances().size());\n    }\n  }"
        },
        "syn_diff": {
            "overall": 2,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 1
        },
        "comment": "[Hard] New parameter relates to old oones"
    },
    {
        "repo_name": "apache/metron",
        "commit_id": "58294b6659856b4e5d1feecc2b670251a15bc09e",
        "commit_url": "https://github.com/apache/metron/commit/58294b6659856b4e5d1feecc2b670251a15bc09e",
        "focal_db": {
            "id": "1232389",
            "rel_path": "metron-analytics/metron-profiler/src/main/java/org/apache/metron/profiler/stellar/DefaultStellarExecutor.java",
            "method_src": "@Override\n  public void assign(String variable, String expression, JSONObject message) {\n    Object result = execute(expression, message);\n    state.put(variable, result);\n  }",
            "method_tgt": "@Override\n  public void assign(String variable, String expression, JSONObject message, Context stellarContext) {\n    Object result = execute(expression, message, stellarContext);\n    state.put(variable, result);\n  }"
        },
        "test_db": {
            "id": "1232434",
            "rel_path": "metron-analytics/metron-profiler/src/test/java/org/apache/metron/profiler/util/DefaultStellarExecutorTest.java",
            "method_src": "@Test\n  public void testAssign() {\n    executor.assign(\"foo\", \"2\", message);\n\n    // verify\n    Object var = executor.getState().get(\"foo\");\n    assertThat(var, instanceOf(Integer.class));\n    assertThat(var, equalTo(2));\n  }",
            "method_tgt": "@Test\n  public void testAssign() {\n    executor.assign(\"foo\", \"2\", message, Context.EMPTY_CONTEXT());\n\n    // verify\n    Object var = executor.getState().get(\"foo\");\n    assertThat(var, instanceOf(Integer.class));\n    assertThat(var, equalTo(2));\n  }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        }
    },
    {
        "repo_name": "apache/metron",
        "commit_id": "58294b6659856b4e5d1feecc2b670251a15bc09e",
        "commit_url": "https://github.com/apache/metron/commit/58294b6659856b4e5d1feecc2b670251a15bc09e",
        "focal_db": {
            "id": "1232389",
            "rel_path": "metron-analytics/metron-profiler/src/main/java/org/apache/metron/profiler/stellar/DefaultStellarExecutor.java",
            "method_src": "@Override\n  public <T> T execute(String expr, JSONObject message, Class<T> clazz) {\n    Object resultObject = execute(expr, message);\n\n    // perform type conversion, if necessary\n    T result = ConversionUtils.convert(resultObject, clazz);\n    if(result == null) {\n      throw new IllegalArgumentException(String.format(\"Unexpected type: expected=%s, actual=%s, expression=%s\",\n              clazz.getSimpleName(), resultObject.getClass().getSimpleName(), expr));\n    }\n\n    return result;\n  }",
            "method_tgt": "@Override\n  public <T> T execute(String expr, JSONObject message, Class<T> clazz, Context stellarContext) {\n    Object resultObject = execute(expr, message, stellarContext);\n\n    // perform type conversion, if necessary\n    T result = ConversionUtils.convert(resultObject, clazz);\n    if(result == null) {\n      throw new IllegalArgumentException(String.format(\"Unexpected type: expected=%s, actual=%s, expression=%s\",\n              clazz.getSimpleName(), resultObject.getClass().getSimpleName(), expr));\n    }\n\n    return result;\n  }"
        },
        "test_db": {
            "id": "1232434",
            "rel_path": "metron-analytics/metron-profiler/src/test/java/org/apache/metron/profiler/util/DefaultStellarExecutorTest.java",
            "method_src": "@Test\n  public void testExecuteTransformation() {\n    String actual = executor.execute(\"TO_UPPER('lowercase')\", message, String.class);\n    assertThat(actual, equalTo(\"LOWERCASE\"));\n  }",
            "method_tgt": "@Test\n  public void testExecuteTransformation() {\n    String actual = executor.execute(\"TO_UPPER('lowercase')\", message, String.class, Context.EMPTY_CONTEXT());\n    assertThat(actual, equalTo(\"LOWERCASE\"));\n  }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 1
    },
    {
        "repo_name": "apache/oozie",
        "commit_id": "85d649e9a06080fefedf162d6ad5f406e0d5f2e0",
        "commit_url": "https://github.com/apache/oozie/commit/85d649e9a06080fefedf162d6ad5f406e0d5f2e0",
        "focal_db": {
            "id": "1245466",
            "rel_path": "core/src/main/java/org/apache/oozie/service/PartitionDependencyManagerService.java",
            "method_src": "public boolean removePartition(PartitionWrapper partition, boolean cascade) {\n        log.debug(\"Removing partition \" + partition + \" with  cascade :\" + cascade);\n        String prefix = PartitionWrapper.makePrefix(partition.getServerName(), partition.getDbName());\n        if (hcatInstanceMap.containsKey(prefix)) {\n            Map<String, PartitionsGroup> tableMap = hcatInstanceMap.get(prefix);\n            String tableName = partition.getTableName();\n            if (tableMap.containsKey(tableName)) {\n                PartitionsGroup missingPartitions = tableMap.get(tableName);\n                if (missingPartitions != null) {\n                    missingPartitions.getPartitionsMap().remove(partition);\n                    // cascading removal\n                    if (cascade) {\n                        if (missingPartitions.getPartitionsMap().size() == 0) {\n                            tableMap.remove(tableName);\n                            if (tableMap.size() == 0) {\n                                hcatInstanceMap.remove(prefix);\n                            }\n                        }\n                    }\n                    return true;\n                }\n                else {\n                    log.warn(\"No partition entries for table [{0}]\", tableName);\n                }\n            }\n            else {\n                log.warn(\"HCat table [{0}] not found\", tableName);\n            }\n        }\n        else {\n            log.warn(\"HCat instance entry [{0}] not found\", prefix);\n        }\n        return false;\n    }",
            "method_tgt": "public boolean removePartition(PartitionWrapper partition, boolean cascade) throws MetadataServiceException {\n        log.debug(\"Removing partition \" + partition + \" with  cascade :\" + cascade);\n        String prefix = PartitionWrapper.makePrefix(partition.getServerName(), partition.getDbName());\n        if (hcatInstanceMap.containsKey(prefix)) {\n            Map<String, PartitionsGroup> tableMap = hcatInstanceMap.get(prefix);\n            String tableName = partition.getTableName();\n            if (tableMap.containsKey(tableName)) {\n                PartitionsGroup missingPartitions = tableMap.get(tableName);\n                if (missingPartitions != null) {\n                    missingPartitions.getPartitionsMap().remove(partition);\n                    // cascading removal\n                    if (cascade) {\n                        if (missingPartitions.getPartitionsMap().size() == 0) {\n                            tableMap.remove(tableName);\n                            if (tableMap.size() == 0) {\n                                hcatInstanceMap.remove(prefix);\n                            }\n                            _deregisterMessageReceiver(partition);\n                        }\n                    }\n                    return true;\n                }\n                else {\n                    log.warn(\"No partition entries for table [{0}]\", tableName);\n                }\n            }\n            else {\n                log.warn(\"HCat table [{0}] not found\", tableName);\n            }\n        }\n        else {\n            log.warn(\"HCat instance entry [{0}] not found\", prefix);\n        }\n        return false;\n    }"
        },
        "test_db": {
            "id": "1245551",
            "rel_path": "core/src/test/java/org/apache/oozie/service/TestPartitionDependencyManagerService.java",
            "method_src": "@Test\n    public void testRemovePartition() throws MetadataServiceException, URISyntaxException {\n        Services services = Services.get();\n        PartitionDependencyManagerService pdms = services.get(PartitionDependencyManagerService.class);\n        String newHCatDependency = \"hcat://hcat.yahoo.com:5080/mydb/clicks/?datastamp=12&region=us\";\n        String actionId = \"myAction\";\n        pdms.addMissingPartition(newHCatDependency, actionId);\n\n        HCatURI hcatUri = new HCatURI(newHCatDependency);\n        Map<String, PartitionsGroup> tablePartitionsMap = pdms.getHCatMap().get(hcatUri.getServerEndPoint() + \"#\" +\n                                                                            hcatUri.getDb()); // clicks\n        assertNotNull(tablePartitionsMap);\n        assertTrue(tablePartitionsMap.containsKey(\"clicks\"));\n        PartitionsGroup missingPartitions = tablePartitionsMap.get(hcatUri.getTable());\n        assertNotNull(missingPartitions);\n\n        // remove with cascading - OFF\n        pdms.removePartition(newHCatDependency, false);\n        assertFalse(missingPartitions.getPartitionsMap().containsKey(hcatUri.getPartitionMap()));\n\n        pdms.addMissingPartition(newHCatDependency, actionId);\n        assertNotNull(missingPartitions);\n\n        // remove with cascading - ON\n        pdms.removePartition(newHCatDependency);\n        assertFalse(pdms.getHCatMap().containsKey(hcatUri.getTable()));\n    }",
            "method_tgt": "@Test\n    public void testRemovePartition() throws Exception {\n        Services services = Services.get();\n        PartitionDependencyManagerService pdms = services.get(PartitionDependencyManagerService.class);\n        String newHCatDependency = \"hcat://hcat.yahoo.com:5080/database/mydb/table/clicks/partition/datastamp=12,region=us\";\n        String actionId = \"myAction\";\n        pdms.addMissingPartition(newHCatDependency, actionId);\n\n        HCatURI hcatUri = new HCatURI(newHCatDependency);\n        Map<String, PartitionsGroup> tablePartitionsMap = pdms.getHCatMap().get(hcatUri.getServerEndPoint() + \"#\" +\n                                                                            hcatUri.getDb()); // clicks\n        assertNotNull(tablePartitionsMap);\n        assertTrue(tablePartitionsMap.containsKey(\"clicks\"));\n        PartitionsGroup missingPartitions = tablePartitionsMap.get(hcatUri.getTable());\n        assertNotNull(missingPartitions);\n\n        // remove with cascading - OFF\n        pdms.removePartition(newHCatDependency, false);\n        assertFalse(missingPartitions.getPartitionsMap().containsKey(hcatUri.getPartitionMap()));\n\n        pdms.addMissingPartition(newHCatDependency, actionId);\n        assertNotNull(missingPartitions);\n\n        // remove with cascading - ON\n        pdms.removePartition(newHCatDependency);\n        assertFalse(pdms.getHCatMap().containsKey(hcatUri.getTable()));\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 0,
            "throw_types": 1
        },
        "comment": "[Hard] Input value changes in the ground truth"
    },
    {
        "repo_name": "apiman/apiman",
        "commit_id": "a49df3db7b8dfeba5957fe743a11564b0789bd52",
        "commit_url": "https://github.com/apiman/apiman/commit/a49df3db7b8dfeba5957fe743a11564b0789bd52",
        "focal_db": {
            "id": "1310205",
            "rel_path": "gateway/platforms/servlet/src/main/java/io/apiman/gateway/platforms/servlet/GatewayServlet.java",
            "method_src": "protected static final ServiceRequestPathInfo parseServiceRequestPath(String pathInfo) {\n        ServiceRequestPathInfo info = new ServiceRequestPathInfo();\n        if (pathInfo != null) {\n            String[] split = pathInfo.split(\"/\"); //$NON-NLS-1$\n            if (split.length >= 4) {\n                info.orgId = split[1];\n                info.serviceId = split[2];\n                info.serviceVersion = split[3];\n                if (split.length > 4) {\n                    StringBuilder resource = new StringBuilder();\n                    for (int idx = 4; idx < split.length; idx++) {\n                        resource.append('/');\n                        resource.append(split[idx]);\n                    }\n                    if (pathInfo.endsWith(\"/\")) { //$NON-NLS-1$\n                        resource.append('/');\n                    }\n                    info.resource = resource.toString();\n                }\n            }\n        }\n        return info;\n    }",
            "method_tgt": "protected static final ServiceRequestPathInfo parseServiceRequestPath(HttpServletRequest request) {\n        String pathInfo = request.getPathInfo();\n        ServiceRequestPathInfo info = new ServiceRequestPathInfo();\n\n        boolean versionFound = false;\n\n        String apiVersionHeader = request.getHeader(\"X-API-Version\"); //$NON-NLS-1$\n        if (apiVersionHeader != null && apiVersionHeader.trim().length() > 0) {\n            info.serviceVersion = apiVersionHeader;\n            versionFound = true;\n        } else {\n            String acceptHeader = request.getHeader(\"Accept\"); //$NON-NLS-1$\n            if (acceptHeader != null && acceptHeader.startsWith(\"application/apiman.\")) { //$NON-NLS-1$\n                String [] split = acceptHeader.split(\"\\\\+\"); //$NON-NLS-1$\n                info.serviceVersion = split[0].substring(\"application/apiman.\".length()); //$NON-NLS-1$\n                versionFound = true;\n            }\n        }\n\n        int minParts = versionFound ? 3 : 4;\n\n        if (pathInfo != null) {\n            String[] split = pathInfo.split(\"/\"); //$NON-NLS-1$\n            if (split.length >= minParts) {\n                info.orgId = split[1];\n                info.serviceId = split[2];\n                if (!versionFound) {\n                    info.serviceVersion = split[3];\n                }\n                if (split.length > minParts) {\n                    StringBuilder resource = new StringBuilder();\n                    for (int idx = minParts; idx < split.length; idx++) {\n                        resource.append('/');\n                        resource.append(split[idx]);\n                    }\n                    if (pathInfo.endsWith(\"/\")) { //$NON-NLS-1$\n                        resource.append('/');\n                    }\n                    info.resource = resource.toString();\n                }\n            }\n        }\n        return info;\n    }"
        },
        "test_db": {
            "id": "1310248",
            "rel_path": "gateway/platforms/servlet/src/test/java/io/apiman/gateway/platforms/servlet/GatewayServletTest.java",
            "method_src": "@Test\n    public void testParseServiceRequestPath() {\n        ServiceRequestPathInfo info = GatewayServlet.parseServiceRequestPath(null);\n\n        info = GatewayServlet.parseServiceRequestPath(\"/invalidpath\");\n        Assert.assertNull(info.orgId);\n        Assert.assertNull(info.serviceId);\n        Assert.assertNull(info.serviceVersion);\n        Assert.assertNull(info.resource);\n\n        info = GatewayServlet.parseServiceRequestPath(\"/invalid/path\");\n        Assert.assertNull(info.orgId);\n        Assert.assertNull(info.serviceId);\n        Assert.assertNull(info.serviceVersion);\n        Assert.assertNull(info.resource);\n\n        info = GatewayServlet.parseServiceRequestPath(\"/Org1/Service1/1.0\");\n        Assert.assertEquals(\"Org1\", info.orgId);\n        Assert.assertEquals(\"Service1\", info.serviceId);\n        Assert.assertEquals(\"1.0\", info.serviceVersion);\n        Assert.assertNull(info.resource);\n\n        info = GatewayServlet.parseServiceRequestPath(\"/MyOrg/Service-99/2.7\");\n        Assert.assertEquals(\"MyOrg\", info.orgId);\n        Assert.assertEquals(\"Service-99\", info.serviceId);\n        Assert.assertEquals(\"2.7\", info.serviceVersion);\n        Assert.assertNull(info.resource);\n\n        info = GatewayServlet.parseServiceRequestPath(\"/MyOrg/Service-99/2.7/resource\");\n        Assert.assertEquals(\"MyOrg\", info.orgId);\n        Assert.assertEquals(\"Service-99\", info.serviceId);\n        Assert.assertEquals(\"2.7\", info.serviceVersion);\n        Assert.assertEquals(\"/resource\", info.resource);\n\n        info = GatewayServlet.parseServiceRequestPath(\"/MyOrg/Service-99/2.7/path/to/resource\");\n        Assert.assertEquals(\"MyOrg\", info.orgId);\n        Assert.assertEquals(\"Service-99\", info.serviceId);\n        Assert.assertEquals(\"2.7\", info.serviceVersion);\n        Assert.assertEquals(\"/path/to/resource\", info.resource);\n\n        info = GatewayServlet.parseServiceRequestPath(\"/MyOrg/Service-99/2.7/path/to/resource?query=1234\");\n        Assert.assertEquals(\"MyOrg\", info.orgId);\n        Assert.assertEquals(\"Service-99\", info.serviceId);\n        Assert.assertEquals(\"2.7\", info.serviceVersion);\n        Assert.assertEquals(\"/path/to/resource?query=1234\", info.resource);\n    }",
            "method_tgt": "@Test\n    public void testParseServiceRequestPath() {\n        ServiceRequestPathInfo info = parseServiceRequestPath(null);\n\n        info = parseServiceRequestPath(\"/invalidpath\");\n        Assert.assertNull(info.orgId);\n        Assert.assertNull(info.serviceId);\n        Assert.assertNull(info.serviceVersion);\n        Assert.assertNull(info.resource);\n\n        info = parseServiceRequestPath(\"/invalid/path\");\n        Assert.assertNull(info.orgId);\n        Assert.assertNull(info.serviceId);\n        Assert.assertNull(info.serviceVersion);\n        Assert.assertNull(info.resource);\n\n        info = parseServiceRequestPath(\"/Org1/Service1/1.0\");\n        Assert.assertEquals(\"Org1\", info.orgId);\n        Assert.assertEquals(\"Service1\", info.serviceId);\n        Assert.assertEquals(\"1.0\", info.serviceVersion);\n        Assert.assertNull(info.resource);\n\n        info = parseServiceRequestPath(\"/MyOrg/Service-99/2.7\");\n        Assert.assertEquals(\"MyOrg\", info.orgId);\n        Assert.assertEquals(\"Service-99\", info.serviceId);\n        Assert.assertEquals(\"2.7\", info.serviceVersion);\n        Assert.assertNull(info.resource);\n\n        info = parseServiceRequestPath(\"/MyOrg/Service-99/2.7/resource\");\n        Assert.assertEquals(\"MyOrg\", info.orgId);\n        Assert.assertEquals(\"Service-99\", info.serviceId);\n        Assert.assertEquals(\"2.7\", info.serviceVersion);\n        Assert.assertEquals(\"/resource\", info.resource);\n\n        info = parseServiceRequestPath(\"/MyOrg/Service-99/2.7/path/to/resource\");\n        Assert.assertEquals(\"MyOrg\", info.orgId);\n        Assert.assertEquals(\"Service-99\", info.serviceId);\n        Assert.assertEquals(\"2.7\", info.serviceVersion);\n        Assert.assertEquals(\"/path/to/resource\", info.resource);\n\n        info = parseServiceRequestPath(\"/MyOrg/Service-99/2.7/path/to/resource?query=1234\");\n        Assert.assertEquals(\"MyOrg\", info.orgId);\n        Assert.assertEquals(\"Service-99\", info.serviceId);\n        Assert.assertEquals(\"2.7\", info.serviceVersion);\n        Assert.assertEquals(\"/path/to/resource?query=1234\", info.resource);\n\n        info = parseServiceRequestPath(\"/MyOrg/Service-99/path/to/resource?query=1234\", null, \"2.7\");\n        Assert.assertEquals(\"MyOrg\", info.orgId);\n        Assert.assertEquals(\"Service-99\", info.serviceId);\n        Assert.assertEquals(\"2.7\", info.serviceVersion);\n        Assert.assertEquals(\"/path/to/resource?query=1234\", info.resource);\n\n        info = parseServiceRequestPath(\"/MyOrg/Service-99/path/to/resource?query=1234\", \"application/apiman.2.7+json\", null);\n        Assert.assertEquals(\"MyOrg\", info.orgId);\n        Assert.assertEquals(\"Service-99\", info.serviceId);\n        Assert.assertEquals(\"2.7\", info.serviceVersion);\n        Assert.assertEquals(\"/path/to/resource?query=1234\", info.resource);\n\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        },
        "comment": "[Hard] Semantic breaking changes are introduced in test"
    },
    {
        "repo_name": "bazelbuild/bazel",
        "commit_id": "d0a3c5eb67320906e4b937df5434f0e673cb6dce",
        "commit_url": "https://github.com/bazelbuild/bazel/commit/d0a3c5eb67320906e4b937df5434f0e673cb6dce",
        "focal_db": {
            "id": "1410298",
            "rel_path": "src/main/java/com/google/devtools/build/lib/packages/AbstractAttributeMapper.java",
            "method_src": "@Override\n  public void visitLabels(final AcceptsLabelAttribute observer) throws InterruptedException {\n    Type.LabelVisitor<Attribute> visitor = new Type.LabelVisitor<Attribute>() {\n      @Override\n      public void visit(@Nullable Label label, Attribute attribute) throws InterruptedException {\n        if (label != null) {\n          Label absoluteLabel = ruleLabel.resolveRepositoryRelative(label);\n          observer.acceptLabelAttribute(absoluteLabel, attribute);\n        }\n      }\n    };\n    for (Attribute attribute : ruleClass.getAttributes()) {\n      Type<?> type = attribute.getType();\n      // TODO(bazel-team): clean up the typing / visitation interface so we don't have to\n      // special-case these types.\n      if (type != BuildType.OUTPUT && type != BuildType.OUTPUT_LIST\n          && type != BuildType.NODEP_LABEL && type != BuildType.NODEP_LABEL_LIST) {\n        visitLabels(attribute, visitor);\n      }\n    }\n  }",
            "method_tgt": "@Override\n  public Collection<DepEdge> visitLabels() throws InterruptedException {\n    List<DepEdge> edges = new ArrayList<>();\n    Type.LabelVisitor<Attribute> visitor =\n        (label, attribute) -> {\n          if (label != null) {\n            Label absoluteLabel = ruleLabel.resolveRepositoryRelative(label);\n            edges.add(AttributeMap.DepEdge.create(absoluteLabel, attribute));\n          }\n        };\n    for (Attribute attribute : ruleClass.getAttributes()) {\n      Type<?> type = attribute.getType();\n      // TODO(bazel-team): clean up the typing / visitation interface so we don't have to\n      // special-case these types.\n      if (type != BuildType.OUTPUT && type != BuildType.OUTPUT_LIST\n          && type != BuildType.NODEP_LABEL && type != BuildType.NODEP_LABEL_LIST) {\n        visitLabels(attribute, visitor);\n      }\n    }\n    return edges;\n  }"
        },
        "test_db": {
            "id": "1410508",
            "rel_path": "src/test/java/com/google/devtools/build/lib/analysis/select/AbstractAttributeMapperTest.java",
            "method_src": "@Test\n  public void testVisitation() throws Exception {\n    VisitationRecorder recorder = new VisitationRecorder(\"srcs\");\n    mapper.visitLabels(recorder);\n    assertThat(recorder.labelsVisited).containsExactly(\"//p:a\", \"//p:b\", \"//p:c\");\n  }",
            "method_tgt": "@Test\n  public void testVisitation() throws Exception {\n    assertThat(getLabelsForAttribute(mapper, \"srcs\")).containsExactly(\"//p:a\", \"//p:b\", \"//p:c\");\n  }"
        },
        "syn_diff": {
            "overall": 2,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 1,
        "comment": "[Hard] Tests are wrapped by a private method."
    },
    {
        "repo_name": "bazelbuild/bazel",
        "commit_id": "d0a3c5eb67320906e4b937df5434f0e673cb6dce",
        "commit_url": "https://github.com/bazelbuild/bazel/commit/d0a3c5eb67320906e4b937df5434f0e673cb6dce",
        "focal_db": {
            "id": "1410298",
            "rel_path": "src/main/java/com/google/devtools/build/lib/packages/AggregatingAttributeMapper.java",
            "method_src": "AttributeMap createMapBackedAttributeMap(final Map<String, Object> directMap) {\n    final AggregatingAttributeMapper owner = AggregatingAttributeMapper.this;\n    return new AttributeMap() {\n\n      @Override\n      public <T> T get(String attributeName, Type<T> type) {\n        owner.checkType(attributeName, type);\n        if (getNonConfigurableAttributes().contains(attributeName)) {\n          return owner.get(attributeName, type);\n        }\n        if (!directMap.containsKey(attributeName)) {\n          throw new IllegalArgumentException(\n              \"attribute \\\"\"\n                  + attributeName\n                  + \"\\\" isn't available in this computed default context\");\n        }\n        return type.cast(directMap.get(attributeName));\n      }\n\n      @Override\n      public boolean isConfigurable(String attributeName) {\n        return owner.isConfigurable(attributeName);\n      }\n\n      @Override\n      public String getName() {\n        return owner.getName();\n      }\n\n      @Override\n      public Label getLabel() {\n        return owner.getLabel();\n      }\n\n      @Override\n      public String getRuleClassName() {\n        return owner.getRuleClassName();\n      }\n\n      @Override\n      public Iterable<String> getAttributeNames() {\n        return ImmutableList.<String>builder()\n            .addAll(directMap.keySet())\n            .addAll(getNonConfigurableAttributes())\n            .build();\n      }\n\n      @Override\n      public void visitLabels(AcceptsLabelAttribute observer) throws InterruptedException {\n        owner.visitLabels(observer);\n      }\n\n      @Override\n      public String getPackageDefaultHdrsCheck() {\n        return owner.getPackageDefaultHdrsCheck();\n      }\n\n      @Override\n      public Boolean getPackageDefaultTestOnly() {\n        return owner.getPackageDefaultTestOnly();\n      }\n\n      @Override\n      public String getPackageDefaultDeprecation() {\n        return owner.getPackageDefaultDeprecation();\n      }\n\n      @Override\n      public ImmutableList<String> getPackageDefaultCopts() {\n        return owner.getPackageDefaultCopts();\n      }\n\n      @Nullable\n      @Override\n      public Type<?> getAttributeType(String attrName) {\n        return owner.getAttributeType(attrName);\n      }\n\n      @Nullable\n      @Override\n      public Attribute getAttributeDefinition(String attrName) {\n        return owner.getAttributeDefinition(attrName);\n      }\n\n      @Override\n      public boolean isAttributeValueExplicitlySpecified(String attributeName) {\n        return owner.isAttributeValueExplicitlySpecified(attributeName);\n      }\n\n      @Override\n      public boolean has(String attrName) {\n        return owner.has(attrName);\n      }\n\n      @Override\n      public <T> boolean has(String attrName, Type<T> type) {\n        return owner.has(attrName, type);\n      }\n\n      @Override\n      public Location getAttributeLocation(String attrName) {\n        return owner.getAttributeLocation(attrName);\n      }\n    };\n  }",
            "method_tgt": "AttributeMap createMapBackedAttributeMap(final Map<String, Object> directMap) {\n    final AggregatingAttributeMapper owner = AggregatingAttributeMapper.this;\n    return new AttributeMap() {\n\n      @Override\n      public <T> T get(String attributeName, Type<T> type) {\n        owner.checkType(attributeName, type);\n        if (getNonConfigurableAttributes().contains(attributeName)) {\n          return owner.get(attributeName, type);\n        }\n        if (!directMap.containsKey(attributeName)) {\n          throw new IllegalArgumentException(\n              \"attribute \\\"\"\n                  + attributeName\n                  + \"\\\" isn't available in this computed default context\");\n        }\n        return type.cast(directMap.get(attributeName));\n      }\n\n      @Override\n      public boolean isConfigurable(String attributeName) {\n        return owner.isConfigurable(attributeName);\n      }\n\n      @Override\n      public String getName() {\n        return owner.getName();\n      }\n\n      @Override\n      public Label getLabel() {\n        return owner.getLabel();\n      }\n\n      @Override\n      public String getRuleClassName() {\n        return owner.getRuleClassName();\n      }\n\n      @Override\n      public Iterable<String> getAttributeNames() {\n        return ImmutableList.<String>builder()\n            .addAll(directMap.keySet())\n            .addAll(getNonConfigurableAttributes())\n            .build();\n      }\n\n      @Override\n      public Collection<DepEdge> visitLabels() throws InterruptedException {\n        return owner.visitLabels();\n      }\n\n      @Override\n      public String getPackageDefaultHdrsCheck() {\n        return owner.getPackageDefaultHdrsCheck();\n      }\n\n      @Override\n      public Boolean getPackageDefaultTestOnly() {\n        return owner.getPackageDefaultTestOnly();\n      }\n\n      @Override\n      public String getPackageDefaultDeprecation() {\n        return owner.getPackageDefaultDeprecation();\n      }\n\n      @Override\n      public ImmutableList<String> getPackageDefaultCopts() {\n        return owner.getPackageDefaultCopts();\n      }\n\n      @Nullable\n      @Override\n      public Type<?> getAttributeType(String attrName) {\n        return owner.getAttributeType(attrName);\n      }\n\n      @Nullable\n      @Override\n      public Attribute getAttributeDefinition(String attrName) {\n        return owner.getAttributeDefinition(attrName);\n      }\n\n      @Override\n      public boolean isAttributeValueExplicitlySpecified(String attributeName) {\n        return owner.isAttributeValueExplicitlySpecified(attributeName);\n      }\n\n      @Override\n      public boolean has(String attrName) {\n        return owner.has(attrName);\n      }\n\n      @Override\n      public <T> boolean has(String attrName, Type<T> type) {\n        return owner.has(attrName, type);\n      }\n\n      @Override\n      public Location getAttributeLocation(String attrName) {\n        return owner.getAttributeLocation(attrName);\n      }\n    };\n  }"
        },
        "test_db": {
            "id": "1410508",
            "rel_path": "src/test/java/com/google/devtools/build/lib/analysis/select/AggregatingAttributeMapperTest.java",
            "method_src": "@Test\n  public void testVisitationConfigurableAttribute() throws Exception {\n    Rule rule = scratchRule(\"a\", \"myrule\",\n        \"sh_binary(name = 'myrule',\",\n        \"          srcs = select({\",\n        \"              '//conditions:a': ['a.sh'],\",\n        \"              '//conditions:b': ['b.sh'],\",\n        \"              '\" + BuildType.Selector.DEFAULT_CONDITION_KEY + \"': ['default.sh'],\",\n        \"          }))\");\n\n    VisitationRecorder recorder = new VisitationRecorder(\"srcs\");\n    AggregatingAttributeMapper.of(rule).visitLabels(recorder);\n    assertThat(recorder.labelsVisited)\n        .containsExactlyElementsIn(\n            ImmutableList.of(\n                \"//a:a.sh\", \"//a:b.sh\", \"//a:default.sh\", \"//conditions:a\", \"//conditions:b\"));\n  }",
            "method_tgt": "@Test\n  public void testVisitationConfigurableAttribute() throws Exception {\n    Rule rule = scratchRule(\"a\", \"myrule\",\n        \"sh_binary(name = 'myrule',\",\n        \"          srcs = select({\",\n        \"              '//conditions:a': ['a.sh'],\",\n        \"              '//conditions:b': ['b.sh'],\",\n        \"              '\" + BuildType.Selector.DEFAULT_CONDITION_KEY + \"': ['default.sh'],\",\n        \"          }))\");\n\n    assertThat(getLabelsForAttribute(AggregatingAttributeMapper.of(rule), \"srcs\"))\n        .containsExactlyElementsIn(\n            ImmutableList.of(\n                \"//a:a.sh\", \"//a:b.sh\", \"//a:default.sh\", \"//conditions:a\", \"//conditions:b\"));\n  }"
        },
        "syn_diff": {
            "overall": 0,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 0,
            "throw_types": 0
        },
        "aug": 2,
        "comment": "[Hard] Tests are wrapped by a private method."
    },
    {
        "repo_name": "biojava/biojava",
        "commit_id": "996c149416ca2d1fcff09e2ce8015d44ff6468eb",
        "commit_url": "https://github.com/biojava/biojava/commit/996c149416ca2d1fcff09e2ce8015d44ff6468eb",
        "focal_db": {
            "id": "1442133",
            "rel_path": "biojava-structure/src/main/java/org/biojava/nbio/structure/cluster/SubunitCluster.java",
            "method_src": "public boolean divideInternally(double coverageThreshold,\n\t\t\tdouble rmsdThreshold, int minSequenceLength)\n\t\t\tthrows StructureException {\n\n\t\tCESymmParameters params = new CESymmParameters();\n\t\tparams.setMinCoreLength(minSequenceLength);\n\t\tparams.setGaps(false); // We want no gaps between the repeats\n\n\t\t// Analyze the internal symmetry of the representative subunit\n\t\tCeSymmResult result = CeSymm.analyze(subunits.get(representative)\n\t\t\t\t.getRepresentativeAtoms(), params);\n\n\t\tif (!result.isSignificant())\n\t\t\treturn false;\n\n\t\tdouble rmsd = result.getMultipleAlignment().getScore(\n\t\t\t\tMultipleAlignmentScorer.RMSD);\n\t\tif (rmsd > rmsdThreshold)\n\t\t\treturn false;\n\n\t\tdouble coverage = result.getMultipleAlignment().getCoverages().get(0)\n\t\t\t\t* result.getNumRepeats();\n\t\tif (coverage < coverageThreshold)\n\t\t\treturn false;\n\n\t\tlogger.info(\"SubunitCluster is internally symmetric with {} repeats, \"\n\t\t\t\t+ \"{} RMSD and {} coverage\", result.getNumRepeats(), rmsd,\n\t\t\t\tcoverage);\n\n\t\t// Divide if symmety was significant with RMSD and coverage sufficient\n\t\tList<List<Integer>> alignedRes = result.getMultipleAlignment()\n\t\t\t\t.getBlock(0).getAlignRes();\n\n\t\tList<List<Integer>> columns = new ArrayList<List<Integer>>();\n\t\tfor (int s = 0; s < alignedRes.size(); s++)\n\t\t\tcolumns.add(new ArrayList<Integer>(alignedRes.get(s).size()));\n\n\t\t// Extract the aligned columns of each repeat in the Subunit\n\t\tfor (int col = 0; col < alignedRes.get(0).size(); col++) {\n\n\t\t\t// Check that all aligned residues are part of the Cluster\n\t\t\tboolean missing = false;\n\t\t\tfor (int s = 0; s < alignedRes.size(); s++) {\n\t\t\t\tif (!subunitEQR.get(representative).contains(\n\t\t\t\t\t\talignedRes.get(s).get(col))) {\n\t\t\t\t\tmissing = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Skip the column if any residue was not part of the cluster\n\t\t\tif (missing)\n\t\t\t\tcontinue;\n\n\t\t\tfor (int s = 0; s < alignedRes.size(); s++) {\n\t\t\t\tcolumns.get(s).add(\n\t\t\t\t\t\tsubunitEQR.get(representative).indexOf(\n\t\t\t\t\t\t\t\talignedRes.get(s).get(col)));\n\t\t\t}\n\t\t}\n\n\t\t// Divide the Subunits in their repeats\n\t\tList<Subunit> newSubunits = new ArrayList<Subunit>(subunits.size()\n\t\t\t\t* columns.size());\n\t\tList<List<Integer>> newSubunitEQR = new ArrayList<List<Integer>>(\n\t\t\t\tsubunits.size() * columns.size());\n\n\t\tfor (int s = 0; s < subunits.size(); s++) {\n\t\t\tfor (int r = 0; r < columns.size(); r++) {\n\n\t\t\t\t// Calculate start and end residues of the new Subunit\n\t\t\t\tint start = subunitEQR.get(s).get(columns.get(r).get(0));\n\t\t\t\tint end = subunitEQR.get(s).get(\n\t\t\t\t\t\tcolumns.get(r).get(columns.get(r).size() - 1));\n\n\t\t\t\tAtom[] reprAtoms = Arrays.copyOfRange(subunits.get(s)\n\t\t\t\t\t\t.getRepresentativeAtoms(), start, end + 1);\n\n\t\t\t\tnewSubunits.add(new Subunit(reprAtoms, subunits.get(s)\n\t\t\t\t\t\t.getName(), subunits.get(s).getIdentifier(), subunits\n\t\t\t\t\t\t.get(s).getStructure()));\n\n\t\t\t\t// Recalculate equivalent residues\n\t\t\t\tList<Integer> eqr = new ArrayList<Integer>();\n\t\t\t\tfor (int p = 0; p < columns.get(r).size(); p++) {\n\t\t\t\t\teqr.add(subunitEQR.get(s).get(columns.get(r).get(p))\n\t\t\t\t\t\t\t- start);\n\t\t\t\t}\n\t\t\t\tnewSubunitEQR.add(eqr);\n\t\t\t}\n\t\t}\n\n\t\tsubunits = newSubunits;\n\t\tsubunitEQR = newSubunitEQR;\n\n\t\t// Update representative\n\t\tfor (int s = 0; s < subunits.size(); s++) {\n\t\t\tif (subunits.get(s).size() > subunits.get(representative).size())\n\t\t\t\trepresentative = s;\n\t\t}\n\n\t\tmethod = SubunitClustererMethod.STRUCTURE;\n\n\t\treturn true;\n\t}",
            "method_tgt": "public boolean divideInternally(SubunitClustererParameters clusterParams)\n\t\t\tthrows StructureException {\n\n\t\tCESymmParameters cesym_params = new CESymmParameters();\n\t\tcesym_params.setMinCoreLength(clusterParams.getMinimumSequenceLength());\n\t\tcesym_params.setGaps(false); // We want no gaps between the repeats\n\n\t\t// Analyze the internal symmetry of the representative subunit\n\t\tCeSymmResult result = CeSymm.analyze(subunits.get(representative)\n\t\t\t\t.getRepresentativeAtoms(), cesym_params);\n\n\t\tif (!result.isSignificant())\n\t\t\treturn false;\n\n\t\tdouble rmsd = result.getMultipleAlignment().getScore(\n\t\t\t\tMultipleAlignmentScorer.RMSD);\n\t\tif (rmsd > clusterParams.getRMSDThreshold())\n\t\t\treturn false;\n\n\t\tdouble coverage = result.getMultipleAlignment().getCoverages().get(0)\n\t\t\t\t* result.getNumRepeats();\n\t\tif (coverage < clusterParams.getStructureCoverageThreshold())\n\t\t\treturn false;\n\n\t\tlogger.info(\"SubunitCluster is internally symmetric with {} repeats, \"\n\t\t\t\t+ \"{} RMSD and {} coverage\", result.getNumRepeats(), rmsd,\n\t\t\t\tcoverage);\n\n\t\t// Divide if symmety was significant with RMSD and coverage sufficient\n\t\tList<List<Integer>> alignedRes = result.getMultipleAlignment()\n\t\t\t\t.getBlock(0).getAlignRes();\n\n\t\tList<List<Integer>> columns = new ArrayList<List<Integer>>();\n\t\tfor (int s = 0; s < alignedRes.size(); s++)\n\t\t\tcolumns.add(new ArrayList<Integer>(alignedRes.get(s).size()));\n\n\t\t// Extract the aligned columns of each repeat in the Subunit\n\t\tfor (int col = 0; col < alignedRes.get(0).size(); col++) {\n\n\t\t\t// Check that all aligned residues are part of the Cluster\n\t\t\tboolean missing = false;\n\t\t\tfor (int s = 0; s < alignedRes.size(); s++) {\n\t\t\t\tif (!subunitEQR.get(representative).contains(\n\t\t\t\t\t\talignedRes.get(s).get(col))) {\n\t\t\t\t\tmissing = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Skip the column if any residue was not part of the cluster\n\t\t\tif (missing)\n\t\t\t\tcontinue;\n\n\t\t\tfor (int s = 0; s < alignedRes.size(); s++) {\n\t\t\t\tcolumns.get(s).add(\n\t\t\t\t\t\tsubunitEQR.get(representative).indexOf(\n\t\t\t\t\t\t\t\talignedRes.get(s).get(col)));\n\t\t\t}\n\t\t}\n\n\t\t// Divide the Subunits in their repeats\n\t\tList<Subunit> newSubunits = new ArrayList<Subunit>(subunits.size()\n\t\t\t\t* columns.size());\n\t\tList<List<Integer>> newSubunitEQR = new ArrayList<List<Integer>>(\n\t\t\t\tsubunits.size() * columns.size());\n\n\t\tfor (int s = 0; s < subunits.size(); s++) {\n\t\t\tfor (int r = 0; r < columns.size(); r++) {\n\n\t\t\t\t// Calculate start and end residues of the new Subunit\n\t\t\t\tint start = subunitEQR.get(s).get(columns.get(r).get(0));\n\t\t\t\tint end = subunitEQR.get(s).get(\n\t\t\t\t\t\tcolumns.get(r).get(columns.get(r).size() - 1));\n\n\t\t\t\tAtom[] reprAtoms = Arrays.copyOfRange(subunits.get(s)\n\t\t\t\t\t\t.getRepresentativeAtoms(), start, end + 1);\n\n\t\t\t\tnewSubunits.add(new Subunit(reprAtoms, subunits.get(s)\n\t\t\t\t\t\t.getName(), subunits.get(s).getIdentifier(), subunits\n\t\t\t\t\t\t.get(s).getStructure()));\n\n\t\t\t\t// Recalculate equivalent residues\n\t\t\t\tList<Integer> eqr = new ArrayList<Integer>();\n\t\t\t\tfor (int p = 0; p < columns.get(r).size(); p++) {\n\t\t\t\t\teqr.add(subunitEQR.get(s).get(columns.get(r).get(p))\n\t\t\t\t\t\t\t- start);\n\t\t\t\t}\n\t\t\t\tnewSubunitEQR.add(eqr);\n\t\t\t}\n\t\t}\n\n\t\tsubunits = newSubunits;\n\t\tsubunitEQR = newSubunitEQR;\n\n\t\t// Update representative\n\t\tfor (int s = 0; s < subunits.size(); s++) {\n\t\t\tif (subunits.get(s).size() > subunits.get(representative).size())\n\t\t\t\trepresentative = s;\n\t\t}\n\n\t\tmethod = SubunitClustererMethod.STRUCTURE;\n\t\tpseudoStoichiometric = true;\n\t\treturn true;\n\t}"
        },
        "test_db": {
            "id": "1442147",
            "rel_path": "biojava-structure/src/test/java/org/biojava/nbio/structure/cluster/TestSubunitCluster.java",
            "method_src": "@Test\n\tpublic void testDivideInternally() throws StructureException, IOException {\n\n\t\tStructure s = StructureIO.getStructure(\"4e3e\");\n\n\t\t// Create a SubunitCluster for the chain\n\t\tSubunitCluster sc1 = new SubunitCluster(\n\t\t\t\tnew Subunit(StructureTools.getRepresentativeAtomArray(s\n\t\t\t\t\t\t.getChainByIndex(0)), \"chain 0\", null, s));\n\n\t\t// Clusters should be merged by identity\n\t\tboolean divided = sc1.divideInternally(0.8, 3.0, 20);\n\n\t\t// Divided has to be true, and Subunit length shorter than half\n\t\tassertTrue(divided);\n\t\tassertEquals(sc1.size(), 2);\n\t\tassertTrue(sc1.length() < 178);\n\t\tassertEquals(sc1.getAlignedAtomsSubunit(0).length,\n\t\t\t\tsc1.getAlignedAtomsSubunit(1).length);\n\t}",
            "method_tgt": "@Test\n\tpublic void testDivideInternally() throws StructureException, IOException {\n\n\t\tStructure s = StructureIO.getStructure(\"4e3e\");\n\n\t\t// Create a SubunitCluster for the chain\n\t\tSubunitCluster sc1 = new SubunitCluster(\n\t\t\t\tnew Subunit(StructureTools.getRepresentativeAtomArray(s\n\t\t\t\t\t\t.getChainByIndex(0)), \"chain 0\", null, s));\n\n\t\tSubunitClustererParameters clustererParameters = new SubunitClustererParameters();\n\t\tclustererParameters.setStructureCoverageThreshold(0.8);\n\t\tclustererParameters.setRMSDThreshold(3.0);\n\t\tclustererParameters.setMinimumSequenceLength(20);\n\n\t\t// Clusters should be merged by identity\n\t\tboolean divided = sc1.divideInternally(clustererParameters);\n\n\t\t// Divided has to be true, and Subunit length shorter than half\n\t\tassertTrue(divided);\n\t\tassertEquals(sc1.size(), 2);\n\t\tassertTrue(sc1.length() < 178);\n\t\tassertEquals(sc1.getAlignedAtomsSubunit(0).length,\n\t\t\t\tsc1.getAlignedAtomsSubunit(1).length);\n\t}"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        },
        "comment": "Case study"
    },
    {
        "repo_name": "biojava/biojava",
        "commit_id": "996c149416ca2d1fcff09e2ce8015d44ff6468eb",
        "commit_url": "https://github.com/biojava/biojava/commit/996c149416ca2d1fcff09e2ce8015d44ff6468eb",
        "focal_db": {
            "id": "1442133",
            "rel_path": "biojava-structure/src/main/java/org/biojava/nbio/structure/cluster/SubunitCluster.java",
            "method_src": "public boolean mergeStructure(SubunitCluster other, double maxRmsd,\n\t\t\tdouble minCoverage) throws StructureException {\n\t\t// Use a CE alignment with default parameters\n\t\tStructureAlignment algorithm = StructureAlignmentFactory\n\t\t\t\t.getAlgorithm(CeMain.algorithmName);\n\t\treturn mergeStructure(other, maxRmsd, minCoverage, algorithm);\n\t}",
            "method_tgt": "public boolean mergeStructure(SubunitCluster other, SubunitClustererParameters params) throws StructureException {\n\n\t\tStructureAlignment aligner = StructureAlignmentFactory.getAlgorithm(params.getSuperpositionAlgorithm());\n\t\tConfigStrucAligParams aligner_params = aligner.getParameters();\n\n\t\tMethod setOptimizeAlignment = null;\n\t\ttry {\n\t\t\tsetOptimizeAlignment = aligner_params.getClass().getMethod(\"setOptimizeAlignment\", boolean.class);\n\t\t} catch (NoSuchMethodException e) {\n\t\t\t//alignment algorithm does not have an optimization switch, moving on\n\t\t}\n\t\tif (setOptimizeAlignment != null) {\n\t\t\ttry {\n\t\t\t\tsetOptimizeAlignment.invoke(aligner_params, params.isOptimizeAlignment());\n\t\t\t} catch (IllegalAccessException|InvocationTargetException e) {\n\t\t\t\tlogger.warn(\"Could not set alignment optimisation switch\");\n\t\t\t}\n\t\t}\n\n\t\tAFPChain afp = aligner.align(this.subunits.get(this.representative)\n\t\t\t\t.getRepresentativeAtoms(),\n\t\t\t\tother.subunits.get(other.representative)\n\t\t\t\t\t\t.getRepresentativeAtoms());\n\n\t\t// Convert AFPChain to MultipleAlignment for convenience\n\t\tMultipleAlignment msa = new MultipleAlignmentEnsembleImpl(\n\t\t\t\tafp,\n\t\t\t\tthis.subunits.get(this.representative).getRepresentativeAtoms(),\n\t\t\t\tother.subunits.get(other.representative)\n\t\t\t\t\t\t.getRepresentativeAtoms(), false)\n\t\t\t\t.getMultipleAlignment(0);\n\n\t\tdouble structureCoverage = Math.min(msa.getCoverages().get(0), msa\n\t\t\t\t.getCoverages().get(1));\n\n\t\tif(params.isUseStructureCoverage() && structureCoverage < params.getStructureCoverageThreshold()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tdouble rmsd = afp.getTotalRmsdOpt();\n\t\tif (params.isUseRMSD() && rmsd > params.getRMSDThreshold()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tdouble tmScore = afp.getTMScore();\n\t\tif (params.isUseTMScore() && tmScore < params.getTMThreshold()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlogger.info(String.format(\"SubunitClusters are structurally similar with \"\n\t\t\t\t+ \"%.2f RMSD %.2f coverage\", rmsd, structureCoverage));\n\n\t\t// Merge clusters\n\t\tList<List<Integer>> alignedRes = msa.getBlock(0).getAlignRes();\n\t\tList<Integer> thisAligned = new ArrayList<Integer>();\n\t\tList<Integer> otherAligned = new ArrayList<Integer>();\n\n\t\t// Extract the aligned residues of both Subunit\n\t\tfor (int p = 0; p < msa.length(); p++) {\n\n\t\t\t// Skip gaps in any of the two sequences\n\t\t\tif (alignedRes.get(0).get(p) == null)\n\t\t\t\tcontinue;\n\t\t\tif (alignedRes.get(1).get(p) == null)\n\t\t\t\tcontinue;\n\n\t\t\tint thisIndex = alignedRes.get(0).get(p);\n\t\t\tint otherIndex = alignedRes.get(1).get(p);\n\n\t\t\t// Only consider residues that are part of the SubunitCluster\n\t\t\tif (this.subunitEQR.get(this.representative).contains(thisIndex)\n\t\t\t\t\t&& other.subunitEQR.get(other.representative).contains(\n\t\t\t\t\t\t\totherIndex)) {\n\t\t\t\tthisAligned.add(thisIndex);\n\t\t\t\totherAligned.add(otherIndex);\n\t\t\t}\n\t\t}\n\n\t\t// Do a List intersection to find out which EQR columns to remove\n\t\tList<Integer> thisRemove = new ArrayList<Integer>();\n\t\tList<Integer> otherRemove = new ArrayList<Integer>();\n\n\t\tfor (int t = 0; t < this.subunitEQR.get(this.representative).size(); t++) {\n\t\t\t// If the index is aligned do nothing, otherwise mark as removing\n\t\t\tif (!thisAligned.contains(this.subunitEQR.get(this.representative)\n\t\t\t\t\t.get(t)))\n\t\t\t\tthisRemove.add(t);\n\t\t}\n\n\t\tfor (int t = 0; t < other.subunitEQR.get(other.representative).size(); t++) {\n\t\t\t// If the index is aligned do nothing, otherwise mark as removing\n\t\t\tif (!otherAligned.contains(other.subunitEQR.get(\n\t\t\t\t\tother.representative).get(t)))\n\t\t\t\totherRemove.add(t);\n\t\t}\n\n\t\t// Now remove unaligned columns, from end to start\n\t\tCollections.sort(thisRemove);\n\t\tCollections.reverse(thisRemove);\n\t\tCollections.sort(otherRemove);\n\t\tCollections.reverse(otherRemove);\n\n\t\tfor (int t = 0; t < thisRemove.size(); t++) {\n\t\t\tfor (List<Integer> eqr : this.subunitEQR) {\n\t\t\t\tint column = thisRemove.get(t);\n\t\t\t\teqr.remove(column);\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < otherRemove.size(); t++) {\n\t\t\tfor (List<Integer> eqr : other.subunitEQR) {\n\t\t\t\tint column = otherRemove.get(t);\n\t\t\t\teqr.remove(column);\n\t\t\t}\n\t\t}\n\n\t\t// The representative is the longest sequence\n\t\tif (this.subunits.get(this.representative).size() < other.subunits.get(\n\t\t\t\tother.representative).size())\n\t\t\tthis.representative = other.representative + subunits.size();\n\n\t\tthis.subunits.addAll(other.subunits);\n\t\tthis.subunitEQR.addAll(other.subunitEQR);\n\n\t\tthis.method = SubunitClustererMethod.STRUCTURE;\n\t\tpseudoStoichiometric = true;\n\n\t\treturn true;\n\t}"
        },
        "test_db": {
            "id": "1442147",
            "rel_path": "biojava-structure/src/test/java/org/biojava/nbio/structure/cluster/TestSubunitCluster.java",
            "method_src": "@Test\n\tpublic void testMergeStructure() throws StructureException, IOException {\n\n\t\tStructure s = StructureIO.getStructure(\"4hhb\");\n\n\t\t// Create one SubunitCluster for each chain\n\t\tSubunitCluster sc1 = new SubunitCluster(\n\t\t\t\tnew Subunit(StructureTools.getRepresentativeAtomArray(s\n\t\t\t\t\t\t.getChainByIndex(0)), \"chain 0\", null, s));\n\t\tSubunitCluster sc2 = new SubunitCluster(\n\t\t\t\tnew Subunit(StructureTools.getRepresentativeAtomArray(s\n\t\t\t\t\t\t.getChainByIndex(1)), \"chain 1\", null, s));\n\t\tSubunitCluster sc3 = new SubunitCluster(\n\t\t\t\tnew Subunit(StructureTools.getRepresentativeAtomArray(s\n\t\t\t\t\t\t.getChainByIndex(2)), \"chain 2\", null, s));\n\t\tSubunitCluster sc4 = new SubunitCluster(\n\t\t\t\tnew Subunit(StructureTools.getRepresentativeAtomArray(s\n\t\t\t\t\t\t.getChainByIndex(3)), \"chain 3\", null, s));\n\n\t\t// Clusters 1 and 3 and 2 and 4 are identical\n\t\tboolean merged13 = sc1.mergeStructure(sc3, 3.0, 0.9);\n\t\tboolean merged24 = sc2.mergeStructure(sc4, 3.0, 0.9);\n\n\t\t// Merged have to be true, and the merged SubunitCluster is sc1\n\t\tassertTrue(merged13);\n\t\tassertTrue(merged24);\n\t\tassertEquals(sc1.size(), 2);\n\t\tassertEquals(sc2.size(), 2);\n\t\tassertEquals(sc1.length(), 141);\n\t\tassertEquals(sc2.length(), 146);\n\t\tassertEquals(sc1.getAlignedAtomsSubunit(0).length,\n\t\t\t\tsc1.getAlignedAtomsSubunit(1).length);\n\t\tassertEquals(sc2.getAlignedAtomsSubunit(0).length,\n\t\t\t\tsc2.getAlignedAtomsSubunit(1).length);\n\n\t\t// Now test for pseudosymmetry\n\t\tboolean merged = sc1.mergeStructure(sc2, 3.0, 0.9);\n\n\t\tassertTrue(merged);\n\t\tassertEquals(sc1.size(), 4);\n\t\tassertEquals(sc1.length(), 140, 2);\n\t\tassertEquals(sc1.getAlignedAtomsSubunit(0).length,\n\t\t\t\tsc1.getAlignedAtomsSubunit(2).length);\n\n\t}",
            "method_tgt": "@Test\n\tpublic void testMergeStructure() throws StructureException, IOException {\n\n\t\tStructure s = StructureIO.getStructure(\"4hhb\");\n\n\t\t// Create one SubunitCluster for each chain\n\t\tSubunitCluster sc1 = new SubunitCluster(\n\t\t\t\tnew Subunit(StructureTools.getRepresentativeAtomArray(s\n\t\t\t\t\t\t.getChainByIndex(0)), \"chain 0\", null, s));\n\t\tSubunitCluster sc2 = new SubunitCluster(\n\t\t\t\tnew Subunit(StructureTools.getRepresentativeAtomArray(s\n\t\t\t\t\t\t.getChainByIndex(1)), \"chain 1\", null, s));\n\t\tSubunitCluster sc3 = new SubunitCluster(\n\t\t\t\tnew Subunit(StructureTools.getRepresentativeAtomArray(s\n\t\t\t\t\t\t.getChainByIndex(2)), \"chain 2\", null, s));\n\t\tSubunitCluster sc4 = new SubunitCluster(\n\t\t\t\tnew Subunit(StructureTools.getRepresentativeAtomArray(s\n\t\t\t\t\t\t.getChainByIndex(3)), \"chain 3\", null, s));\n\n\t\t// Clusters 1 and 3 and 2 and 4 are identical\n\t\tSubunitClustererParameters clustererParameters = new SubunitClustererParameters();\n\t\tclustererParameters.setRMSDThreshold(3.0);\n\t\tclustererParameters.setStructureCoverageThreshold(0.9);\n\n\t\tboolean merged13 = sc1.mergeStructure(sc3,clustererParameters);\n\t\tboolean merged24 = sc2.mergeStructure(sc4,clustererParameters);\n\n\t\t// Merged have to be true, and the merged SubunitCluster is sc1\n\t\tassertTrue(merged13);\n\t\tassertTrue(merged24);\n\t\tassertEquals(sc1.size(), 2);\n\t\tassertEquals(sc2.size(), 2);\n\t\tassertEquals(sc1.length(), 141);\n\t\tassertEquals(sc2.length(), 146);\n\t\tassertEquals(sc1.getAlignedAtomsSubunit(0).length,\n\t\t\t\tsc1.getAlignedAtomsSubunit(1).length);\n\t\tassertEquals(sc2.getAlignedAtomsSubunit(0).length,\n\t\t\t\tsc2.getAlignedAtomsSubunit(1).length);\n\n\t\t// Now test for pseudosymmetry\n\t\tboolean merged = sc1.mergeStructure(sc2, clustererParameters);\n\n\t\tassertTrue(merged);\n\t\tassertEquals(sc1.size(), 4);\n\t\tassertEquals(sc1.length(), 140, 2);\n\t\tassertEquals(sc1.getAlignedAtomsSubunit(0).length,\n\t\t\t\tsc1.getAlignedAtomsSubunit(2).length);\n\n\t}"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 1
    },
    {
        "repo_name": "biojava/biojava",
        "commit_id": "996c149416ca2d1fcff09e2ce8015d44ff6468eb",
        "commit_url": "https://github.com/biojava/biojava/commit/996c149416ca2d1fcff09e2ce8015d44ff6468eb",
        "focal_db": {
            "id": "1442133",
            "rel_path": "biojava-core/src/main/java/org/biojava/nbio/core/alignment/SimpleSequencePair.java",
            "method_src": "@Override\n\tpublic double getPercentageOfIdentity() {\n\t\tdouble seqid = getNumIdenticals();\n\t\tdouble length = getLength()\n\t\t\t\t- getAlignedSequence(1).getNumGapPositions()\n\t\t\t\t- getAlignedSequence(2).getNumGapPositions();\n\t\treturn seqid / length;\n\t}",
            "method_tgt": "@Override\n\tpublic double getPercentageOfIdentity(boolean countGaps) {\n\t\tdouble seqid = getNumIdenticals();\n\t\tdouble length = getLength();\n\t\tif (!countGaps) {\n\t\t\tlength = length - getAlignedSequence(1).getNumGapPositions()\n\t\t\t\t\t- getAlignedSequence(2).getNumGapPositions();\n\t\t}\n\t\treturn seqid / length;\n\t}"
        },
        "test_db": {
            "id": "1442147",
            "rel_path": "biojava-core/src/test/java/org/biojava/nbio/core/alignment/SimpleSequencePairTest.java",
            "method_src": "@Test\n\tpublic void testGetPercentageOfIdentity() {\n\t\tassertEquals(global.getPercentageOfIdentity(), 1.0, 0.01);\n\t\tassertEquals(local.getPercentageOfIdentity(), 1.0, 0.01);\n\t}",
            "method_tgt": "@Test\n\tpublic void testGetPercentageOfIdentity() {\n\t\tassertEquals(global.getPercentageOfIdentity(false), 1.0, 0.01);\n\t\tassertEquals(local.getPercentageOfIdentity(false), 1.0, 0.01);\n\t}"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 2,
        "comment": "Case study for adding boolean parameter"
    },
    {
        "repo_name": "caskdata/cdap",
        "commit_id": "ace313c1903f6b4f2b46892f43c6bd2352d55f1a",
        "commit_url": "https://github.com/caskdata/cdap/commit/ace313c1903f6b4f2b46892f43c6bd2352d55f1a",
        "focal_db": {
            "id": "1600832",
            "rel_path": "gateway/src/test/java/com/continuuity/gateway/v2/handlers/v2/AppFabricServiceHandlerTest.java",
            "method_src": "private HttpResponse deploy(String filename) throws Exception {\n    File archive = FileUtils.toFile(getClass().getResource(\"/\" + filename));\n    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n    try {\n      ByteStreams.copy(new FileInputStream(archive), bos);\n    } finally {\n      bos.close();\n    }\n\n    HttpPut put = GatewayFastTestsSuite.getPUT(\"/v2/apps\");\n    put.setHeader(GatewayAuthenticator.CONTINUUITY_API_KEY, \"api-key-example\");\n    put.setHeader(\"X-Archive-Name\", filename);\n    put.setEntity(new ByteArrayEntity(bos.toByteArray()));\n    return GatewayFastTestsSuite.PUT(put);\n  }",
            "method_tgt": "private HttpResponse deploy(Class<? extends Application> application) throws Exception {\n    Manifest manifest = new Manifest();\n    manifest.getMainAttributes().put(ManifestFields.MANIFEST_VERSION, \"1.0\");\n    manifest.getMainAttributes().put(ManifestFields.MAIN_CLASS, application.getName());\n\n    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n    final JarOutputStream jarOut = new JarOutputStream(bos, manifest);\n    final String pkgName = application.getPackage().getName();\n\n    // Grab every classes under the application class package.\n    try {\n      Dependencies.findClassDependencies(application.getClassLoader(), new Dependencies.ClassAcceptor() {\n        @Override\n        public boolean accept(String className, URL classUrl, URL classPathUrl) {\n          try {\n            if (className.startsWith(pkgName)) {\n              jarOut.putNextEntry(new JarEntry(className.replace('.', '/') + \".class\"));\n              InputStream in = classUrl.openStream();\n              try {\n                ByteStreams.copy(in, jarOut);\n              } finally {\n                in.close();\n              }\n              return true;\n            }\n            return false;\n          } catch (Exception e) {\n            throw Throwables.propagate(e);\n          }\n        }\n      }, application.getName());\n    } finally {\n      jarOut.close();\n    }\n\n    HttpPut put = GatewayFastTestsSuite.getPUT(\"/v2/apps\");\n    put.setHeader(GatewayAuthenticator.CONTINUUITY_API_KEY, \"api-key-example\");\n    put.setHeader(\"X-Archive-Name\", application.getSimpleName() + \".jar\");\n    put.setEntity(new ByteArrayEntity(bos.toByteArray()));\n    return GatewayFastTestsSuite.PUT(put);\n  }"
        },
        "test_db": {
            "id": "1600829",
            "rel_path": "gateway/src/test/java/com/continuuity/gateway/v2/handlers/v2/AppFabricServiceHandlerTest.java",
            "method_src": "@Test\n  public void testDeploy() throws Exception {\n    HttpResponse response = deploy(\"WordCount.jar\");\n    Assert.assertEquals(200, response.getStatusLine().getStatusCode());\n  }",
            "method_tgt": "@Test\n  public void testDeploy() throws Exception {\n    HttpResponse response = deploy(WordCount.class);\n    Assert.assertEquals(200, response.getStatusLine().getStatusCode());\n  }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        }
    },
    {
        "repo_name": "datumbox/datumbox-framework",
        "commit_id": "082e6c44f04813d2164d6f7d8c878484edfff219",
        "commit_url": "https://github.com/datumbox/datumbox-framework/commit/082e6c44f04813d2164d6f7d8c878484edfff219",
        "focal_db": {
            "id": "1762220",
            "rel_path": "src/main/java/com/datumbox/framework/statistics/distributions/DiscreteDistributions.java",
            "method_src": "public static double HypergeometricCdf(int k, int n, int Kp, int Np) {\r\n        if(k<0 || n<0 || Kp<0 || Np<0) {\r\n            throw new IllegalArgumentException(\"All the parameters must be positive.\");\r\n        }\r\n        Kp = Math.max(k, Kp);\r\n        Np = Math.max(n, Np);\r\n        \r\n        /*\r\n        //slow!\r\n        $probabilitySum=0;\r\n        for($i=0;$i<=$k;++$i) {\r\n            $probabilitySum+=self::Hypergeometric($i,$n,$Kp,$Np);\r\n        }\r\n        */\r\n\r\n        //fast and can handle large numbers\r\n        //Cdf(k)-Cdf(k-1)\r\n        double probabilitySum = approxHypergeometricCdf(k,n,Kp,Np);\r\n        \r\n        return probabilitySum;\r\n    }",
            "method_tgt": "public static double hypergeometricCdf(int k, int n, int Kp, int Np) {\r\n        if(k<0 || n<0 || Kp<0 || Np<0) {\r\n            throw new IllegalArgumentException(\"All the parameters must be positive.\");\r\n        }\r\n        Kp = Math.max(k, Kp);\r\n        Np = Math.max(n, Np);\r\n        \r\n        /*\r\n        //slow!\r\n        $probabilitySum=0;\r\n        for($i=0;$i<=$k;++$i) {\r\n            $probabilitySum+=self::hypergeometric($i,$n,$Kp,$Np);\r\n        }\r\n        */\r\n\r\n        //fast and can handle large numbers\r\n        //Cdf(k)-Cdf(k-1)\r\n        double probabilitySum = approxHypergeometricCdf(k,n,Kp,Np);\r\n        \r\n        return probabilitySum;\r\n    }"
        },
        "test_db": {
            "id": "1762309",
            "rel_path": "src/test/java/com/datumbox/framework/statistics/distributions/DiscreteDistributionsTest.java",
            "method_src": "@Test\r\n    public void testHypergeometricCdf() {\r\n        logger.info(\"HypergeometricCdf\");\r\n        int k = 3;\r\n        int n = 10;\r\n        int Kp = 30;\r\n        int Np = 100;\r\n        double expResult = 0.65401998866081;\r\n        double result = DiscreteDistributions.HypergeometricCdf(k, n, Kp, Np);\r\n        assertEquals(expResult, result, TestConfiguration.DOUBLE_ACCURACY_HIGH);\r\n    }",
            "method_tgt": "@Test\r\n    public void testHypergeometricCdf() {\r\n        logger.info(\"HypergeometricCdf\");\r\n        int k = 3;\r\n        int n = 10;\r\n        int Kp = 30;\r\n        int Np = 100;\r\n        double expResult = 0.65401998866081;\r\n        double result = DiscreteDistributions.hypergeometricCdf(k, n, Kp, Np);\r\n        assertEquals(expResult, result, TestConfiguration.DOUBLE_ACCURACY_HIGH);\r\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 1,
            "param_types": 0,
            "throw_types": 0
        }
    },
    {
        "repo_name": "datumbox/datumbox-framework",
        "commit_id": "3ee9d3a883f6c108b9f208c1757b8cc20b1a79ae",
        "commit_url": "https://github.com/datumbox/datumbox-framework/commit/3ee9d3a883f6c108b9f208c1757b8cc20b1a79ae",
        "focal_db": {
            "id": "1762974",
            "rel_path": "src/main/java/com/datumbox/common/dataobjects/Dataset.java",
            "method_src": "public Map<Object, ColumnType> getColumns() {\r\n        return Collections.unmodifiableMap(columns);\r\n    }",
            "method_tgt": "public Map<Object, TypeInference.DataType> getXDataTypes() {\r\n        return Collections.unmodifiableMap(xDataTypes);\r\n    }"
        },
        "test_db": {
            "id": "1763024",
            "rel_path": "src/test/java/com/datumbox/common/dataobjects/DatasetTest.java",
            "method_src": "@Test\r\n    public void testGetColumns() {\r\n        TestUtils.log(this.getClass(), \"getColumns\");\r\n        RandomSingleton.getInstance().setSeed(TestConfiguration.RANDOM_SEED);\r\n        DatabaseConfiguration dbConf = TestUtils.getDBConfig();\r\n        \r\n        Dataset instance = new Dataset(dbConf);\r\n        \r\n        AssociativeArray xData1 = new AssociativeArray();\r\n        xData1.put(\"1\", true);\r\n        instance.add(new Record(xData1, null));\r\n        \r\n        AssociativeArray xData2 = new AssociativeArray();\r\n        xData2.put(\"2\", 1.0);\r\n        instance.add(new Record(xData2, null));\r\n        \r\n        AssociativeArray xData3 = new AssociativeArray();\r\n        xData3.put(\"3\", (short)1);\r\n        instance.add(new Record(xData3, null));\r\n        \r\n        AssociativeArray xData4 = new AssociativeArray();\r\n        xData4.put(\"4\", \"s\");\r\n        instance.add(new Record(xData4, null));\r\n        \r\n        Map<Object, Dataset.ColumnType> expResult = new LinkedHashMap<>();\r\n        expResult.put(\"1\", Dataset.ColumnType.DUMMYVAR);\r\n        expResult.put(\"2\", Dataset.ColumnType.NUMERICAL);\r\n        expResult.put(\"3\", Dataset.ColumnType.ORDINAL);\r\n        expResult.put(\"4\", Dataset.ColumnType.CATEGORICAL);\r\n        Map<Object, Dataset.ColumnType> result = instance.getColumns();\r\n        assertEquals(expResult, result);\r\n    }",
            "method_tgt": "@Test\r\n    public void testGetColumns() {\r\n        TestUtils.log(this.getClass(), \"getColumns\");\r\n        RandomSingleton.getInstance().setSeed(TestConfiguration.RANDOM_SEED);\r\n        DatabaseConfiguration dbConf = TestUtils.getDBConfig();\r\n        \r\n        Dataset instance = new Dataset(dbConf);\r\n        \r\n        AssociativeArray xData1 = new AssociativeArray();\r\n        xData1.put(\"1\", true);\r\n        instance.add(new Record(xData1, null));\r\n        \r\n        AssociativeArray xData2 = new AssociativeArray();\r\n        xData2.put(\"2\", 1.0);\r\n        instance.add(new Record(xData2, null));\r\n        \r\n        AssociativeArray xData3 = new AssociativeArray();\r\n        xData3.put(\"3\", (short)1);\r\n        instance.add(new Record(xData3, null));\r\n        \r\n        AssociativeArray xData4 = new AssociativeArray();\r\n        xData4.put(\"4\", \"s\");\r\n        instance.add(new Record(xData4, null));\r\n        \r\n        Map<Object, TypeInference.DataType> expResult = new LinkedHashMap<>();\r\n        expResult.put(\"1\", TypeInference.DataType.BOOLEAN);\r\n        expResult.put(\"2\", TypeInference.DataType.NUMERICAL);\r\n        expResult.put(\"3\", TypeInference.DataType.ORDINAL);\r\n        expResult.put(\"4\", TypeInference.DataType.CATEGORICAL);\r\n        Map<Object, TypeInference.DataType> result = instance.getXDataTypes();\r\n        assertEquals(expResult, result);\r\n    }"
        },
        "syn_diff": {
            "overall": 2,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 1,
            "param_types": 0,
            "throw_types": 0
        }
    },
    {
        "repo_name": "dayatang/dddlib",
        "commit_id": "28777b0b20b5748c4c738909dfb5a69ce0320170",
        "commit_url": "https://github.com/dayatang/dddlib/commit/28777b0b20b5748c4c738909dfb5a69ce0320170",
        "focal_db": {
            "id": "1769168",
            "rel_path": "dddlib-persistence/dddlib-persistence-hibernate/src/main/java/org/dayatang/event/hibernate/HibernateEventStore.java",
            "method_src": "@Override\n    public List<StoredEvent> allStoredEventsSince(Date occurredFrom) {\n        return null;\n    }",
            "method_tgt": "@Override\n    public List<StoredEvent> findStoredEventsSince(Date occurredFrom) {\n        return null;\n    }"
        },
        "test_db": {
            "id": "1769171",
            "rel_path": "dddlib-persistence/dddlib-persistence-hibernate/src/test/java/org/dayatang/event/hibernate/HibernateEventStoreTest.java",
            "method_src": "@Test\n    public void testAllStoredEventsSince() {\n        System.out.println(\"allStoredEventsSince\");\n        Date occurredFrom = null;\n        HibernateEventStore instance = new HibernateEventStore();\n        List<StoredEvent> expResult = null;\n        List<StoredEvent> result = instance.allStoredEventsSince(occurredFrom);\n        assertEquals(expResult, result);\n        // TODO review the generated test code and remove the default call to fail.\n        fail(\"The test case is a prototype.\");\n    }",
            "method_tgt": "@Test\n    public void testFindStoredEventsSince() {\n        System.out.println(\"findStoredEventsSince\");\n        Date occurredFrom = null;\n        HibernateEventStore instance = new HibernateEventStore();\n        List<StoredEvent> expResult = null;\n        List<StoredEvent> result = instance.findStoredEventsSince(occurredFrom);\n        assertEquals(expResult, result);\n        // TODO review the generated test code and remove the default call to fail.\n        fail(\"The test case is a prototype.\");\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 1,
            "param_types": 0,
            "throw_types": 0
        },
        "aug": 0
    },
    {
        "repo_name": "eclipse/jetty.project",
        "commit_id": "8101b67ce88b6f78bceef167cf8483acb2c55342",
        "commit_url": "https://github.com/eclipse/jetty.project/commit/8101b67ce88b6f78bceef167cf8483acb2c55342",
        "focal_db": {
            "id": "4877637",
            "rel_path": "jetty-util/src/main/java/org/eclipse/jetty/util/MultiMap.java",
            "method_src": "public void putAll(Map<? extends K, ? extends Object> m)\n    {\n        boolean multi = (m instanceof MultiMap);\n\n        if (multi)\n        {\n            for (Map.Entry<? extends K, ? extends Object> entry : m.entrySet())\n            {\n                _map.put(entry.getKey(),LazyList.clone(entry.getValue()));\n            }\n        }\n        else\n        {\n            _map.putAll(m);\n        }\n    }",
            "method_tgt": "@Override\n    public void putAll(Map<? extends String, ? extends Object> m)\n    {\n        boolean multi = (m instanceof MultiMap);\n\n        if (multi)\n        {\n            for (Map.Entry<? extends String, ? extends Object> entry : m.entrySet())\n            {\n                _map.put(entry.getKey(),LazyList.clone(entry.getValue()));\n            }\n        }\n        else\n        {\n            _map.putAll(m);\n        }\n    }"
        },
        "test_db": {
            "id": "4877655",
            "rel_path": "jetty-util/src/test/java/org/eclipse/jetty/util/MultiMapTest.java",
            "method_src": "@Test\n    public void testPutAll_MultiMap_Simple()\n    {\n        MultiMap<String> mm = new MultiMap<String>();\n        \n        assertMapSize(mm,0); // Shouldn't have anything yet.\n        \n        MultiMap<String> input = new MultiMap<String>();\n        input.put(\"food\",\"apple\");\n        input.put(\"color\",\"red\");\n        input.put(\"amount\",\"bushel\");\n        \n        mm.putAll(input);\n        \n        assertMapSize(mm,3);\n        assertValues(mm,\"food\",\"apple\");\n        assertValues(mm,\"color\",\"red\");\n        assertValues(mm,\"amount\",\"bushel\");\n    }",
            "method_tgt": "@Test\n    public void testPutAll_MultiMap_Simple()\n    {\n        MultiMap mm = new MultiMap();\n        \n        assertMapSize(mm,0); // Shouldn't have anything yet.\n        \n        MultiMap input = new MultiMap();\n        input.put(\"food\",\"apple\");\n        input.put(\"color\",\"red\");\n        input.put(\"amount\",\"bushel\");\n        \n        mm.putAll(input);\n        \n        assertMapSize(mm,3);\n        assertValues(mm,\"food\",\"apple\");\n        assertValues(mm,\"color\",\"red\");\n        assertValues(mm,\"amount\",\"bushel\");\n    }"
        },
        "syn_diff": {
            "overall": 2,
            "modifiers": 1,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        }
    },
    {
        "repo_name": "google/nomulus",
        "commit_id": "a68b1a12fd5bb8d9880a78fe27256e9d2558c6f0",
        "commit_url": "https://github.com/google/nomulus/commit/a68b1a12fd5bb8d9880a78fe27256e9d2558c6f0",
        "focal_db": {
            "id": "2081363",
            "rel_path": "core/src/main/java/google/registry/model/ofy/Ofy.java",
            "method_src": "public void transact(Runnable work) {\n    transact(\n        () -> {\n          work.run();\n          return null;\n        });\n  }",
            "method_tgt": "void transact(Runnable work) {\n    transact(\n        () -> {\n          work.run();\n          return null;\n        });\n  }"
        },
        "test_db": {
            "id": "2081384",
            "rel_path": "core/src/test/java/google/registry/model/ofy/OfyTest.java",
            "method_src": "@Test\n  public void testTransact_getsNewTimestampOnEachTry() {\n    ofy().transact(new VoidWork() {\n\n      DateTime firstAttemptTime;\n\n      @Override\n      public void vrun() {\n        if (firstAttemptTime == null) {\n          // Sleep a bit to ensure that the next attempt is at a new millisecond.\n          firstAttemptTime = ofy().getTransactionTime();\n          sleepUninterruptibly(10, MILLISECONDS);\n          throw new ConcurrentModificationException();\n        }\n        assertThat(ofy().getTransactionTime()).isGreaterThan(firstAttemptTime);\n      }});\n  }",
            "method_tgt": "@Test\n  public void testTransact_getsNewTimestampOnEachTry() {\n    tm().transact(new Runnable() {\n\n      DateTime firstAttemptTime;\n\n      @Override\n      public void run() {\n        if (firstAttemptTime == null) {\n          // Sleep a bit to ensure that the next attempt is at a new millisecond.\n          firstAttemptTime = tm().getTransactionTime();\n          sleepUninterruptibly(10, MILLISECONDS);\n          throw new ConcurrentModificationException();\n        }\n        assertThat(tm().getTransactionTime()).isGreaterThan(firstAttemptTime);\n      }});\n  }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 1,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 0,
            "throw_types": 0
        },
        "comment": "[Hard] method become private(access by Manager in the same package)"
    },
    {
        "repo_name": "google/tink",
        "commit_id": "eaf138464158349ffaa9ff54cc9b706fd3277aaa",
        "commit_url": "https://github.com/google/tink/commit/eaf138464158349ffaa9ff54cc9b706fd3277aaa",
        "focal_db": {
            "id": "2087775",
            "rel_path": "java/src/main/java/com/google/crypto/tink/KeysetManager.java",
            "method_src": "@GuardedBy(\"this\")\n  public synchronized KeysetManager promote(int keyId) throws GeneralSecurityException {\n    for (int i = 0; i < keysetBuilder.getKeyCount(); i++) {\n      Keyset.Key key = keysetBuilder.getKey(i);\n      if (key.getKeyId() == keyId) {\n        if (!key.getStatus().equals(KeyStatusType.ENABLED)) {\n          throw new GeneralSecurityException(\n              \"cannot promote key because it's not enabled: \" + keyId);\n        }\n        keysetBuilder.setPrimaryKeyId(keyId);\n        return this;\n      }\n    }\n    throw new GeneralSecurityException(\"key not found: \" + keyId);\n  }",
            "method_tgt": "@GuardedBy(\"this\")\n  public synchronized KeysetManager setPrimary(int keyId) throws GeneralSecurityException {\n    for (int i = 0; i < keysetBuilder.getKeyCount(); i++) {\n      Keyset.Key key = keysetBuilder.getKey(i);\n      if (key.getKeyId() == keyId) {\n        if (!key.getStatus().equals(KeyStatusType.ENABLED)) {\n          throw new GeneralSecurityException(\n              \"cannot set key as primary because it's not enabled: \" + keyId);\n        }\n        keysetBuilder.setPrimaryKeyId(keyId);\n        return this;\n      }\n    }\n    throw new GeneralSecurityException(\"key not found: \" + keyId);\n  }"
        },
        "test_db": {
            "id": "2087777",
            "rel_path": "java/src/test/java/com/google/crypto/tink/KeysetManagerTest.java",
            "method_src": "@Test\n  public void testPromote_shouldPromoteKey() throws Exception {\n    int primaryKeyId = 42;\n    int newPrimaryKeyId = 43;\n    KeysetHandle handle = KeysetHandle.fromKeyset(\n        TestUtil.createKeyset(\n            createEnabledKey(primaryKeyId),\n            createEnabledKey(newPrimaryKeyId)));\n    Keyset keyset = KeysetManager\n        .withKeysetHandle(handle)\n        .promote(newPrimaryKeyId)\n        .getKeysetHandle()\n        .getKeyset();\n\n    assertThat(keyset.getKeyCount()).isEqualTo(2);\n    assertThat(keyset.getPrimaryKeyId()).isEqualTo(newPrimaryKeyId);\n  }",
            "method_tgt": "@Test\n  public void testSetPrimary_shouldSetPrimary() throws Exception {\n    int primaryKeyId = 42;\n    int newPrimaryKeyId = 43;\n    KeysetHandle handle = KeysetHandle.fromKeyset(\n        TestUtil.createKeyset(\n            createEnabledKey(primaryKeyId),\n            createEnabledKey(newPrimaryKeyId)));\n    Keyset keyset = KeysetManager\n        .withKeysetHandle(handle)\n        .setPrimary(newPrimaryKeyId)\n        .getKeysetHandle()\n        .getKeyset();\n\n    assertThat(keyset.getKeyCount()).isEqualTo(2);\n    assertThat(keyset.getPrimaryKeyId()).isEqualTo(newPrimaryKeyId);\n  }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 1,
            "param_types": 0,
            "throw_types": 0
        },
        "aug": 1
    },
    {
        "repo_name": "gridgain/gridgain",
        "commit_id": "42d637cd06c3c058e28cb557255a5590c132b6de",
        "commit_url": "https://github.com/gridgain/gridgain/commit/42d637cd06c3c058e28cb557255a5590c132b6de",
        "focal_db": {
            "id": "5138995",
            "rel_path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/transactions/LocalPendingTransactionsTracker.java",
            "method_src": "public Map<GridCacheVersion, WALPointer> currentlyPreparedTxs() {\n        assert stateLock.writeLock().isHeldByCurrentThread();\n\n        return U.sealMap(currentlyPreparedTxs);\n    }",
            "method_tgt": "public Set<GridCacheVersion> currentlyPreparedTxs() {\n        assert stateLock.writeLock().isHeldByCurrentThread();\n\n        return U.sealSet(preparedCommittedTxsCounters.keySet());\n    }"
        },
        "test_db": {
            "id": "5139001",
            "rel_path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/transactions/LocalPendingTransactionsTrackerTest.java",
            "method_src": "@Test\n    public void testCurrentlyPreparedTxs() {\n        txPrepare(1);\n        txKeyWrite(1, 10);\n        txKeyWrite(1, 11);\n\n        txPrepare(2);\n        txKeyWrite(2, 20);\n        txKeyWrite(2, 21);\n        txKeyWrite(2, 22);\n\n        txPrepare(3);\n        txKeyWrite(3, 30);\n\n        txCommit(2);\n\n        tracker.writeLockState();\n\n        try {\n            Map<GridCacheVersion, WALPointer> currentlyPreparedTxs = tracker.currentlyPreparedTxs();\n\n            assertEquals(2, currentlyPreparedTxs.size());\n            assertTrue(currentlyPreparedTxs.containsKey(nearXidVersion(1)));\n            assertTrue(currentlyPreparedTxs.containsKey(nearXidVersion(3)));\n        }\n        finally {\n            tracker.writeUnlockState();\n        }\n\n        txKeyWrite(3, 31);\n        txCommit(3);\n\n        tracker.writeLockState();\n\n        try {\n            Map<GridCacheVersion, WALPointer> currentlyPreparedTxs = tracker.currentlyPreparedTxs();\n\n            assertEquals(1, currentlyPreparedTxs.size());\n            assertTrue(currentlyPreparedTxs.containsKey(nearXidVersion(1)));\n        }\n        finally {\n            tracker.writeUnlockState();\n        }\n    }",
            "method_tgt": "@Test\n    public void testCurrentlyPreparedTxs() {\n        txPrepare(1);\n        txKeyWrite(1, 10);\n        txKeyWrite(1, 11);\n\n        txPrepare(2);\n        txKeyWrite(2, 20);\n        txKeyWrite(2, 21);\n        txKeyWrite(2, 22);\n\n        txPrepare(3);\n        txKeyWrite(3, 30);\n\n        txCommit(2);\n\n        tracker.writeLockState();\n\n        try {\n            Set<GridCacheVersion> currentlyPreparedTxs = tracker.currentlyPreparedTxs();\n\n            assertEquals(2, currentlyPreparedTxs.size());\n            assertTrue(currentlyPreparedTxs.contains(nearXidVersion(1)));\n            assertTrue(currentlyPreparedTxs.contains(nearXidVersion(3)));\n        }\n        finally {\n            tracker.writeUnlockState();\n        }\n\n        txKeyWrite(3, 31);\n        txCommit(3);\n\n        tracker.writeLockState();\n\n        try {\n            Set<GridCacheVersion> currentlyPreparedTxs = tracker.currentlyPreparedTxs();\n\n            assertEquals(1, currentlyPreparedTxs.size());\n            assertTrue(currentlyPreparedTxs.contains(nearXidVersion(1)));\n        }\n        finally {\n            tracker.writeUnlockState();\n        }\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 0,
            "param_types": 0,
            "throw_types": 0
        }
    },
    {
        "repo_name": "haifengl/smile",
        "commit_id": "a3fa23bb11330250810cfd19869050240b67a17e",
        "commit_url": "https://github.com/haifengl/smile/commit/a3fa23bb11330250810cfd19869050240b67a17e",
        "focal_db": {
            "id": "2221812",
            "rel_path": "math/src/main/java/smile/math/Math.java",
            "method_src": "public static double[][] solve(double[][] A, double[][] B) {\n        if (A.length == A[0].length) {\n            LUDecomposition lu = new LUDecomposition(A);\n            lu.solve(B);\n            return B;\n        } else {\n            double[][] X = new double[A[0].length][B[0].length];\n            QRDecomposition qr = new QRDecomposition(A);\n            qr.solve(B, X);\n            return X;\n        }\n    }",
            "method_tgt": "public static DenseMatrix solve(double[][] A, double[][] B) {\n        DenseMatrix b = new ColumnMajorMatrix(B);\n        DenseMatrix X = new ColumnMajorMatrix(A[0].length, B[0].length);\n        if (A.length == A[0].length) {\n            LUDecomposition lu = new LUDecomposition(A);\n            lu.solve(b, X);\n        } else {\n            QRDecomposition qr = new QRDecomposition(A);\n            qr.solve(b, X);\n        }\n\n        return X;\n    }"
        },
        "test_db": {
            "id": "2221863",
            "rel_path": "math/src/test/java/smile/math/MathTest.java",
            "method_src": "@Test\n    public void testSolve_doubleArrArr_doubleArrArr() {\n        System.out.println(\"solve\");\n        double[][] A = {\n            {0.9000, 0.4000, 0.7000},\n            {0.4000, 0.5000, 0.3000},\n            {0.7000, 0.3000, 0.8000}\n        };\n        double[][] B2 = {\n            {0.5, 0.2},\n            {0.5, 0.8},\n            {0.5, 0.3}\n        };\n        double[][] X2 = {\n            {-0.2027027, -1.2837838},\n            {0.8783784, 2.2297297},\n            {0.4729730, 0.6621622}\n        };\n        double[][] x = Math.solve(A, B2);\n        assertEquals(X2.length, x.length);\n        assertEquals(X2[0].length, x[0].length);\n        for (int i = 0; i < X2.length; i++) {\n            for (int j = 0; j < X2[i].length; j++) {\n                assertEquals(X2[i][j], x[i][j], 1E-7);\n            }\n        }\n    }",
            "method_tgt": "@Test\n    public void testSolve_doubleArrArr_doubleArrArr() {\n        System.out.println(\"solve\");\n        double[][] A = {\n            {0.9000, 0.4000, 0.7000},\n            {0.4000, 0.5000, 0.3000},\n            {0.7000, 0.3000, 0.8000}\n        };\n        double[][] B2 = {\n            {0.5, 0.2},\n            {0.5, 0.8},\n            {0.5, 0.3}\n        };\n        double[][] X2 = {\n            {-0.2027027, -1.2837838},\n            {0.8783784, 2.2297297},\n            {0.4729730, 0.6621622}\n        };\n        DenseMatrix x = Math.solve(A, B2);\n        assertEquals(X2.length, x.nrows());\n        assertEquals(X2[0].length, x.ncols());\n        for (int i = 0; i < X2.length; i++) {\n            for (int j = 0; j < X2[i].length; j++) {\n                assertEquals(X2[i][j], x.get(i, j), 1E-7);\n            }\n        }\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 0,
            "param_types": 0,
            "throw_types": 0
        }
    },
    {
        "repo_name": "haifengl/smile",
        "commit_id": "3c56a91914b2101a17e91d89be2b9ea2b2158b1a",
        "commit_url": "https://github.com/haifengl/smile/commit/3c56a91914b2101a17e91d89be2b9ea2b2158b1a",
        "focal_db": {
            "id": "2221587",
            "rel_path": "math/src/main/java/smile/math/Math.java",
            "method_src": "public static double[] colSum(double[][] data) {\n        double[] x = data[0].clone();\n\n        for (int i = 1; i < data.length; i++) {\n            for (int j = 0; j < x.length; j++) {\n                x[j] += data[i][j];\n            }\n        }\n\n        return x;\n    }",
            "method_tgt": "public static double[] colSums(double[][] data) {\n        double[] x = data[0].clone();\n\n        for (int i = 1; i < data.length; i++) {\n            for (int j = 0; j < x.length; j++) {\n                x[j] += data[i][j];\n            }\n        }\n\n        return x;\n    }"
        },
        "test_db": {
            "id": "2221603",
            "rel_path": "math/src/test/java/smile/math/MathTest.java",
            "method_src": "@Test\n    public void testColSum() {\n        System.out.println(\"colSum\");\n        double[][] A = {\n            {0.7220180, 0.07121225, 0.6881997},\n            {-0.2648886, -0.89044952, 0.3700456},\n            {-0.6391588, 0.44947578, 0.6240573}\n        };\n        double[] r = {-0.1820294, -0.3697615, 1.6823026};\n\n        double[] result = Math.colSum(A);\n        for (int i = 0; i < r.length; i++) {\n            assertEquals(result[i], r[i], 1E-7);\n        }\n    }",
            "method_tgt": "@Test\n    public void testColSums() {\n        System.out.println(\"colSums\");\n        double[][] A = {\n            {0.7220180, 0.07121225, 0.6881997},\n            {-0.2648886, -0.89044952, 0.3700456},\n            {-0.6391588, 0.44947578, 0.6240573}\n        };\n        double[] r = {-0.1820294, -0.3697615, 1.6823026};\n\n        double[] result = Math.colSums(A);\n        for (int i = 0; i < r.length; i++) {\n            assertEquals(result[i], r[i], 1E-7);\n        }\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 1,
            "param_types": 0,
            "throw_types": 0
        }
    },
    {
        "repo_name": "hazelcast/hazelcast",
        "commit_id": "83d814eefb9864187b3a43736d29422a1581f0aa",
        "commit_url": "https://github.com/hazelcast/hazelcast/commit/83d814eefb9864187b3a43736d29422a1581f0aa",
        "focal_db": {
            "id": "2229308",
            "rel_path": "hazelcast/src/main/java/com/hazelcast/ringbuffer/impl/RingbufferProxy.java",
            "method_src": "@Override\n    public ICompletableFuture<Long> addAllAsync(@Nonnull Collection<? extends E> collection,\n                                                @Nonnull OverflowPolicy overflowPolicy) {\n        checkNotNull(collection, \"collection can't be null\");\n        checkNotNull(overflowPolicy, \"overflowPolicy can't be null\");\n        checkFalse(collection.isEmpty(), \"collection can't be empty\");\n        checkTrue(collection.size() <= MAX_BATCH_SIZE, \"collection can't be larger than \" + MAX_BATCH_SIZE);\n\n        Operation op = new AddAllOperation(name, toDataArray(collection), overflowPolicy)\n                .setPartitionId(partitionId);\n        OperationService operationService = getOperationService();\n        return operationService.createInvocationBuilder(null, op, partitionId)\n                               .setCallTimeout(Long.MAX_VALUE)\n                               .invoke();\n    }",
            "method_tgt": "@Override\n    public CompletionStage<Long> addAllAsync(@Nonnull Collection<? extends E> collection,\n                                                @Nonnull OverflowPolicy overflowPolicy) {\n        checkNotNull(collection, \"collection can't be null\");\n        checkNotNull(overflowPolicy, \"overflowPolicy can't be null\");\n        checkFalse(collection.isEmpty(), \"collection can't be empty\");\n        checkTrue(collection.size() <= MAX_BATCH_SIZE, \"collection can't be larger than \" + MAX_BATCH_SIZE);\n\n        Operation op = new AddAllOperation(name, toDataArray(collection), overflowPolicy)\n                .setPartitionId(partitionId);\n        OperationService operationService = getOperationService();\n        return operationService.createInvocationBuilder(null, op, partitionId)\n                               .setCallTimeout(Long.MAX_VALUE)\n                               .invoke();\n    }"
        },
        "test_db": {
            "id": "2229339",
            "rel_path": "hazelcast/src/test/java/com/hazelcast/ringbuffer/impl/RingbufferAbstractTest.java",
            "method_src": "@Test\n    public void addAllAsync_manyTimesRoundTheRing() throws Exception {\n        RingbufferConfig c = config.getRingbufferConfig(ringbuffer.getName());\n        Random random = new Random();\n\n        for (int iteration = 0; iteration < 1000; iteration++) {\n            List<String> items = randomList(max(1, random.nextInt(c.getCapacity())));\n\n            long previousTailSeq = ringbuffer.tailSequence();\n\n            long result = ringbuffer.addAllAsync(items, OVERWRITE).get();\n\n            assertEquals(previousTailSeq + items.size(), ringbuffer.tailSequence());\n\n            if (ringbuffer.tailSequence() < c.getCapacity()) {\n                assertEquals(0, ringbuffer.headSequence());\n            } else {\n                assertEquals(ringbuffer.tailSequence() - c.getCapacity() + 1, ringbuffer.headSequence());\n            }\n            assertEquals(ringbuffer.tailSequence(), result);\n\n            long startSequence = previousTailSeq + 1;\n            for (int k = 0; k < items.size(); k++) {\n                assertEquals(items.get(k), ringbuffer.readOne(startSequence + k));\n            }\n        }\n    }",
            "method_tgt": "@Test\n    public void addAllAsync_manyTimesRoundTheRing() throws Exception {\n        RingbufferConfig c = config.getRingbufferConfig(ringbuffer.getName());\n        Random random = new Random();\n\n        for (int iteration = 0; iteration < 1000; iteration++) {\n            List<String> items = randomList(max(1, random.nextInt(c.getCapacity())));\n\n            long previousTailSeq = ringbuffer.tailSequence();\n\n            long result = ringbuffer.addAllAsync(items, OVERWRITE).toCompletableFuture().get();\n\n            assertEquals(previousTailSeq + items.size(), ringbuffer.tailSequence());\n\n            if (ringbuffer.tailSequence() < c.getCapacity()) {\n                assertEquals(0, ringbuffer.headSequence());\n            } else {\n                assertEquals(ringbuffer.tailSequence() - c.getCapacity() + 1, ringbuffer.headSequence());\n            }\n            assertEquals(ringbuffer.tailSequence(), result);\n\n            long startSequence = previousTailSeq + 1;\n            for (int k = 0; k < items.size(); k++) {\n                assertEquals(items.get(k), ringbuffer.readOne(startSequence + k));\n            }\n        }\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 0,
            "param_types": 0,
            "throw_types": 0
        },
        "aug": 0
    },
    {
        "repo_name": "javaee/glassfish",
        "commit_id": "1814c817013a89eb0737918de03ee33295ec8263",
        "commit_url": "https://github.com/javaee/glassfish/commit/1814c817013a89eb0737918de03ee33295ec8263",
        "focal_db": {
            "id": "5798307",
            "rel_path": "v3/deployment/versioning/src/main/java/org/glassfish/deployment/versioning/VersioningService.java",
            "method_src": "public final String getUntaggedName(String appName)\n            throws VersioningSyntaxException {\n\n        int colonIndex = appName.indexOf(EXPRESSION_SEPARATOR);\n        // if versioned\n        if (colonIndex != -1) {\n\n            // if appName is ending with a colon\n            if (colonIndex == (appName.length() - 1)) {\n                throw new VersioningSyntaxException(\n                        LOCALSTRINGS.getLocalString(\"invalid.appname\",\n                        \"excepted version identifier after colon: {0}\",\n                        appName));\n            }\n            return appName.substring(0, colonIndex);\n        }\n        // not versioned\n        return appName;\n    }",
            "method_tgt": "public static final String getUntaggedName(String appName)\n            throws VersioningSyntaxException {\n\n        if(appName != null && !appName.isEmpty()){\n            int colonIndex = appName.indexOf(EXPRESSION_SEPARATOR);\n            // if versioned\n            if (colonIndex != -1) {\n\n                // if appName is ending with a colon\n                if (colonIndex == (appName.length() - 1)) {\n                    throw new VersioningSyntaxException(\n                            LOCALSTRINGS.getLocalString(\"invalid.appname\",\n                            \"excepted version identifier after colon: {0}\",\n                            appName));\n                }\n                return appName.substring(0, colonIndex);\n            }\n        }\n        // not versioned\n        return appName;\n    }"
        },
        "test_db": {
            "id": "5798308",
            "rel_path": "v3/deployment/versioning/src/test/java/org/glassfish/deployment/versioning/VersioningServiceTest.java",
            "method_src": "@Test\n    public void testGetUntaggedName() throws VersioningSyntaxException {\n        VersioningService instance = new VersioningService();\n\n        // test an application name that contains a version expression\n        // application name : foo:RC-*\n        String expression = APPLICATION_NAME\n                + VersioningService.EXPRESSION_SEPARATOR + \"RC-\"\n                + VersioningService.EXPRESSION_WILDCARD;\n\n        String result = instance.getUntaggedName(expression);\n        assertEquals(APPLICATION_NAME, result);\n\n        // test an application name that contains a version identifier\n        // application name : foo:RC-1.0.0\n        expression = APPLICATION_NAME\n                + VersioningService.EXPRESSION_SEPARATOR + \"RC-1.0.0\";\n\n        result = instance.getUntaggedName(expression);\n        assertEquals(APPLICATION_NAME, result);\n\n        // test an application name that is an untagged version name\n        // application name : foo\n        expression = APPLICATION_NAME;\n\n        result = instance.getUntaggedName(expression);\n        assertEquals(APPLICATION_NAME, result);\n\n        // test an application name containing a critical pattern\n        // application name : foo:\n        expression = APPLICATION_NAME + VersioningService.EXPRESSION_SEPARATOR;\n\n        try {\n            result = instance.getUntaggedName(expression);\n            fail(\"the getUntagged method did not throw a VersioningSyntaxException\");\n        }\n        catch(VersioningSyntaxException e){}\n    }",
            "method_tgt": "@Test\n    public void testGetUntaggedName() throws VersioningSyntaxException {\n\n        // test an application name that contains a version expression\n        // application name : foo:RC-*\n        String expression = APPLICATION_NAME\n                + VersioningService.EXPRESSION_SEPARATOR + \"RC-\"\n                + VersioningService.EXPRESSION_WILDCARD;\n\n        String result = VersioningService.getUntaggedName(expression);\n        assertEquals(APPLICATION_NAME, result);\n\n        // test an application name that contains a version identifier\n        // application name : foo:RC-1.0.0\n        expression = APPLICATION_NAME\n                + VersioningService.EXPRESSION_SEPARATOR + \"RC-1.0.0\";\n\n        result = VersioningService.getUntaggedName(expression);\n        assertEquals(APPLICATION_NAME, result);\n\n        // test an application name that is an untagged version name\n        // application name : foo\n        expression = APPLICATION_NAME;\n\n        result = VersioningService.getUntaggedName(expression);\n        assertEquals(APPLICATION_NAME, result);\n\n        // test an application name containing a critical pattern\n        // application name : foo:\n        expression = APPLICATION_NAME + VersioningService.EXPRESSION_SEPARATOR;\n\n        try {\n            result = VersioningService.getUntaggedName(expression);\n            fail(\"the getUntagged method did not throw a VersioningSyntaxException\");\n        }\n        catch(VersioningSyntaxException e){}\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 1,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 0,
            "throw_types": 0
        }
    },
    {
        "repo_name": "jclouds/jclouds",
        "commit_id": "cd0aa72ae11353d7e53df873180a989d24e5454f",
        "commit_url": "https://github.com/jclouds/jclouds/commit/cd0aa72ae11353d7e53df873180a989d24e5454f",
        "focal_db": {
            "id": "2410543",
            "rel_path": "labs/vcloud-director/src/main/java/org/jclouds/vcloud/director/v1_5/features/VAppApi.java",
            "method_src": "Task modifyVApp(URI vAppURI, VApp vApp);",
            "method_tgt": "Task editVApp(URI vAppURI, VApp vApp);"
        },
        "test_db": {
            "id": "2410657",
            "rel_path": "labs/vcloud-director/src/test/java/org/jclouds/vcloud/director/v1_5/features/VAppApiLiveTest.java",
            "method_src": "@Test(description = \"PUT /vApp/{id}\", dependsOnMethods = { \"testGetVApp\" })\n   public void testModifyVApp() {\n      VApp newVApp = VApp.builder()\n            .name(name(\"new-name-\"))\n            .description(\"New Description\")\n            .build();\n      vAppNames.add(newVApp.getName());\n\n      // The method under test\n      Task modifyVApp = vAppApi.modifyVApp(vApp.getHref(), newVApp);\n      assertTrue(retryTaskSuccess.apply(modifyVApp), String.format(TASK_COMPLETE_TIMELY, \"modifyVApp\"));\n\n      // Get the updated VApp\n      vApp = vAppApi.getVApp(vApp.getHref());\n\n      // Check the required fields are set\n      assertEquals(vApp.getName(), newVApp.getName(), String.format(OBJ_FIELD_EQ, VAPP, \"Name\", newVApp.getName(), vApp.getName()));\n      assertEquals(vApp.getDescription(), newVApp.getDescription(), String.format(OBJ_FIELD_EQ, VAPP, \"Description\", newVApp.getDescription(), vApp.getDescription()));\n   }",
            "method_tgt": "@Test(description = \"PUT /vApp/{id}\", dependsOnMethods = { \"testGetVApp\" })\n   public void testEditVApp() {\n      VApp newVApp = VApp.builder().name(name(\"new-name-\")).description(\"New Description\").build();\n      vAppNames.add(newVApp.getName());\n\n      // The method under test\n      Task editVApp = vAppApi.editVApp(vApp.getHref(), newVApp);\n      assertTrue(retryTaskSuccess.apply(editVApp), String.format(TASK_COMPLETE_TIMELY, \"editVApp\"));\n\n      // Get the edited VApp\n      vApp = vAppApi.getVApp(vApp.getHref());\n\n      // Check the required fields are set\n      assertEquals(vApp.getName(), newVApp.getName(),\n               String.format(OBJ_FIELD_EQ, VAPP, \"Name\", newVApp.getName(), vApp.getName()));\n      assertEquals(vApp.getDescription(), newVApp.getDescription(),\n               String.format(OBJ_FIELD_EQ, VAPP, \"Description\", newVApp.getDescription(), vApp.getDescription()));\n   }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 1,
            "param_types": 0,
            "throw_types": 0
        }
    },
    {
        "repo_name": "jclouds/jclouds",
        "commit_id": "b5f60f1e70af33f8fe7119d693233fe1a24e6bfb",
        "commit_url": "https://github.com/jclouds/jclouds/commit/b5f60f1e70af33f8fe7119d693233fe1a24e6bfb",
        "focal_db": {
            "id": "2409919",
            "rel_path": "apis/openstack-nova/src/main/java/org/jclouds/openstack/nova/v2_0/features/FlavorApi.java",
            "method_src": "Set<? extends Flavor> listFlavorsInDetail();",
            "method_tgt": "PagedIterable<? extends Flavor> listInDetail();"
        },
        "test_db": {
            "id": "2409968",
            "rel_path": "apis/openstack-nova/src/test/java/org/jclouds/openstack/nova/v2_0/features/FlavorApiLiveTest.java",
            "method_src": "@Test(description = \"GET /v${apiVersion}/{tenantId}/flavors/detail\")\n   public void testListFlavorsInDetail() throws Exception {\n      for (String zoneId : zones) {\n         FlavorApi api = novaContext.getApi().getFlavorApiForZone(zoneId);\n         Set<? extends Flavor> response = api.listFlavorsInDetail();\n         assertNotNull(response);\n         assertFalse(response.isEmpty());\n         for (Flavor flavor : response) {\n             assertNotNull(flavor.getId());\n             assertNotNull(flavor.getName());\n             assertNotNull(flavor.getLinks());\n             assertTrue(flavor.getRam() > 0);\n             assertTrue(flavor.getDisk() > 0);\n             assertTrue(flavor.getVcpus() > 0);\n         }\n      }\n   }",
            "method_tgt": "@Test(description = \"GET /v${apiVersion}/{tenantId}/flavors/detail\")\n   public void testListFlavorsInDetail() throws Exception {\n      for (String zoneId : zones) {\n         FlavorApi api = novaContext.getApi().getFlavorApiForZone(zoneId);\n         Set<? extends Flavor> response = api.listInDetail().concat().toImmutableSet();\n         assertNotNull(response);\n         assertFalse(response.isEmpty());\n         for (Flavor flavor : response) {\n             assertNotNull(flavor.getId());\n             assertNotNull(flavor.getName());\n             assertNotNull(flavor.getLinks());\n             assertTrue(flavor.getRam() > 0);\n             assertTrue(flavor.getDisk() > 0);\n             assertTrue(flavor.getVcpus() > 0);\n         }\n      }\n   }"
        },
        "syn_diff": {
            "overall": 2,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 1,
            "param_types": 0,
            "throw_types": 0
        }
    },
    {
        "repo_name": "jclouds/jclouds",
        "commit_id": "b5f60f1e70af33f8fe7119d693233fe1a24e6bfb",
        "commit_url": "https://github.com/jclouds/jclouds/commit/b5f60f1e70af33f8fe7119d693233fe1a24e6bfb",
        "focal_db": {
            "id": "2409918",
            "rel_path": "apis/openstack-nova/src/main/java/org/jclouds/openstack/nova/v2_0/features/FlavorApi.java",
            "method_src": "Set<? extends Resource> listFlavors();",
            "method_tgt": "PagedIterable<? extends Resource> list();"
        },
        "test_db": {
            "id": "2409970",
            "rel_path": "apis/openstack-nova/src/test/java/org/jclouds/openstack/nova/v2_0/features/FlavorApiLiveTest.java",
            "method_src": "@Test(description = \"GET /v${apiVersion}/{tenantId}/flavors\")\n   public void testListFlavors() throws Exception {\n      for (String zoneId : zones) {\n         FlavorApi api = novaContext.getApi().getFlavorApiForZone(zoneId);\n         Set<? extends Resource> response = api.listFlavors();\n         assertNotNull(response);\n         assertFalse(response.isEmpty());\n         for (Resource flavor : response) {\n            assertNotNull(flavor.getId());\n            assertNotNull(flavor.getName());\n            assertNotNull(flavor.getLinks());\n         }\n      }\n   }",
            "method_tgt": "@Test(description = \"GET /v${apiVersion}/{tenantId}/flavors\")\n   public void testListFlavors() throws Exception {\n      for (String zoneId : zones) {\n         FlavorApi api = novaContext.getApi().getFlavorApiForZone(zoneId);\n         Set<? extends Resource> response = api.list().concat().toImmutableSet();\n         assertNotNull(response);\n         assertFalse(response.isEmpty());\n         for (Resource flavor : response) {\n            assertNotNull(flavor.getId());\n            assertNotNull(flavor.getName());\n            assertNotNull(flavor.getLinks());\n         }\n      }\n   }"
        },
        "syn_diff": {
            "overall": 2,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 1,
            "param_types": 0,
            "throw_types": 0
        }
    },
    {
        "repo_name": "jeremylong/DependencyCheck",
        "commit_id": "3bf638f7c6d77cf5062bfe555cb14a0e381a709f",
        "commit_url": "https://github.com/jeremylong/DependencyCheck/commit/3bf638f7c6d77cf5062bfe555cb14a0e381a709f",
        "focal_db": {
            "id": "2443025",
            "rel_path": "src/main/java/org/codesecure/dependencycheck/utils/Checksum.java",
            "method_src": "public static byte[] getChecksum(String algorithm, File file) throws FileNotFoundException, NoSuchAlgorithmException {\n        InputStream fis = new FileInputStream(file);\n        byte[] buffer = new byte[1024];\n        MessageDigest complete = MessageDigest.getInstance(algorithm);\n        int numRead;\n        try {\n            do {\n                numRead = fis.read(buffer);\n                if (numRead > 0) {\n                    complete.update(buffer, 0, numRead);\n                }\n            } while (numRead != -1);\n        } catch (IOException ex) {\n            Logger.getLogger(Checksum.class.getName()).log(Level.SEVERE, null, ex);\n        } finally {\n            try {\n                fis.close();\n            } catch (IOException ex) {\n                Logger.getLogger(Checksum.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n        return complete.digest();\n    }",
            "method_tgt": "public static byte[] getChecksum(String algorithm, File file) throws NoSuchAlgorithmException, IOException {\n        InputStream fis = null;\n        byte[] buffer = new byte[1024];\n        MessageDigest complete = MessageDigest.getInstance(algorithm);\n        int numRead;\n        try {\n            fis = new FileInputStream(file);\n            do {\n                numRead = fis.read(buffer);\n                if (numRead > 0) {\n                    complete.update(buffer, 0, numRead);\n                }\n            } while (numRead != -1);\n        } finally {\n            if (fis != null) {\n                try {\n                    fis.close();\n                } catch (IOException ex) {\n                    Logger.getLogger(Checksum.class.getName()).log(Level.SEVERE, null, ex);\n                }\n            }\n        }\n        return complete.digest();\n    }"
        },
        "test_db": {
            "id": "2443030",
            "rel_path": "src/test/java/org/codesecure/dependencycheck/utils/ChecksumTest.java",
            "method_src": "@Test\n    public void testGetChecksum_FileNotFound() throws Exception {\n        System.out.println(\"getChecksum (invalid path)\");\n        String algorithm = \"MD5\";\n        File file = new File(\"not a valid file\");\n        boolean exceptionThrown = false;\n        try {\n            byte[] result = Checksum.getChecksum(algorithm, file);\n        } catch (FileNotFoundException ex) {\n            exceptionThrown = true;\n        }\n        assertTrue(exceptionThrown);\n    }",
            "method_tgt": "@Test\n    public void testGetChecksum_FileNotFound() throws Exception {\n        System.out.println(\"getChecksum (invalid path)\");\n        String algorithm = \"MD5\";\n        File file = new File(\"not a valid file\");\n        boolean exceptionThrown = false;\n        try {\n            byte[] result = Checksum.getChecksum(algorithm, file);\n        } catch (IOException ex) {\n            exceptionThrown = true;\n        }\n        assertTrue(exceptionThrown);\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 0,
            "throw_types": 1
        }
    },
    {
        "repo_name": "jeremylong/DependencyCheck",
        "commit_id": "5702543bc5c209c16cd98988fa83e82dd4036649",
        "commit_url": "https://github.com/jeremylong/DependencyCheck/commit/5702543bc5c209c16cd98988fa83e82dd4036649",
        "focal_db": {
            "id": "2442832",
            "rel_path": "src/main/java/org/codesecure/dependencycheck/analyzer/FileNameAnalyzer.java",
            "method_src": "public void analyze(Dependency dependency) throws AnalysisException {\n\n        String fileName = dependency.getFileName();\n        int pos = fileName.lastIndexOf(\".\");\n        if (pos > 0) {\n            fileName = fileName.substring(0, pos - 1);\n        }\n\n        dependency.getProductEvidence().addEvidence(\"file\", \"name\",\n                fileName, Evidence.Confidence.HIGH);\n\n        dependency.getVendorEvidence().addEvidence(\"file\", \"name\",\n                fileName, Evidence.Confidence.HIGH);\n\n        if (fileName.matches(\".*\\\\d.*\")) {\n            dependency.getVersionEvidence().addEvidence(\"file\", \"name\",\n                    fileName, Evidence.Confidence.HIGH);\n        }\n    }",
            "method_tgt": "public void analyze(Dependency dependency, Engine engine) throws AnalysisException {\n\n        String fileName = dependency.getFileName();\n        int pos = fileName.lastIndexOf(\".\");\n        if (pos > 0) {\n            fileName = fileName.substring(0, pos - 1);\n        }\n\n        dependency.getProductEvidence().addEvidence(\"file\", \"name\",\n                fileName, Evidence.Confidence.HIGH);\n\n        dependency.getVendorEvidence().addEvidence(\"file\", \"name\",\n                fileName, Evidence.Confidence.HIGH);\n\n        if (fileName.matches(\".*\\\\d.*\")) {\n            dependency.getVersionEvidence().addEvidence(\"file\", \"name\",\n                    fileName, Evidence.Confidence.HIGH);\n        }\n    }"
        },
        "test_db": {
            "id": "2442844",
            "rel_path": "src/test/java/org/codesecure/dependencycheck/analyzer/FileNameAnalyzerTest.java",
            "method_src": "@Test\n    public void testAnalyze() throws Exception {\n        System.out.println(\"analyze\");\n        File file = new File(this.getClass().getClassLoader().getResource(\"struts2-core-2.1.2.jar\").getPath());\n        Dependency result = new Dependency(file);\n        FileNameAnalyzer instance = new FileNameAnalyzer();\n        instance.analyze(result);\n        assertTrue(result.getVendorEvidence().toString().toLowerCase().contains(\"struts\"));\n    }",
            "method_tgt": "@Test\n    public void testAnalyze() throws Exception {\n        System.out.println(\"analyze\");\n        File file = new File(this.getClass().getClassLoader().getResource(\"struts2-core-2.1.2.jar\").getPath());\n        Dependency result = new Dependency(file);\n        FileNameAnalyzer instance = new FileNameAnalyzer();\n        instance.analyze(result, null);\n        assertTrue(result.getVendorEvidence().toString().toLowerCase().contains(\"struts\"));\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 0
    },
    {
        "repo_name": "jeremylong/DependencyCheck",
        "commit_id": "74a2326e0e3d4004f07aaa3be97a913e34bf4ea7",
        "commit_url": "https://github.com/jeremylong/DependencyCheck/commit/74a2326e0e3d4004f07aaa3be97a913e34bf4ea7",
        "focal_db": {
            "id": "2436913",
            "rel_path": "dependency-check-utils/src/main/java/org/owasp/dependencycheck/utils/Settings.java",
            "method_src": "public static void removeProperty(String key) {\n        LOCAL_SETTINGS.get().props.remove(key);\n    }",
            "method_tgt": "public void removeProperty(String key) {\n        props.remove(key);\n    }"
        },
        "test_db": {
            "id": "2436940",
            "rel_path": "dependency-check-utils/src/test/java/org/owasp/dependencycheck/utils/SettingsTest.java",
            "method_src": "@Test\n    public void testRemoveProperty() {\n        String key = \"SomeKey\";\n        String value = \"value\";\n        String dfault = \"default\";\n        Settings.setString(key, value);\n        String ret = Settings.getString(key);\n        Assert.assertEquals(value, ret);\n        Settings.removeProperty(key);\n        ret = Settings.getString(key, dfault);\n        Assert.assertEquals(dfault, ret);\n    }",
            "method_tgt": "@Test\n    public void testRemoveProperty() {\n        String key = \"SomeKey\";\n        String value = \"value\";\n        String dfault = \"default\";\n        getSettings().setString(key, value);\n        String ret = getSettings().getString(key);\n        Assert.assertEquals(value, ret);\n        getSettings().removeProperty(key);\n        ret = getSettings().getString(key, dfault);\n        Assert.assertEquals(dfault, ret);\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 1,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 0,
            "throw_types": 0
        }
    },
    {
        "repo_name": "kermitt2/grobid",
        "commit_id": "13839d64c90a8f1771e5a601810e12ae0a18971a",
        "commit_url": "https://github.com/kermitt2/grobid/commit/13839d64c90a8f1771e5a601810e12ae0a18971a",
        "focal_db": {
            "id": "5937436",
            "rel_path": "grobid-core/src/main/java/org/grobid/core/lexicon/Lexicon.java",
            "method_src": "public List<OffsetPosition> inAbbrevJournalNames(String s) {\n        if (abbrevJournalPattern == null) {\n            initJournals();\n        }\n        List<OffsetPosition> results = abbrevJournalPattern.matcher(s);\n        return results;\n    }",
            "method_tgt": "public List<OffsetPosition> tokenPositionsAbbrevJournalNames(String s) {\n        if (abbrevJournalPattern == null) {\n            initJournals();\n        }\n        List<OffsetPosition> results = abbrevJournalPattern.matchToken(s);\n        return results;\n    }"
        },
        "test_db": {
            "id": "5937443",
            "rel_path": "grobid-core/src/test/java/org/grobid/core/lexicon/LexiconIntegrationTest.java",
            "method_src": "@Test\n    public void testInAbbrevJournalNames_case1() throws Exception {\n        String input = \"Nature\";\n        List<OffsetPosition> journalsPositions = target.inAbbrevJournalNames(input);\n\n        assertNotNull(journalsPositions);\n        assertThat(journalsPositions, hasSize(1));\n        assertThat(journalsPositions.get(0).start, is(0));\n    }",
            "method_tgt": "@Test\n    public void testInAbbrevJournalNames_case1() throws Exception {\n        String input = \"Nature\";\n        List<OffsetPosition> journalsPositions = target.tokenPositionsAbbrevJournalNames(input);\n\n        assertNotNull(journalsPositions);\n        assertThat(journalsPositions, hasSize(1));\n        assertThat(journalsPositions.get(0).start, is(0));\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 1,
            "param_types": 0,
            "throw_types": 0
        },
        "aug": 0
    },
    {
        "repo_name": "kermitt2/grobid",
        "commit_id": "13839d64c90a8f1771e5a601810e12ae0a18971a",
        "commit_url": "https://github.com/kermitt2/grobid/commit/13839d64c90a8f1771e5a601810e12ae0a18971a",
        "focal_db": {
            "id": "5937436",
            "rel_path": "grobid-core/src/main/java/org/grobid/core/lexicon/FastMatcher.java",
            "method_src": "public List<OffsetPosition> matcher(List<String> tokens) {\n        StringBuilder text = new StringBuilder();\n        for (String token : tokens) {\n            text.append(processToken(token));\n        }\n        return matcher(text.toString());\n    }",
            "method_tgt": "public List<OffsetPosition> matchLayoutToken(List<LayoutToken> tokens) {\n        return matchLayoutToken(tokens, true);\n    }"
        },
        "test_db": {
            "id": "5937443",
            "rel_path": "grobid-core/src/test/java/org/grobid/core/lexicon/FastMatcherTest.java",
            "method_src": "@Test\n    public void testMatcherList_location() throws Exception {\n        target = new FastMatcher(this.getClass().getResourceAsStream(\"location.txt\"));\n\n        final List<OffsetPosition> offsetPositions = target.matcher(Arrays.asList(\"I\", \"m\", \"walking\", \"in\", \"The\", \"Bronx\"));\n        assertThat(offsetPositions, hasSize(2));\n        assertThat(offsetPositions.get(0).start, is(4));\n        assertThat(offsetPositions.get(0).end, is(5));\n        assertThat(offsetPositions.get(1).start, is(5));\n        assertThat(offsetPositions.get(1).end, is(5));\n    }",
            "method_tgt": "@Test\n    public void testMatcherList_location() throws Exception {\n        target = new FastMatcher(this.getClass().getResourceAsStream(\"location.txt\"));\n        final String input = \"I'm walking in The Bronx\";\n        List<LayoutToken> tokenisedInput = GrobidAnalyzer.getInstance().tokenizeWithLayoutToken(input);\n\n        final List<OffsetPosition> offsetPositions = target.matchLayoutToken(tokenisedInput);\n        assertThat(offsetPositions, hasSize(2));\n        assertThat(offsetPositions.get(0).start, is(8));\n        assertThat(offsetPositions.get(0).end, is(10));\n        assertThat(offsetPositions.get(1).start, is(10));\n        assertThat(offsetPositions.get(1).end, is(10));\n    }"
        },
        "syn_diff": {
            "overall": 2,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 1,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 1,
        "comment": "Case study hard"
    },
    {
        "repo_name": "kermitt2/grobid",
        "commit_id": "13839d64c90a8f1771e5a601810e12ae0a18971a",
        "commit_url": "https://github.com/kermitt2/grobid/commit/13839d64c90a8f1771e5a601810e12ae0a18971a",
        "focal_db": {
            "id": "5937436",
            "rel_path": "grobid-core/src/main/java/org/grobid/core/lexicon/FastMatcher.java",
            "method_src": "public List<OffsetPosition> match(String text) {\n        List<OffsetPosition> results = new ArrayList<>();\n        List<Integer> startPosition = new ArrayList<>();\n        List<Integer> lastNonSeparatorPos = new ArrayList<>();\n        List<Map> currentMatches = new ArrayList<>();\n        int currentPos = 0;\n        StringTokenizer st = new StringTokenizer(text, delimiters, true);\n        while (st.hasMoreTokens()) {\n            String token = st.nextToken();\n            if (token.equals(\" \")) {\n                currentPos++;\n                continue;\n            }\n            if (delimiters.indexOf(token) != -1) {\n                currentPos++;\n                continue;\n            }\n            //ignore tags\n            if ((token.charAt(0) == '<') && (token.charAt(token.length() - 1) == '>')) {\n                currentPos += token.length();\n                continue;\n            }\n            token = token.toLowerCase();\n\n            // we try to complete opened matching\n            int i = 0;\n            List<Map> matchesTreeList = new ArrayList<>();\n            List<Integer> matchesPosition = new ArrayList<>();\n            List<Integer> new_lastNonSeparatorPos = new ArrayList<>();\n\n            // we check whether the current token matches as continuation of a previous match.\n            for (Map currentMatch : currentMatches) {\n                Map childMatches = (Map) currentMatch.get(token);\n                if (childMatches != null) {\n                    matchesTreeList.add(childMatches);\n                    matchesPosition.add(startPosition.get(i));\n                    new_lastNonSeparatorPos.add(currentPos + token.length());\n                }\n\n                //check if the token itself is present, I add the match in the list of results\n                childMatches = (Map) currentMatch.get(\"#\");\n                if (childMatches != null) {\n                    // end of the current term, matching successful\n                    OffsetPosition ofp = new OffsetPosition(startPosition.get(i), lastNonSeparatorPos.get(i));\n                    results.add(ofp);\n                }\n\n                i++;\n            }\n\n            //TODO: e.g. The Bronx matches 'The Bronx' and 'Bronx' is this correct? \n\n            // we start new matching starting at the current token\n            Map match = (Map) terms.get(token);\n            if (match != null) {\n                matchesTreeList.add(match);\n                matchesPosition.add(currentPos);\n                new_lastNonSeparatorPos.add(currentPos + token.length());\n            }\n\n            currentMatches = matchesTreeList;\n            startPosition = matchesPosition;\n            lastNonSeparatorPos = new_lastNonSeparatorPos;\n            currentPos += token.length();\n        }\n\n        // test if the end of the string correspond to the end of a term\n        int i = 0;\n        if (currentMatches != null) {\n            for (Map tt : currentMatches) {\n                Map t2 = (Map) tt.get(\"#\");\n                if (t2 != null) {\n                    // end of the current term, matching successful\n                    OffsetPosition ofp = new OffsetPosition(startPosition.get(i), lastNonSeparatorPos.get(i));\n                    results.add(ofp);\n                }\n                i++;\n            }\n        }\n\n        return results;\n    }",
            "method_tgt": "public List<OffsetPosition> matchCharacter(String text) {\n        List<OffsetPosition> results = new ArrayList<>();\n        List<Integer> startPosition = new ArrayList<>();\n        List<Integer> lastNonSeparatorPos = new ArrayList<>();\n        List<Map> currentMatches = new ArrayList<>();\n        int currentPos = 0;\n        StringTokenizer st = new StringTokenizer(text, delimiters, true);\n        while (st.hasMoreTokens()) {\n            String token = st.nextToken();\n            if (token.equals(\" \")) {\n                currentPos++;\n                continue;\n            }\n            if (delimiters.indexOf(token) != -1) {\n                currentPos++;\n                continue;\n            }\n            //ignore tags\n            /*if ((token.charAt(0) == '<') && (token.charAt(token.length() - 1) == '>')) {\n                currentPos += token.length();\n                continue;\n            }*/\n            token = token.toLowerCase();\n\n            // we try to complete opened matching\n            int i = 0;\n            List<Map> matchesTreeList = new ArrayList<>();\n            List<Integer> matchesPosition = new ArrayList<>();\n            List<Integer> new_lastNonSeparatorPos = new ArrayList<>();\n\n            // we check whether the current token matches as continuation of a previous match.\n            for (Map currentMatch : currentMatches) {\n                Map childMatches = (Map) currentMatch.get(token);\n                if (childMatches != null) {\n                    matchesTreeList.add(childMatches);\n                    matchesPosition.add(startPosition.get(i));\n                    new_lastNonSeparatorPos.add(currentPos + token.length());\n                }\n\n                //check if the token itself is present, I add the match in the list of results\n                childMatches = (Map) currentMatch.get(\"#\");\n                if (childMatches != null) {\n                    // end of the current term, matching successful\n                    OffsetPosition ofp = new OffsetPosition(startPosition.get(i), lastNonSeparatorPos.get(i));\n                    results.add(ofp);\n                }\n\n                i++;\n            }\n\n            //TODO: e.g. The Bronx matches 'The Bronx' and 'Bronx' is this correct? \n\n            // we start new matching starting at the current token\n            Map match = (Map) terms.get(token);\n            if (match != null) {\n                matchesTreeList.add(match);\n                matchesPosition.add(currentPos);\n                new_lastNonSeparatorPos.add(currentPos + token.length());\n            }\n\n            currentMatches = matchesTreeList;\n            startPosition = matchesPosition;\n            lastNonSeparatorPos = new_lastNonSeparatorPos;\n            currentPos += token.length();\n        }\n\n        // test if the end of the string correspond to the end of a term\n        int i = 0;\n        if (currentMatches != null) {\n            for (Map tt : currentMatches) {\n                Map t2 = (Map) tt.get(\"#\");\n                if (t2 != null) {\n                    // end of the current term, matching successful\n                    OffsetPosition ofp = new OffsetPosition(startPosition.get(i), lastNonSeparatorPos.get(i));\n                    results.add(ofp);\n                }\n                i++;\n            }\n        }\n\n        return results;\n    }"
        },
        "test_db": {
            "id": "5937443",
            "rel_path": "grobid-core/src/test/java/org/grobid/core/lexicon/FastMatcherTest.java",
            "method_src": "@Test\n    public void testMatchString_location() throws Exception {\n        target = new FastMatcher(this.getClass().getResourceAsStream(\"location.txt\"));\n\n        final String input = \"I'm walking in The Bronx\";\n        final List<OffsetPosition> positions = target.match(input);\n        assertThat(positions, hasSize(2));\n        \n        //The Bronx\n        assertThat(positions.get(0).start, is(15));\n        assertThat(positions.get(0).end, is(24));\n\n        //Bronx\n        assertThat(positions.get(1).start, is(19));\n        assertThat(positions.get(1).end, is(24));\n    }",
            "method_tgt": "@Test\n    public void testMatchString_location() throws Exception {\n        target = new FastMatcher(this.getClass().getResourceAsStream(\"location.txt\"));\n\n        final String input = \"I'm walking in The Bronx\";\n        final List<OffsetPosition> positions = target.matchCharacter(input);\n        assertThat(positions, hasSize(2));\n        \n        //The Bronx\n        assertThat(positions.get(0).start, is(15));\n        assertThat(positions.get(0).end, is(24));\n\n        //Bronx\n        assertThat(positions.get(1).start, is(19));\n        assertThat(positions.get(1).end, is(24));\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 1,
            "param_types": 0,
            "throw_types": 0
        },
        "aug": 2
    },
    {
        "repo_name": "kermitt2/grobid",
        "commit_id": "13839d64c90a8f1771e5a601810e12ae0a18971a",
        "commit_url": "https://github.com/kermitt2/grobid/commit/13839d64c90a8f1771e5a601810e12ae0a18971a",
        "focal_db": {
            "id": "5937436",
            "rel_path": "grobid-core/src/main/java/org/grobid/core/lexicon/FastMatcher.java",
            "method_src": "public List<OffsetPosition> match(List<String> tokens) {\n        List<OffsetPosition> results = new ArrayList<>();\n        List<Integer> startPosition = new ArrayList<>();\n        List<Integer> lastNonSeparatorPos = new ArrayList<>();\n        List<Map> currentMatches = new ArrayList<>();\n\n        int currentPos = 0;\n\n        for (String token : tokens) {\n            if (token.equals(\" \")) {\n                currentPos++;\n                continue;\n            }\n            if (delimiters.indexOf(token) != -1) {\n                currentPos++;\n                continue;\n            }\n            //ignore tags\n            if ((token.charAt(0) == '<') && (token.charAt(token.length() - 1) == '>')) {\n                currentPos++;\n                continue;\n            }\n            token = token.toLowerCase();\n\n            // we try to complete opened matching\n            int i = 0;\n            List<Map> matchesTreeList = new ArrayList<>();\n            List<Integer> matchesPosition = new ArrayList<>();\n            List<Integer> new_lastNonSeparatorPos = new ArrayList<>();\n\n            // we check whether the current token matches as continuation of a previous match.\n            for (Map currentMatch : currentMatches) {\n                Map childMatches = (Map) currentMatch.get(token);\n                if (childMatches != null) {\n                    matchesTreeList.add(childMatches);\n                    matchesPosition.add(startPosition.get(i));\n                    new_lastNonSeparatorPos.add(currentPos);\n                }\n\n                //check if the token itself is present, I add the match in the list of results\n                childMatches = (Map) currentMatch.get(\"#\");\n                if (childMatches != null) {\n                    // end of the current term, matching successful\n                    OffsetPosition ofp = new OffsetPosition(startPosition.get(i), lastNonSeparatorPos.get(i));\n                    results.add(ofp);\n                }\n\n                i++;\n            }\n\n            // we start new matching starting at the current token\n            Map match = (Map) terms.get(token);\n            if (match != null) {\n                matchesTreeList.add(match);\n                matchesPosition.add(currentPos);\n                new_lastNonSeparatorPos.add(currentPos);\n            }\n\n            currentMatches = matchesTreeList;\n            startPosition = matchesPosition;\n            lastNonSeparatorPos = new_lastNonSeparatorPos;\n            currentPos++;\n        }\n\n        // test if the end of the string correspond to the end of a term\n        int i = 0;\n        if (currentMatches != null) {\n            for (Map tt : currentMatches) {\n                Map t2 = (Map) tt.get(\"#\");\n                if (t2 != null) {\n                    // end of the current term, matching successful\n                    OffsetPosition ofp = new OffsetPosition(startPosition.get(i), lastNonSeparatorPos.get(i));\n                    results.add(ofp);\n                }\n                i++;\n            }\n        }\n\n        return results;\n    }",
            "method_tgt": "public List<OffsetPosition> matchCharacterLayoutToken(List<LayoutToken> tokens) {\n        List<OffsetPosition> results = new ArrayList<>();\n        List<Integer> startPosition = new ArrayList<>();\n        List<Integer> lastNonSeparatorPos = new ArrayList<>();\n        List<Map> currentMatches = new ArrayList<>();\n\n        int currentPos = 0;\n\n        for (LayoutToken token : tokens) {\n            if (token.getText().equals(\" \")) {\n                currentPos++;\n                continue;\n            }\n            if (delimiters.indexOf(token.getText()) != -1) {\n                currentPos++;\n                continue;\n            }\n            //ignore tags\n            /*if ((token.charAt(0) == '<') && (token.charAt(token.length() - 1) == '>')) {\n                currentPos++;\n                continue;\n            }*/\n            String tokenString = token.getText().toLowerCase();\n\n            // we try to complete opened matching\n            int i = 0;\n            List<Map> matchesTreeList = new ArrayList<>();\n            List<Integer> matchesPosition = new ArrayList<>();\n            List<Integer> new_lastNonSeparatorPos = new ArrayList<>();\n\n            // we check whether the current token matches as continuation of a previous match.\n            for (Map currentMatch : currentMatches) {\n                Map childMatches = (Map) currentMatch.get(tokenString);\n                if (childMatches != null) {\n                    matchesTreeList.add(childMatches);\n                    matchesPosition.add(startPosition.get(i));\n                    new_lastNonSeparatorPos.add(currentPos);\n                }\n\n                //check if the token itself is present, I add the match in the list of results\n                childMatches = (Map) currentMatch.get(\"#\");\n                if (childMatches != null) {\n                    // end of the current term, matching successful\n                    OffsetPosition ofp = new OffsetPosition(startPosition.get(i), lastNonSeparatorPos.get(i));\n                    results.add(ofp);\n                }\n\n                i++;\n            }\n\n            // we start new matching starting at the current token\n            Map match = (Map) terms.get(tokenString);\n            if (match != null) {\n                matchesTreeList.add(match);\n                matchesPosition.add(currentPos);\n                new_lastNonSeparatorPos.add(currentPos);\n            }\n\n            currentMatches = matchesTreeList;\n            startPosition = matchesPosition;\n            lastNonSeparatorPos = new_lastNonSeparatorPos;\n            currentPos++;\n        }\n\n        // test if the end of the string correspond to the end of a term\n        int i = 0;\n        if (currentMatches != null) {\n            for (Map tt : currentMatches) {\n                Map t2 = (Map) tt.get(\"#\");\n                if (t2 != null) {\n                    // end of the current term, matching successful\n                    OffsetPosition ofp = new OffsetPosition(startPosition.get(i), lastNonSeparatorPos.get(i));\n                    results.add(ofp);\n                }\n                i++;\n            }\n        }\n\n        return results;\n    }"
        },
        "test_db": {
            "id": "5937443",
            "rel_path": "grobid-core/src/test/java/org/grobid/core/lexicon/FastMatcherTest.java",
            "method_src": "@Test\n    public void testMatchList_location_1Match() throws Exception {\n        target = new FastMatcher(this.getClass().getResourceAsStream(\"location.txt\"));\n\n        final String input = \"This is Bronx\";\n        final List<OffsetPosition> offsetPositions = target.match(Arrays.asList(input.split(\" \")));\n        assertThat(offsetPositions, hasSize(1));\n        assertThat(offsetPositions.get(0).start, is(2));\n        assertThat(offsetPositions.get(0).end, is(2));\n    }",
            "method_tgt": "@Test\n    public void testMatchList_location_1Match() throws Exception {\n        target = new FastMatcher(this.getClass().getResourceAsStream(\"location.txt\"));\n\n        final String input = \"This is Bronx\";\n        List<LayoutToken> tokenisedInput = GrobidAnalyzer.getInstance().tokenizeWithLayoutToken(input);\n        final List<OffsetPosition> offsetPositions = target.matchCharacterLayoutToken(tokenisedInput);\n        assertThat(offsetPositions, hasSize(1));\n        assertThat(offsetPositions.get(0).start, is(4));\n        assertThat(offsetPositions.get(0).end, is(4));\n    }"
        },
        "syn_diff": {
            "overall": 2,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 1,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 3,
        "comment": "Case study hard"
    },
    {
        "repo_name": "knightliao/disconf",
        "commit_id": "a70e72bab657035c227c593c74b3bcb92fd4a31f",
        "commit_url": "https://github.com/knightliao/disconf/commit/a70e72bab657035c227c593c74b3bcb92fd4a31f",
        "focal_db": {
            "id": "2587256",
            "rel_path": "disconf-client/src/main/java/com/baidu/disconf/client/fetcher/impl/FetcherMgrImpl.java",
            "method_src": "public String downloadFileFromServer(String url, String fileName) throws Exception {\n\n        // \u4e0b\u8f7d\u7684\u8def\u5f84\n        String localDir = getLocalDownloadDirPath();\n\n        // \u8bbe\u7f6e\u8fdc\u7a0b\u5730\u5740\n        RemoteUrl remoteUrl = new RemoteUrl(url, hostList);\n\n        // \u4e0b\u8f7d\n        return restfulMgr\n                   .downloadFromServer(remoteUrl, fileName, localDir, this.enableLocalDownloadDirInClassPath, retryTime,\n                                          retrySleepSeconds);\n    }",
            "method_tgt": "public String downloadFileFromServer(String url, String fileName, String targetFileDir) throws Exception {\n\n        // \u4e0b\u8f7d\u7684\u8def\u5f84\n        String localDir = getLocalDownloadDirPath();\n\n        // \u8bbe\u7f6e\u8fdc\u7a0b\u5730\u5740\n        RemoteUrl remoteUrl = new RemoteUrl(url, hostList);\n\n        // \u4e0b\u8f7d\n        return restfulMgr\n                .downloadFromServer(remoteUrl, fileName, localDir, targetFileDir,\n                        retryTime,\n                        retrySleepSeconds);\n\n    }"
        },
        "test_db": {
            "id": "2587259",
            "rel_path": "disconf-client/src/test/java/com/baidu/disconf/client/test/fetcher/FetcherMgrMgrTestCase.java",
            "method_src": "@Test\n    public void testDownloadFileFromServer() throws Exception {\n\n        final RestfulMgr restfulMgr = new RestfulMgrMock().getMockInstance();\n\n        FetcherMgr fetcherMgr = new FetcherMgrImpl(restfulMgr, 3, 5, true, \"\", new ArrayList<String>());\n\n        try {\n\n            String valueString = fetcherMgr.downloadFileFromServer(requestUrl, RestfulMgrMock.defaultFileName);\n            Assert.assertEquals(RestfulMgrMock.defaultFileName, valueString);\n\n        } catch (Exception e) {\n            e.printStackTrace();\n            Assert.assertTrue(false);\n        }\n    }",
            "method_tgt": "@Test\n    public void testDownloadFileFromServer() throws Exception {\n\n        final RestfulMgr restfulMgr = new RestfulMgrMock().getMockInstance();\n\n        FetcherMgr fetcherMgr = new FetcherMgrImpl(restfulMgr, 3, 5, true, \"\", new ArrayList<String>());\n\n        try {\n\n            String valueString = fetcherMgr.downloadFileFromServer(requestUrl, RestfulMgrMock.defaultFileName,\n                    \"./disconf\");\n            Assert.assertEquals(RestfulMgrMock.defaultFileName, valueString);\n\n        } catch (Exception e) {\n            e.printStackTrace();\n            Assert.assertTrue(false);\n        }\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 0
    },
    {
        "repo_name": "lessthanoptimal/BoofCV",
        "commit_id": "57a0b41ed9323721c705618f4b9703c19bb6caf5",
        "commit_url": "https://github.com/lessthanoptimal/BoofCV/commit/57a0b41ed9323721c705618f4b9703c19bb6caf5",
        "focal_db": {
            "id": "6025648",
            "rel_path": "main/feature/src/boofcv/alg/feature/detect/interest/UnrollSiftScaleSpaceGradient.java",
            "method_src": "public void setImage(ImageFloat32 image) {\n\n\t\tscaleSpace.initialize(image);\n\n\t\tusedScales.clear();\n\t\tdo {\n\t\t\tfor (int i = 0; i < scaleSpace.getNumScales(); i++) {\n\t\t\t\tImageFloat32 scaleImage = scaleSpace.getImageScale(i);\n\t\t\t\tdouble sigma = scaleSpace.computeSigmaScale(i);\n\t\t\t\tdouble pixelCurrentToInput = scaleSpace.pixelScaleCurrentToInput();\n\n\t\t\t\tImageScale scale = allScales.get(usedScales.size());\n\t\t\t\tscale.derivX.reshape(scaleImage.width,scaleImage.height);\n\t\t\t\tscale.derivY.reshape(scaleImage.width,scaleImage.height);\n\n\t\t\t\tgradient.process(scaleImage,scale.derivX,scale.derivY);\n\t\t\t\tscale.imageToInput = pixelCurrentToInput;\n\t\t\t\tscale.sigma = sigma;\n\n\t\t\t\tusedScales.add(scale);\n\t\t\t}\n\t\t} while( scaleSpace.computeNextOctave() );\n\t}",
            "method_tgt": "public void setImage(GrayF32 image) {\n\n\t\tscaleSpace.initialize(image);\n\n\t\tusedScales.clear();\n\t\tdo {\n\t\t\tfor (int i = 0; i < scaleSpace.getNumScales(); i++) {\n\t\t\t\tGrayF32 scaleImage = scaleSpace.getImageScale(i);\n\t\t\t\tdouble sigma = scaleSpace.computeSigmaScale(i);\n\t\t\t\tdouble pixelCurrentToInput = scaleSpace.pixelScaleCurrentToInput();\n\n\t\t\t\tImageScale scale = allScales.get(usedScales.size());\n\t\t\t\tscale.derivX.reshape(scaleImage.width,scaleImage.height);\n\t\t\t\tscale.derivY.reshape(scaleImage.width,scaleImage.height);\n\n\t\t\t\tgradient.process(scaleImage,scale.derivX,scale.derivY);\n\t\t\t\tscale.imageToInput = pixelCurrentToInput;\n\t\t\t\tscale.sigma = sigma;\n\n\t\t\t\tusedScales.add(scale);\n\t\t\t}\n\t\t} while( scaleSpace.computeNextOctave() );\n\t}"
        },
        "test_db": {
            "id": "6025889",
            "rel_path": "main/feature/test/boofcv/alg/feature/detect/interest/TestUnrollSiftScaleSpaceGradient.java",
            "method_src": "@Test\n\tpublic void setImage() {\n\t\tImageFloat32 image = new ImageFloat32(640,480);\n\t\tGImageMiscOps.fillUniform(image,rand,0,200);\n\n\n\t\tUnrollSiftScaleSpaceGradient alg = new UnrollSiftScaleSpaceGradient(new SiftScaleSpace(-1,3,3,2));\n\t\talg.setImage(image);\n\n\t\tSiftScaleSpace ss = new SiftScaleSpace(-1,3,3,2);\n\t\tss.initialize(image);\n\n\t\tImageFloat32 derivX = new ImageFloat32(640,480);\n\t\tImageFloat32 derivY = new ImageFloat32(640,480);\n\n\t\tint total = 0;\n\t\tdo {\n\t\t\tfor (int i = 0; i < ss.getNumScales(); i++, total++ ) {\n\t\t\t\tImageFloat32 scaleImage = ss.getImageScale(i);\n\n\t\t\t\tderivX.reshape(scaleImage.width,scaleImage.height);\n\t\t\t\tderivY.reshape(scaleImage.width,scaleImage.height);\n\n\t\t\t\tGImageDerivativeOps.gradient(DerivativeType.THREE,scaleImage,derivX,derivY, BorderType.EXTENDED);\n\n\t\t\t\tUnrollSiftScaleSpaceGradient.ImageScale found = alg.usedScales.get(total);\n\n\t\t\t\tBoofTesting.assertEquals(derivX,found.derivX,1e-4);\n\t\t\t\tBoofTesting.assertEquals(derivY,found.derivY,1e-4);\n\t\t\t\tassertEquals(ss.computeSigmaScale(i),found.sigma,1e-4);\n\t\t\t\tassertEquals(image.width/(double)scaleImage.width,found.imageToInput,1e-4);\n\n\t\t\t}\n\n\t\t} while( ss.computeNextOctave() );\n\t}",
            "method_tgt": "@Test\n\tpublic void setImage() {\n\t\tGrayF32 image = new GrayF32(640,480);\n\t\tGImageMiscOps.fillUniform(image,rand,0,200);\n\n\n\t\tUnrollSiftScaleSpaceGradient alg = new UnrollSiftScaleSpaceGradient(new SiftScaleSpace(-1,3,3,2));\n\t\talg.setImage(image);\n\n\t\tSiftScaleSpace ss = new SiftScaleSpace(-1,3,3,2);\n\t\tss.initialize(image);\n\n\t\tGrayF32 derivX = new GrayF32(640,480);\n\t\tGrayF32 derivY = new GrayF32(640,480);\n\n\t\tint total = 0;\n\t\tdo {\n\t\t\tfor (int i = 0; i < ss.getNumScales(); i++, total++ ) {\n\t\t\t\tGrayF32 scaleImage = ss.getImageScale(i);\n\n\t\t\t\tderivX.reshape(scaleImage.width,scaleImage.height);\n\t\t\t\tderivY.reshape(scaleImage.width,scaleImage.height);\n\n\t\t\t\tGImageDerivativeOps.gradient(DerivativeType.THREE,scaleImage,derivX,derivY, BorderType.EXTENDED);\n\n\t\t\t\tUnrollSiftScaleSpaceGradient.ImageScale found = alg.usedScales.get(total);\n\n\t\t\t\tBoofTesting.assertEquals(derivX,found.derivX,1e-4);\n\t\t\t\tBoofTesting.assertEquals(derivY,found.derivY,1e-4);\n\t\t\t\tassertEquals(ss.computeSigmaScale(i),found.sigma,1e-4);\n\t\t\t\tassertEquals(image.width/(double)scaleImage.width,found.imageToInput,1e-4);\n\n\t\t\t}\n\n\t\t} while( ss.computeNextOctave() );\n\t}"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        }
    },
    {
        "repo_name": "lessthanoptimal/BoofCV",
        "commit_id": "8692802ff83b42362792f4a90d3409360a7071d1",
        "commit_url": "https://github.com/lessthanoptimal/BoofCV/commit/8692802ff83b42362792f4a90d3409360a7071d1",
        "focal_db": {
            "id": "6027102",
            "rel_path": "main/feature/src/boofcv/alg/shapes/polyline/MinimizeEnergyPrune.java",
            "method_src": "public boolean fit( List<Point2D_I32> contour , GrowQueue_I32 input , GrowQueue_I32 output ) {\n\n\t\tthis.contour = contour;\n\t\toutput.setTo(input);\n\t\tremoveDuplicates(output);\n\n\t\t// can't prune a corner and it will still be a polygon\n\t\tif( output.size() <= 3 )\n\t\t\treturn false;\n\n\t\tcomputeSegmentEnergy(output);\n\n\t\tdouble total = 0;\n\t\tfor (int i = 0; i < output.size(); i++) {\n\t\t\ttotal += energySegment[i];\n\t\t}\n\n\t\tFitLinesToContour fit = new FitLinesToContour();\n\t\tfit.setContour(contour);\n\n\t\tboolean modified = false;\n\t\twhile( output.size() > 3 ) {\n\t\t\tdouble bestEnergy = total;\n\t\t\tboolean betterFound = false;\n\t\t\tbestCorners.reset();\n\n\t\t\tfor (int i = 0; i < output.size(); i++) {\n\t\t\t\t// add all but the one which was removed\n\t\t\t\tworkCorners1.reset();\n\t\t\t\tfor (int j = 0; j < output.size(); j++) {\n\t\t\t\t\tif( i != j ) {\n\t\t\t\t\t\tworkCorners1.add(output.get(j));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// just in case it created a duplicate\n\t\t\t\tremoveDuplicates(workCorners1);// todo optimize\n\t\t\t\tif( workCorners1.size() > 3 ) {\n\n\t\t\t\t\tint anchor0 = CircularIndex.addOffset(i, -2, workCorners1.size());\n\t\t\t\t\tint anchor1 = CircularIndex.addOffset(i, 1, workCorners1.size());\n\n\t\t\t\t\tif (fit.fitAnchored(anchor0, anchor1, workCorners1, workCorners2)) {\n\n\t\t\t\t\t\tdouble score = 0;\n\t\t\t\t\t\tfor (int j = 0, k = workCorners2.size() - 1; j < workCorners2.size(); k = j, j++) {\n\t\t\t\t\t\t\tscore += computeSegmentEnergy(workCorners2, k, j);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (score < bestEnergy) {\n\t\t\t\t\t\t\tbetterFound = true;\n\t\t\t\t\t\t\tbestEnergy = score;\n\t\t\t\t\t\t\tbestCorners.reset();\n\t\t\t\t\t\t\tbestCorners.addAll(workCorners2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( betterFound ) {\n\t\t\t\tmodified = true;\n\t\t\t\ttotal = bestEnergy;\n\t\t\t\toutput.setTo(bestCorners);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn modified;\n\t}",
            "method_tgt": "public boolean prune(List<Point2D_I32> contour, GrowQueue_I32 input, GrowQueue_I32 output) {\n\n\t\tthis.contour = contour;\n\t\toutput.setTo(input);\n\t\tremoveDuplicates(output);\n\n\t\t// can't prune a corner and it will still be a polygon\n\t\tif( output.size() <= 3 )\n\t\t\treturn false;\n\n\t\tcomputeSegmentEnergy(output);\n\n\t\tdouble total = 0;\n\t\tfor (int i = 0; i < output.size(); i++) {\n\t\t\ttotal += energySegment[i];\n\t\t}\n\n\t\tFitLinesToContour fit = new FitLinesToContour();\n\t\tfit.setContour(contour);\n\n\t\tboolean modified = false;\n\t\twhile( output.size() > 3 ) {\n\t\t\tdouble bestEnergy = total;\n\t\t\tboolean betterFound = false;\n\t\t\tbestCorners.reset();\n\n\t\t\tfor (int i = 0; i < output.size(); i++) {\n\t\t\t\t// add all but the one which was removed\n\t\t\t\tworkCorners1.reset();\n\t\t\t\tfor (int j = 0; j < output.size(); j++) {\n\t\t\t\t\tif( i != j ) {\n\t\t\t\t\t\tworkCorners1.add(output.get(j));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// just in case it created a duplicate\n\t\t\t\tremoveDuplicates(workCorners1);\n\t\t\t\tif( workCorners1.size() > 3 ) {\n\n\t\t\t\t\t// when looking at these anchors remember that they are relative to the new list without\n\t\t\t\t\t// the removed corner and that the two adjacent corners need to be optimized\n\t\t\t\t\tint anchor0 = CircularIndex.addOffset(i, -2, workCorners1.size());\n\t\t\t\t\tint anchor1 = CircularIndex.addOffset(i, 1, workCorners1.size());\n\n\t\t\t\t\t// optimize the two adjacent corners to the removed one\n\t\t\t\t\tif (fit.fitAnchored(anchor0, anchor1, workCorners1, workCorners2)) {\n\n\t\t\t\t\t\t// TODO this isn't taking advantage of previously computed line segment energy is it?\n\t\t\t\t\t\t//      maybe a small speed up can be had by doing that\n\t\t\t\t\t\tdouble score = 0;\n\t\t\t\t\t\tfor (int j = 0, k = workCorners2.size() - 1; j < workCorners2.size(); k = j, j++) {\n\t\t\t\t\t\t\tscore += computeSegmentEnergy(workCorners2, k, j);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (score < bestEnergy) {\n\t\t\t\t\t\t\tbetterFound = true;\n\t\t\t\t\t\t\tbestEnergy = score;\n\t\t\t\t\t\t\tbestCorners.reset();\n\t\t\t\t\t\t\tbestCorners.addAll(workCorners2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( betterFound ) {\n\t\t\t\tmodified = true;\n\t\t\t\ttotal = bestEnergy;\n\t\t\t\toutput.setTo(bestCorners);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn modified;\n\t}"
        },
        "test_db": {
            "id": "6027104",
            "rel_path": "main/feature/test/boofcv/alg/shapes/polyline/TestMinimizeEnergyPrune.java",
            "method_src": "@Test\n\tpublic void fit_obvious() {\n\t\tList<Point2D_I32> contours = createSquare(10,12,20,30);\n\t\tGrowQueue_I32 corners = createSquareCorners(10, 12, 20, 30);\n\t\tcorners.add(corners.get(3)+4);\n\n\t\tMinimizeEnergyPrune alg = new MinimizeEnergyPrune(1);\n\n\t\tGrowQueue_I32 output = new GrowQueue_I32();\n\t\talg.fit(contours,corners,output);\n\n\t\tassertEquals(4, output.size());\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tassertEquals(corners.get(i),output.get(i));\n\t\t}\n\t}",
            "method_tgt": "@Test\n\tpublic void prune_obvious() {\n\t\tList<Point2D_I32> contours = createSquare(10,12,20,30);\n\t\tGrowQueue_I32 corners = createSquareCorners(10, 12, 20, 30);\n\t\tcorners.add(corners.get(3)+4);\n\n\t\tMinimizeEnergyPrune alg = new MinimizeEnergyPrune(1);\n\n\t\tGrowQueue_I32 output = new GrowQueue_I32();\n\t\talg.prune(contours, corners, output);\n\n\t\tassertEquals(4, output.size());\n\n\t\t// see if the two sets of corners are equivalent, taking in account the possibility of a rotation\n\t\tcheckMatched(corners, output);\n\n\t}"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 1,
            "param_types": 0,
            "throw_types": 0
        }
    },
    {
        "repo_name": "lessthanoptimal/BoofCV",
        "commit_id": "2ab0996c4019d1b057bef89a32aa1753265fe37c",
        "commit_url": "https://github.com/lessthanoptimal/BoofCV/commit/2ab0996c4019d1b057bef89a32aa1753265fe37c",
        "focal_db": {
            "id": "6015661",
            "rel_path": "main/boofcv-feature/src/main/java/boofcv/alg/feature/disparity/sgm/SgmCostAggregation.java",
            "method_src": "void computeCostInnerD(GrayU16 costXD, int idxCost, int idxLrPrev, int lengthLocalD ) {\n\t\tidxLrPrev += 1; // start at d=1\n\t\tfor (int d = 1; d < lengthLocalD-1; d++, idxLrPrev++) {\n\t\t\tint cost = costXD.data[idxCost+d] & 0xFFFF; // C(p,d)\n\n\t\t\tint b = workCostLr[idxLrPrev-1]&0xFFFF; // Lr(p-r,d-1)\n\t\t\tint a = workCostLr[idxLrPrev  ]&0xFFFF; // Lr(p-r,d  )\n\t\t\tint c = workCostLr[idxLrPrev+1]&0xFFFF; // Lr(p-r,d+1)\n\n\t\t\t// Add penalty terms\n\t\t\tb += penalty1;\n\t\t\tc += penalty1;\n\n\t\t\t// Find the minimum of the three scores\n\t\t\tif( b < a )\n\t\t\t\ta = b;\n\t\t\tif( c < a )\n\t\t\t\ta = c;\n\t\t\tif( penalty2 < a )\n\t\t\t\ta = penalty2;\n\n\t\t\t// minCostPrev is done to reduce the rate at which the cost increases\n\t\t\tif( cost + a > Short.MAX_VALUE )\n\t\t\t\tthrow new RuntimeException(\"Egads\");\n\t\t\tworkCostLr[idxLrPrev+this.lengthD] = (short)(cost + a);\n\t\t\t// Lr(p,d) = above\n\t\t}\n\t}",
            "method_tgt": "void computeCostInnerD(GrayU16 costXD, int idxCost, int idxLrPrev, int lengthLocalD , short[] workCostLr) {\n\t\tidxLrPrev += 1; // start at d=1\n\t\tfor (int d = 1; d < lengthLocalD-1; d++, idxLrPrev++) {\n\t\t\tint cost = costXD.data[idxCost+d] & 0xFFFF; // C(p,d)\n\n\t\t\tint b = workCostLr[idxLrPrev-1]&0xFFFF; // Lr(p-r,d-1)\n\t\t\tint a = workCostLr[idxLrPrev  ]&0xFFFF; // Lr(p-r,d  )\n\t\t\tint c = workCostLr[idxLrPrev+1]&0xFFFF; // Lr(p-r,d+1)\n\n\t\t\t// Add penalty terms\n\t\t\tb += penalty1;\n\t\t\tc += penalty1;\n\n\t\t\t// Find the minimum of the three scores\n\t\t\tif( b < a )\n\t\t\t\ta = b;\n\t\t\tif( c < a )\n\t\t\t\ta = c;\n\t\t\tif( penalty2 < a )\n\t\t\t\ta = penalty2;\n\n\t\t\t// minCostPrev is done to reduce the rate at which the cost increases\n\t\t\tif( cost + a > Short.MAX_VALUE )\n\t\t\t\tthrow new RuntimeException(\"Egads\");\n\t\t\tworkCostLr[idxLrPrev+this.lengthD] = (short)(cost + a);\n\t\t\t// Lr(p,d) = above\n\t\t}\n\t}"
        },
        "test_db": {
            "id": "6015673",
            "rel_path": "main/boofcv-feature/src/test/java/boofcv/alg/feature/disparity/sgm/TestSgmCostAggregation.java",
            "method_src": "@Test\n\tvoid computeCostInnerD() {\n\t\tPlanar<GrayU16> costYXD = new Planar<>(GrayU16.class,rangeD,width,height);\n\t\tGImageMiscOps.fillUniform(costYXD,rand,0,SgmDisparityCost.MAX_COST);\n\n\t\tSgmCostAggregation alg = new SgmCostAggregation();\n\t\talg.init(costYXD);\n\t\tfor (int i = 0; i < alg.workCostLr.length; i++) {\n\t\t\talg.workCostLr[i] = (short)rand.nextInt(SgmDisparityCost.MAX_COST);\n\t\t}\n\n\t\tGrayU16 costXD = costYXD.getBand(2);\n\n\t\tint x = rangeD + 2;  // x-value in image\n\t\tint pathI = 3;       // location along the path\n\n\t\tint idxCost = costXD.getIndex(0,x); // x=row, d=col\n\t\tint idxWork = alg.lengthD*pathI;\n\n\t\t// Compute the cost using this algorithm\n\t\talg.computeCostInnerD(costXD,idxCost,idxWork, rangeD);\n\n\t\t// Now compare it to a brute force solution\n\t\tfor (int d = 1; d < rangeD-1; d++) {\n\t\t\tint cost_p_d = costXD.get(d,x);\n\n\t\t\tint l0 = workArray(alg,pathI,d);\n\t\t\tint l1 = workArray(alg,pathI,d-1) + alg.penalty1;\n\t\t\tint l2 = workArray(alg,pathI,d+1) + alg.penalty1;\n\t\t\tint l3 = alg.penalty2;\n\n\t\t\tint v = min(min(min(l0,l1),l2),l3);\n\n\t\t\tint expected = cost_p_d + v;\n\t\t\tint found = workArray(alg,pathI+1,d);\n\n\t\t\tassertEquals(expected,found);\n\t\t}\n\t}",
            "method_tgt": "@Test\n\tvoid computeCostInnerD() {\n\t\tPlanar<GrayU16> costYXD = new Planar<>(GrayU16.class,rangeD,width,height);\n\t\tGImageMiscOps.fillUniform(costYXD,rand,0,SgmDisparityCost.MAX_COST);\n\n\t\tSgmCostAggregation alg = new SgmCostAggregation();\n\t\talg.init(costYXD);\n\t\tshort[] workCostLr = alg.workspace.get(0).workCostLr;\n\t\tfor (int i = 0; i < workCostLr.length; i++) {\n\t\t\tworkCostLr[i] = (short)rand.nextInt(SgmDisparityCost.MAX_COST);\n\t\t}\n\n\t\tGrayU16 costXD = costYXD.getBand(2);\n\n\t\tint x = rangeD + 2;  // x-value in image\n\t\tint pathI = 3;       // location along the path\n\n\t\tint idxCost = costXD.getIndex(0,x); // x=row, d=col\n\t\tint idxWork = alg.lengthD*pathI;\n\n\t\t// Compute the cost using this algorithm\n\t\talg.computeCostInnerD(costXD,idxCost,idxWork, rangeD, workCostLr);\n\n\t\t// Now compare it to a brute force solution\n\t\tfor (int d = 1; d < rangeD-1; d++) {\n\t\t\tint cost_p_d = costXD.get(d,x);\n\n\t\t\tint l0 = workArray(alg,pathI,d);\n\t\t\tint l1 = workArray(alg,pathI,d-1) + alg.penalty1;\n\t\t\tint l2 = workArray(alg,pathI,d+1) + alg.penalty1;\n\t\t\tint l3 = alg.penalty2;\n\n\t\t\tint v = min(min(min(l0,l1),l2),l3);\n\n\t\t\tint expected = cost_p_d + v;\n\t\t\tint found = workArray(alg,pathI+1,d);\n\n\t\t\tassertEquals(expected,found);\n\t\t}\n\t}"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        }
    },
    {
        "repo_name": "lessthanoptimal/BoofCV",
        "commit_id": "7993d6598710c979202ff9ca343cd16b00d95085",
        "commit_url": "https://github.com/lessthanoptimal/BoofCV/commit/7993d6598710c979202ff9ca343cd16b00d95085",
        "focal_db": {
            "id": "6033369",
            "rel_path": "ip/src/gecv/factory/filter/kernel/FactorySteerable.java",
            "method_src": "public static <K extends Kernel2D> SteerableKernel<K> gaussian( Class<K> kernelType , int orderX , int orderY , int radius ) {\n\t\tif( orderX < 0 || orderX > 4 )\n\t\t\tthrow new IllegalArgumentException(\"derivX must be from 0 to 4 inclusive.\");\n\t\tif( orderY < 0 || orderY > 4 )\n\t\t\tthrow new IllegalArgumentException(\"derivT must be from 0 to 4 inclusive.\");\n\n\t\tint order = orderX + orderY;\n\n\t\tif( order > 4 ) {\n\t\t\tthrow new IllegalArgumentException(\"The total order of x and y can't be greater than 4\");\n\t\t}\n\t\tint maxOrder = Math.max(orderX,orderY);\n\n\t\tfloat sigma = (float)FactoryKernelGaussian.sigmaForRadius(radius,maxOrder);\n\n\t\tClass kernel1DType = FactoryKernel.get1DType(kernelType);\n\t\tKernel1D kerX =  FactoryKernelGaussian.derivativeK(kernel1DType,orderX,sigma,radius);\n\t\tKernel1D kerY = FactoryKernelGaussian.derivativeK(kernel1DType,orderY,sigma,radius);\n\t\tKernel2D kernel = GKernelMath.convolve(kerY,kerX);\n\n\t\tKernel2D []basis = new Kernel2D[order+1];\n\n\t\t// convert it into an image which can be rotated\n\t\tImageBase image = GKernelMath.convertToImage(kernel);\n\t\tImageBase imageRotated = image._createNew(image.width,image.height);\n\n\t\tfloat centerX = image.width/2;\n\t\tfloat centerY = image.height/2;\n\n\t\tbasis[0] = kernel;\n\n\t\t// form the basis by created rotated versions of the kernel\n\t\tdouble angleStep = Math.PI/basis.length;\n\n\t\tfor( int index = 1; index <= order; index++ ) {\n\t\t\tfloat angle = (float)(angleStep*index);\n\n\t\t\tGeneralizedImageOps.fill(imageRotated,0);\n\t\t\tDistortImageOps.rotate(image,imageRotated, TypeInterpolate.BILINEAR,centerX,centerY,angle);\n\n\t\t\tbasis[index] = GKernelMath.convertToKernel(imageRotated);\n\t\t}\n\n\t\tSteerableKernel<K> ret;\n\n\t\tif( kernelType == Kernel2D_F32.class )\n\t\t\tret = (SteerableKernel<K>)new SteerableKernel_F32();\n\t\telse\n\t\t\tret = (SteerableKernel<K>)new SteerableKernel_I32();\n\n\t\tret.setBasis(FactorySteerCoefficients.polynomial(order),basis);\n\n\t\treturn ret;\n\t}",
            "method_tgt": "public static <K extends Kernel2D> SteerableKernel<K> gaussian(Class<K> kernelType, int orderX, int orderY, double sigma, int radius) {\n\t\tif( orderX < 0 || orderX > 4 )\n\t\t\tthrow new IllegalArgumentException(\"derivX must be from 0 to 4 inclusive.\");\n\t\tif( orderY < 0 || orderY > 4 )\n\t\t\tthrow new IllegalArgumentException(\"derivT must be from 0 to 4 inclusive.\");\n\n\t\tint order = orderX + orderY;\n\n\t\tif( order > 4 ) {\n\t\t\tthrow new IllegalArgumentException(\"The total order of x and y can't be greater than 4\");\n\t\t}\n\t\tint maxOrder = Math.max(orderX,orderY);\n\n\t\tif( sigma <= 0 )\n\t\t\tsigma = (float)FactoryKernelGaussian.sigmaForRadius(radius,maxOrder);\n\t\telse if( radius <= 0 )\n\t\t\tradius = FactoryKernelGaussian.radiusForSigma(sigma,maxOrder);\n\n\t\tClass kernel1DType = FactoryKernel.get1DType(kernelType);\n\t\tKernel1D kerX =  FactoryKernelGaussian.derivativeK(kernel1DType,orderX,sigma,radius);\n\t\tKernel1D kerY = FactoryKernelGaussian.derivativeK(kernel1DType,orderY,sigma,radius);\n\t\tKernel2D kernel = GKernelMath.convolve(kerY,kerX);\n\n\t\tKernel2D []basis = new Kernel2D[order+1];\n\n\t\t// convert it into an image which can be rotated\n\t\tImageBase image = GKernelMath.convertToImage(kernel);\n\t\tImageBase imageRotated = image._createNew(image.width,image.height);\n\n\t\tfloat centerX = image.width/2;\n\t\tfloat centerY = image.height/2;\n\n\t\tbasis[0] = kernel;\n\n\t\t// form the basis by created rotated versions of the kernel\n\t\tdouble angleStep = Math.PI/basis.length;\n\n\t\tfor( int index = 1; index <= order; index++ ) {\n\t\t\tfloat angle = (float)(angleStep*index);\n\n\t\t\tGeneralizedImageOps.fill(imageRotated,0);\n\t\t\tDistortImageOps.rotate(image,imageRotated, TypeInterpolate.BILINEAR,centerX,centerY,angle);\n\n\t\t\tbasis[index] = GKernelMath.convertToKernel(imageRotated);\n\t\t}\n\n\t\tSteerableKernel<K> ret;\n\n\t\tif( kernelType == Kernel2D_F32.class )\n\t\t\tret = (SteerableKernel<K>)new SteerableKernel_F32();\n\t\telse\n\t\t\tret = (SteerableKernel<K>)new SteerableKernel_I32();\n\n\t\tret.setBasis(FactorySteerCoefficients.polynomial(order),basis);\n\n\t\treturn ret;\n\t}"
        },
        "test_db": {
            "id": "6033371",
            "rel_path": "ip/test/gecv/factory/filter/kernel/TestFactorySteerable.java",
            "method_src": "@Test\n\tpublic void gaussian() {\n\n\t\tfor( int totalOrder = 1; totalOrder <= 4; totalOrder++ ) {\n\t\t\tfor( int orderX = 0; orderX<= totalOrder; orderX++ ) {\n\t\t\t\tint orderY = totalOrder-orderX;\n\n\t\t\t\tSteerableKernel<Kernel2D_F32> alg = FactorySteerable.gaussian(Kernel2D_F32.class,orderX,orderY,10);\n\n\t\t\t\tKernel2D_F32 k = alg.compute(0.1);\n\n\t\t\t\t// make sure its not zero.\n\t\t\t\tboolean notZero = false;\n\t\t\t\tfor( int y = 0; y < k.width; y++ ) {\n\t\t\t\t\tfor( int x = 0; x < k.width; x++ ) {\n\t\t\t\t\t\tif( k.get(x,y) != 0 )\n\t\t\t\t\t\t\tnotZero=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tassertTrue(notZero);\n\t\t\t}\n\t\t}\n\t}",
            "method_tgt": "@Test\n\tpublic void gaussian() {\n\n\t\tfor( int totalOrder = 1; totalOrder <= 4; totalOrder++ ) {\n\t\t\tfor( int orderX = 0; orderX<= totalOrder; orderX++ ) {\n\t\t\t\tint orderY = totalOrder-orderX;\n\n\t\t\t\tSteerableKernel<Kernel2D_F32> alg = FactorySteerable.gaussian(Kernel2D_F32.class,orderX,orderY, -1, 10);\n\n\t\t\t\tKernel2D_F32 k = alg.compute(0.1);\n\n\t\t\t\t// make sure its not zero.\n\t\t\t\tboolean notZero = false;\n\t\t\t\tfor( int y = 0; y < k.width; y++ ) {\n\t\t\t\t\tfor( int x = 0; x < k.width; x++ ) {\n\t\t\t\t\t\tif( k.get(x,y) != 0 )\n\t\t\t\t\t\t\tnotZero=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tassertTrue(notZero);\n\t\t\t}\n\t\t}\n\t}"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        }
    },
    {
        "repo_name": "lessthanoptimal/BoofCV",
        "commit_id": "3032ec90ebdc393779956b7665e735cee7e13cad",
        "commit_url": "https://github.com/lessthanoptimal/BoofCV/commit/3032ec90ebdc393779956b7665e735cee7e13cad",
        "focal_db": {
            "id": "6028159",
            "rel_path": "main/geo/src/boofcv/alg/distort/LensDistortionOps.java",
            "method_src": "public static PointTransform_F32 fullView( IntrinsicParameters param,\n\t\t\t\t\t\t\t\t\t\t\t   IntrinsicParameters paramAdj ,\n\t\t\t\t\t\t\t\t\t\t\t   boolean adjToDistorted ) {\n\n\t\tPointTransform_F32 remove_p_to_p = distortTransform(param).undistort_F32(true, true);\n\n\t\tRectangleLength2D_F32 bound = DistortImageOps.boundBox_F32(param.width, param.height,\n\t\t\t\tnew PointToPixelTransform_F32(remove_p_to_p));\n\n\t\tdouble scaleX = bound.width/param.width;\n\t\tdouble scaleY = bound.height/param.height;\n\n\t\tdouble scale = Math.max(scaleX, scaleY);\n\n\t\t// translation\n\t\tdouble deltaX = bound.x0;\n\t\tdouble deltaY = bound.y0;\n\n\t\t// adjustment matrix\n\t\tDenseMatrix64F A = new DenseMatrix64F(3,3,true,scale,0,deltaX,0,scale,deltaY,0,0,1);\n\n\t\treturn adjustmentTransform(param, paramAdj, adjToDistorted, remove_p_to_p, A);\n\t}",
            "method_tgt": "public static PointTransform_F32 transform_F32(AdjustmentType type,\n\t\t\t\t\t\t\t\t\t\t\t\t   IntrinsicParameters param,\n\t\t\t\t\t\t\t\t\t\t\t\t   IntrinsicParameters paramAdj,\n\t\t\t\t\t\t\t\t\t\t\t\t   boolean adjToDistorted)\n\t{\n\t\tPointTransform_F32 remove_p_to_p = distortTransform(param).undistort_F32(true, true);\n\n\t\tRectangleLength2D_F32 bound;\n\t\tif( type == AdjustmentType.FULL_VIEW ) {\n\t\t\tbound = DistortImageOps.boundBox_F32(param.width, param.height,\n\t\t\t\t\tnew PointToPixelTransform_F32(remove_p_to_p));\n\t\t} else if( type == AdjustmentType.SHRINK) {\n\t\t\tbound = LensDistortionOps.boundBoxInside(param.width, param.height,\n\t\t\t\t\tnew PointToPixelTransform_F32(remove_p_to_p));\n\n\t\t\t// ensure there are no strips of black\n\t\t\tLensDistortionOps.roundInside(bound);\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException(\"Unsupported type \"+type);\n\t\t}\n\n\t\tdouble scaleX = bound.width/param.width;\n\t\tdouble scaleY = bound.height/param.height;\n\n\t\tdouble scale,deltaX,deltaY;\n\n\t\tif( type == AdjustmentType.FULL_VIEW ) {\n\t\t\tscale = Math.max(scaleX, scaleY);\n\t\t\tdeltaX = bound.x0;\n\t\t\tdeltaY = bound.y0;\n\t\t} else {\n\t\t\tscale = Math.min(scaleX, scaleY);\n\t\t\t// translation and shift over so that the small axis is in the middle\n\t\t\tdeltaX = bound.x0 + (scaleX-scale)*param.width/2.0;\n\t\t\tdeltaY = bound.y0 + (scaleY-scale)*param.height/2.0;\n\t\t}\n\n\t\t// adjustment matrix\n\t\tDenseMatrix64F A = new DenseMatrix64F(3,3,true,scale,0,deltaX,0,scale,deltaY,0,0,1);\n\n\t\treturn adjustmentTransform_F32(param, paramAdj, adjToDistorted, remove_p_to_p, A);\n\t}"
        },
        "test_db": {
            "id": "6028162",
            "rel_path": "main/geo/test/boofcv/alg/distort/TestLensDistortionOps.java",
            "method_src": "@Test\n\tpublic void fullView_Transform() {\n\t\tIntrinsicParameters param = new IntrinsicParameters().\n\t\t\t\tfsetK(300, 320, 0, 150, 130, width, height).fsetRadial(0.1, 0.05);\n\n\t\tPointTransform_F32 adjToDist = LensDistortionOps.fullView(param, null, true);\n\t\tPointTransform_F32 distToAdj = LensDistortionOps.fullView(param, null, false);\n\n\t\tcheckBorderOutside(adjToDist,distToAdj);\n\n\t\tparam = new IntrinsicParameters().\n\t\t\t\tfsetK(300, 320, 0, 150, 130, width, height).fsetRadial(-0.1,-0.05);\n\t\tadjToDist = LensDistortionOps.fullView(param, null, true);\n\t\tdistToAdj = LensDistortionOps.fullView(param, null, false);\n\t\tcheckBorderOutside(adjToDist,distToAdj);\n\t}",
            "method_tgt": "@Test\n\tpublic void transform_F32_fullView() {\n\t\tIntrinsicParameters param = new IntrinsicParameters().\n\t\t\t\tfsetK(300, 320, 0, 150, 130, width, height).fsetRadial(0.1, 0.05);\n\n\t\tPointTransform_F32 adjToDist = LensDistortionOps.transform_F32(AdjustmentType.FULL_VIEW, param, null, true);\n\t\tPointTransform_F32 distToAdj = LensDistortionOps.transform_F32(AdjustmentType.FULL_VIEW, param, null, false);\n\n\t\tcheckBorderOutside(adjToDist,distToAdj);\n\n\t\tparam = new IntrinsicParameters().\n\t\t\t\tfsetK(300, 320, 0, 150, 130, width, height).fsetRadial(-0.1,-0.05);\n\t\tadjToDist = LensDistortionOps.transform_F32(AdjustmentType.FULL_VIEW, param, null, true);\n\t\tdistToAdj = LensDistortionOps.transform_F32(AdjustmentType.FULL_VIEW, param, null, false);\n\t\tcheckBorderOutside(adjToDist,distToAdj);\n\t}"
        },
        "syn_diff": {
            "overall": 2,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 1,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 0,
        "comment": "Case study hard"
    },
    {
        "repo_name": "lessthanoptimal/BoofCV",
        "commit_id": "3032ec90ebdc393779956b7665e735cee7e13cad",
        "commit_url": "https://github.com/lessthanoptimal/BoofCV/commit/3032ec90ebdc393779956b7665e735cee7e13cad",
        "focal_db": {
            "id": "6028159",
            "rel_path": "main/geo/src/boofcv/alg/distort/LensDistortionOps.java",
            "method_src": "public static PointTransform_F32 allInside( IntrinsicParameters param,\n\t\t\t\t\t\t\t\t\t\t\t\tIntrinsicParameters paramAdj ,\n\t\t\t\t\t\t\t\t\t\t\t\tboolean adjToDistorted ) {\n\t\tPointTransform_F32 remove_p_to_p = distortTransform(param).undistort_F32(true, true);\n\n\t\tRectangleLength2D_F32 bound = LensDistortionOps.boundBoxInside(param.width, param.height,\n\t\t\t\tnew PointToPixelTransform_F32(remove_p_to_p));\n\n\t\t// ensure there are no strips of black\n\t\tLensDistortionOps.roundInside(bound);\n\n\t\tdouble scaleX = bound.width/param.width;\n\t\tdouble scaleY = bound.height/param.height;\n\n\t\tdouble scale = Math.min(scaleX, scaleY);\n\n\t\t// translation and shift over so that the small axis is in the middle\n\t\tdouble deltaX = bound.x0 + (scaleX-scale)*param.width/2.0;\n\t\tdouble deltaY = bound.y0 + (scaleY-scale)*param.height/2.0;\n\n\t\t// adjustment matrix\n\t\tDenseMatrix64F A = new DenseMatrix64F(3,3,true,scale,0,deltaX,0,scale,deltaY,0,0,1);\n\n\t\treturn adjustmentTransform(param, paramAdj, adjToDistorted, remove_p_to_p, A);\n\t}",
            "method_tgt": "public static PointTransform_F32 transform_F32(AdjustmentType type,\n\t\t\t\t\t\t\t\t\t\t\t\t   IntrinsicParameters param,\n\t\t\t\t\t\t\t\t\t\t\t\t   IntrinsicParameters paramAdj,\n\t\t\t\t\t\t\t\t\t\t\t\t   boolean adjToDistorted)\n\t{\n\t\tPointTransform_F32 remove_p_to_p = distortTransform(param).undistort_F32(true, true);\n\n\t\tRectangleLength2D_F32 bound;\n\t\tif( type == AdjustmentType.FULL_VIEW ) {\n\t\t\tbound = DistortImageOps.boundBox_F32(param.width, param.height,\n\t\t\t\t\tnew PointToPixelTransform_F32(remove_p_to_p));\n\t\t} else if( type == AdjustmentType.SHRINK) {\n\t\t\tbound = LensDistortionOps.boundBoxInside(param.width, param.height,\n\t\t\t\t\tnew PointToPixelTransform_F32(remove_p_to_p));\n\n\t\t\t// ensure there are no strips of black\n\t\t\tLensDistortionOps.roundInside(bound);\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException(\"Unsupported type \"+type);\n\t\t}\n\n\t\tdouble scaleX = bound.width/param.width;\n\t\tdouble scaleY = bound.height/param.height;\n\n\t\tdouble scale,deltaX,deltaY;\n\n\t\tif( type == AdjustmentType.FULL_VIEW ) {\n\t\t\tscale = Math.max(scaleX, scaleY);\n\t\t\tdeltaX = bound.x0;\n\t\t\tdeltaY = bound.y0;\n\t\t} else {\n\t\t\tscale = Math.min(scaleX, scaleY);\n\t\t\t// translation and shift over so that the small axis is in the middle\n\t\t\tdeltaX = bound.x0 + (scaleX-scale)*param.width/2.0;\n\t\t\tdeltaY = bound.y0 + (scaleY-scale)*param.height/2.0;\n\t\t}\n\n\t\t// adjustment matrix\n\t\tDenseMatrix64F A = new DenseMatrix64F(3,3,true,scale,0,deltaX,0,scale,deltaY,0,0,1);\n\n\t\treturn adjustmentTransform_F32(param, paramAdj, adjToDistorted, remove_p_to_p, A);\n\t}"
        },
        "test_db": {
            "id": "6028162",
            "rel_path": "main/geo/test/boofcv/alg/distort/TestLensDistortionOps.java",
            "method_src": "@Test\n\tpublic void allInside_Transform() {\n\t\tIntrinsicParameters param =\n\t\t\t\tnew IntrinsicParameters().fsetK(300, 320, 0, 150, 130, width, height).fsetRadial(0.1, 1e-4);\n\n\t\tPointTransform_F32 adjToDist = LensDistortionOps.allInside(param, null, true);\n\t\tPointTransform_F32 distToAdj = LensDistortionOps.allInside(param, null, false);\n\t\tcheckInside(adjToDist, distToAdj);\n\n\t\t// distort it in the other direction\n\t\tparam = new IntrinsicParameters().fsetK(300, 320, 0, 150, 130, width, height).fsetRadial(-0.1,-1e-4);\n\n\t\tadjToDist = LensDistortionOps.allInside(param, null, true);\n\t\tdistToAdj = LensDistortionOps.allInside(param, null, false);\n\n\t\tcheckInside(adjToDist, distToAdj);\n\t}",
            "method_tgt": "@Test\n\tpublic void transform_F32_shrink() {\n\t\tIntrinsicParameters param =\n\t\t\t\tnew IntrinsicParameters().fsetK(300, 320, 0, 150, 130, width, height).fsetRadial(0.1, 1e-4);\n\n\t\tPointTransform_F32 adjToDist = LensDistortionOps.transform_F32(AdjustmentType.SHRINK, param, null, true);\n\t\tPointTransform_F32 distToAdj = LensDistortionOps.transform_F32(AdjustmentType.SHRINK, param, null, false);\n\t\tcheckInside(adjToDist, distToAdj);\n\n\t\t// distort it in the other direction\n\t\tparam = new IntrinsicParameters().fsetK(300, 320, 0, 150, 130, width, height).fsetRadial(-0.1,-1e-4);\n\n\t\tadjToDist = LensDistortionOps.transform_F32(AdjustmentType.SHRINK, param, null, true);\n\t\tdistToAdj = LensDistortionOps.transform_F32(AdjustmentType.SHRINK, param, null, false);\n\n\t\tcheckInside(adjToDist, distToAdj);\n\t}"
        },
        "syn_diff": {
            "overall": 2,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 1,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 1,
        "comment": "Case study hard"
    },
    {
        "repo_name": "lessthanoptimal/BoofCV",
        "commit_id": "57a0b41ed9323721c705618f4b9703c19bb6caf5",
        "commit_url": "https://github.com/lessthanoptimal/BoofCV/commit/57a0b41ed9323721c705618f4b9703c19bb6caf5",
        "focal_db": {
            "id": "6025629",
            "rel_path": "main/feature/src/boofcv/alg/feature/detect/intensity/IntegralImageFeatureIntensity.java",
            "method_src": "public static void hessian( ImageFloat32 integral, int skip , int size ,\n\t\t\t\t\t\t\t\tImageFloat32 intensity)\n\t{\n\t\t// todo check size with skip\n//\t\tInputSanityCheck.checkSameShape(integral,intensity);\n\n\t\tImplIntegralImageFeatureIntensity.hessianBorder(integral,skip,size,intensity);\n\t\tImplIntegralImageFeatureIntensity.hessianInner(integral,skip,size,intensity);\n\t}",
            "method_tgt": "public static void hessian(GrayF32 integral, int skip , int size ,\n\t\t\t\t\t\t\t   GrayF32 intensity)\n\t{\n\t\t// todo check size with skip\n//\t\tInputSanityCheck.checkSameShape(integral,intensity);\n\n\t\tImplIntegralImageFeatureIntensity.hessianBorder(integral,skip,size,intensity);\n\t\tImplIntegralImageFeatureIntensity.hessianInner(integral,skip,size,intensity);\n\t}"
        },
        "test_db": {
            "id": "6025860",
            "rel_path": "main/feature/test/boofcv/alg/feature/detect/intensity/TestIntegralImageFeatureIntensity.java",
            "method_src": "@Test\n\tpublic void hessian_F32() {\n\t\tImageFloat32 original = new ImageFloat32(width,height);\n\t\tImageFloat32 integral = new ImageFloat32(width,height);\n\t\tImageFloat32 found = new ImageFloat32(width,height);\n\t\tImageFloat32 expected = new ImageFloat32(width,height);\n\n\t\tGImageMiscOps.fillUniform(original, rand, 0, 50);\n\t\tIntegralImageOps.transform(original,integral);\n\n\t\tint size = 9;\n\n\t\tfor( int skip = 1; skip <= 4; skip++ ) {\n\t\t\tfound.reshape(width/skip,height/skip);\n\t\t\texpected.reshape(width/skip,height/skip);\n\t\t\tImplIntegralImageFeatureIntensity.hessianNaive(integral,skip,size,expected);\n\t\t\tIntegralImageFeatureIntensity.hessian(integral,skip,size,found);\n\n\t\t\tBoofTesting.assertEquals(expected,found, 1e-4f);\n\t\t}\n\t}",
            "method_tgt": "@Test\n\tpublic void hessian_F32() {\n\t\tGrayF32 original = new GrayF32(width,height);\n\t\tGrayF32 integral = new GrayF32(width,height);\n\t\tGrayF32 found = new GrayF32(width,height);\n\t\tGrayF32 expected = new GrayF32(width,height);\n\n\t\tGImageMiscOps.fillUniform(original, rand, 0, 50);\n\t\tIntegralImageOps.transform(original,integral);\n\n\t\tint size = 9;\n\n\t\tfor( int skip = 1; skip <= 4; skip++ ) {\n\t\t\tfound.reshape(width/skip,height/skip);\n\t\t\texpected.reshape(width/skip,height/skip);\n\t\t\tImplIntegralImageFeatureIntensity.hessianNaive(integral,skip,size,expected);\n\t\t\tIntegralImageFeatureIntensity.hessian(integral,skip,size,found);\n\n\t\t\tBoofTesting.assertEquals(expected,found, 1e-4f);\n\t\t}\n\t}"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        }
    },
    {
        "repo_name": "lessthanoptimal/BoofCV",
        "commit_id": "5d782fc0b7a2bb2e1d33b20864b093fe1f34a376",
        "commit_url": "https://github.com/lessthanoptimal/BoofCV/commit/5d782fc0b7a2bb2e1d33b20864b093fe1f34a376",
        "focal_db": {
            "id": "6021183",
            "rel_path": "main/boofcv-recognition/src/main/java/boofcv/alg/fiducial/qrcode/ReidSolomonCodes.java",
            "method_src": "void findErrorLocatorBM( int syndromes[] , int length , GrowQueue_I8 errorLocator ) {\n\t\tGrowQueue_I8 C = errorLocator; // error polynomial\n\t\tGrowQueue_I8 B = new GrowQueue_I8();  // previous error polynomial\n\t\t// TODO remove new from this function\n\n\t\tinitToOne(C,length+1);\n\t\tinitToOne(B,length+1);\n\n\t\tGrowQueue_I8 tmp = new GrowQueue_I8(length);\n\n//\t\tint L = 0;\n//\t\tint m = 1; // stores how much B is 'shifted' by\n\t\tint b = 1;\n\n\t\tfor (int n = 0; n < length; n++) {\n\n\t\t\t// Compute discrepancy delta\n\t\t\tint delta = syndromes[n];\n\n\t\t\tfor (int j = 1; j < C.size; j++) {\n\t\t\t\tdelta ^= math.multiply(C.data[C.size-j-1]&0xFF, syndromes[n-j]);\n\t\t\t}\n\n\t\t\t// B = D^m * B\n\t\t\tB.data[B.size++] = 0;\n\n\t\t\t// Step 3 is implicitly handled\n\t\t\t// m = m + 1\n\n\t\t\tif( delta != 0 ) {\n\t\t\t\tint scale = math.multiply(delta, math.inverse(b));\n\t\t\t\tmath.polyAddScaleB(C, B, scale, tmp);\n\n\t\t\t\tif (2 * C.size > length) {\n\t\t\t\t\t// if 2*L > N ---- Step 4\n//\t\t\t\t\tm += 1;\n\t\t\t\t} else {\n\t\t\t\t\t// if 2*L <= N --- Step 5\n\t\t\t\t\tB.setTo(C);\n//\t\t\t\t\tL = n+1-L;\n\t\t\t\t\tb = delta;\n//\t\t\t\t\tm = 1;\n\t\t\t\t}\n\t\t\t\tC.setTo(tmp);\n\t\t\t}\n\t\t}\n\n\t\tremoveLeadingZeros(C);\n\t}",
            "method_tgt": "void findErrorLocatorPolynomialBM(int syndromes[] , int length , GrowQueue_I8 errorLocator ) {\n\t\tGrowQueue_I8 C = errorLocator; // error polynomial\n\t\tGrowQueue_I8 B = new GrowQueue_I8();  // previous error polynomial\n\t\t// TODO remove new from this function\n\n\t\tinitToOne(C,length+1);\n\t\tinitToOne(B,length+1);\n\n\t\tGrowQueue_I8 tmp = new GrowQueue_I8(length);\n\n//\t\tint L = 0;\n//\t\tint m = 1; // stores how much B is 'shifted' by\n\t\tint b = 1;\n\n\t\tfor (int n = 0; n < length; n++) {\n\n\t\t\t// Compute discrepancy delta\n\t\t\tint delta = syndromes[n];\n\n\t\t\tfor (int j = 1; j < C.size; j++) {\n\t\t\t\tdelta ^= math.multiply(C.data[C.size-j-1]&0xFF, syndromes[n-j]);\n\t\t\t}\n\n\t\t\t// B = D^m * B\n\t\t\tB.data[B.size++] = 0;\n\n\t\t\t// Step 3 is implicitly handled\n\t\t\t// m = m + 1\n\n\t\t\tif( delta != 0 ) {\n\t\t\t\tint scale = math.multiply(delta, math.inverse(b));\n\t\t\t\tmath.polyAddScaleB(C, B, scale, tmp);\n\n\t\t\t\tif (2 * C.size > length) {\n\t\t\t\t\t// if 2*L > N ---- Step 4\n//\t\t\t\t\tm += 1;\n\t\t\t\t} else {\n\t\t\t\t\t// if 2*L <= N --- Step 5\n\t\t\t\t\tB.setTo(C);\n//\t\t\t\t\tL = n+1-L;\n\t\t\t\t\tb = delta;\n//\t\t\t\t\tm = 1;\n\t\t\t\t}\n\t\t\t\tC.setTo(tmp);\n\t\t\t}\n\t\t}\n\n\t\tremoveLeadingZeros(C);\n\t}"
        },
        "test_db": {
            "id": "6021184",
            "rel_path": "main/boofcv-recognition/src/test/java/boofcv/alg/fiducial/qrcode/TestReidSolomonCodes.java",
            "method_src": "@Test\n\tpublic void findErrorLocatorBM() {\n\t\tGrowQueue_I8 message = GrowQueue_I8.parseHex(\n\t\t\t\t\"[ 0x40, 0xd2, 0x75, 0x47, 0x76, 0x17, 0x32, 0x06, 0x27, 0x26, 0x96, 0xc6, 0xc6, 0x96, 0x70, 0xec ]\");\n\t\tGrowQueue_I8 ecc = new GrowQueue_I8();\n\t\tint nsyn = 10;\n\t\tint syndromes[] = new int[nsyn];\n\n\t\tReidSolomonCodes alg = new ReidSolomonCodes(8,primitive8);\n\t\talg.generator(nsyn);\n\t\talg.computeECC(message,ecc);\n\n\t\tmessage.data[0] = 0;\n\t\talg.computeSyndromes(message,ecc,syndromes);\n\t\tGrowQueue_I8 errorLocator = new GrowQueue_I8();\n\t\talg.findErrorLocatorBM(syndromes,nsyn,errorLocator);\n\t\tassertEquals(2,errorLocator.size);\n\t\tassertEquals(3,errorLocator.get(0));\n\t\tassertEquals(1,errorLocator.get(1));\n\n\t\tmessage.data[6] = 10;\n\t\talg.computeSyndromes(message,ecc,syndromes);\n\t\talg.findErrorLocatorBM(syndromes,nsyn,errorLocator);\n\t\tassertEquals(3,errorLocator.size);\n\t\tassertEquals(238,errorLocator.get(0)&0xFF);\n\t\tassertEquals(89,errorLocator.get(1));\n\t\tassertEquals(1,errorLocator.get(2));\n\t}",
            "method_tgt": "@Test\n\tpublic void findErrorLocatorPolynomialBM() {\n\t\tGrowQueue_I8 message = GrowQueue_I8.parseHex(\n\t\t\t\t\"[ 0x40, 0xd2, 0x75, 0x47, 0x76, 0x17, 0x32, 0x06, 0x27, 0x26, 0x96, 0xc6, 0xc6, 0x96, 0x70, 0xec ]\");\n\t\tGrowQueue_I8 ecc = new GrowQueue_I8();\n\t\tint nsyn = 10;\n\t\tint syndromes[] = new int[nsyn];\n\n\t\tReidSolomonCodes alg = new ReidSolomonCodes(8,primitive8);\n\t\talg.generator(nsyn);\n\t\talg.computeECC(message,ecc);\n\n\t\tmessage.data[0] = 0;\n\t\talg.computeSyndromes(message,ecc,syndromes);\n\t\tGrowQueue_I8 errorLocator = new GrowQueue_I8();\n\t\talg.findErrorLocatorPolynomialBM(syndromes,nsyn,errorLocator);\n\t\tassertEquals(2,errorLocator.size);\n\t\tassertEquals(3,errorLocator.get(0));\n\t\tassertEquals(1,errorLocator.get(1));\n\n\t\tmessage.data[6] = 10;\n\t\talg.computeSyndromes(message,ecc,syndromes);\n\t\talg.findErrorLocatorPolynomialBM(syndromes,nsyn,errorLocator);\n\t\tassertEquals(3,errorLocator.size);\n\t\tassertEquals(238,errorLocator.get(0)&0xFF);\n\t\tassertEquals(89,errorLocator.get(1));\n\t\tassertEquals(1,errorLocator.get(2));\n\t}"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 1,
            "param_types": 0,
            "throw_types": 0
        }
    },
    {
        "repo_name": "lessthanoptimal/BoofCV",
        "commit_id": "57a0b41ed9323721c705618f4b9703c19bb6caf5",
        "commit_url": "https://github.com/lessthanoptimal/BoofCV/commit/57a0b41ed9323721c705618f4b9703c19bb6caf5",
        "focal_db": {
            "id": "6026882",
            "rel_path": "main/ip/src/boofcv/factory/transform/pyramid/FactoryPyramid.java",
            "method_src": "public static <T extends ImageSingleBand>\n\tPyramidFloat<T> scaleSpace( double scaleSpace[], Class<T> imageType ) {\n\n\t\tdouble[] scaleFactors = new double[ scaleSpace.length ];\n\n\t\tfor( int i = 0; i < scaleSpace.length; i++ ) {\n\t\t\tscaleFactors[i] = 1;\n\t\t}\n\n\t\t// find the amount of blue that it needs to apply at each layer\n\t\tdouble[] sigmas = new double[ scaleSpace.length ];\n\n\t\tsigmas[0] = scaleSpace[0];\n\t\tfor( int i = 1; i < scaleSpace.length; i++ ) {\n\t\t\t// the desired amount of blur\n\t\t\tdouble c = scaleSpace[i];\n\t\t\t// the effective amount of blur applied to the last level\n\t\t\tdouble b = scaleSpace[i-1];\n\t\t\t// the amount of additional blur which is needed\n\t\t\tsigmas[i] = Math.sqrt(c*c-b*b);\n\t\t}\n\n\t\treturn floatGaussian(scaleFactors,sigmas,imageType);\n\t}",
            "method_tgt": "public static <T extends ImageGray>\n\tPyramidFloat<T> scaleSpace( double scaleSpace[], Class<T> imageType ) {\n\n\t\tdouble[] scaleFactors = new double[ scaleSpace.length ];\n\n\t\tfor( int i = 0; i < scaleSpace.length; i++ ) {\n\t\t\tscaleFactors[i] = 1;\n\t\t}\n\n\t\t// find the amount of blue that it needs to apply at each layer\n\t\tdouble[] sigmas = new double[ scaleSpace.length ];\n\n\t\tsigmas[0] = scaleSpace[0];\n\t\tfor( int i = 1; i < scaleSpace.length; i++ ) {\n\t\t\t// the desired amount of blur\n\t\t\tdouble c = scaleSpace[i];\n\t\t\t// the effective amount of blur applied to the last level\n\t\t\tdouble b = scaleSpace[i-1];\n\t\t\t// the amount of additional blur which is needed\n\t\t\tsigmas[i] = Math.sqrt(c*c-b*b);\n\t\t}\n\n\t\treturn floatGaussian(scaleFactors,sigmas,imageType);\n\t}"
        },
        "test_db": {
            "id": "6026982",
            "rel_path": "main/ip/test/boofcv/factory/transform/pyramid/TestFactoryPyramid.java",
            "method_src": "@Test\n\tpublic void scaleSpace() {\n\t\tdouble ss[] = new double[]{1,2,4,6,8,10};\n\n\t\tPyramidFloat<ImageFloat32> pyramid = FactoryPyramid.scaleSpacePyramid(ss, ImageFloat32.class);\n\n\t\tfor( int i = 0; i < ss.length; i++ ) {\n\t\t\tassertEquals(ss[i],pyramid.getSigma(i),1e-8);\n\t\t\tassertEquals(ss[i],pyramid.getScale(i),1e-8);\n\t\t\t// the amount of blur applied to the previous layer should be different\n\t\t\tif( i > 1)\n\t\t\t\tassertTrue(Math.abs(ss[i] - ((PyramidFloatGaussianScale)pyramid).getSigmaLayers()[i])>0.1);\n\t\t}\n\t}",
            "method_tgt": "@Test\n\tpublic void scaleSpace() {\n\t\tdouble ss[] = new double[]{1,2,4,6,8,10};\n\n\t\tPyramidFloat<GrayF32> pyramid = FactoryPyramid.scaleSpacePyramid(ss, GrayF32.class);\n\n\t\tfor( int i = 0; i < ss.length; i++ ) {\n\t\t\tassertEquals(ss[i],pyramid.getSigma(i),1e-8);\n\t\t\tassertEquals(ss[i],pyramid.getScale(i),1e-8);\n\t\t\t// the amount of blur applied to the previous layer should be different\n\t\t\tif( i > 1)\n\t\t\t\tassertTrue(Math.abs(ss[i] - ((PyramidFloatGaussianScale)pyramid).getSigmaLayers()[i])>0.1);\n\t\t}\n\t}"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 1,
            "type": 0,
            "name": 0,
            "param_types": 0,
            "throw_types": 0
        },
        "comment": "[Hard] Param class is determined in runtime"
    },
    {
        "repo_name": "linkedin/ambry",
        "commit_id": "1dd3a5f3b325fc42b9b282d906211422cfe8b3e2",
        "commit_url": "https://github.com/linkedin/ambry/commit/1dd3a5f3b325fc42b9b282d906211422cfe8b3e2",
        "focal_db": {
            "id": "2632730",
            "rel_path": "ambry-tools/src/main/java/com.github.ambry/store/StoreCopier.java",
            "method_src": "public Pair<FindToken, Boolean> copy(FindToken startToken) throws IOException, StoreException {\n    boolean sourceHasProblems = false;\n    FindToken lastToken;\n    FindToken token = startToken;\n    do {\n      lastToken = token;\n      FindInfo findInfo = src.findEntriesSince(lastToken, fetchSizeInBytes);\n      List<MessageInfo> messageInfos = findInfo.getMessageEntries();\n      for (MessageInfo messageInfo : messageInfos) {\n        logger.trace(\"Processing {} - isDeleted: {}, isExpired {}\", messageInfo.getStoreKey(), messageInfo.isDeleted(),\n            messageInfo.isExpired());\n        if (!messageInfo.isExpired() && !messageInfo.isDeleted()) {\n          if (messageInfo.getSize() > Integer.MAX_VALUE) {\n            throw new IllegalStateException(\"Cannot copy blobs whose size > Integer.MAX_VALUE\");\n          }\n          if (tgt.findMissingKeys(Collections.singletonList(messageInfo.getStoreKey())).size() == 1) {\n            int size = (int) messageInfo.getSize();\n            StoreInfo storeInfo =\n                src.get(Collections.singletonList(messageInfo.getStoreKey()), EnumSet.allOf(StoreGetOptions.class));\n            MessageReadSet readSet = storeInfo.getMessageReadSet();\n            byte[] buf = new byte[size];\n            readSet.writeTo(0, new ByteBufferChannel(ByteBuffer.wrap(buf)), 0, size);\n            Message message = new Message(messageInfo, new ByteArrayInputStream(buf));\n            for (Transformer transformer : transformers) {\n              message = transformer.transform(message);\n            }\n            MessageFormatWriteSet writeSet =\n                new MessageFormatWriteSet(message.getStream(), Collections.singletonList(message.getMessageInfo()),\n                    false);\n            tgt.put(writeSet);\n            logger.trace(\"Copied {} as {}\", messageInfo.getStoreKey(), message.getMessageInfo().getStoreKey());\n          } else {\n            logger.warn(\"Found a duplicate entry for {} while copying data\", messageInfo.getStoreKey());\n            sourceHasProblems = true;\n          }\n        }\n      }\n      token = findInfo.getFindToken();\n      logger.info(\"[{}] [{}] {}% copied\", Thread.currentThread().getName(), storeId,\n          df.format(token.getBytesRead() * 100.0 / src.getSizeInBytes()));\n    } while (!token.equals(lastToken));\n    return new Pair<>(token, sourceHasProblems);\n  }",
            "method_tgt": "public Pair<FindToken, Boolean> copy(FindToken startToken) throws Exception {\n    boolean sourceHasProblems = false;\n    FindToken lastToken;\n    FindToken token = startToken;\n    do {\n      lastToken = token;\n      FindInfo findInfo = src.findEntriesSince(lastToken, fetchSizeInBytes);\n      List<MessageInfo> messageInfos = findInfo.getMessageEntries();\n      for (MessageInfo messageInfo : messageInfos) {\n        logger.trace(\"Processing {} - isDeleted: {}, isExpired {}\", messageInfo.getStoreKey(), messageInfo.isDeleted(),\n            messageInfo.isExpired());\n        if (!messageInfo.isExpired() && !messageInfo.isDeleted()) {\n          if (messageInfo.getSize() > Integer.MAX_VALUE) {\n            throw new IllegalStateException(\"Cannot copy blobs whose size > Integer.MAX_VALUE\");\n          }\n          if (tgt.findMissingKeys(Collections.singletonList(messageInfo.getStoreKey())).size() == 1) {\n            int size = (int) messageInfo.getSize();\n            StoreInfo storeInfo =\n                src.get(Collections.singletonList(messageInfo.getStoreKey()), EnumSet.allOf(StoreGetOptions.class));\n            MessageReadSet readSet = storeInfo.getMessageReadSet();\n            byte[] buf = new byte[size];\n            readSet.writeTo(0, new ByteBufferChannel(ByteBuffer.wrap(buf)), 0, size);\n            Message message = new Message(messageInfo, new ByteArrayInputStream(buf));\n            for (Transformer transformer : transformers) {\n              message = transformer.transform(message);\n            }\n            MessageFormatWriteSet writeSet =\n                new MessageFormatWriteSet(message.getStream(), Collections.singletonList(message.getMessageInfo()),\n                    false);\n            tgt.put(writeSet);\n            logger.trace(\"Copied {} as {}\", messageInfo.getStoreKey(), message.getMessageInfo().getStoreKey());\n          } else {\n            logger.warn(\"Found a duplicate entry for {} while copying data\", messageInfo.getStoreKey());\n            sourceHasProblems = true;\n          }\n        }\n      }\n      token = findInfo.getFindToken();\n      logger.info(\"[{}] [{}] {}% copied\", Thread.currentThread().getName(), storeId,\n          df.format(token.getBytesRead() * 100.0 / src.getSizeInBytes()));\n    } while (!token.equals(lastToken));\n    return new Pair<>(token, sourceHasProblems);\n  }"
        },
        "test_db": {
            "id": "2632731",
            "rel_path": "ambry-tools/src/test/java/com.github.ambry/store/StoreCopierTest.java",
            "method_src": "@Test\n  public void copyTest() throws IOException, StoreException {\n    storeCopier.copy(new StoreFindTokenFactory(STORE_KEY_FACTORY).getNewFindToken());\n    storeCopier.close();\n    // copy the store descriptor file over\n    StoreMetrics storeMetrics = new StoreMetrics(new MetricRegistry());\n    Files.copy(new File(srcDir, StoreDescriptor.STORE_DESCRIPTOR_FILENAME).toPath(),\n        new File(tgtDir, StoreDescriptor.STORE_DESCRIPTOR_FILENAME).toPath(), StandardCopyOption.REPLACE_EXISTING);\n    BlobStore tgt =\n        new BlobStore(STORE_ID, storeConfig, null, null, DISK_IO_SCHEDULER, StoreTestUtils.DEFAULT_DISK_SPACE_ALLOCATOR,\n            storeMetrics, storeMetrics, tgtDir.getAbsolutePath(), STORE_CAPACITY, STORE_KEY_FACTORY, null, null, time);\n    tgt.start();\n    try {\n      // should not be able to get expired or deleted ids\n      StoreKey[] failKeys = {expiredId, deletedId};\n      for (StoreKey key : failKeys) {\n        try {\n          tgt.get(Collections.singletonList(key), EnumSet.allOf(StoreGetOptions.class));\n          fail(\"Should have failed to get \" + key);\n        } catch (StoreException e) {\n          assertEquals(\"Unexpected StoreErrorCode\", StoreErrorCodes.ID_Not_Found, e.getErrorCode());\n        }\n      }\n      // should be able to get the put id\n      StoreInfo storeInfo = tgt.get(Collections.singletonList(putId), EnumSet.noneOf(StoreGetOptions.class));\n      MessageInfo messageInfo = storeInfo.getMessageReadSetInfo().get(0);\n      assertEquals(\"Size does not match\", putData.length, messageInfo.getSize());\n      assertEquals(\"Size does not match\", putData.length, storeInfo.getMessageReadSet().sizeInBytes(0));\n      assertFalse(\"Should not be deleted or expired\", messageInfo.isDeleted() || messageInfo.isExpired());\n      ByteBufferChannel channel = new ByteBufferChannel(ByteBuffer.allocate(putData.length));\n      storeInfo.getMessageReadSet().writeTo(0, channel, 0, putData.length);\n      assertArrayEquals(\"Data put does not match data copied\", putData, channel.getBuffer().array());\n    } finally {\n      tgt.shutdown();\n    }\n  }",
            "method_tgt": "@Test\n  public void copyTest() throws Exception {\n    storeCopier.copy(new StoreFindTokenFactory(STORE_KEY_FACTORY).getNewFindToken());\n    storeCopier.close();\n    // copy the store descriptor file over\n    StoreMetrics storeMetrics = new StoreMetrics(new MetricRegistry());\n    Files.copy(new File(srcDir, StoreDescriptor.STORE_DESCRIPTOR_FILENAME).toPath(),\n        new File(tgtDir, StoreDescriptor.STORE_DESCRIPTOR_FILENAME).toPath(), StandardCopyOption.REPLACE_EXISTING);\n    BlobStore tgt =\n        new BlobStore(STORE_ID, storeConfig, null, null, DISK_IO_SCHEDULER, StoreTestUtils.DEFAULT_DISK_SPACE_ALLOCATOR,\n            storeMetrics, storeMetrics, tgtDir.getAbsolutePath(), STORE_CAPACITY, STORE_KEY_FACTORY, null, null, time);\n    tgt.start();\n    try {\n      // should not be able to get expired or deleted ids\n      StoreKey[] failKeys = {expiredId, deletedId};\n      for (StoreKey key : failKeys) {\n        try {\n          tgt.get(Collections.singletonList(key), EnumSet.allOf(StoreGetOptions.class));\n          fail(\"Should have failed to get \" + key);\n        } catch (StoreException e) {\n          assertEquals(\"Unexpected StoreErrorCode\", StoreErrorCodes.ID_Not_Found, e.getErrorCode());\n        }\n      }\n      // should be able to get the put id\n      StoreInfo storeInfo = tgt.get(Collections.singletonList(putId), EnumSet.noneOf(StoreGetOptions.class));\n      MessageInfo messageInfo = storeInfo.getMessageReadSetInfo().get(0);\n      assertEquals(\"Size does not match\", putData.length, messageInfo.getSize());\n      assertEquals(\"Size does not match\", putData.length, storeInfo.getMessageReadSet().sizeInBytes(0));\n      assertFalse(\"Should not be deleted or expired\", messageInfo.isDeleted() || messageInfo.isExpired());\n      ByteBufferChannel channel = new ByteBufferChannel(ByteBuffer.allocate(putData.length));\n      storeInfo.getMessageReadSet().writeTo(0, channel, 0, putData.length);\n      assertArrayEquals(\"Data put does not match data copied\", putData, channel.getBuffer().array());\n    } finally {\n      tgt.shutdown();\n    }\n  }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 0,
            "throw_types": 1
        }
    },
    {
        "repo_name": "linkedin/ambry",
        "commit_id": "308ba5772c6069e419a398ab703fae885be27a72",
        "commit_url": "https://github.com/linkedin/ambry/commit/308ba5772c6069e419a398ab703fae885be27a72",
        "focal_db": {
            "id": "2628825",
            "rel_path": "ambry-network/src/main/java/com.github.ambry.network/ConnectionTracker.java",
            "method_src": "int replenishConnections(ConnectionFactory connectionFactory) {\n    int connectionsInitiated = 0;\n    Iterator<HostPortPoolManager> iter = poolManagersBelowMinActiveConnections.iterator();\n    while (iter.hasNext()) {\n      HostPortPoolManager poolManager = iter.next();\n      try {\n        // avoid continuously attempting to connect to down nodes.\n        if (poolManager.dataNodeId.getState() == HardwareState.AVAILABLE) {\n          while (!poolManager.hasMinActiveConnections()) {\n            String connId = connectionFactory.connect(poolManager.host, poolManager.port);\n            poolManager.incrementPoolCount();\n            connectionIdToPoolManager.put(connId, poolManager);\n            totalManagedConnectionsCount++;\n            connectionsInitiated++;\n          }\n          iter.remove();\n        }\n      } catch (IOException e) {\n        LOGGER.warn(\"Encountered exception while replenishing connections to {}:{}.\", poolManager.host,\n            poolManager.port.getPort(), e);\n      }\n    }\n    return connectionsInitiated;\n  }",
            "method_tgt": "int replenishConnections(ConnectionFactory connectionFactory, int maxNewConnectionsPerHost) {\n    int newConnections = 0;\n    Iterator<HostPortPoolManager> iter = poolManagersBelowMinActiveConnections.iterator();\n    while (iter.hasNext()) {\n      HostPortPoolManager poolManager = iter.next();\n      try {\n        // avoid continuously attempting to connect to down nodes.\n        if (poolManager.dataNodeId.getState() == HardwareState.AVAILABLE) {\n          int newConnectionsToHost = 0;\n          while (newConnectionsToHost < maxNewConnectionsPerHost && !poolManager.hasMinActiveConnections()) {\n            String connId = connectionFactory.connect(poolManager.host, poolManager.port);\n            poolManager.incrementPoolCount();\n            connectionIdToPoolManager.put(connId, poolManager);\n            totalManagedConnectionsCount++;\n            newConnections++;\n            newConnectionsToHost++;\n          }\n          if (poolManager.hasMinActiveConnections()) {\n            iter.remove();\n          }\n        }\n      } catch (IOException e) {\n        LOGGER.warn(\"Encountered exception while replenishing connections to {}:{}.\", poolManager.host,\n            poolManager.port.getPort(), e);\n      }\n    }\n    return newConnections;\n  }"
        },
        "test_db": {
            "id": "2628830",
            "rel_path": "ambry-network/src/test/java/com.github.ambry.network/ConnectionTrackerTest.java",
            "method_src": "@Test\n  public void testReplenishConnections() {\n    connectionTracker = new ConnectionTracker(routerConfig.routerScalingUnitMaxConnectionsPerPortPlainText,\n        routerConfig.routerScalingUnitMaxConnectionsPerPortSsl);\n    // When no connections were ever made to a host:port, connectionTracker should return null, but\n    // initiate connections.\n    int minActiveConnectionsCount = 0;\n    int totalConnectionsCount = 0;\n    int availableCount = 0;\n\n    MockDataNodeId dataNodeId1 =\n        new MockDataNodeId(\"host1\", Collections.singletonList(plainTextPort), Collections.emptyList(), \"DC1\");\n    MockDataNodeId dataNodeId2 =\n        new MockDataNodeId(\"host2\", Arrays.asList(plainTextPort, sslPort), Collections.emptyList(), \"DC1\");\n    dataNodeId2.setSslEnabledDataCenters(Collections.singletonList(\"DC1\"));\n    connectionTracker.setMinimumActiveConnectionsPercentage(dataNodeId1, 50);\n    minActiveConnectionsCount += 50 * routerConfig.routerScalingUnitMaxConnectionsPerPortPlainText / 100;\n    connectionTracker.setMinimumActiveConnectionsPercentage(dataNodeId2, 200);\n    minActiveConnectionsCount += routerConfig.routerScalingUnitMaxConnectionsPerPortSsl;\n\n    // call replenishConnections to warm up connections\n    assertCounts(totalConnectionsCount, availableCount);\n    connectionTracker.replenishConnections(this::mockNewConnection);\n    totalConnectionsCount += minActiveConnectionsCount;\n    assertCounts(totalConnectionsCount, availableCount);\n    List<String> newConnections = getNewlyEstablishedConnections();\n    newConnections.forEach(connectionTracker::checkInConnection);\n    availableCount += minActiveConnectionsCount;\n    assertCounts(totalConnectionsCount, availableCount);\n    Assert.assertTrue(connectionTracker.mayCreateNewConnection(\"host1\", plainTextPort, dataNodeId1));\n    Assert.assertFalse(connectionTracker.mayCreateNewConnection(\"host2\", sslPort, dataNodeId2));\n\n    // remove 2 connections\n    newConnections.stream().limit(2).forEach(connectionTracker::removeConnection);\n    totalConnectionsCount -= 2;\n    availableCount -= 2;\n    assertCounts(totalConnectionsCount, availableCount);\n\n    // replenish connections again\n    connectionTracker.replenishConnections(this::mockNewConnection);\n    totalConnectionsCount += 2;\n    assertCounts(totalConnectionsCount, availableCount);\n    newConnections = getNewlyEstablishedConnections();\n    newConnections.forEach(connectionTracker::checkInConnection);\n    availableCount += 2;\n    assertCounts(totalConnectionsCount, availableCount);\n\n    // check out connections\n    String conn1 = connectionTracker.checkOutConnection(\"host1\", plainTextPort, dataNodeId1);\n    Assert.assertNotNull(conn1);\n    String conn2 = connectionTracker.checkOutConnection(\"host2\", sslPort, dataNodeId2);\n    Assert.assertNotNull(conn2);\n    availableCount -= 2;\n    assertCounts(totalConnectionsCount, availableCount);\n\n    // destroy one and return the other and then replenish\n    connectionTracker.removeConnection(conn1);\n    connectionTracker.checkInConnection(conn2);\n    totalConnectionsCount -= 1;\n    availableCount += 1;\n    assertCounts(totalConnectionsCount, availableCount);\n    connectionTracker.replenishConnections(this::mockNewConnection);\n    totalConnectionsCount += 1;\n    assertCounts(totalConnectionsCount, availableCount);\n  }",
            "method_tgt": "@Test\n  public void testReplenishConnections() {\n    connectionTracker = new ConnectionTracker(routerConfig.routerScalingUnitMaxConnectionsPerPortPlainText,\n        routerConfig.routerScalingUnitMaxConnectionsPerPortSsl);\n    // When no connections were ever made to a host:port, connectionTracker should return null, but\n    // initiate connections.\n    int minActiveConnectionsCount = 0;\n    int totalConnectionsCount = 0;\n    int availableCount = 0;\n\n    MockDataNodeId dataNodeId1 =\n        new MockDataNodeId(\"host1\", Collections.singletonList(plainTextPort), Collections.emptyList(), \"DC1\");\n    MockDataNodeId dataNodeId2 =\n        new MockDataNodeId(\"host2\", Arrays.asList(plainTextPort, sslPort), Collections.emptyList(), \"DC1\");\n    dataNodeId2.setSslEnabledDataCenters(Collections.singletonList(\"DC1\"));\n    connectionTracker.setMinimumActiveConnectionsPercentage(dataNodeId1, 50);\n    minActiveConnectionsCount += 50 * routerConfig.routerScalingUnitMaxConnectionsPerPortPlainText / 100;\n    connectionTracker.setMinimumActiveConnectionsPercentage(dataNodeId2, 200);\n    minActiveConnectionsCount += routerConfig.routerScalingUnitMaxConnectionsPerPortSsl;\n\n    // call replenishConnections to warm up connections\n    assertCounts(totalConnectionsCount, availableCount);\n    connectionTracker.replenishConnections(this::mockNewConnection, Integer.MAX_VALUE);\n    totalConnectionsCount += minActiveConnectionsCount;\n    assertCounts(totalConnectionsCount, availableCount);\n    List<String> newConnections = getNewlyEstablishedConnections();\n    newConnections.forEach(connectionTracker::checkInConnection);\n    availableCount += minActiveConnectionsCount;\n    assertCounts(totalConnectionsCount, availableCount);\n    Assert.assertTrue(connectionTracker.mayCreateNewConnection(\"host1\", plainTextPort, dataNodeId1));\n    Assert.assertFalse(connectionTracker.mayCreateNewConnection(\"host2\", sslPort, dataNodeId2));\n\n    // remove 2 connections\n    newConnections.stream().limit(2).forEach(connectionTracker::removeConnection);\n    totalConnectionsCount -= 2;\n    availableCount -= 2;\n    assertCounts(totalConnectionsCount, availableCount);\n\n    // replenish connections again\n    connectionTracker.replenishConnections(this::mockNewConnection, Integer.MAX_VALUE);\n    totalConnectionsCount += 2;\n    assertCounts(totalConnectionsCount, availableCount);\n    newConnections = getNewlyEstablishedConnections();\n    newConnections.forEach(connectionTracker::checkInConnection);\n    availableCount += 2;\n    assertCounts(totalConnectionsCount, availableCount);\n\n    // check out connections\n    String conn1 = connectionTracker.checkOutConnection(\"host1\", plainTextPort, dataNodeId1);\n    Assert.assertNotNull(conn1);\n    String conn2 = connectionTracker.checkOutConnection(\"host2\", sslPort, dataNodeId2);\n    Assert.assertNotNull(conn2);\n    availableCount -= 2;\n    assertCounts(totalConnectionsCount, availableCount);\n\n    // destroy one and return the other and then replenish\n    connectionTracker.removeConnection(conn1);\n    connectionTracker.checkInConnection(conn2);\n    totalConnectionsCount -= 1;\n    availableCount += 1;\n    assertCounts(totalConnectionsCount, availableCount);\n    connectionTracker.replenishConnections(this::mockNewConnection, Integer.MAX_VALUE);\n    totalConnectionsCount += 1;\n    assertCounts(totalConnectionsCount, availableCount);\n\n    // check out and destroy all host2 connections\n    String connId;\n    while ((connId = connectionTracker.checkOutConnection(\"host2\", sslPort, dataNodeId2)) != null) {\n      connectionTracker.removeConnection(connId);\n    }\n    totalConnectionsCount -= 2;\n    availableCount -= 2;\n    assertCounts(totalConnectionsCount, availableCount);\n\n    // Replenish connection with rate limit of 1 connection per host per call.\n    connectionTracker.replenishConnections(this::mockNewConnection, 1);\n    totalConnectionsCount += 1;\n    assertCounts(totalConnectionsCount, availableCount);\n    connectionTracker.replenishConnections(this::mockNewConnection, 1);\n    totalConnectionsCount += 1;\n    assertCounts(totalConnectionsCount, availableCount);\n  }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        },
        "comment": "New assertions are added."
    },
    {
        "repo_name": "mulesoft/mule",
        "commit_id": "9758359884b63e430a112565a7649596e6a26abb",
        "commit_url": "https://github.com/mulesoft/mule/commit/9758359884b63e430a112565a7649596e6a26abb",
        "focal_db": {
            "id": "6206207",
            "rel_path": "modules/reboot/src/main/java/org/mule/module/reboot/MuleContainerBootstrapUtils.java",
            "method_src": "public static File getMuleHomeFile()\n    {\n        return isStandalone() ? new File(MULE_HOME) : null;\n    }",
            "method_tgt": "public static File getMuleHome()\n    {\n        return isStandalone() ? new File(MULE_HOME) : null;\n    }"
        },
        "test_db": {
            "id": "6206209",
            "rel_path": "modules/reboot/src/test/java/org/mule/module/reboot/MuleContainerBootstrapUtilsTestCase.java",
            "method_src": "@Test\n    public void testGetMuleHomeFile()\n    {\n        File muleHome = MuleContainerBootstrapUtils.getMuleHomeFile();\n        assertNotNull(muleHome.getAbsolutePath());\n    }",
            "method_tgt": "@Test\n    public void testGetMuleHomeFile()\n    {\n        File muleHome = MuleContainerBootstrapUtils.getMuleHome();\n        assertNotNull(muleHome.getAbsolutePath());\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 1,
            "param_types": 0,
            "throw_types": 0
        }
    },
    {
        "repo_name": "naver/ngrinder",
        "commit_id": "3607e43c1516ec45c26dd9a56349a9f9a500e394",
        "commit_url": "https://github.com/naver/ngrinder/commit/3607e43c1516ec45c26dd9a56349a9f9a500e394",
        "focal_db": {
            "id": "2808689",
            "rel_path": "ngrinder-controller/src/main/java/org/ngrinder/user/controller/UserController.java",
            "method_src": "@RequestMapping(\"/save\")\n\t@PreAuthorize(\"hasAnyRole('A') or #user.id == #updatedUser.id\")\n\tpublic String saveOrUpdateUserDetail(User user, ModelMap model, @ModelAttribute(\"user\") User updatedUser,\n\t                                     @RequestParam(required = false) String followersStr) {\n\t\tcheckArgument(updatedUser.validate());\n\t\tif (user.getRole() == Role.USER) {\n\t\t\t// General user can not change their role.\n\t\t\tUser updatedUserInDb = userService.getUserById(updatedUser.getUserId());\n\t\t\tcheckNotNull(updatedUserInDb);\n\t\t\tupdatedUser.setRole(updatedUserInDb.getRole());\n\n\t\t\t// prevent user to modify with other user id\n\t\t\tcheckArgument(updatedUserInDb.getId().equals(updatedUser.getId()), \"Illegal request to update user:%s\",\n\t\t\t\t\tupdatedUser);\n\t\t}\n\t\tif (updatedUser.exist()) {\n\t\t\tuserService.saveUser(updatedUser, followersStr);\n\t\t} else {\n\t\t\tuserService.saveUser(updatedUser);\n\t\t}\n\t\tmodel.clear();\n\t\tif (user.getId().equals(updatedUser.getId())) {\n\t\t\treturn \"redirect:/\";\n\t\t} else {\n\t\t\treturn \"redirect:/user/\";\n\t\t}\n\t}",
            "method_tgt": "@RequestMapping(\"/save\")\n\t@PreAuthorize(\"hasAnyRole('A') or #user.id == #updatedUser.id\")\n\tpublic String saveUser(User user, ModelMap model, @ModelAttribute(\"user\") User updatedUser) {\n\t\tcheckArgument(updatedUser.validate());\n\t\tif (user.getRole() == Role.USER) {\n\t\t\t// General user can not change their role.\n\t\t\tUser updatedUserInDb = userService.getUserById(updatedUser.getUserId());\n\t\t\tcheckNotNull(updatedUserInDb);\n\t\t\tupdatedUser.setRole(updatedUserInDb.getRole());\n\n\t\t\t// prevent user to modify with other user id\n\t\t\tcheckArgument(updatedUserInDb.getId().equals(updatedUser.getId()), \"Illegal request to update user:%s\",\n\t\t\t\t\tupdatedUser);\n\t\t}\n\t\tsaveUser(updatedUser);\n\t\tmodel.clear();\n\t\tif (user.getId().equals(updatedUser.getId())) {\n\t\t\treturn \"redirect:/\";\n\t\t} else {\n\t\t\treturn \"redirect:/user/\";\n\t\t}\n\t}"
        },
        "test_db": {
            "id": "2808697",
            "rel_path": "ngrinder-controller/src/test/java/org/ngrinder/user/controller/UserControllerTest.java",
            "method_src": "@Test\n\tpublic void testSaveOrUpdateUserDetail() {\n\t\t// test update\n\t\tModelMap model = new ModelMap();\n\t\tUser currUser = getTestUser();\n\t\tcurrUser.setUserName(\"new name\");\n\t\tuserController.saveOrUpdateUserDetail(currUser, model, currUser, null);\n\t\tuserController.getUserDetail(getTestUser(), model, currUser.getUserId());\n\t\tUser user = (User) model.get(\"user\");\n\t\tassertThat(user.getUserName(), is(\"new name\"));\n\t\tassertThat(user.getPassword(), is(currUser.getPassword()));\n\n\t\tUser admin = getAdminUser();\n\t\tUser temp = new User(\"temp1\", \"temp1\", \"temp1\", \"temp@nhn.com\", Role.USER);\n\t\tuserController.saveOrUpdateUserDetail(admin, model, temp, null);\n\t\ttemp = new User(\"temp2\", \"temp2\", \"temp2\", \"temp@nhn.com\", Role.USER);\n\t\tuserController.saveOrUpdateUserDetail(admin, model, temp, null);\n\t\tmodel.clear();\n\t\tuserController.saveOrUpdateUserDetail(currUser, model, currUser, \"temp1, temp2\");\n\t\tuserController.getUserDetail(getTestUser(), model, currUser.getUserId());\n\t\tuser = (User) model.get(\"user\");\n\t\tassertThat(user.getFollowers().size(), is(2));\n\t\tassertThat(user.getFollowers().get(0).getUserId(), is(\"temp1\"));\n\t}",
            "method_tgt": "@Test\n\tpublic void testSaveOrUpdateUserDetail() {\n\t\t// test update\n\t\tModelMap model = new ModelMap();\n\t\tUser currUser = getTestUser();\n\t\tcurrUser.setUserName(\"new name\");\n\t\tuserController.saveUser(currUser, model, currUser);\n\t\tuserController.getUserDetail(getTestUser(), model, currUser.getUserId());\n\t\tUser user = (User) model.get(\"user\");\n\t\tassertThat(user.getUserName(), is(\"new name\"));\n\t\tassertThat(user.getPassword(), is(currUser.getPassword()));\n\n\t\tUser admin = getAdminUser();\n\t\tUser temp = new User(\"temp1\", \"temp1\", \"temp1\", \"temp@nhn.com\", Role.USER);\n\t\tuserController.saveUser(admin, model, temp);\n\t\ttemp = new User(\"temp2\", \"temp2\", \"temp2\", \"temp@nhn.com\", Role.USER);\n\t\tuserController.saveUser(admin, model, temp);\n\t\tmodel.clear();\n\t\tcurrUser.setFollowersStr(\"temp1, temp2\");\n\t\tuserController.saveUser(currUser, model, currUser);\n\t\tuserController.getUserDetail(getTestUser(), model, currUser.getUserId());\n\t\tuser = (User) model.get(\"user\");\n\t\tassertThat(user.getFollowers().size(), is(2));\n\t\tassertThat(user.getFollowers().get(0).getUserId(), is(\"temp1\"));\n\t}"
        },
        "syn_diff": {
            "overall": 2,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 1,
            "param_types": 1,
            "throw_types": 0
        }
    },
    {
        "repo_name": "naver/pinpoint",
        "commit_id": "75a9e5c2b78b8e7396b3855c9d3244762b734399",
        "commit_url": "https://github.com/naver/pinpoint/commit/75a9e5c2b78b8e7396b3855c9d3244762b734399",
        "focal_db": {
            "id": "2813543",
            "rel_path": "commons/src/main/java/com/navercorp/pinpoint/common/buffer/FixedBuffer.java",
            "method_src": "@Override\n    public void put(final boolean v) {\n        if (v) {\n            this.buffer[offset++] = BOOLEAN_TRUE;\n        } else {\n            this.buffer[offset++] = BOOLEAN_FALSE;\n        }\n    }",
            "method_tgt": "@Override\n    public void putBoolean(final boolean v) {\n        if (v) {\n            this.buffer[offset++] = BOOLEAN_TRUE;\n        } else {\n            this.buffer[offset++] = BOOLEAN_FALSE;\n        }\n    }"
        },
        "test_db": {
            "id": "2813562",
            "rel_path": "commons/src/test/java/com/navercorp/pinpoint/common/buffer/FixedBufferTest.java",
            "method_src": "@Test\n    public void testBoolean() {\n        Buffer buffer = new FixedBuffer(16);\n        buffer.put(true);\n        buffer.put(false);\n\n        Buffer read = new FixedBuffer(buffer.getBuffer());\n        boolean b = read.readBoolean();\n        Assert.assertEquals(true, b);\n\n        boolean c = read.readBoolean();\n        Assert.assertEquals(false, c);\n    }",
            "method_tgt": "@Test\n    public void testBoolean() {\n        Buffer buffer = new FixedBuffer(16);\n        buffer.putBoolean(true);\n        buffer.putBoolean(false);\n\n        Buffer read = new FixedBuffer(buffer.getBuffer());\n        boolean b = read.readBoolean();\n        Assert.assertEquals(true, b);\n\n        boolean c = read.readBoolean();\n        Assert.assertEquals(false, c);\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 1,
            "param_types": 0,
            "throw_types": 0
        },
        "aug": 0
    },
    {
        "repo_name": "openmrs/openmrs-core",
        "commit_id": "87dce904ef02a942534ee284e610789f1bc9a19e",
        "commit_url": "https://github.com/openmrs/openmrs-core/commit/87dce904ef02a942534ee284e610789f1bc9a19e",
        "focal_db": {
            "id": "2994345",
            "rel_path": "api/src/main/java/org/openmrs/Order.java",
            "method_src": "public Order cloneForDiscontinuing() {\r\n\t\tOrder newOrder = new Order();\r\n\t\tnewOrder.setCareSetting(this.getCareSetting());\r\n\t\tnewOrder.setConcept(this.getConcept());\r\n\t\tnewOrder.setAction(Action.DISCONTINUE);\r\n\t\tnewOrder.setPreviousOrder(this);\r\n\t\t\r\n\t\treturn newOrder;\r\n\t}",
            "method_tgt": "public Order cloneForDiscontinuing() throws IllegalAccessException, InstantiationException {\r\n\t\tOrder newOrder = this.getClass().newInstance();\r\n\t\tnewOrder.setCareSetting(this.getCareSetting());\r\n\t\tnewOrder.setConcept(this.getConcept());\r\n\t\tnewOrder.setAction(Action.DISCONTINUE);\r\n\t\tnewOrder.setPreviousOrder(this);\r\n\t\t\r\n\t\treturn newOrder;\r\n\t}"
        },
        "test_db": {
            "id": "2994358",
            "rel_path": "api/src/test/java/org/openmrs/OrderTest.java",
            "method_src": "@Test\r\n\t@Verifies(value = \"set this care setting to new order\", method = \"cloneForDiscontinuing(Order)\")\r\n\tpublic void cloneForDiscontinuing_shouldSetThisCareSettingToNewOrder() {\r\n\t\tOrder anOrder = new Order();\r\n\t\tCareSetting careSetting = new CareSetting();\r\n\t\tanOrder.setCareSetting(careSetting);\r\n\t\t\r\n\t\tOrder orderThatCanDiscontinueTheOrder = anOrder.cloneForDiscontinuing();\r\n\t\t\r\n\t\tassertEquals(anOrder.getCareSetting(), orderThatCanDiscontinueTheOrder.getCareSetting());\r\n\t}",
            "method_tgt": "@Test\r\n\t@Verifies(value = \"set this care setting to new order\", method = \"cloneForDiscontinuing(Order)\")\r\n\tpublic void cloneForDiscontinuing_shouldSetThisCareSettingToNewOrder() throws Exception {\r\n\t\tOrder anOrder = new Order();\r\n\t\tCareSetting careSetting = new CareSetting();\r\n\t\tanOrder.setCareSetting(careSetting);\r\n\t\t\r\n\t\tOrder orderThatCanDiscontinueTheOrder = anOrder.cloneForDiscontinuing();\r\n\t\t\r\n\t\tassertEquals(anOrder.getCareSetting(), orderThatCanDiscontinueTheOrder.getCareSetting());\r\n\t}"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 0,
            "throw_types": 1
        }
    },
    {
        "repo_name": "opennetworkinglab/onos",
        "commit_id": "6107111d0094e76ac9eb6f9466bf55d05c63a33b",
        "commit_url": "https://github.com/opennetworkinglab/onos/commit/6107111d0094e76ac9eb6f9466bf55d05c63a33b",
        "focal_db": {
            "id": "3050219",
            "rel_path": "utils/yangutils/src/main/java/org/onosproject/yangutils/translator/tojava/utils/MethodsGenerator.java",
            "method_src": "public static String getConstructor(String yangName, JavaAttributeInfo attr, int generatedJavaFiles) {\n\n        String attributeName = attr.getAttributeName();\n        String constructor;\n\n        if ((generatedJavaFiles & GENERATE_SERVICE_AND_MANAGER) != 0) {\n            constructor = EIGHT_SPACE_INDENTATION + THIS + PERIOD + getCamelCase(attributeName, null) + SPACE + EQUAL\n                    + SPACE + BUILDER.toLowerCase() + OBJECT + PERIOD + GET_METHOD_PREFIX\n                    + getCapitalCase(getCamelCase(attributeName, null)) + OPEN_PARENTHESIS + CLOSE_PARENTHESIS +\n                    SEMI_COLAN\n                    + NEW_LINE;\n        } else {\n            constructor = EIGHT_SPACE_INDENTATION + THIS + PERIOD + getCamelCase(attributeName, null) + SPACE + EQUAL\n                    + SPACE + BUILDER.toLowerCase() + OBJECT + PERIOD + getCamelCase(attributeName, null) +\n                    OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN\n                    + NEW_LINE;\n        }\n        return constructor;\n    }",
            "method_tgt": "public static String getConstructor(String yangName, JavaAttributeInfo attr, int generatedJavaFiles,\n            YangPluginConfig pluginConfig) {\n\n        String attributeName = attr.getAttributeName();\n        String constructor;\n\n        if ((generatedJavaFiles & GENERATE_SERVICE_AND_MANAGER) != 0) {\n            constructor =\n                    EIGHT_SPACE_INDENTATION + THIS + PERIOD\n                            + getCamelCase(attributeName, pluginConfig.getConflictResolver()) + SPACE + EQUAL\n                            + SPACE + BUILDER.toLowerCase() + OBJECT + PERIOD + GET_METHOD_PREFIX\n                            + getCapitalCase(getCamelCase(attributeName, pluginConfig.getConflictResolver()))\n                            + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;\n        } else {\n            constructor =\n                    EIGHT_SPACE_INDENTATION + THIS + PERIOD\n                            + getCamelCase(attributeName, pluginConfig.getConflictResolver()) + SPACE + EQUAL\n                            + SPACE + BUILDER.toLowerCase() + OBJECT + PERIOD\n                            + getCamelCase(attributeName, pluginConfig.getConflictResolver()) +\n                            OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;\n        }\n        return constructor;\n    }"
        },
        "test_db": {
            "id": "3050262",
            "rel_path": "utils/yangutils/src/test/java/org/onosproject/yangutils/translator/tojava/utils/MethodsGeneratorTest.java",
            "method_src": "@Test\n    public void getConstructorTest() {\n        JavaAttributeInfo testAttr = getTestAttribute();\n        String method = getConstructor(CLASS_NAME, testAttr, GENERATE_SERVICE_AND_MANAGER);\n        assertThat(true, is(method.contains(THIS + PERIOD + CLASS_NAME + SPACE + EQUAL + SPACE + \"builder\" + OBJECT\n                + PERIOD + GET_METHOD_PREFIX + \"Testname\" + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN)));\n    }",
            "method_tgt": "@Test\n    public void getConstructorTest() {\n        JavaAttributeInfo testAttr = getTestAttribute();\n        YangPluginConfig pluginConfig = new YangPluginConfig();\n        String method = getConstructor(CLASS_NAME, testAttr, GENERATE_SERVICE_AND_MANAGER, pluginConfig);\n        assertThat(true, is(method.contains(THIS + PERIOD + CLASS_NAME + SPACE + EQUAL + SPACE + \"builder\" + OBJECT\n                + PERIOD + GET_METHOD_PREFIX + \"Testname\" + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN)));\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        }
    },
    {
        "repo_name": "opennetworkinglab/onos",
        "commit_id": "9e848e8717e2b7adcc6fe4abbcc970802e307faa",
        "commit_url": "https://github.com/opennetworkinglab/onos/commit/9e848e8717e2b7adcc6fe4abbcc970802e307faa",
        "focal_db": {
            "id": "3046930",
            "rel_path": "apps/pce/app/src/main/java/org/onosproject/pce/pcestore/DistributedPceStore.java",
            "method_src": "@Override\n    public Map<TunnelId, PceccTunnelInfo> getTunnelInfos() {\n       return tunnelInfoMap.entrySet().stream()\n                 .collect(Collectors.toMap(Map.Entry::getKey, e -> (PceccTunnelInfo) e.getValue().value()));\n    }",
            "method_tgt": "@Override\n    public Map<TunnelId, ResourceConsumer> getTunnelInfos() {\n       return tunnelInfoMap.entrySet().stream()\n                 .collect(Collectors.toMap(Map.Entry::getKey, e -> e.getValue().value()));\n    }"
        },
        "test_db": {
            "id": "3046935",
            "rel_path": "apps/pce/app/src/test/java/org/onosproject/pce/pcestore/DistributedPceStoreTest.java",
            "method_src": "@Test\n    public void testGetTunnelInfos() {\n        testAddTunnelInfo();\n\n        Map<TunnelId, PceccTunnelInfo> tunnelInfoMap = distrPceStore.getTunnelInfos();\n        assertThat(tunnelInfoMap, is(notNullValue()));\n        assertThat(tunnelInfoMap.isEmpty(), is(false));\n        assertThat(tunnelInfoMap.size(), is(2));\n    }",
            "method_tgt": "@Test\n    public void testGetTunnelInfos() {\n        testAddTunnelInfo();\n\n        Map<TunnelId, ResourceConsumer> tunnelInfoMap = distrPceStore.getTunnelInfos();\n        assertThat(tunnelInfoMap, is(notNullValue()));\n        assertThat(tunnelInfoMap.isEmpty(), is(false));\n        assertThat(tunnelInfoMap.size(), is(2));\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 0,
            "param_types": 0,
            "throw_types": 0
        },
        "aug": 0
    },
    {
        "repo_name": "opennetworkinglab/onos",
        "commit_id": "9e848e8717e2b7adcc6fe4abbcc970802e307faa",
        "commit_url": "https://github.com/opennetworkinglab/onos/commit/9e848e8717e2b7adcc6fe4abbcc970802e307faa",
        "focal_db": {
            "id": 3046930,
            "rel_path": "apps/pce/app/src/main/java/org/onosproject/pce/pcestore/DistributedPceStore.java",
            "method_src": "@Override\n    public PceccTunnelInfo getTunnelInfo(TunnelId tunnelId) {\n        checkNotNull(tunnelId, TUNNEL_ID_NULL);\n        return tunnelInfoMap.get(tunnelId) == null ? null : tunnelInfoMap.get(tunnelId).value();\n    }",
            "method_tgt": "@Override\n    public ResourceConsumer getTunnelInfo(TunnelId tunnelId) {\n        checkNotNull(tunnelId, TUNNEL_ID_NULL);\n        return tunnelInfoMap.get(tunnelId) == null ? null : tunnelInfoMap.get(tunnelId).value();\n    }"
        },
        "test_db": {
            "id": 3046935,
            "rel_path": "apps/pce/app/src/test/java/org/onosproject/pce/pcestore/DistributedPceStoreTest.java",
            "method_src": "@Test\n    public void testGetTunnelInfo() {\n        testAddTunnelInfo();\n\n        // tunnelId1 with device label store info\n        assertThat(tunnelId1, is(notNullValue()));\n        assertThat(distrPceStore.getTunnelInfo(tunnelId1), is(pceccTunnelInfo1));\n\n        // tunnelId2 with device label store info\n        assertThat(tunnelId2, is(notNullValue()));\n        assertThat(distrPceStore.getTunnelInfo(tunnelId2), is(pceccTunnelInfo2));\n    }",
            "method_tgt": "@Test\n    public void testGetTunnelInfo() {\n        testAddTunnelInfo();\n\n        // tunnelId1 with device label store info\n        assertThat(tunnelId1, is(notNullValue()));\n        assertThat(distrPceStore.getTunnelInfo(tunnelId1), is(tunnelConsumerId1));\n\n        // tunnelId2 with device label store info\n        assertThat(tunnelId2, is(notNullValue()));\n        assertThat(distrPceStore.getTunnelInfo(tunnelId2), is(tunnelConsumerId2));\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 0,
            "param_types": 0,
            "throw_types": 0
        },
        "aug": 1
    },
    {
        "repo_name": "opennetworkinglab/onos",
        "commit_id": "9e848e8717e2b7adcc6fe4abbcc970802e307faa",
        "commit_url": "https://github.com/opennetworkinglab/onos/commit/9e848e8717e2b7adcc6fe4abbcc970802e307faa",
        "focal_db": {
            "id": 3046930,
            "rel_path": "apps/pce/app/src/main/java/org/onosproject/pce/pcestore/DistributedPceStore.java",
            "method_src": "@Override\n    public void addTunnelInfo(TunnelId tunnelId, PceccTunnelInfo pceccTunnelInfo) {\n        checkNotNull(tunnelId, TUNNEL_ID_NULL);\n        checkNotNull(pceccTunnelInfo, PCECC_TUNNEL_INFO_NULL);\n\n        tunnelInfoMap.put(tunnelId, pceccTunnelInfo);\n    }",
            "method_tgt": "@Override\n    public void addTunnelInfo(TunnelId tunnelId, ResourceConsumer tunnelConsumerId) {\n        checkNotNull(tunnelId, TUNNEL_ID_NULL);\n        checkNotNull(tunnelConsumerId, PCECC_TUNNEL_INFO_NULL);\n\n        tunnelInfoMap.put(tunnelId, tunnelConsumerId);\n    }"
        },
        "test_db": {
            "id": 3046935,
            "rel_path": "apps/pce/app/src/test/java/org/onosproject/pce/pcestore/DistributedPceStoreTest.java",
            "method_src": "@Test\n    public void testAddTunnelInfo() {\n        // initialization\n        distrPceStore.storageService = new TestStorageService();\n        distrPceStore.activate();\n\n        // TunnelId with device label store information\n        distrPceStore.addTunnelInfo(tunnelId1, pceccTunnelInfo1);\n        assertThat(distrPceStore.existsTunnelInfo(tunnelId1), is(true));\n        assertThat(distrPceStore.getTunnelInfo(tunnelId1), is(pceccTunnelInfo1));\n        distrPceStore.addTunnelInfo(tunnelId2, pceccTunnelInfo2);\n        assertThat(distrPceStore.existsTunnelInfo(tunnelId2), is(true));\n        assertThat(distrPceStore.getTunnelInfo(tunnelId2), is(pceccTunnelInfo2));\n    }",
            "method_tgt": "@Test\n    public void testAddTunnelInfo() {\n        // initialization\n        distrPceStore.storageService = new TestStorageService();\n        distrPceStore.activate();\n\n        // TunnelId with device label store information\n        distrPceStore.addTunnelInfo(tunnelId1, tunnelConsumerId1);\n        assertThat(distrPceStore.existsTunnelInfo(tunnelId1), is(true));\n        assertThat(distrPceStore.getTunnelInfo(tunnelId1), is(tunnelConsumerId1));\n        distrPceStore.addTunnelInfo(tunnelId2, tunnelConsumerId2);\n        assertThat(distrPceStore.existsTunnelInfo(tunnelId2), is(true));\n        assertThat(distrPceStore.getTunnelInfo(tunnelId2), is(tunnelConsumerId2));\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 2
    },
    {
        "repo_name": "opennetworkinglab/onos",
        "commit_id": "08537a8c36df8d84e77e7667b4b6e3c766278dd0",
        "commit_url": "https://github.com/opennetworkinglab/onos/commit/08537a8c36df8d84e77e7667b4b6e3c766278dd0",
        "focal_db": {
            "id": "3043386",
            "rel_path": "utils/misc/src/main/java/org/onlab/packet/ndp/NeighborSolicitation.java",
            "method_src": "public static Ethernet buildNdpSolicit(byte[] targetIp,\n                                           byte[] sourceIp,\n                                           byte[] destinationIp,\n                                           byte[] sourceMac,\n                                           byte[] destinationMac,\n                                           VlanId vlan) {\n\n        if (targetIp.length != Ip6Address.BYTE_LENGTH ||\n                sourceIp.length != Ip6Address.BYTE_LENGTH ||\n                destinationIp.length != Ip6Address.BYTE_LENGTH ||\n                sourceMac.length != MacAddress.MAC_ADDRESS_LENGTH ||\n                destinationMac.length != MacAddress.MAC_ADDRESS_LENGTH) {\n            return null;\n        }\n\n        // Here we craft the Ethernet packet.\n        Ethernet ethernet = new Ethernet();\n        ethernet.setEtherType(Ethernet.TYPE_IPV6)\n                .setDestinationMACAddress(destinationMac)\n                .setSourceMACAddress(sourceMac);\n        ethernet.setVlanID(vlan.id());\n        // IPv6 packet is created.\n        IPv6 ipv6 = new IPv6();\n        ipv6.setSourceAddress(sourceIp);\n        ipv6.setDestinationAddress(destinationIp);\n        ipv6.setHopLimit((byte) 255);\n        // Create the ICMPv6 packet.\n        ICMP6 icmp6 = new ICMP6();\n        icmp6.setIcmpType(ICMP6.NEIGHBOR_SOLICITATION);\n        icmp6.setIcmpCode((byte) 0);\n        // Create the Neighbor Solicitation packet.\n        NeighborSolicitation ns = new NeighborSolicitation();\n        ns.setTargetAddress(targetIp);\n        // DAD packets should not contain SRC_LL_ADDR option\n        if (!Arrays.equals(sourceIp, Ip6Address.ZERO.toOctets())) {\n            ns.addOption(NeighborDiscoveryOptions.TYPE_SOURCE_LL_ADDRESS, sourceMac);\n        }\n        // Set the payloads\n        icmp6.setPayload(ns);\n        ipv6.setPayload(icmp6);\n        ethernet.setPayload(ipv6);\n\n        return ethernet;\n    }",
            "method_tgt": "public static Ethernet buildNdpSolicit(Ip6Address targetIp,\n                                           Ip6Address sourceIp,\n                                           Ip6Address destinationIp,\n                                           MacAddress sourceMac,\n                                           MacAddress destinationMac,\n                                           VlanId vlan) {\n\n        checkNotNull(targetIp, \"Target IP address cannot be null\");\n        checkNotNull(sourceIp, \"Source IP address cannot be null\");\n        checkNotNull(destinationIp, \"Destination IP address cannot be null\");\n        checkNotNull(sourceMac, \"Source MAC address cannot be null\");\n        checkNotNull(destinationMac, \"Destination MAC address cannot be null\");\n        checkNotNull(vlan, \"Vlan cannot be null\");\n\n        // Here we craft the Ethernet packet.\n        Ethernet ethernet = new Ethernet();\n        ethernet.setEtherType(Ethernet.TYPE_IPV6)\n                .setDestinationMACAddress(destinationMac)\n                .setSourceMACAddress(sourceMac);\n        ethernet.setVlanID(vlan.id());\n        // IPv6 packet is created.\n        IPv6 ipv6 = new IPv6();\n        ipv6.setSourceAddress(sourceIp.toOctets());\n        ipv6.setDestinationAddress(destinationIp.toOctets());\n        ipv6.setHopLimit(NDP_HOP_LIMIT);\n        // Create the ICMPv6 packet.\n        ICMP6 icmp6 = new ICMP6();\n        icmp6.setIcmpType(ICMP6.NEIGHBOR_SOLICITATION);\n        icmp6.setIcmpCode(RESERVED_CODE);\n        // Create the Neighbor Solicitation packet.\n        NeighborSolicitation ns = new NeighborSolicitation();\n        ns.setTargetAddress(targetIp.toOctets());\n        // DAD packets should not contain SRC_LL_ADDR option\n        if (!Arrays.equals(sourceIp.toOctets(), Ip6Address.ZERO.toOctets())) {\n            ns.addOption(NeighborDiscoveryOptions.TYPE_SOURCE_LL_ADDRESS, sourceMac.toBytes());\n        }\n        // Set the payloads\n        icmp6.setPayload(ns);\n        ipv6.setPayload(icmp6);\n        ethernet.setPayload(ipv6);\n\n        return ethernet;\n    }"
        },
        "test_db": {
            "id": "3043389",
            "rel_path": "utils/misc/src/test/java/org/onlab/packet/ndp/NeighborSolicitationTest.java",
            "method_src": "@Test\n    public void testBuildNdpSolicit() throws Exception {\n        Ethernet ethPacket = NeighborSolicitation.buildNdpSolicit(TARGET_IP.toOctets(),\n                SRC_IP.toOctets(), DST_IP.toOctets(),\n                SRC_MAC.toBytes(), DST_MAC.toBytes(), VLAN_ID);\n        IPv6 ipPacket = (IPv6) ethPacket.getPayload();\n        ICMP6 icmp6Packet = (ICMP6) ipPacket.getPayload();\n        NeighborSolicitation nsPacket = (NeighborSolicitation) icmp6Packet.getPayload();\n\n        assertEquals(\"Non-DAD NS should have 1 option\", 1, nsPacket.getOptions().size());\n        assertEquals(\"The option should be SRC_LL_ADDR type\", TYPE_SOURCE_LL_ADDRESS,\n                nsPacket.getOptions().stream().findFirst().get().type());\n    }",
            "method_tgt": "@Test\n    public void testBuildNdpSolicit() throws Exception {\n        final Ethernet ethPacket = NeighborSolicitation.buildNdpSolicit(TARGET_IP,\n                SRC_IP, DST_IP, SRC_MAC, DST_MAC, VLAN_ID);\n\n        assertTrue(ethPacket.getDestinationMAC().equals(DST_MAC));\n        assertTrue(ethPacket.getSourceMAC().equals(SRC_MAC));\n        assertTrue(ethPacket.getEtherType() == Ethernet.TYPE_IPV6);\n        assertTrue(ethPacket.getVlanID() == VLAN_ID.id());\n\n        final IPv6 ipPacket = (IPv6) ethPacket.getPayload();\n\n        assertArrayEquals(ipPacket.getSourceAddress(), SRC_IP.toOctets());\n        assertArrayEquals(ipPacket.getDestinationAddress(), DST_IP.toOctets());\n\n        final ICMP6 icmp6Packet = (ICMP6) ipPacket.getPayload();\n        final NeighborSolicitation nsPacket = (NeighborSolicitation) icmp6Packet.getPayload();\n\n        assertArrayEquals(nsPacket.getTargetAddress(), TARGET_IP.toOctets());\n\n        assertEquals(\"Non-DAD NS should have 1 option\", 1, nsPacket.getOptions().size());\n        assertEquals(\"The option should be SRC_LL_ADDR type\", TYPE_SOURCE_LL_ADDRESS,\n                nsPacket.getOptions().stream().findFirst().get().type());\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 1,
        "comment": "Case study hard: also add more verifications"
    },
    {
        "repo_name": "opennetworkinglab/onos",
        "commit_id": "08537a8c36df8d84e77e7667b4b6e3c766278dd0",
        "commit_url": "https://github.com/opennetworkinglab/onos/commit/08537a8c36df8d84e77e7667b4b6e3c766278dd0",
        "focal_db": {
            "id": "3043386",
            "rel_path": "utils/misc/src/main/java/org/onlab/packet/ndp/NeighborSolicitation.java",
            "method_src": "public static Ethernet buildNdpSolicit(byte[] targetIp,\n                                           byte[] sourceIp,\n                                           byte[] destinationIp,\n                                           byte[] sourceMac,\n                                           byte[] destinationMac,\n                                           VlanId vlan) {\n\n        if (targetIp.length != Ip6Address.BYTE_LENGTH ||\n                sourceIp.length != Ip6Address.BYTE_LENGTH ||\n                destinationIp.length != Ip6Address.BYTE_LENGTH ||\n                sourceMac.length != MacAddress.MAC_ADDRESS_LENGTH ||\n                destinationMac.length != MacAddress.MAC_ADDRESS_LENGTH) {\n            return null;\n        }\n\n        // Here we craft the Ethernet packet.\n        Ethernet ethernet = new Ethernet();\n        ethernet.setEtherType(Ethernet.TYPE_IPV6)\n                .setDestinationMACAddress(destinationMac)\n                .setSourceMACAddress(sourceMac);\n        ethernet.setVlanID(vlan.id());\n        // IPv6 packet is created.\n        IPv6 ipv6 = new IPv6();\n        ipv6.setSourceAddress(sourceIp);\n        ipv6.setDestinationAddress(destinationIp);\n        ipv6.setHopLimit((byte) 255);\n        // Create the ICMPv6 packet.\n        ICMP6 icmp6 = new ICMP6();\n        icmp6.setIcmpType(ICMP6.NEIGHBOR_SOLICITATION);\n        icmp6.setIcmpCode((byte) 0);\n        // Create the Neighbor Solicitation packet.\n        NeighborSolicitation ns = new NeighborSolicitation();\n        ns.setTargetAddress(targetIp);\n        // DAD packets should not contain SRC_LL_ADDR option\n        if (!Arrays.equals(sourceIp, Ip6Address.ZERO.toOctets())) {\n            ns.addOption(NeighborDiscoveryOptions.TYPE_SOURCE_LL_ADDRESS, sourceMac);\n        }\n        // Set the payloads\n        icmp6.setPayload(ns);\n        ipv6.setPayload(icmp6);\n        ethernet.setPayload(ipv6);\n\n        return ethernet;\n    }",
            "method_tgt": "public static Ethernet buildNdpSolicit(Ip6Address targetIp,\n                                           Ip6Address sourceIp,\n                                           Ip6Address destinationIp,\n                                           MacAddress sourceMac,\n                                           MacAddress destinationMac,\n                                           VlanId vlan) {\n\n        checkNotNull(targetIp, \"Target IP address cannot be null\");\n        checkNotNull(sourceIp, \"Source IP address cannot be null\");\n        checkNotNull(destinationIp, \"Destination IP address cannot be null\");\n        checkNotNull(sourceMac, \"Source MAC address cannot be null\");\n        checkNotNull(destinationMac, \"Destination MAC address cannot be null\");\n        checkNotNull(vlan, \"Vlan cannot be null\");\n\n        // Here we craft the Ethernet packet.\n        Ethernet ethernet = new Ethernet();\n        ethernet.setEtherType(Ethernet.TYPE_IPV6)\n                .setDestinationMACAddress(destinationMac)\n                .setSourceMACAddress(sourceMac);\n        ethernet.setVlanID(vlan.id());\n        // IPv6 packet is created.\n        IPv6 ipv6 = new IPv6();\n        ipv6.setSourceAddress(sourceIp.toOctets());\n        ipv6.setDestinationAddress(destinationIp.toOctets());\n        ipv6.setHopLimit(NDP_HOP_LIMIT);\n        // Create the ICMPv6 packet.\n        ICMP6 icmp6 = new ICMP6();\n        icmp6.setIcmpType(ICMP6.NEIGHBOR_SOLICITATION);\n        icmp6.setIcmpCode(RESERVED_CODE);\n        // Create the Neighbor Solicitation packet.\n        NeighborSolicitation ns = new NeighborSolicitation();\n        ns.setTargetAddress(targetIp.toOctets());\n        // DAD packets should not contain SRC_LL_ADDR option\n        if (!Arrays.equals(sourceIp.toOctets(), Ip6Address.ZERO.toOctets())) {\n            ns.addOption(NeighborDiscoveryOptions.TYPE_SOURCE_LL_ADDRESS, sourceMac.toBytes());\n        }\n        // Set the payloads\n        icmp6.setPayload(ns);\n        ipv6.setPayload(icmp6);\n        ethernet.setPayload(ipv6);\n\n        return ethernet;\n    }"
        },
        "test_db": {
            "id": "3043389",
            "rel_path": "utils/misc/src/test/java/org/onlab/packet/ndp/NeighborSolicitationTest.java",
            "method_src": "@Test\n    public void testBuildNdpSolicitDad() throws Exception {\n        Ethernet ethPacket = NeighborSolicitation.buildNdpSolicit(TARGET_IP.toOctets(),\n                Ip6Address.ZERO.toOctets(), DST_IP.toOctets(),\n                SRC_MAC.toBytes(), DST_MAC.toBytes(), VLAN_ID);\n        IPv6 ipPacket = (IPv6) ethPacket.getPayload();\n        ICMP6 icmp6Packet = (ICMP6) ipPacket.getPayload();\n        NeighborSolicitation nsPacket = (NeighborSolicitation) icmp6Packet.getPayload();\n\n        assertEquals(\"DAD NS should have no option\", 0, nsPacket.getOptions().size());\n    }",
            "method_tgt": "@Test\n    public void testBuildNdpSolicitDad() throws Exception {\n        Ethernet ethPacket = NeighborSolicitation.buildNdpSolicit(TARGET_IP,\n                Ip6Address.ZERO, DST_IP, SRC_MAC, DST_MAC, VLAN_ID);\n        IPv6 ipPacket = (IPv6) ethPacket.getPayload();\n        ICMP6 icmp6Packet = (ICMP6) ipPacket.getPayload();\n        NeighborSolicitation nsPacket = (NeighborSolicitation) icmp6Packet.getPayload();\n\n        assertEquals(\"DAD NS should have no option\", 0, nsPacket.getOptions().size());\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 2,
        "comment": "Case study: no additionally verifications"
    },
    {
        "repo_name": "opennetworkinglab/onos",
        "commit_id": "deac28bfbbaf0d8a1452272ac31c20c52db38416",
        "commit_url": "https://github.com/opennetworkinglab/onos/commit/deac28bfbbaf0d8a1452272ac31c20c52db38416",
        "focal_db": {
            "id": "3048746",
            "rel_path": "utils/yangutils/plugin/src/main/java/org/onosproject/yangutils/translator/tojava/utils/JavaIdentifierSyntax.java",
            "method_src": "public static String getRootPackage(byte version, String nameSpace, String revision,\n                                        YangToJavaNamingConflictUtil conflictResolver) {\n\n        String pkg;\n        pkg = DEFAULT_BASE_PKG;\n        pkg = pkg + PERIOD;\n        pkg = pkg + getYangVersion(version);\n        pkg = pkg + PERIOD;\n        pkg = pkg + getPkgFromNameSpace(nameSpace, conflictResolver);\n        pkg = pkg + PERIOD;\n        pkg = pkg + getYangRevisionStr(revision);\n\n        return pkg.toLowerCase();\n    }",
            "method_tgt": "public static String getRootPackage(byte version, String nameSpace, Date revision,\n                                        YangToJavaNamingConflictUtil conflictResolver) {\n\n        String pkg;\n        pkg = DEFAULT_BASE_PKG;\n        pkg = pkg + PERIOD;\n        pkg = pkg + getYangVersion(version);\n        pkg = pkg + PERIOD;\n        pkg = pkg + getPkgFromNameSpace(nameSpace, conflictResolver);\n        pkg = pkg + PERIOD;\n        pkg = pkg + getYangRevisionStr(revision);\n\n        return pkg.toLowerCase();\n    }"
        },
        "test_db": {
            "id": "3048758",
            "rel_path": "utils/yangutils/plugin/src/test/java/org/onosproject/yangutils/translator/tojava/utils/JavaIdentifierSyntaxTest.java",
            "method_src": "@Test\n    public void getRootPackageTest() {\n        conflictResolver.setPrefixForIdentifier(null);\n        String rootPackage = getRootPackage((byte) 1, CHILD_PACKAGE, DATE1, conflictResolver);\n        assertThat(rootPackage.equals(DEFAULT_BASE_PKG + PERIOD + VERSION_NUMBER\n                + PERIOD + CHILD_WITH_PERIOD + PERIOD + DATE_WITH_REV1), is(true));\n    }",
            "method_tgt": "@Test\n    public void getRootPackageTest() throws ParseException {\n        conflictResolver.setPrefixForIdentifier(null);\n        Date date = simpleDateFormat.parse(DATE1);\n        String rootPackage = getRootPackage((byte) 1, CHILD_PACKAGE, date, conflictResolver);\n        assertThat(rootPackage.equals(DEFAULT_BASE_PKG + PERIOD + VERSION_NUMBER\n                + PERIOD + CHILD_WITH_PERIOD + PERIOD + DATE_WITH_REV1), is(true));\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        }
    },
    {
        "repo_name": "opennetworkinglab/onos",
        "commit_id": "deac28bfbbaf0d8a1452272ac31c20c52db38416",
        "commit_url": "https://github.com/opennetworkinglab/onos/commit/deac28bfbbaf0d8a1452272ac31c20c52db38416",
        "focal_db": {
            "id": "3048746",
            "rel_path": "utils/yangutils/plugin/src/main/java/org/onosproject/yangutils/translator/tojava/utils/JavaIdentifierSyntax.java",
            "method_src": "public static String getRootPackage(byte version, String nameSpace, String revision,\n                                        YangToJavaNamingConflictUtil conflictResolver) {\n\n        String pkg;\n        pkg = DEFAULT_BASE_PKG;\n        pkg = pkg + PERIOD;\n        pkg = pkg + getYangVersion(version);\n        pkg = pkg + PERIOD;\n        pkg = pkg + getPkgFromNameSpace(nameSpace, conflictResolver);\n        pkg = pkg + PERIOD;\n        pkg = pkg + getYangRevisionStr(revision);\n\n        return pkg.toLowerCase();\n    }",
            "method_tgt": "public static String getRootPackage(byte version, String nameSpace, Date revision,\n                                        YangToJavaNamingConflictUtil conflictResolver) {\n\n        String pkg;\n        pkg = DEFAULT_BASE_PKG;\n        pkg = pkg + PERIOD;\n        pkg = pkg + getYangVersion(version);\n        pkg = pkg + PERIOD;\n        pkg = pkg + getPkgFromNameSpace(nameSpace, conflictResolver);\n        pkg = pkg + PERIOD;\n        pkg = pkg + getYangRevisionStr(revision);\n\n        return pkg.toLowerCase();\n    }"
        },
        "test_db": {
            "id": "3048758",
            "rel_path": "utils/yangutils/plugin/src/test/java/org/onosproject/yangutils/translator/tojava/utils/JavaIdentifierSyntaxTest.java",
            "method_src": "@Test\n    public void getRootPackageWithRevTest() {\n        String rootPkgWithRev = getRootPackage((byte) 1, CHILD_PACKAGE, DATE2, null);\n        assertThat(rootPkgWithRev.equals(\n                DEFAULT_BASE_PKG + PERIOD + VERSION_NUMBER + PERIOD + CHILD_WITH_PERIOD + PERIOD + DATE_WITH_REV2),\n                is(true));\n    }",
            "method_tgt": "@Test\n    public void getRootPackageWithRevTest() throws ParseException {\n        Date date = simpleDateFormat.parse(DATE2);\n        String rootPkgWithRev = getRootPackage((byte) 1, CHILD_PACKAGE, date, null);\n        assertThat(rootPkgWithRev.equals(\n                DEFAULT_BASE_PKG + PERIOD + VERSION_NUMBER + PERIOD + CHILD_WITH_PERIOD + PERIOD + DATE_WITH_REV2),\n                is(true));\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 1
    },
    {
        "repo_name": "opennetworkinglab/onos",
        "commit_id": "6107111d0094e76ac9eb6f9466bf55d05c63a33b",
        "commit_url": "https://github.com/opennetworkinglab/onos/commit/6107111d0094e76ac9eb6f9466bf55d05c63a33b",
        "focal_db": {
            "id": "3050245",
            "rel_path": "utils/yangutils/src/main/java/org/onosproject/yangutils/utils/io/impl/YangIoUtils.java",
            "method_src": "public static void addPackageInfo(File path, String classInfo, String pack, boolean isChildNode)\n            throws IOException {\n\n        if (pack.contains(ORG)) {\n            String[] strArray = pack.split(ORG);\n            pack = ORG + strArray[1];\n        }\n        try {\n\n            File packageInfo = new File(path + SLASH + \"package-info.java\");\n            packageInfo.createNewFile();\n\n            FileWriter fileWriter = new FileWriter(packageInfo);\n            BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);\n\n            bufferedWriter.write(CopyrightHeader.getCopyrightHeader());\n            bufferedWriter.write(getJavaDoc(PACKAGE_INFO, classInfo, isChildNode));\n            bufferedWriter.write(PACKAGE + SPACE + pack + SEMI_COLAN);\n\n            bufferedWriter.close();\n            fileWriter.close();\n        } catch (IOException e) {\n            throw new IOException(\"Exception occured while creating package info file.\");\n        }\n    }",
            "method_tgt": "public static void addPackageInfo(File path, String classInfo, String pack, boolean isChildNode,\n            YangPluginConfig pluginConfig)\n            throws IOException {\n\n        pack = parsePkg(pack);\n\n        try {\n\n            File packageInfo = new File(path + SLASH + \"package-info.java\");\n            packageInfo.createNewFile();\n\n            FileWriter fileWriter = new FileWriter(packageInfo);\n            BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);\n\n            bufferedWriter.write(CopyrightHeader.getCopyrightHeader());\n            bufferedWriter.write(getJavaDoc(PACKAGE_INFO, classInfo, isChildNode, pluginConfig));\n            String pkg = PACKAGE + SPACE + pack + SEMI_COLAN;\n            if (pkg.length() > LINE_SIZE) {\n                pkg = whenDelimiterIsPersent(pkg, LINE_SIZE);\n            }\n            bufferedWriter.write(pkg);\n            bufferedWriter.close();\n            fileWriter.close();\n        } catch (IOException e) {\n            throw new IOException(\"Exception occured while creating package info file.\");\n        }\n    }"
        },
        "test_db": {
            "id": "3050282",
            "rel_path": "utils/yangutils/src/test/java/org/onosproject/yangutils/utils/io/impl/YangIoUtilsTest.java",
            "method_src": "@Test\n    public void addPackageInfoTest() throws IOException {\n\n        File dirPath = new File(CREATE_PATH);\n        dirPath.mkdirs();\n        addPackageInfo(dirPath, CHECK1, CREATE_PATH, false);\n        File filePath = new File(dirPath + File.separator + PKG_INFO);\n        assertThat(filePath.isFile(), is(true));\n    }",
            "method_tgt": "@Test\n    public void addPackageInfoTest() throws IOException {\n\n        File dirPath = new File(CREATE_PATH);\n        dirPath.mkdirs();\n        addPackageInfo(dirPath, CHECK1, CREATE_PATH, false, getStubPluginConfig());\n        File filePath = new File(dirPath + File.separator + PKG_INFO);\n        assertThat(filePath.isFile(), is(true));\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        },
        "comment": "Case study hard"
    },
    {
        "repo_name": "opennetworkinglab/onos",
        "commit_id": "c0e04846a216b06e061c8b23b0dbf569de381b35",
        "commit_url": "https://github.com/opennetworkinglab/onos/commit/c0e04846a216b06e061c8b23b0dbf569de381b35",
        "focal_db": {
            "id": "3051064",
            "rel_path": "utils/yangutils/src/main/java/org/onosproject/yangutils/utils/io/impl/YangIoUtils.java",
            "method_src": "public static void addPackageInfo(File path, String classInfo, String pack) throws IOException {\n\n        if (pack.contains(ORG)) {\n            String[] strArray = pack.split(ORG);\n            pack = ORG + strArray[1];\n        }\n        try {\n\n            File packageInfo = new File(path + SLASH + \"package-info.java\");\n            packageInfo.createNewFile();\n\n            FileWriter fileWriter = new FileWriter(packageInfo);\n            BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);\n\n            bufferedWriter.write(CopyrightHeader.getCopyrightHeader());\n            bufferedWriter.write(getJavaDoc(PACKAGE_INFO, classInfo, false));\n            bufferedWriter.write(PACKAGE + SPACE + pack + SEMI_COLAN);\n\n            bufferedWriter.close();\n            fileWriter.close();\n        } catch (IOException e) {\n            throw new IOException(\"Exception occured while creating package info file.\");\n        }\n    }",
            "method_tgt": "public static void addPackageInfo(File path, String classInfo, String pack, boolean isChildNode)\n            throws IOException {\n\n        if (pack.contains(ORG)) {\n            String[] strArray = pack.split(ORG);\n            pack = ORG + strArray[1];\n        }\n        try {\n\n            File packageInfo = new File(path + SLASH + \"package-info.java\");\n            packageInfo.createNewFile();\n\n            FileWriter fileWriter = new FileWriter(packageInfo);\n            BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);\n\n            bufferedWriter.write(CopyrightHeader.getCopyrightHeader());\n            bufferedWriter.write(getJavaDoc(PACKAGE_INFO, classInfo, isChildNode));\n            bufferedWriter.write(PACKAGE + SPACE + pack + SEMI_COLAN);\n\n            bufferedWriter.close();\n            fileWriter.close();\n        } catch (IOException e) {\n            throw new IOException(\"Exception occured while creating package info file.\");\n        }\n    }"
        },
        "test_db": {
            "id": "3051067",
            "rel_path": "utils/yangutils/src/test/java/org/onosproject/yangutils/utils/io/impl/YangIoUtilsTest.java",
            "method_src": "@Test\n    public void addPackageInfoTest() throws IOException {\n\n        File dirPath = new File(CREATE_PATH);\n        dirPath.mkdirs();\n        addPackageInfo(dirPath, \"check1\", CREATE_PATH);\n        File filePath = new File(dirPath + File.separator + \"package-info.java\");\n        assertThat(filePath.isFile(), is(true));\n    }",
            "method_tgt": "@Test\n    public void addPackageInfoTest() throws IOException {\n\n        File dirPath = new File(CREATE_PATH);\n        dirPath.mkdirs();\n        addPackageInfo(dirPath, CHECK1, CREATE_PATH, false);\n        File filePath = new File(dirPath + File.separator + PKG_INFO);\n        assertThat(filePath.isFile(), is(true));\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        }
    },
    {
        "repo_name": "opennetworkinglab/onos",
        "commit_id": "d9681e7d54d04f0931fffa5c13c0a5ba88d8f8d1",
        "commit_url": "https://github.com/opennetworkinglab/onos/commit/d9681e7d54d04f0931fffa5c13c0a5ba88d8f8d1",
        "focal_db": {
            "id": "3054564",
            "rel_path": "apps/segmentrouting/src/main/java/org/onosproject/segmentrouting/config/SegmentRoutingAppConfig.java",
            "method_src": "public SegmentRoutingAppConfig setExcludePorts(Set<String> excludePorts) {\n        if (excludePorts == null) {\n            object.remove(EXCLUDE_PORTS);\n        } else {\n            ArrayNode arrayNode = mapper.createArrayNode();\n            excludePorts.forEach(portName -> {\n                arrayNode.add(portName);\n            });\n            object.set(EXCLUDE_PORTS, arrayNode);\n        }\n        return this;\n    }",
            "method_tgt": "public SegmentRoutingAppConfig setSuppressHost(Set<ConnectPoint> suppressHost) {\n        if (suppressHost == null) {\n            object.remove(SUPPRESS_HOST);\n        } else {\n            ArrayNode arrayNode = mapper.createArrayNode();\n            suppressHost.forEach(connectPoint -> {\n                arrayNode.add(connectPoint.deviceId() + \"/\" + connectPoint.port());\n            });\n            object.set(SUPPRESS_HOST, arrayNode);\n        }\n        return this;\n    }"
        },
        "test_db": {
            "id": "3054567",
            "rel_path": "apps/segmentrouting/src/test/java/org/onosproject/segmentrouting/config/SegmentRoutingAppConfigTest.java",
            "method_src": "@Test\n    public void testSetExcludePorts() throws Exception {\n        ImmutableSet.Builder<String> builder = ImmutableSet.builder();\n        builder.add(PORT_NAME_3);\n        config.setExcludePorts(builder.build());\n\n        Set<String> excludePorts = config.excludePorts();\n        assertThat(excludePorts.size(), is(1));\n        assertTrue(excludePorts.contains(PORT_NAME_3));\n    }",
            "method_tgt": "@Test\n    public void testSetSuppressHost() throws Exception {\n        ImmutableSet.Builder<ConnectPoint> builder = ImmutableSet.builder();\n        builder.add(PORT_3);\n        config.setSuppressHost(builder.build());\n\n        Set<ConnectPoint> suppressHost = config.suppressHost();\n        assertNotNull(\"suppressHost should not be null\", suppressHost);\n        assertThat(suppressHost.size(), is(1));\n        assertTrue(suppressHost.contains(PORT_3));\n    }"
        },
        "syn_diff": {
            "overall": 2,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 1,
            "param_types": 1,
            "throw_types": 0
        }
    },
    {
        "repo_name": "pentaho/pentaho-kettle",
        "commit_id": "6cf722d5fd2d2c6d46a399a6217c12ced33aaeed",
        "commit_url": "https://github.com/pentaho/pentaho-kettle/commit/6cf722d5fd2d2c6d46a399a6217c12ced33aaeed",
        "focal_db": {
            "id": "3212428",
            "rel_path": "src/org/pentaho/di/ui/job/entries/sqoop/AbstractSqoopJobEntryController.java",
            "method_src": "public void setSelectedDatabaseConnection(String selected) {\n    updateSelectedDatabase(selected, true);\n  }",
            "method_tgt": "public void setSelectedDatabaseConnection(DatabaseItem selectedDatabaseConnection) {\n    DatabaseItem old = this.selectedDatabaseConnection;\n    this.selectedDatabaseConnection = selectedDatabaseConnection;\n    DatabaseMeta databaseMeta = this.selectedDatabaseConnection == null ? null : jobMeta.findDatabase(this.selectedDatabaseConnection.getName());\n    boolean validDatabaseSelected = databaseMeta != null;\n    setDatabaseInteractionButtonsDisabled(!validDatabaseSelected);\n    updateDatabaseItemsList();\n    // If the selected database changes update the config\n    if (!suppressEventHandling && (old == null && this.selectedDatabaseConnection != null || !old.equals(this.selectedDatabaseConnection))) {\n      if (validDatabaseSelected) {\n        try {\n          getConfig().setConnectionInfo(databaseMeta.getName(), databaseMeta.getURL(), databaseMeta.getUsername(), databaseMeta.getPassword());\n        } catch (KettleDatabaseException ex) {\n          sqoopJobEntry.logError(BaseMessages.getString(AbstractSqoopJobEntry.class, \"ErrorConfiguringDatabaseConnection\"), ex);\n        }\n      } else {\n        getConfig().copyConnectionInfoFromAdvanced();\n      }\n    }\n    firePropertyChange(\"selectedDatabaseConnection\", old, this.selectedDatabaseConnection);\n  }"
        },
        "test_db": {
            "id": "3212438",
            "rel_path": "test-src/org/pentaho/di/ui/job/entries/sqoop/AbstractSqoopJobEntryControllerTest.java",
            "method_src": "@Test\n  public void setSelectedDatabaseConnection() {\n    AbstractSqoopJobEntryController controller = new TestSqoopJobEntryController();\n\n    String database = \"testing\";\n    controller.setSelectedDatabaseConnection(database);\n\n    assertNull(\"Setting a database to one that doesn't exist in the JobMeta should not work\", controller.getConfig().getDatabase());\n\n    controller.getJobMeta().addDatabase(new DatabaseMeta(database, \"MYSQL\", null, null, null, null, null, null));\n    controller.setSelectedDatabaseConnection(database);\n\n    assertEquals(database, controller.getConfig().getDatabase());\n  }",
            "method_tgt": "@Test\n  public void setSelectedDatabaseConnection() throws KettleDatabaseException {\n    AbstractSqoopJobEntryController controller = new TestSqoopJobEntryController();\n\n    String connect = \"jdbc:bogus://bogus\";\n    String username = \"username\";\n    String password = \"password\";\n    controller.getConfig().setConnect(connect);\n    controller.getConfig().setUsername(username);\n    controller.getConfig().setPassword(password);\n\n    String connectAdvanced = \"jdbc:advanced://bogus\";\n    String usernameAdvanced = \"advanced_user\";\n    String passwordAdvanced = \"super password!\";\n    controller.getConfig().setConnectFromAdvanced(connectAdvanced);\n    controller.getConfig().setUsernameFromAdvanced(usernameAdvanced);\n    controller.getConfig().setPasswordFromAdvanced(passwordAdvanced);\n\n    DatabaseItem test = new DatabaseItem(\"test\");\n    DatabaseMeta database = new DatabaseMeta(test.getName(), \"MYSQL\", null, null, null, null, null, null);\n    controller.getJobMeta().addDatabase(database);\n    controller.setSelectedDatabaseConnection(test);\n\n    assertEquals(test, controller.getSelectedDatabaseConnection());\n    assertEquals(test.getName(), controller.getConfig().getDatabase());\n    assertEquals(database.getURL(), controller.getConfig().getConnect());\n    assertEquals(database.getUsername(), controller.getConfig().getUsername());\n    assertEquals(database.getPassword(), controller.getConfig().getPassword());\n\n    assertEquals(connectAdvanced, controller.getConfig().getConnectFromAdvanced());\n    assertEquals(usernameAdvanced, controller.getConfig().getUsernameFromAdvanced());\n    assertEquals(passwordAdvanced, controller.getConfig().getPasswordFromAdvanced());\n\n    controller.setSelectedDatabaseConnection(controller.USE_ADVANCED_OPTIONS);\n    assertEquals(controller.USE_ADVANCED_OPTIONS, controller.getSelectedDatabaseConnection());\n    assertNull(controller.getConfig().getDatabase());\n    assertEquals(connectAdvanced, controller.getConfig().getConnect());\n    assertEquals(usernameAdvanced, controller.getConfig().getUsername());\n    assertEquals(passwordAdvanced, controller.getConfig().getPassword());\n    assertEquals(connectAdvanced, controller.getConfig().getConnectFromAdvanced());\n    assertEquals(usernameAdvanced, controller.getConfig().getUsernameFromAdvanced());\n    assertEquals(passwordAdvanced, controller.getConfig().getPasswordFromAdvanced());\n\n    controller.setSelectedDatabaseConnection(test);\n    assertEquals(test, controller.getSelectedDatabaseConnection());\n    assertEquals(test.getName(), controller.getConfig().getDatabase());\n    assertEquals(database.getURL(), controller.getConfig().getConnect());\n    assertEquals(database.getUsername(), controller.getConfig().getUsername());\n    assertEquals(database.getPassword(), controller.getConfig().getPassword());\n\n    assertEquals(connectAdvanced, controller.getConfig().getConnectFromAdvanced());\n    assertEquals(usernameAdvanced, controller.getConfig().getUsernameFromAdvanced());\n    assertEquals(passwordAdvanced, controller.getConfig().getPasswordFromAdvanced());\n  }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        },
        "comment": "New assertions are added and Needs more setup for auth."
    },
    {
        "repo_name": "pravega/pravega",
        "commit_id": "7ebc10b5a9e50d0b5307b0e204f31486f30ef1b3",
        "commit_url": "https://github.com/pravega/pravega/commit/7ebc10b5a9e50d0b5307b0e204f31486f30ef1b3",
        "focal_db": {
            "id": "3287953",
            "rel_path": "service/storage/src/main/java/com/emc/pravega/service/storage/Storage.java",
            "method_src": "CompletableFuture<Void> concat(SegmentHandle targetHandle, long offset, SegmentHandle sourceHandle, Duration timeout);",
            "method_tgt": "CompletableFuture<Void> concat(SegmentHandle targetHandle, long offset, String sourceSegment, Duration timeout);"
        },
        "test_db": {
            "id": "3287956",
            "rel_path": "service/storage/src/test/java/com/emc/pravega/service/storage/StorageTestBase.java",
            "method_src": "@Test\n    public void testConcat() throws Exception {\n        final String context = \"Concat\";\n        try (Storage s = createStorage()) {\n            s.initialize(0);\n            HashMap<String, ByteArrayOutputStream> appendData = populate(s, context);\n\n            // Check invalid segment name.\n            val firstSegmentName = getSegmentName(0, context);\n            val firstSegmentHandle = s.openWrite(firstSegmentName).join();\n            AtomicLong firstSegmentLength = new AtomicLong(s.getStreamSegmentInfo(firstSegmentName,\n                    TIMEOUT).join().getLength());\n            assertThrows(\"concat() did not throw for non-existent target segment name.\",\n                    () -> s.concat(createHandle(\"foo1\", false), 0, firstSegmentHandle, TIMEOUT),\n                    ex -> ex instanceof StreamSegmentNotExistsException);\n\n            assertThrows(\"concat() did not throw for invalid source StreamSegment name.\",\n                    () -> s.concat(firstSegmentHandle, firstSegmentLength.get(), createHandle(\"foo2\", false), TIMEOUT),\n                    ex -> ex instanceof StreamSegmentNotExistsException);\n\n            ArrayList<String> concatOrder = new ArrayList<>();\n            concatOrder.add(firstSegmentName);\n            for (String sourceSegment : appendData.keySet()) {\n                if (sourceSegment.equals(firstSegmentName)) {\n                    // FirstSegment is where we'll be concatenating to.\n                    continue;\n                }\n\n                val sourceWriteHandle = s.openWrite(sourceSegment).join();\n                assertThrows(\"Concat allowed when source segment is not sealed.\",\n                        () -> s.concat(firstSegmentHandle, firstSegmentLength.get(), sourceWriteHandle, TIMEOUT),\n                        ex -> ex instanceof IllegalStateException);\n\n                // Seal the source segment and then re-try the concat\n                s.seal(sourceWriteHandle, TIMEOUT).join();\n                SegmentProperties preConcatTargetProps = s.getStreamSegmentInfo(firstSegmentName, TIMEOUT).join();\n                SegmentProperties sourceProps = s.getStreamSegmentInfo(sourceSegment, TIMEOUT).join();\n\n                s.concat(firstSegmentHandle, firstSegmentLength.get(), sourceWriteHandle, TIMEOUT).join();\n                concatOrder.add(sourceSegment);\n                SegmentProperties postConcatTargetProps = s.getStreamSegmentInfo(firstSegmentName, TIMEOUT).join();\n                Assert.assertFalse(\"concat() did not delete source segment\", s.exists(sourceSegment, TIMEOUT).join());\n\n                // Only check lengths here; we'll check the contents at the end.\n                Assert.assertEquals(\"Unexpected target StreamSegment.length after concatenation.\",\n                        preConcatTargetProps.getLength() + sourceProps.getLength(), postConcatTargetProps.getLength());\n                firstSegmentLength.set(postConcatTargetProps.getLength());\n            }\n\n            // Check the contents of the first StreamSegment. We already validated that the length is correct.\n            SegmentProperties segmentProperties = s.getStreamSegmentInfo(firstSegmentName, TIMEOUT).join();\n            byte[] readBuffer = new byte[(int) segmentProperties.getLength()];\n\n            // Read the entire StreamSegment.\n            int bytesRead = s.read(firstSegmentHandle, 0, readBuffer, 0, readBuffer.length, TIMEOUT).join();\n            Assert.assertEquals(\"Unexpected number of bytes read.\", readBuffer.length, bytesRead);\n\n            // Check, concat-by-concat, that the final data is correct.\n            int offset = 0;\n            for (String segmentName : concatOrder) {\n                byte[] concatData = appendData.get(segmentName).toByteArray();\n                AssertExtensions.assertArrayEquals(\"Unexpected concat data.\", concatData, 0, readBuffer, offset,\n                        concatData.length);\n                offset += concatData.length;\n            }\n\n            Assert.assertEquals(\"Concat included more bytes than expected.\", offset, readBuffer.length);\n        }\n    }",
            "method_tgt": "@Test\n    public void testConcat() throws Exception {\n        final String context = \"Concat\";\n        try (Storage s = createStorage()) {\n            s.initialize(DEFAULT_EPOCH);\n            HashMap<String, ByteArrayOutputStream> appendData = populate(s, context);\n\n            // Check invalid segment name.\n            val firstSegmentName = getSegmentName(0, context);\n            val firstSegmentHandle = s.openWrite(firstSegmentName).join();\n            AtomicLong firstSegmentLength = new AtomicLong(s.getStreamSegmentInfo(firstSegmentName,\n                    TIMEOUT).join().getLength());\n            assertThrows(\"concat() did not throw for non-existent target segment name.\",\n                    () -> s.concat(createHandle(\"foo1\", false, DEFAULT_EPOCH), 0, firstSegmentName, TIMEOUT),\n                    ex -> ex instanceof StreamSegmentNotExistsException);\n\n            assertThrows(\"concat() did not throw for invalid source StreamSegment name.\",\n                    () -> s.concat(firstSegmentHandle, firstSegmentLength.get(), \"foo2\", TIMEOUT),\n                    ex -> ex instanceof StreamSegmentNotExistsException);\n\n            ArrayList<String> concatOrder = new ArrayList<>();\n            concatOrder.add(firstSegmentName);\n            for (String sourceSegment : appendData.keySet()) {\n                if (sourceSegment.equals(firstSegmentName)) {\n                    // FirstSegment is where we'll be concatenating to.\n                    continue;\n                }\n\n                assertThrows(\"Concat allowed when source segment is not sealed.\",\n                        () -> s.concat(firstSegmentHandle, firstSegmentLength.get(), sourceSegment, TIMEOUT),\n                        ex -> ex instanceof IllegalStateException);\n\n                // Seal the source segment and then re-try the concat\n                val sourceWriteHandle = s.openWrite(sourceSegment).join();\n                s.seal(sourceWriteHandle, TIMEOUT).join();\n                SegmentProperties preConcatTargetProps = s.getStreamSegmentInfo(firstSegmentName, TIMEOUT).join();\n                SegmentProperties sourceProps = s.getStreamSegmentInfo(sourceSegment, TIMEOUT).join();\n\n                s.concat(firstSegmentHandle, firstSegmentLength.get(), sourceSegment, TIMEOUT).join();\n                concatOrder.add(sourceSegment);\n                SegmentProperties postConcatTargetProps = s.getStreamSegmentInfo(firstSegmentName, TIMEOUT).join();\n                Assert.assertFalse(\"concat() did not delete source segment\", s.exists(sourceSegment, TIMEOUT).join());\n\n                // Only check lengths here; we'll check the contents at the end.\n                Assert.assertEquals(\"Unexpected target StreamSegment.length after concatenation.\",\n                        preConcatTargetProps.getLength() + sourceProps.getLength(), postConcatTargetProps.getLength());\n                firstSegmentLength.set(postConcatTargetProps.getLength());\n            }\n\n            // Check the contents of the first StreamSegment. We already validated that the length is correct.\n            SegmentProperties segmentProperties = s.getStreamSegmentInfo(firstSegmentName, TIMEOUT).join();\n            byte[] readBuffer = new byte[(int) segmentProperties.getLength()];\n\n            // Read the entire StreamSegment.\n            int bytesRead = s.read(firstSegmentHandle, 0, readBuffer, 0, readBuffer.length, TIMEOUT).join();\n            Assert.assertEquals(\"Unexpected number of bytes read.\", readBuffer.length, bytesRead);\n\n            // Check, concat-by-concat, that the final data is correct.\n            int offset = 0;\n            for (String segmentName : concatOrder) {\n                byte[] concatData = appendData.get(segmentName).toByteArray();\n                AssertExtensions.assertArrayEquals(\"Unexpected concat data.\", concatData, 0, readBuffer, offset,\n                        concatData.length);\n                offset += concatData.length;\n            }\n\n            Assert.assertEquals(\"Concat included more bytes than expected.\", offset, readBuffer.length);\n        }\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        }
    },
    {
        "repo_name": "pravega/pravega",
        "commit_id": "0c2cdc8616e272f3dc4a5157cbce5ade38f12c58",
        "commit_url": "https://github.com/pravega/pravega/commit/0c2cdc8616e272f3dc4a5157cbce5ade38f12c58",
        "focal_db": {
            "id": "3287361",
            "rel_path": "segmentstore/storage/impl/src/main/java/io/pravega/segmentstore/storage/impl/bookkeeper/WriteQueue.java",
            "method_src": "synchronized boolean removeFinishedWrites() {\n        long currentTime = this.timeSupplier.get();\n        long totalElapsed = 0;\n        int removedCount = 0;\n        while (!this.writes.isEmpty() && this.writes.peekFirst().isDone()) {\n            Write w = this.writes.removeFirst();\n            this.totalLength = Math.max(0, this.totalLength - w.data.getLength());\n            removedCount++;\n            totalElapsed += currentTime - w.getTimestamp();\n        }\n\n        if (removedCount > 0) {\n            this.lastDurationMillis = (int) (totalElapsed / removedCount / AbstractTimer.NANOS_TO_MILLIS);\n        }\n\n        return !this.writes.isEmpty();\n    }",
            "method_tgt": "synchronized EnumSet<CleanupStatus> removeFinishedWrites() {\n        Exceptions.checkNotClosed(this.closed, this);\n        long currentTime = this.timeSupplier.get();\n        long totalElapsed = 0;\n        int removedCount = 0;\n        boolean failedWrite = false;\n        while (!this.writes.isEmpty() && this.writes.peekFirst().isDone()) {\n            Write w = this.writes.removeFirst();\n            this.totalLength = Math.max(0, this.totalLength - w.data.getLength());\n            removedCount++;\n            totalElapsed += currentTime - w.getTimestamp();\n            failedWrite |= w.getFailureCause() != null;\n        }\n\n        if (removedCount > 0) {\n            this.lastDurationMillis = (int) (totalElapsed / removedCount / AbstractTimer.NANOS_TO_MILLIS);\n        }\n\n        CleanupStatus empty = this.writes.isEmpty() ? CleanupStatus.QueueEmpty : CleanupStatus.QueueNotEmpty;\n        return failedWrite ? EnumSet.of(CleanupStatus.WriteFailed, empty) : EnumSet.of(empty);\n    }"
        },
        "test_db": {
            "id": "3287370",
            "rel_path": "segmentstore/storage/impl/src/test/java/io/pravega/segmentstore/storage/impl/bookkeeper/WriteQueueTests.java",
            "method_src": "@Test\n    public void testRemoveFinishedWrites() {\n        final int timeIncrement = 1234 * 1000; // Just over 1ms.\n        AtomicLong time = new AtomicLong();\n        val q = new WriteQueue(MAX_PARALLELISM, time::get);\n\n        val writes = new ArrayDeque<Write>();\n        for (int i = 0; i < ITEM_COUNT; i++) {\n            time.addAndGet(timeIncrement);\n            val w = new Write(new ByteArraySegment(new byte[i]), new TestWriteLedger(i), new CompletableFuture<>());\n            if (i % 2 == 0) {\n                // Complete 1 out of two writes.\n                w.complete(new TestLogAddress(i));\n            }\n\n            q.add(w);\n            writes.addLast(w);\n        }\n\n        while (!writes.isEmpty()) {\n            val write = writes.pollFirst();\n            if (!write.isDone()) {\n                boolean result1 = q.removeFinishedWrites();\n                Assert.assertTrue(\"Unexpected value from removeFinishedWrites when there were writes left in the queue.\", result1);\n                val stats1 = q.getStatistics();\n                Assert.assertEquals(\"Unexpected size after removeFinishedWrites with no effect.\", writes.size() + 1, stats1.getSize());\n\n                // Complete this write.\n                write.complete(new TestLogAddress(time.get()));\n            }\n\n            // Estimate the Expected elapsed time based on the removals.\n            long expectedElapsed = write.getTimestamp();\n            int removed = 1;\n            while (!writes.isEmpty() && writes.peekFirst().isDone()) {\n                expectedElapsed += writes.pollFirst().getTimestamp();\n                removed++;\n            }\n            expectedElapsed = (time.get() * removed - expectedElapsed) / AbstractTimer.NANOS_TO_MILLIS / removed;\n\n            boolean result2 = q.removeFinishedWrites();\n            Assert.assertEquals(\"Unexpected result from removeFinishedWrites.\", !writes.isEmpty(), result2);\n            val stats2 = q.getStatistics();\n            Assert.assertEquals(\"Unexpected size after removeFinishedWrites.\", writes.size(), stats2.getSize());\n            Assert.assertEquals(\"Unexpected getExpectedProcessingTimeMillis after clear.\", expectedElapsed, stats2.getExpectedProcessingTimeMillis());\n        }\n    }",
            "method_tgt": "@Test\n    public void testRemoveFinishedWrites() {\n        final int timeIncrement = 1234 * 1000; // Just over 1ms.\n        AtomicLong time = new AtomicLong();\n        val q = new WriteQueue(MAX_PARALLELISM, time::get);\n\n        val writes = new ArrayDeque<Write>();\n        for (int i = 0; i < ITEM_COUNT; i++) {\n            time.addAndGet(timeIncrement);\n            val w = new Write(new ByteArraySegment(new byte[i]), new TestWriteLedger(i), new CompletableFuture<>());\n            if (i % 2 == 0) {\n                // Complete 1 out of two writes.\n                w.setEntryId(i);\n                w.complete();\n            }\n\n            q.add(w);\n            writes.addLast(w);\n        }\n\n        while (!writes.isEmpty()) {\n            val write = writes.pollFirst();\n            if (!write.isDone()) {\n                val result1 = q.removeFinishedWrites();\n                AssertExtensions.assertContainsSameElements(\"Unexpected value from removeFinishedWrites when there were writes left in the queue.\",\n                        EnumSet.of(WriteQueue.CleanupStatus.QueueNotEmpty), result1);\n                val stats1 = q.getStatistics();\n                Assert.assertEquals(\"Unexpected size after removeFinishedWrites with no effect.\", writes.size() + 1, stats1.getSize());\n\n                // Complete this write.\n                write.setEntryId(time.get());\n                write.complete();\n            }\n\n            // Estimate the Expected elapsed time based on the removals.\n            long expectedElapsed = write.getTimestamp();\n            int removed = 1;\n            while (!writes.isEmpty() && writes.peekFirst().isDone()) {\n                expectedElapsed += writes.pollFirst().getTimestamp();\n                removed++;\n            }\n            expectedElapsed = (time.get() * removed - expectedElapsed) / AbstractTimer.NANOS_TO_MILLIS / removed;\n\n            val result2 = q.removeFinishedWrites();\n            val expectedResult = EnumSet.of(writes.isEmpty() ? WriteQueue.CleanupStatus.QueueEmpty : WriteQueue.CleanupStatus.QueueNotEmpty);\n            AssertExtensions.assertContainsSameElements(\"Unexpected result from removeFinishedWrites.\", expectedResult, result2);\n            val stats2 = q.getStatistics();\n            Assert.assertEquals(\"Unexpected size after removeFinishedWrites.\", writes.size(), stats2.getSize());\n            Assert.assertEquals(\"Unexpected getExpectedProcessingTimeMillis after clear.\", expectedElapsed, stats2.getExpectedProcessingTimeMillis());\n        }\n\n        // Verify that it does report failed writes when encountered.\n        val w3 = new Write(new ByteArraySegment(new byte[1]), new TestWriteLedger(0), new CompletableFuture<>());\n        q.add(w3);\n        w3.fail(new IntentionalException(), true);\n        val result3 = q.removeFinishedWrites();\n        AssertExtensions.assertContainsSameElements(\"Unexpected value from removeFinishedWrites when there were failed writes.\",\n                EnumSet.of(WriteQueue.CleanupStatus.QueueEmpty, WriteQueue.CleanupStatus.WriteFailed), result3);\n\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 0,
            "param_types": 0,
            "throw_types": 0
        },
        "aug": 1,
        "comment": "Case study hard"
    },
    {
        "repo_name": "springside/springside4",
        "commit_id": "4a3af887c465fc667af48da4e4214123cee4c85a",
        "commit_url": "https://github.com/springside/springside4/commit/4a3af887c465fc667af48da4e4214123cee4c85a",
        "focal_db": {
            "id": "3561544",
            "rel_path": "examples/showcase/src/main/java/org/springside/examples/showcase/webservice/soap/AccountWebServiceImpl.java",
            "method_src": "@Override\n\tpublic IdResponse createUser(UserDTO user) {\n\t\tIdResponse response = new IdResponse();\n\t\ttry {\n\t\t\tValidate.notNull(user, \"\u7528\u6237\u53c2\u6570\u4e3a\u7a7a\");\n\n\t\t\tUser userEntity = BeanMapper.map(user, User.class);\n\t\t\tBeanValidators.validateWithException(validator, userEntity);\n\n\t\t\taccountService.saveUser(userEntity);\n\n\t\t\treturn new IdResponse(userEntity.getId());\n\t\t} catch (ConstraintViolationException e) {\n\t\t\tString message = StringUtils.join(BeanValidators.extractPropertyAndMessageAsList(e, \" \"), \"\\n\");\n\t\t\treturn handleParameterError(response, e, message);\n\t\t} catch (RuntimeException e) {\n\t\t\tif (Exceptions.isCausedBy(e, org.hibernate.exception.ConstraintViolationException.class)) {\n\t\t\t\tString message = \"\u65b0\u5efa\u7528\u6237\u53c2\u6570\u5b58\u5728\u552f\u4e00\u6027\u51b2\u7a81(\u7528\u6237:\" + user + \")\";\n\t\t\t\treturn handleParameterError(response, e, message);\n\t\t\t} else {\n\t\t\t\treturn handleGeneralError(response, e);\n\t\t\t}\n\t\t}\n\t}",
            "method_tgt": "@Override\n\tpublic IdResult createUser(UserDTO user) {\n\t\tIdResult result = new IdResult();\n\t\ttry {\n\t\t\tValidate.notNull(user, \"\u7528\u6237\u53c2\u6570\u4e3a\u7a7a\");\n\n\t\t\tUser userEntity = BeanMapper.map(user, User.class);\n\t\t\tBeanValidators.validateWithException(validator, userEntity);\n\n\t\t\taccountService.saveUser(userEntity);\n\n\t\t\treturn new IdResult(userEntity.getId());\n\t\t} catch (ConstraintViolationException e) {\n\t\t\tString message = StringUtils.join(BeanValidators.extractPropertyAndMessageAsList(e, \" \"), \"\\n\");\n\t\t\treturn handleParameterError(result, e, message);\n\t\t} catch (RuntimeException e) {\n\t\t\tif (Exceptions.isCausedBy(e, org.hibernate.exception.ConstraintViolationException.class)) {\n\t\t\t\tString message = \"\u65b0\u5efa\u7528\u6237\u53c2\u6570\u5b58\u5728\u552f\u4e00\u6027\u51b2\u7a81(\u7528\u6237:\" + user + \")\";\n\t\t\t\treturn handleParameterError(result, e, message);\n\t\t\t} else {\n\t\t\t\treturn handleGeneralError(result, e);\n\t\t\t}\n\t\t}\n\t}"
        },
        "test_db": {
            "id": "3561553",
            "rel_path": "examples/showcase/src/test/functional/org/springside/examples/showcase/functional/soap/AccountWebServiceWithPredefineClientFT.java",
            "method_src": "@Test\n\tpublic void createUserWithInvalidLoginName() {\n\t\tUser user = UserData.randomUser();\n\t\tUserDTO userDTO = BeanMapper.map(user, UserDTO.class);\n\n\t\t//\u767b\u5f55\u540d\u4e3a\u7a7a\n\t\tuserDTO.setLoginName(null);\n\t\tIdResponse response = accountWebServiceClient.createUser(userDTO);\n\t\tassertEquals(WSResponse.PARAMETER_ERROR, response.getCode());\n\n\t\t//\u767b\u5f55\u540d\u91cd\u590d\n\t\tuserDTO.setLoginName(\"user\");\n\t\tresponse = accountWebServiceClient.createUser(userDTO);\n\t\tassertEquals(WSResponse.PARAMETER_ERROR, response.getCode());\n\t}",
            "method_tgt": "@Test\n\tpublic void createUserWithInvalidLoginName() {\n\t\tUser user = UserData.randomUser();\n\t\tUserDTO userDTO = BeanMapper.map(user, UserDTO.class);\n\n\t\t//\u767b\u5f55\u540d\u4e3a\u7a7a\n\t\tuserDTO.setLoginName(null);\n\t\tIdResult response = accountWebServiceClient.createUser(userDTO);\n\t\tassertEquals(WSResult.PARAMETER_ERROR, response.getCode());\n\n\t\t//\u767b\u5f55\u540d\u91cd\u590d\n\t\tuserDTO.setLoginName(\"user\");\n\t\tresponse = accountWebServiceClient.createUser(userDTO);\n\t\tassertEquals(WSResult.PARAMETER_ERROR, response.getCode());\n\t}"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 0,
            "param_types": 0,
            "throw_types": 0
        },
        "aug": 0
    },
    {
        "repo_name": "springside/springside4",
        "commit_id": "4a3af887c465fc667af48da4e4214123cee4c85a",
        "commit_url": "https://github.com/springside/springside4/commit/4a3af887c465fc667af48da4e4214123cee4c85a",
        "focal_db": {
            "id": "3561544",
            "rel_path": "examples/showcase/src/main/java/org/springside/examples/showcase/webservice/soap/AccountWebServiceImpl.java",
            "method_src": "@Override\n\tpublic GetUserResponse getUser(Long id) {\n\t\tGetUserResponse response = new GetUserResponse();\n\t\ttry {\n\n\t\t\tValidate.notNull(id, \"id\u53c2\u6570\u4e3a\u7a7a\");\n\n\t\t\tUser user = accountService.getUser(id);\n\n\t\t\tValidate.notNull(user, \"\u7528\u6237\u4e0d\u5b58\u5728(id:\" + id + \")\");\n\n\t\t\tUserDTO dto = BeanMapper.map(user, UserDTO.class);\n\t\t\tresponse.setUser(dto);\n\n\t\t\treturn response;\n\n\t\t} catch (IllegalArgumentException e) {\n\t\t\treturn handleParameterError(response, e);\n\t\t} catch (RuntimeException e) {\n\t\t\treturn handleGeneralError(response, e);\n\t\t}\n\t}",
            "method_tgt": "@Override\n\tpublic GetUserResult getUser(Long id) {\n\t\tGetUserResult result = new GetUserResult();\n\t\ttry {\n\n\t\t\tValidate.notNull(id, \"id\u53c2\u6570\u4e3a\u7a7a\");\n\n\t\t\tUser user = accountService.getUser(id);\n\n\t\t\tValidate.notNull(user, \"\u7528\u6237\u4e0d\u5b58\u5728(id:\" + id + \")\");\n\n\t\t\tUserDTO dto = BeanMapper.map(user, UserDTO.class);\n\t\t\tresult.setUser(dto);\n\n\t\t\treturn result;\n\n\t\t} catch (IllegalArgumentException e) {\n\t\t\treturn handleParameterError(result, e);\n\t\t} catch (RuntimeException e) {\n\t\t\treturn handleGeneralError(result, e);\n\t\t}\n\t}"
        },
        "test_db": {
            "id": "3561553",
            "rel_path": "examples/showcase/src/test/functional/org/springside/examples/showcase/functional/soap/AccountWebServiceWithPredefineClientFT.java",
            "method_src": "@Test\n\t@Category(Smoke.class)\n\tpublic void getUser() {\n\t\tGetUserResponse response = accountWebServiceClient.getUser(1L);\n\t\tassertEquals(\"admin\", response.getUser().getLoginName());\n\t}",
            "method_tgt": "@Test\n\t@Category(Smoke.class)\n\tpublic void getUser() {\n\t\tGetUserResult response = accountWebServiceClient.getUser(1L);\n\t\tassertEquals(\"admin\", response.getUser().getLoginName());\n\t}"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 0,
            "param_types": 0,
            "throw_types": 0
        },
        "aug": 1
    },
    {
        "repo_name": "strimzi/strimzi-kafka-operator",
        "commit_id": "c80df3256f3cc92559f8a6aad6a1fb9e30228061",
        "commit_url": "https://github.com/strimzi/strimzi-kafka-operator/commit/c80df3256f3cc92559f8a6aad6a1fb9e30228061",
        "focal_db": {
            "id": "5382851",
            "rel_path": "topic-operator/src/main/java/io/strimzi/operator/topic/OperatorAssignedKafkaImpl.java",
            "method_src": "@Override\n    public void changeReplicationFactor(Topic topic, Handler<AsyncResult<Void>> handler) {\n\n        LOGGER.info(\"Changing replication factor of topic {} to {}\", topic.getTopicName(), topic.getNumReplicas());\n\n        final String zookeeper = config.get(Config.ZOOKEEPER_CONNECT);\n        Future<File> generateFuture = Future.future();\n\n        // generate a reassignment\n        vertx.executeBlocking(fut -> {\n            try {\n                LOGGER.debug(\"Generating reassignment json for topic {}\", topic.getTopicName());\n                String reassignment = generateReassignment(topic, zookeeper);\n                LOGGER.debug(\"Reassignment json for topic {}: {}\", topic.getTopicName(), reassignment);\n                File reassignmentJsonFile = ProcessHelper.createTmpFile(\"-reassignment.json\");\n                try (Writer w = new OutputStreamWriter(new FileOutputStream(reassignmentJsonFile), StandardCharsets.UTF_8)) {\n                    w.write(reassignment);\n                }\n                fut.complete(reassignmentJsonFile);\n            } catch (Exception e) {\n                fut.fail(e);\n            }\n        },\n            generateFuture);\n\n        Future<File> executeFuture = Future.future();\n\n        generateFuture.compose(reassignmentJsonFile -> {\n            // execute the reassignment\n            vertx.executeBlocking(fut -> {\n                final Long throttle = config.get(Config.REASSIGN_THROTTLE);\n                try {\n                    LOGGER.debug(\"Starting reassignment for topic {} with throttle {}\", topic.getTopicName(), throttle);\n                    executeReassignment(reassignmentJsonFile, zookeeper, throttle);\n                    fut.complete(reassignmentJsonFile);\n                } catch (Exception e) {\n                    fut.fail(e);\n                }\n            },\n                executeFuture);\n        }, executeFuture);\n\n        Future<Void> periodicFuture = Future.future();\n        Future<Void> reassignmentFinishedFuture = Future.future();\n\n        executeFuture.compose(reassignmentJsonFile -> {\n            // Poll repeatedly, calling --verify to remove the throttle\n            long timeout = 10_000;\n            long first = System.currentTimeMillis();\n            final Long periodMs = config.get(Config.REASSIGN_VERIFY_INTERVAL_MS);\n            LOGGER.debug(\"Verifying reassignment every {} seconds\", TimeUnit.SECONDS.convert(periodMs, TimeUnit.MILLISECONDS));\n            vertx.setPeriodic(periodMs, timerId ->\n                vertx.<Boolean>executeBlocking(fut -> {\n                    LOGGER.debug(String.format(\"Verifying reassignment for topic {} (timer id=%s)\", topic.getTopicName(), timerId));\n\n                    final Long throttle = config.get(Config.REASSIGN_THROTTLE);\n                    final boolean reassignmentComplete;\n                    try {\n                        reassignmentComplete = verifyReassignment(reassignmentJsonFile, zookeeper, throttle);\n                    } catch (Exception e) {\n                        fut.fail(e);\n                        return;\n                    }\n                    fut.complete(reassignmentComplete);\n                },\n                    ar -> {\n                        if (ar.succeeded()) {\n                            if (ar.result()) {\n                                LOGGER.info(\"Reassignment complete\");\n                                ProcessHelper.delete(reassignmentJsonFile);\n                                LOGGER.debug(\"Cancelling timer \" + timerId);\n                                vertx.cancelTimer(timerId);\n                                reassignmentFinishedFuture.complete();\n                            } else if (System.currentTimeMillis() - first > timeout) {\n                                LOGGER.error(\"Reassignment timed out\");\n                                ProcessHelper.delete(reassignmentJsonFile);\n                                LOGGER.debug(\"Cancelling timer \" + timerId);\n                                vertx.cancelTimer(timerId);\n                                reassignmentFinishedFuture.fail(\"Timeout\");\n                            }\n                        } else {\n                            //reassignmentFinishedFuture.fail(ar.cause());\n                            LOGGER.error(\"Error while verifying reassignment\", ar.cause());\n                        }\n                    }\n                )\n            );\n            periodicFuture.complete();\n        },\n            periodicFuture);\n\n\n        CompositeFuture.all(periodicFuture, reassignmentFinishedFuture).map((Void) null).setHandler(handler);\n\n        // TODO The algorithm should really be more like this:\n        // 1. Use the cmdline tool to generate an assignment\n        // 2. Set the throttles\n        // 3. Update the reassign_partitions znode\n        // 4. Watch for changes or deletion of reassign_partitions\n        //    a. Update the throttles\n        //    b. complete the handler\n        // Doing this is much better because means we don't have to batch reassignments\n        // and also means we need less state for reassignment\n        // though we aren't relieved of the statefullness wrt removing throttles :-(\n    }",
            "method_tgt": "@Override\n    public Future<Void> changeReplicationFactor(Topic topic) {\n        Future<Void> handler = Future.future();\n\n        LOGGER.info(\"Changing replication factor of topic {} to {}\", topic.getTopicName(), topic.getNumReplicas());\n\n        final String zookeeper = config.get(Config.ZOOKEEPER_CONNECT);\n        Future<File> generateFuture = Future.future();\n\n        // generate a reassignment\n        vertx.executeBlocking(fut -> {\n            try {\n                LOGGER.debug(\"Generating reassignment json for topic {}\", topic.getTopicName());\n                String reassignment = generateReassignment(topic, zookeeper);\n                LOGGER.debug(\"Reassignment json for topic {}: {}\", topic.getTopicName(), reassignment);\n                File reassignmentJsonFile = ProcessHelper.createTmpFile(\"-reassignment.json\");\n                try (Writer w = new OutputStreamWriter(new FileOutputStream(reassignmentJsonFile), StandardCharsets.UTF_8)) {\n                    w.write(reassignment);\n                }\n                fut.complete(reassignmentJsonFile);\n            } catch (Exception e) {\n                fut.fail(e);\n            }\n        },\n            generateFuture);\n\n        Future<File> executeFuture = Future.future();\n\n        generateFuture.compose(reassignmentJsonFile -> {\n            // execute the reassignment\n            vertx.executeBlocking(fut -> {\n                final Long throttle = config.get(Config.REASSIGN_THROTTLE);\n                try {\n                    LOGGER.debug(\"Starting reassignment for topic {} with throttle {}\", topic.getTopicName(), throttle);\n                    executeReassignment(reassignmentJsonFile, zookeeper, throttle);\n                    fut.complete(reassignmentJsonFile);\n                } catch (Exception e) {\n                    fut.fail(e);\n                }\n            },\n                executeFuture);\n        }, executeFuture);\n\n        Future<Void> periodicFuture = Future.future();\n        Future<Void> reassignmentFinishedFuture = Future.future();\n\n        executeFuture.compose(reassignmentJsonFile -> {\n            // Poll repeatedly, calling --verify to remove the throttle\n            long timeout = 10_000;\n            long first = System.currentTimeMillis();\n            final Long periodMs = config.get(Config.REASSIGN_VERIFY_INTERVAL_MS);\n            LOGGER.debug(\"Verifying reassignment every {} seconds\", TimeUnit.SECONDS.convert(periodMs, TimeUnit.MILLISECONDS));\n            vertx.setPeriodic(periodMs, timerId ->\n                vertx.<Boolean>executeBlocking(fut -> {\n                    LOGGER.debug(String.format(\"Verifying reassignment for topic {} (timer id=%s)\", topic.getTopicName(), timerId));\n\n                    final Long throttle = config.get(Config.REASSIGN_THROTTLE);\n                    final boolean reassignmentComplete;\n                    try {\n                        reassignmentComplete = verifyReassignment(reassignmentJsonFile, zookeeper, throttle);\n                    } catch (Exception e) {\n                        fut.fail(e);\n                        return;\n                    }\n                    fut.complete(reassignmentComplete);\n                },\n                    ar -> {\n                        if (ar.succeeded()) {\n                            if (ar.result()) {\n                                LOGGER.info(\"Reassignment complete\");\n                                ProcessHelper.delete(reassignmentJsonFile);\n                                LOGGER.debug(\"Cancelling timer \" + timerId);\n                                vertx.cancelTimer(timerId);\n                                reassignmentFinishedFuture.complete();\n                            } else if (System.currentTimeMillis() - first > timeout) {\n                                LOGGER.error(\"Reassignment timed out\");\n                                ProcessHelper.delete(reassignmentJsonFile);\n                                LOGGER.debug(\"Cancelling timer \" + timerId);\n                                vertx.cancelTimer(timerId);\n                                reassignmentFinishedFuture.fail(\"Timeout\");\n                            }\n                        } else {\n                            //reassignmentFinishedFuture.fail(ar.cause());\n                            LOGGER.error(\"Error while verifying reassignment\", ar.cause());\n                        }\n                    }\n                )\n            );\n            periodicFuture.complete();\n        },\n            periodicFuture);\n\n\n        CompositeFuture.all(periodicFuture, reassignmentFinishedFuture).map((Void) null).setHandler(handler);\n        return handler;\n        // TODO The algorithm should really be more like this:\n        // 1. Use the cmdline tool to generate an assignment\n        // 2. Set the throttles\n        // 3. Update the reassign_partitions znode\n        // 4. Watch for changes or deletion of reassign_partitions\n        //    a. Update the throttles\n        //    b. complete the handler\n        // Doing this is much better because means we don't have to batch reassignments\n        // and also means we need less state for reassignment\n        // though we aren't relieved of the statefullness wrt removing throttles :-(\n    }"
        },
        "test_db": {
            "id": "5382861",
            "rel_path": "topic-operator/src/test/java/io/strimzi/operator/topic/TopicOperatorAssignedKafkaImplTest.java",
            "method_src": "@Test\n    public void changeReplicationFactor_missingExecutable(TestContext context) {\n        MockAdminClient adminClient = new MockAdminClient();\n        Vertx vertx = Vertx.vertx();\n        Topic topic = new Topic.Builder(\"changeReplicationFactor\", 2, (short) 2, emptyMap()).build();\n        String[] partitions = new String[]{\"changeReplicationFactor-0\", \"changeReplicationFactor-1\"};\n        final String doesNotExist = \"/some/executable/that/does/not/exist\";\n        Subclass sub = new Subclass(adminClient, vertx, config, doesNotExist, asList(\n                Subclass.generate(\"{\\\"version\\\":1,\\\"partitions\\\":[{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":0,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]},{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":1,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]}]}\",\n                        \"{\\\"version\\\":1,\\\"partitions\\\":[{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":0,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]},{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":1,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]}]}\"),\n                Subclass.executeStarted(),\n                Subclass.verifyInProgress(partitions),\n                Subclass.verifySuccess(partitions)));\n        Async async = context.async();\n        sub.changeReplicationFactor(topic, ar -> {\n            context.assertFalse(ar.succeeded());\n            final String message = ar.cause().getMessage();\n            context.assertTrue(message.contains(\"lacks an executable arg[0]\")\n                    && message.contains(\"/some/executable/that/does/not/exist\"));\n            async.complete();\n        });\n    }",
            "method_tgt": "@Test\n    public void changeReplicationFactor_missingExecutable(TestContext context) {\n        MockAdminClient adminClient = new MockAdminClient();\n        Vertx vertx = Vertx.vertx();\n        Topic topic = new Topic.Builder(\"changeReplicationFactor\", 2, (short) 2, emptyMap()).build();\n        String[] partitions = new String[]{\"changeReplicationFactor-0\", \"changeReplicationFactor-1\"};\n        final String doesNotExist = \"/some/executable/that/does/not/exist\";\n        Subclass sub = new Subclass(adminClient, vertx, config, doesNotExist, asList(\n                Subclass.generate(\"{\\\"version\\\":1,\\\"partitions\\\":[{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":0,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]},{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":1,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]}]}\",\n                        \"{\\\"version\\\":1,\\\"partitions\\\":[{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":0,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]},{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":1,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]}]}\"),\n                Subclass.executeStarted(),\n                Subclass.verifyInProgress(partitions),\n                Subclass.verifySuccess(partitions)));\n        Async async = context.async();\n        sub.changeReplicationFactor(topic).setHandler(ar -> {\n            context.assertFalse(ar.succeeded());\n            final String message = ar.cause().getMessage();\n            context.assertTrue(message.contains(\"lacks an executable arg[0]\")\n                    && message.contains(\"/some/executable/that/does/not/exist\"));\n            async.complete();\n        });\n    }"
        },
        "syn_diff": {
            "overall": 2,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 1
    },
    {
        "repo_name": "strimzi/strimzi-kafka-operator",
        "commit_id": "c80df3256f3cc92559f8a6aad6a1fb9e30228061",
        "commit_url": "https://github.com/strimzi/strimzi-kafka-operator/commit/c80df3256f3cc92559f8a6aad6a1fb9e30228061",
        "focal_db": {
            "id": "5382851",
            "rel_path": "topic-operator/src/main/java/io/strimzi/operator/topic/OperatorAssignedKafkaImpl.java",
            "method_src": "@Override\n    public void changeReplicationFactor(Topic topic, Handler<AsyncResult<Void>> handler) {\n\n        LOGGER.info(\"Changing replication factor of topic {} to {}\", topic.getTopicName(), topic.getNumReplicas());\n\n        final String zookeeper = config.get(Config.ZOOKEEPER_CONNECT);\n        Future<File> generateFuture = Future.future();\n\n        // generate a reassignment\n        vertx.executeBlocking(fut -> {\n            try {\n                LOGGER.debug(\"Generating reassignment json for topic {}\", topic.getTopicName());\n                String reassignment = generateReassignment(topic, zookeeper);\n                LOGGER.debug(\"Reassignment json for topic {}: {}\", topic.getTopicName(), reassignment);\n                File reassignmentJsonFile = ProcessHelper.createTmpFile(\"-reassignment.json\");\n                try (Writer w = new OutputStreamWriter(new FileOutputStream(reassignmentJsonFile), StandardCharsets.UTF_8)) {\n                    w.write(reassignment);\n                }\n                fut.complete(reassignmentJsonFile);\n            } catch (Exception e) {\n                fut.fail(e);\n            }\n        },\n            generateFuture);\n\n        Future<File> executeFuture = Future.future();\n\n        generateFuture.compose(reassignmentJsonFile -> {\n            // execute the reassignment\n            vertx.executeBlocking(fut -> {\n                final Long throttle = config.get(Config.REASSIGN_THROTTLE);\n                try {\n                    LOGGER.debug(\"Starting reassignment for topic {} with throttle {}\", topic.getTopicName(), throttle);\n                    executeReassignment(reassignmentJsonFile, zookeeper, throttle);\n                    fut.complete(reassignmentJsonFile);\n                } catch (Exception e) {\n                    fut.fail(e);\n                }\n            },\n                executeFuture);\n        }, executeFuture);\n\n        Future<Void> periodicFuture = Future.future();\n        Future<Void> reassignmentFinishedFuture = Future.future();\n\n        executeFuture.compose(reassignmentJsonFile -> {\n            // Poll repeatedly, calling --verify to remove the throttle\n            long timeout = 10_000;\n            long first = System.currentTimeMillis();\n            final Long periodMs = config.get(Config.REASSIGN_VERIFY_INTERVAL_MS);\n            LOGGER.debug(\"Verifying reassignment every {} seconds\", TimeUnit.SECONDS.convert(periodMs, TimeUnit.MILLISECONDS));\n            vertx.setPeriodic(periodMs, timerId ->\n                vertx.<Boolean>executeBlocking(fut -> {\n                    LOGGER.debug(String.format(\"Verifying reassignment for topic {} (timer id=%s)\", topic.getTopicName(), timerId));\n\n                    final Long throttle = config.get(Config.REASSIGN_THROTTLE);\n                    final boolean reassignmentComplete;\n                    try {\n                        reassignmentComplete = verifyReassignment(reassignmentJsonFile, zookeeper, throttle);\n                    } catch (Exception e) {\n                        fut.fail(e);\n                        return;\n                    }\n                    fut.complete(reassignmentComplete);\n                },\n                    ar -> {\n                        if (ar.succeeded()) {\n                            if (ar.result()) {\n                                LOGGER.info(\"Reassignment complete\");\n                                ProcessHelper.delete(reassignmentJsonFile);\n                                LOGGER.debug(\"Cancelling timer \" + timerId);\n                                vertx.cancelTimer(timerId);\n                                reassignmentFinishedFuture.complete();\n                            } else if (System.currentTimeMillis() - first > timeout) {\n                                LOGGER.error(\"Reassignment timed out\");\n                                ProcessHelper.delete(reassignmentJsonFile);\n                                LOGGER.debug(\"Cancelling timer \" + timerId);\n                                vertx.cancelTimer(timerId);\n                                reassignmentFinishedFuture.fail(\"Timeout\");\n                            }\n                        } else {\n                            //reassignmentFinishedFuture.fail(ar.cause());\n                            LOGGER.error(\"Error while verifying reassignment\", ar.cause());\n                        }\n                    }\n                )\n            );\n            periodicFuture.complete();\n        },\n            periodicFuture);\n\n\n        CompositeFuture.all(periodicFuture, reassignmentFinishedFuture).map((Void) null).setHandler(handler);\n\n        // TODO The algorithm should really be more like this:\n        // 1. Use the cmdline tool to generate an assignment\n        // 2. Set the throttles\n        // 3. Update the reassign_partitions znode\n        // 4. Watch for changes or deletion of reassign_partitions\n        //    a. Update the throttles\n        //    b. complete the handler\n        // Doing this is much better because means we don't have to batch reassignments\n        // and also means we need less state for reassignment\n        // though we aren't relieved of the statefullness wrt removing throttles :-(\n    }",
            "method_tgt": "@Override\n    public Future<Void> changeReplicationFactor(Topic topic) {\n        Future<Void> handler = Future.future();\n\n        LOGGER.info(\"Changing replication factor of topic {} to {}\", topic.getTopicName(), topic.getNumReplicas());\n\n        final String zookeeper = config.get(Config.ZOOKEEPER_CONNECT);\n        Future<File> generateFuture = Future.future();\n\n        // generate a reassignment\n        vertx.executeBlocking(fut -> {\n            try {\n                LOGGER.debug(\"Generating reassignment json for topic {}\", topic.getTopicName());\n                String reassignment = generateReassignment(topic, zookeeper);\n                LOGGER.debug(\"Reassignment json for topic {}: {}\", topic.getTopicName(), reassignment);\n                File reassignmentJsonFile = ProcessHelper.createTmpFile(\"-reassignment.json\");\n                try (Writer w = new OutputStreamWriter(new FileOutputStream(reassignmentJsonFile), StandardCharsets.UTF_8)) {\n                    w.write(reassignment);\n                }\n                fut.complete(reassignmentJsonFile);\n            } catch (Exception e) {\n                fut.fail(e);\n            }\n        },\n            generateFuture);\n\n        Future<File> executeFuture = Future.future();\n\n        generateFuture.compose(reassignmentJsonFile -> {\n            // execute the reassignment\n            vertx.executeBlocking(fut -> {\n                final Long throttle = config.get(Config.REASSIGN_THROTTLE);\n                try {\n                    LOGGER.debug(\"Starting reassignment for topic {} with throttle {}\", topic.getTopicName(), throttle);\n                    executeReassignment(reassignmentJsonFile, zookeeper, throttle);\n                    fut.complete(reassignmentJsonFile);\n                } catch (Exception e) {\n                    fut.fail(e);\n                }\n            },\n                executeFuture);\n        }, executeFuture);\n\n        Future<Void> periodicFuture = Future.future();\n        Future<Void> reassignmentFinishedFuture = Future.future();\n\n        executeFuture.compose(reassignmentJsonFile -> {\n            // Poll repeatedly, calling --verify to remove the throttle\n            long timeout = 10_000;\n            long first = System.currentTimeMillis();\n            final Long periodMs = config.get(Config.REASSIGN_VERIFY_INTERVAL_MS);\n            LOGGER.debug(\"Verifying reassignment every {} seconds\", TimeUnit.SECONDS.convert(periodMs, TimeUnit.MILLISECONDS));\n            vertx.setPeriodic(periodMs, timerId ->\n                vertx.<Boolean>executeBlocking(fut -> {\n                    LOGGER.debug(String.format(\"Verifying reassignment for topic {} (timer id=%s)\", topic.getTopicName(), timerId));\n\n                    final Long throttle = config.get(Config.REASSIGN_THROTTLE);\n                    final boolean reassignmentComplete;\n                    try {\n                        reassignmentComplete = verifyReassignment(reassignmentJsonFile, zookeeper, throttle);\n                    } catch (Exception e) {\n                        fut.fail(e);\n                        return;\n                    }\n                    fut.complete(reassignmentComplete);\n                },\n                    ar -> {\n                        if (ar.succeeded()) {\n                            if (ar.result()) {\n                                LOGGER.info(\"Reassignment complete\");\n                                ProcessHelper.delete(reassignmentJsonFile);\n                                LOGGER.debug(\"Cancelling timer \" + timerId);\n                                vertx.cancelTimer(timerId);\n                                reassignmentFinishedFuture.complete();\n                            } else if (System.currentTimeMillis() - first > timeout) {\n                                LOGGER.error(\"Reassignment timed out\");\n                                ProcessHelper.delete(reassignmentJsonFile);\n                                LOGGER.debug(\"Cancelling timer \" + timerId);\n                                vertx.cancelTimer(timerId);\n                                reassignmentFinishedFuture.fail(\"Timeout\");\n                            }\n                        } else {\n                            //reassignmentFinishedFuture.fail(ar.cause());\n                            LOGGER.error(\"Error while verifying reassignment\", ar.cause());\n                        }\n                    }\n                )\n            );\n            periodicFuture.complete();\n        },\n            periodicFuture);\n\n\n        CompositeFuture.all(periodicFuture, reassignmentFinishedFuture).map((Void) null).setHandler(handler);\n        return handler;\n        // TODO The algorithm should really be more like this:\n        // 1. Use the cmdline tool to generate an assignment\n        // 2. Set the throttles\n        // 3. Update the reassign_partitions znode\n        // 4. Watch for changes or deletion of reassign_partitions\n        //    a. Update the throttles\n        //    b. complete the handler\n        // Doing this is much better because means we don't have to batch reassignments\n        // and also means we need less state for reassignment\n        // though we aren't relieved of the statefullness wrt removing throttles :-(\n    }"
        },
        "test_db": {
            "id": "5382861",
            "rel_path": "topic-operator/src/test/java/io/strimzi/operator/topic/TopicOperatorAssignedKafkaImplTest.java",
            "method_src": "@Test\n    public void changeReplicationFactor(TestContext context) {\n        MockAdminClient adminClient = new MockAdminClient();\n        Vertx vertx = Vertx.vertx();\n        Topic topic = new Topic.Builder(\"changeReplicationFactor\", 2, (short) 2, emptyMap()).build();\n        String[] partitions = new String[]{\"changeReplicationFactor-0\", \"changeReplicationFactor-1\"};\n        Subclass sub = new Subclass(adminClient, vertx, config, asList(\n                Subclass.generate(\"{\\\"version\\\":1,\\\"partitions\\\":[{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":0,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]},{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":1,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]}]}\",\n                        \"{\\\"version\\\":1,\\\"partitions\\\":[{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":0,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]},{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":1,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]}]}\"),\n                Subclass.executeStarted(),\n                Subclass.verifyInProgress(partitions),\n                Subclass.verifySuccess(partitions)));\n        Async async = context.async();\n        sub.changeReplicationFactor(topic, ar -> {\n            context.assertTrue(ar.succeeded());\n            async.complete();\n        });\n    }",
            "method_tgt": "@Test\n    public void changeReplicationFactor(TestContext context) {\n        MockAdminClient adminClient = new MockAdminClient();\n        Vertx vertx = Vertx.vertx();\n        Topic topic = new Topic.Builder(\"changeReplicationFactor\", 2, (short) 2, emptyMap()).build();\n        String[] partitions = new String[]{\"changeReplicationFactor-0\", \"changeReplicationFactor-1\"};\n        Subclass sub = new Subclass(adminClient, vertx, config, asList(\n                Subclass.generate(\"{\\\"version\\\":1,\\\"partitions\\\":[{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":0,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]},{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":1,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]}]}\",\n                        \"{\\\"version\\\":1,\\\"partitions\\\":[{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":0,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]},{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":1,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]}]}\"),\n                Subclass.executeStarted(),\n                Subclass.verifyInProgress(partitions),\n                Subclass.verifySuccess(partitions)));\n        Async async = context.async();\n        sub.changeReplicationFactor(topic).setHandler(ar -> {\n            context.assertTrue(ar.succeeded());\n            async.complete();\n        });\n    }"
        },
        "syn_diff": {
            "overall": 2,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 2
    },
    {
        "repo_name": "strimzi/strimzi-kafka-operator",
        "commit_id": "c80df3256f3cc92559f8a6aad6a1fb9e30228061",
        "commit_url": "https://github.com/strimzi/strimzi-kafka-operator/commit/c80df3256f3cc92559f8a6aad6a1fb9e30228061",
        "focal_db": {
            "id": "5382851",
            "rel_path": "topic-operator/src/main/java/io/strimzi/operator/topic/OperatorAssignedKafkaImpl.java",
            "method_src": "@Override\n    public void changeReplicationFactor(Topic topic, Handler<AsyncResult<Void>> handler) {\n\n        LOGGER.info(\"Changing replication factor of topic {} to {}\", topic.getTopicName(), topic.getNumReplicas());\n\n        final String zookeeper = config.get(Config.ZOOKEEPER_CONNECT);\n        Future<File> generateFuture = Future.future();\n\n        // generate a reassignment\n        vertx.executeBlocking(fut -> {\n            try {\n                LOGGER.debug(\"Generating reassignment json for topic {}\", topic.getTopicName());\n                String reassignment = generateReassignment(topic, zookeeper);\n                LOGGER.debug(\"Reassignment json for topic {}: {}\", topic.getTopicName(), reassignment);\n                File reassignmentJsonFile = ProcessHelper.createTmpFile(\"-reassignment.json\");\n                try (Writer w = new OutputStreamWriter(new FileOutputStream(reassignmentJsonFile), StandardCharsets.UTF_8)) {\n                    w.write(reassignment);\n                }\n                fut.complete(reassignmentJsonFile);\n            } catch (Exception e) {\n                fut.fail(e);\n            }\n        },\n            generateFuture);\n\n        Future<File> executeFuture = Future.future();\n\n        generateFuture.compose(reassignmentJsonFile -> {\n            // execute the reassignment\n            vertx.executeBlocking(fut -> {\n                final Long throttle = config.get(Config.REASSIGN_THROTTLE);\n                try {\n                    LOGGER.debug(\"Starting reassignment for topic {} with throttle {}\", topic.getTopicName(), throttle);\n                    executeReassignment(reassignmentJsonFile, zookeeper, throttle);\n                    fut.complete(reassignmentJsonFile);\n                } catch (Exception e) {\n                    fut.fail(e);\n                }\n            },\n                executeFuture);\n        }, executeFuture);\n\n        Future<Void> periodicFuture = Future.future();\n        Future<Void> reassignmentFinishedFuture = Future.future();\n\n        executeFuture.compose(reassignmentJsonFile -> {\n            // Poll repeatedly, calling --verify to remove the throttle\n            long timeout = 10_000;\n            long first = System.currentTimeMillis();\n            final Long periodMs = config.get(Config.REASSIGN_VERIFY_INTERVAL_MS);\n            LOGGER.debug(\"Verifying reassignment every {} seconds\", TimeUnit.SECONDS.convert(periodMs, TimeUnit.MILLISECONDS));\n            vertx.setPeriodic(periodMs, timerId ->\n                vertx.<Boolean>executeBlocking(fut -> {\n                    LOGGER.debug(String.format(\"Verifying reassignment for topic {} (timer id=%s)\", topic.getTopicName(), timerId));\n\n                    final Long throttle = config.get(Config.REASSIGN_THROTTLE);\n                    final boolean reassignmentComplete;\n                    try {\n                        reassignmentComplete = verifyReassignment(reassignmentJsonFile, zookeeper, throttle);\n                    } catch (Exception e) {\n                        fut.fail(e);\n                        return;\n                    }\n                    fut.complete(reassignmentComplete);\n                },\n                    ar -> {\n                        if (ar.succeeded()) {\n                            if (ar.result()) {\n                                LOGGER.info(\"Reassignment complete\");\n                                ProcessHelper.delete(reassignmentJsonFile);\n                                LOGGER.debug(\"Cancelling timer \" + timerId);\n                                vertx.cancelTimer(timerId);\n                                reassignmentFinishedFuture.complete();\n                            } else if (System.currentTimeMillis() - first > timeout) {\n                                LOGGER.error(\"Reassignment timed out\");\n                                ProcessHelper.delete(reassignmentJsonFile);\n                                LOGGER.debug(\"Cancelling timer \" + timerId);\n                                vertx.cancelTimer(timerId);\n                                reassignmentFinishedFuture.fail(\"Timeout\");\n                            }\n                        } else {\n                            //reassignmentFinishedFuture.fail(ar.cause());\n                            LOGGER.error(\"Error while verifying reassignment\", ar.cause());\n                        }\n                    }\n                )\n            );\n            periodicFuture.complete();\n        },\n            periodicFuture);\n\n\n        CompositeFuture.all(periodicFuture, reassignmentFinishedFuture).map((Void) null).setHandler(handler);\n\n        // TODO The algorithm should really be more like this:\n        // 1. Use the cmdline tool to generate an assignment\n        // 2. Set the throttles\n        // 3. Update the reassign_partitions znode\n        // 4. Watch for changes or deletion of reassign_partitions\n        //    a. Update the throttles\n        //    b. complete the handler\n        // Doing this is much better because means we don't have to batch reassignments\n        // and also means we need less state for reassignment\n        // though we aren't relieved of the statefullness wrt removing throttles :-(\n    }",
            "method_tgt": "@Override\n    public Future<Void> changeReplicationFactor(Topic topic) {\n        Future<Void> handler = Future.future();\n\n        LOGGER.info(\"Changing replication factor of topic {} to {}\", topic.getTopicName(), topic.getNumReplicas());\n\n        final String zookeeper = config.get(Config.ZOOKEEPER_CONNECT);\n        Future<File> generateFuture = Future.future();\n\n        // generate a reassignment\n        vertx.executeBlocking(fut -> {\n            try {\n                LOGGER.debug(\"Generating reassignment json for topic {}\", topic.getTopicName());\n                String reassignment = generateReassignment(topic, zookeeper);\n                LOGGER.debug(\"Reassignment json for topic {}: {}\", topic.getTopicName(), reassignment);\n                File reassignmentJsonFile = ProcessHelper.createTmpFile(\"-reassignment.json\");\n                try (Writer w = new OutputStreamWriter(new FileOutputStream(reassignmentJsonFile), StandardCharsets.UTF_8)) {\n                    w.write(reassignment);\n                }\n                fut.complete(reassignmentJsonFile);\n            } catch (Exception e) {\n                fut.fail(e);\n            }\n        },\n            generateFuture);\n\n        Future<File> executeFuture = Future.future();\n\n        generateFuture.compose(reassignmentJsonFile -> {\n            // execute the reassignment\n            vertx.executeBlocking(fut -> {\n                final Long throttle = config.get(Config.REASSIGN_THROTTLE);\n                try {\n                    LOGGER.debug(\"Starting reassignment for topic {} with throttle {}\", topic.getTopicName(), throttle);\n                    executeReassignment(reassignmentJsonFile, zookeeper, throttle);\n                    fut.complete(reassignmentJsonFile);\n                } catch (Exception e) {\n                    fut.fail(e);\n                }\n            },\n                executeFuture);\n        }, executeFuture);\n\n        Future<Void> periodicFuture = Future.future();\n        Future<Void> reassignmentFinishedFuture = Future.future();\n\n        executeFuture.compose(reassignmentJsonFile -> {\n            // Poll repeatedly, calling --verify to remove the throttle\n            long timeout = 10_000;\n            long first = System.currentTimeMillis();\n            final Long periodMs = config.get(Config.REASSIGN_VERIFY_INTERVAL_MS);\n            LOGGER.debug(\"Verifying reassignment every {} seconds\", TimeUnit.SECONDS.convert(periodMs, TimeUnit.MILLISECONDS));\n            vertx.setPeriodic(periodMs, timerId ->\n                vertx.<Boolean>executeBlocking(fut -> {\n                    LOGGER.debug(String.format(\"Verifying reassignment for topic {} (timer id=%s)\", topic.getTopicName(), timerId));\n\n                    final Long throttle = config.get(Config.REASSIGN_THROTTLE);\n                    final boolean reassignmentComplete;\n                    try {\n                        reassignmentComplete = verifyReassignment(reassignmentJsonFile, zookeeper, throttle);\n                    } catch (Exception e) {\n                        fut.fail(e);\n                        return;\n                    }\n                    fut.complete(reassignmentComplete);\n                },\n                    ar -> {\n                        if (ar.succeeded()) {\n                            if (ar.result()) {\n                                LOGGER.info(\"Reassignment complete\");\n                                ProcessHelper.delete(reassignmentJsonFile);\n                                LOGGER.debug(\"Cancelling timer \" + timerId);\n                                vertx.cancelTimer(timerId);\n                                reassignmentFinishedFuture.complete();\n                            } else if (System.currentTimeMillis() - first > timeout) {\n                                LOGGER.error(\"Reassignment timed out\");\n                                ProcessHelper.delete(reassignmentJsonFile);\n                                LOGGER.debug(\"Cancelling timer \" + timerId);\n                                vertx.cancelTimer(timerId);\n                                reassignmentFinishedFuture.fail(\"Timeout\");\n                            }\n                        } else {\n                            //reassignmentFinishedFuture.fail(ar.cause());\n                            LOGGER.error(\"Error while verifying reassignment\", ar.cause());\n                        }\n                    }\n                )\n            );\n            periodicFuture.complete();\n        },\n            periodicFuture);\n\n\n        CompositeFuture.all(periodicFuture, reassignmentFinishedFuture).map((Void) null).setHandler(handler);\n        return handler;\n        // TODO The algorithm should really be more like this:\n        // 1. Use the cmdline tool to generate an assignment\n        // 2. Set the throttles\n        // 3. Update the reassign_partitions znode\n        // 4. Watch for changes or deletion of reassign_partitions\n        //    a. Update the throttles\n        //    b. complete the handler\n        // Doing this is much better because means we don't have to batch reassignments\n        // and also means we need less state for reassignment\n        // though we aren't relieved of the statefullness wrt removing throttles :-(\n    }"
        },
        "test_db": {
            "id": "5382861",
            "rel_path": "topic-operator/src/test/java/io/strimzi/operator/topic/TopicOperatorAssignedKafkaImplTest.java",
            "method_src": "@Test\n    public void changeReplicationFactor_ExecuteFail(TestContext context) {\n        MockAdminClient adminClient = new MockAdminClient();\n        Vertx vertx = Vertx.vertx();\n        Topic topic = new Topic.Builder(\"changeReplicationFactor\", 2, (short) 2, emptyMap()).build();\n        String[] partitions = new String[]{\"changeReplicationFactor-0\", \"changeReplicationFactor-1\"};\n        Subclass sub = new Subclass(adminClient, vertx, config, asList(\n                Subclass.generate(\"{\\\"version\\\":1,\\\"partitions\\\":[{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":0,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]},{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":1,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]}]}\",\n                        \"{\\\"version\\\":1,\\\"partitions\\\":[{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":0,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]},{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":1,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]}]}\"),\n                Subclass.executeFail(\"Bang!\"),\n                Subclass.executeStarted(),\n                Subclass.verifyInProgress(partitions),\n                Subclass.verifySuccess(partitions)));\n        Async async = context.async();\n        sub.changeReplicationFactor(topic, ar -> {\n            context.assertFalse(ar.succeeded());\n            context.assertTrue(ar.cause().getMessage().contains(\"Failed to reassign partitions\"));\n            async.complete();\n        });\n    }",
            "method_tgt": "@Test\n    public void changeReplicationFactor_ExecuteFail(TestContext context) {\n        MockAdminClient adminClient = new MockAdminClient();\n        Vertx vertx = Vertx.vertx();\n        Topic topic = new Topic.Builder(\"changeReplicationFactor\", 2, (short) 2, emptyMap()).build();\n        String[] partitions = new String[]{\"changeReplicationFactor-0\", \"changeReplicationFactor-1\"};\n        Subclass sub = new Subclass(adminClient, vertx, config, asList(\n                Subclass.generate(\"{\\\"version\\\":1,\\\"partitions\\\":[{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":0,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]},{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":1,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]}]}\",\n                        \"{\\\"version\\\":1,\\\"partitions\\\":[{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":0,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]},{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":1,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]}]}\"),\n                Subclass.executeFail(\"Bang!\"),\n                Subclass.executeStarted(),\n                Subclass.verifyInProgress(partitions),\n                Subclass.verifySuccess(partitions)));\n        Async async = context.async();\n        sub.changeReplicationFactor(topic).setHandler(ar -> {\n            context.assertFalse(ar.succeeded());\n            context.assertTrue(ar.cause().getMessage().contains(\"Failed to reassign partitions\"));\n            async.complete();\n        });\n    }"
        },
        "syn_diff": {
            "overall": 2,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 3
    },
    {
        "repo_name": "undera/jmeter-plugins",
        "commit_id": "b59c9ff292550d54a656eb28b7cbb3e03276f205",
        "commit_url": "https://github.com/undera/jmeter-plugins/commit/b59c9ff292550d54a656eb28b7cbb3e03276f205",
        "focal_db": {
            "id": "3753414",
            "rel_path": "src/kg/apc/jmeter/perfmon/AgentConnector.java",
            "method_src": "public double getCpu()\n   {\n      double ret;\n\n      String value = getData(CPU);\n      if (value != null)\n      {\n         ret = Double.parseDouble(value);\n      }\n      else\n      {\n         ret = AGENT_ERROR;\n      }\n\n      return ret;\n   }",
            "method_tgt": "public double getCpu() throws PerfMonException\n   {\n      double ret = -1;\n\n      String value = getData(CPU);\n      if (value != null) ret = Double.parseDouble(value);\n      if(ret < 0) throwNotSupportedMetricException(\"cpu\");\n\n      return ret;\n   }"
        },
        "test_db": {
            "id": "3753420",
            "rel_path": "test/kg/apc/jmeter/perfmon/AgentConnectorTest.java",
            "method_src": "@Test\n   public void testGetCpu()\n   {\n      System.out.println(\"getCpu\");\n      prepareTestData(123);\n      double result = instance.getCpu();\n      System.out.println(result);\n      assertTrue(result >= 0);\n   }",
            "method_tgt": "@Test\n   public void testGetCpu() throws PerfMonException\n   {\n      System.out.println(\"getCpu\");\n      prepareTestData(123);\n      double result = instance.getCpu();\n      System.out.println(result);\n      assertTrue(result >= 0);\n   }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 0,
            "throw_types": 1
        }
    },
    {
        "repo_name": "venusdrogon/feilong-core",
        "commit_id": "517425365f707578982ba5cb0d6ff91a96769e62",
        "commit_url": "https://github.com/venusdrogon/feilong-core/commit/517425365f707578982ba5cb0d6ff91a96769e62",
        "focal_db": {
            "id": "3825145",
            "rel_path": "src/main/java/com/feilong/core/lang/SystemUtil.java",
            "method_src": "public static Map<String, String> getEnvMapForLog(){\n        return new TreeMap<String, String>(System.getenv());\n    }",
            "method_tgt": "public static Map<String, String> getEnvMap(){\n        return new TreeMap<String, String>(System.getenv());\n    }"
        },
        "test_db": {
            "id": "3825147",
            "rel_path": "src/test/java/com/feilong/core/lang/SystemUtilTest.java",
            "method_src": "@Test\n    public void testGetEnvMapForLog(){\n        LOGGER.debug(JsonUtil.format(SystemUtil.getEnvMapForLog()));\n    }",
            "method_tgt": "@Test\n    public void testGetEnvMap(){\n        LOGGER.debug(JsonUtil.format(SystemUtil.getEnvMap()));\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 1,
            "param_types": 0,
            "throw_types": 0
        }
    },
    {
        "repo_name": "venusdrogon/feilong-core",
        "commit_id": "b9478add0be4e963e237c6119d121b3cab65b6b0",
        "commit_url": "https://github.com/venusdrogon/feilong-core/commit/b9478add0be4e963e237c6119d121b3cab65b6b0",
        "focal_db": {
            "id": "3827135",
            "rel_path": "src/main/java/com/feilong/core/net/URLConnectionUtil.java",
            "method_src": "public static String getResponseBodyAsString(String urlString,HttpURLConnectionParam httpURLConnectionParam){\n        if (null == httpURLConnectionParam){\n            httpURLConnectionParam = new HttpURLConnectionParam();\n        }\n        InputStream inputStream = getInputStream(urlString, httpURLConnectionParam);\n        String inputStream2String = InputStreamUtil.inputStream2String(inputStream, httpURLConnectionParam.getContentCharset());\n        return inputStream2String;\n\n    }",
            "method_tgt": "public static String getResponseBodyAsString(String urlString,ConnectionConfig connectionConfig){\n        if (null == connectionConfig){\n            connectionConfig = new ConnectionConfig();\n        }\n        InputStream inputStream = getInputStream(urlString, connectionConfig);\n        return InputStreamUtil.inputStream2String(inputStream, connectionConfig.getContentCharset());\n\n    }"
        },
        "test_db": {
            "id": "3827138",
            "rel_path": "src/test/java/com/feilong/core/net/URLConnectionUtilTest.java",
            "method_src": "@Test\n    public final void getResponseBodyAsString(){\n        String templateFile = \"http://10.8.25.80:6666/template.csv?sign=123456\";\n\n        HttpURLConnectionParam httpURLConnectionParam = new HttpURLConnectionParam();\n        httpURLConnectionParam.setContentCharset(CharsetType.GBK);\n\n        String responseBodyAsString = URLConnectionUtil.getResponseBodyAsString(templateFile, httpURLConnectionParam);\n        LOGGER.info(responseBodyAsString);\n    }",
            "method_tgt": "@Test\n    public final void getResponseBodyAsString(){\n        String templateFile = \"http://10.8.25.80:6666/template.csv?sign=123456\";\n\n        ConnectionConfig connectionConfig = new ConnectionConfig();\n        connectionConfig.setContentCharset(CharsetType.GBK);\n\n        String responseBodyAsString = URLConnectionUtil.getResponseBodyAsString(templateFile, connectionConfig);\n        LOGGER.info(responseBodyAsString);\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        }
    },
    {
        "repo_name": "venusdrogon/feilong-core",
        "commit_id": "cb6b034b1b5642eb9fb47b7c67dea09e11ff415a",
        "commit_url": "https://github.com/venusdrogon/feilong-core/commit/cb6b034b1b5642eb9fb47b7c67dea09e11ff415a",
        "focal_db": {
            "id": "3826323",
            "rel_path": "src/main/java/com/feilong/core/net/ParamUtil.java",
            "method_src": "public static String joinValues(Map<String, String> singleValueMap,String...includeKeys){\n        Validate.notNull(singleValueMap, \"singleValueMap can't be null!\");\n\n        if (Validator.isNullOrEmpty(includeKeys)){\n            return StringUtils.EMPTY;\n        }\n        StringBuilder sb = new StringBuilder();\n        //\u6709\u987a\u5e8f\u7684\u53c2\u6570\n        for (String key : includeKeys){\n            String value = singleValueMap.get(key);\n\n            //value\u8f6c\u6362,\u6ce8\u610f:\u5982\u679c value \u662fnull ,StringBuilder\u5c06\u62fc\u63a5 \"null\" \u5b57\u7b26\u4e32, \u8be6\u89c1  java.lang.AbstractStringBuilder#append(String)\n            sb.append(StringUtils.defaultString(value));\n        }\n        return sb.toString();\n    }",
            "method_tgt": "public static String joinValuesOrderByIncludeKeys(Map<String, String> singleValueMap,String...includeKeys){\n        Validate.notNull(singleValueMap, \"singleValueMap can't be null!\");\n\n        if (Validator.isNullOrEmpty(includeKeys)){\n            return StringUtils.EMPTY;\n        }\n        StringBuilder sb = new StringBuilder();\n        //\u6709\u987a\u5e8f\u7684\u53c2\u6570\n        for (String key : includeKeys){\n            String value = singleValueMap.get(key);\n\n            //value\u8f6c\u6362,\u6ce8\u610f:\u5982\u679c value\u662fnull ,StringBuilder\u5c06\u62fc\u63a5 \"null\" \u5b57\u7b26\u4e32, \u8be6\u89c1  java.lang.AbstractStringBuilder#append(String)\n            sb.append(StringUtils.defaultString(value));\n        }\n        return sb.toString();\n    }"
        },
        "test_db": {
            "id": "3826330",
            "rel_path": "src/test/java/com/feilong/core/net/ParamUtilTest.java",
            "method_src": "@Test\n    public void testJoinValues(){\n        String value = \"create_salesorder\";\n        String value2 = \"unionpay_mobile\";\n\n        Map<String, String> map = new HashMap<String, String>();\n        map.put(\"service\", value);\n        map.put(\"paymentType\", value2);\n\n        assertEquals(StringUtils.EMPTY, ParamUtil.joinValues(map, \"a\", \"b\"));\n        assertEquals(value, ParamUtil.joinValues(map, \"service\"));\n        assertEquals(value + value2, ParamUtil.joinValues(map, \"service\", \"paymentType\"));\n        assertEquals(value2 + value, ParamUtil.joinValues(map, \"paymentType\", \"service\"));\n    }",
            "method_tgt": "@Test\n    public void testJoinValues(){\n        String value = \"create_salesorder\";\n        String value2 = \"unionpay_mobile\";\n\n        Map<String, String> map = new HashMap<String, String>();\n        map.put(\"service\", value);\n        map.put(\"paymentType\", value2);\n\n        assertEquals(StringUtils.EMPTY, ParamUtil.joinValuesOrderByIncludeKeys(map, \"a\", \"b\"));\n        assertEquals(value, ParamUtil.joinValuesOrderByIncludeKeys(map, \"service\"));\n        assertEquals(value + value2, ParamUtil.joinValuesOrderByIncludeKeys(map, \"service\", \"paymentType\"));\n        assertEquals(value2 + value, ParamUtil.joinValuesOrderByIncludeKeys(map, \"paymentType\", \"service\"));\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 1,
            "param_types": 0,
            "throw_types": 0
        }
    },
    {
        "repo_name": "venusdrogon/feilong-core",
        "commit_id": "901b241ac2e996adaf2540244e410f3ddf1173f1",
        "commit_url": "https://github.com/venusdrogon/feilong-core/commit/901b241ac2e996adaf2540244e410f3ddf1173f1",
        "focal_db": {
            "id": "3826761",
            "rel_path": "src/main/java/com/feilong/core/bean/ConvertUtil.java",
            "method_src": "@Deprecated\n    public static String toString(final Collection collection,ToStringConfig toStringConfig){\n        if (Validator.isNullOrEmpty(collection)){\n            return StringUtils.EMPTY;\n        }\n        Object[] array = toArray(collection, Object.class);\n        return toString(toStringConfig, array);\n    }",
            "method_tgt": "@Deprecated\n    public static String toString(ToStringConfig toStringConfig,final Collection collection){\n        if (Validator.isNullOrEmpty(collection)){\n            return StringUtils.EMPTY;\n        }\n        Object[] array = toArray(collection, Object.class);\n        return toString(toStringConfig, array);\n    }"
        },
        "test_db": {
            "id": "3826766",
            "rel_path": "src/test/java/com/feilong/core/bean/ConvertUtilTest.java",
            "method_src": "@Test\n    public void testCollectionToString(){\n        List<String> list = new ArrayList<String>();\n        list.add(\"2548\");\n        list.add(\"\");\n\n        ToStringConfig toStringConfig = new ToStringConfig(\",\");\n        toStringConfig.setIsJoinNullOrEmpty(false);\n\n        assertEquals(\"2548\", ConvertUtil.toString(list, toStringConfig));\n    }",
            "method_tgt": "@Test\n    public void testCollectionToString(){\n        List<String> list = new ArrayList<String>();\n        list.add(\"2548\");\n        list.add(\"\");\n\n        ToStringConfig toStringConfig = new ToStringConfig(\",\");\n        toStringConfig.setIsJoinNullOrEmpty(false);\n\n        assertEquals(\"2548\", ConvertUtil.toString(toStringConfig, list));\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 1,
        "comment": "Case study: order of params changes"
    },
    {
        "repo_name": "venusdrogon/feilong-core",
        "commit_id": "901b241ac2e996adaf2540244e410f3ddf1173f1",
        "commit_url": "https://github.com/venusdrogon/feilong-core/commit/901b241ac2e996adaf2540244e410f3ddf1173f1",
        "focal_db": {
            "id": "3826761",
            "rel_path": "src/main/java/com/feilong/core/bean/ConvertUtil.java",
            "method_src": "@Deprecated\n    public static String toString(final Collection collection,ToStringConfig toStringConfig){\n        if (Validator.isNullOrEmpty(collection)){\n            return StringUtils.EMPTY;\n        }\n        Object[] array = toArray(collection, Object.class);\n        return toString(toStringConfig, array);\n    }",
            "method_tgt": "@Deprecated\n    public static String toString(ToStringConfig toStringConfig,final Collection collection){\n        if (Validator.isNullOrEmpty(collection)){\n            return StringUtils.EMPTY;\n        }\n        Object[] array = toArray(collection, Object.class);\n        return toString(toStringConfig, array);\n    }"
        },
        "test_db": {
            "id": "3826766",
            "rel_path": "src/test/java/com/feilong/core/bean/ConvertUtilTest.java",
            "method_src": "@Test\n    public void testCollectionToString1(){\n        List<String> list = new ArrayList<String>();\n        list.add(\"2548\");\n        list.add(\"2548\");\n        list.add(\"2548\");\n        list.add(\"2548\");\n        list.add(\"2548\");\n        list.add(\"2548\");\n\n        ToStringConfig toStringConfig = new ToStringConfig(SystemUtils.LINE_SEPARATOR);\n        LOGGER.debug(ConvertUtil.toString(list, toStringConfig));\n    }",
            "method_tgt": "@Test\n    public void testCollectionToString1(){\n        List<String> list = new ArrayList<String>();\n        list.add(\"2548\");\n        list.add(\"2548\");\n        list.add(\"2548\");\n        list.add(\"2548\");\n        list.add(\"2548\");\n        list.add(\"2548\");\n\n        ToStringConfig toStringConfig = new ToStringConfig(SystemUtils.LINE_SEPARATOR);\n        LOGGER.debug(ConvertUtil.toString(toStringConfig, list));\n    }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 2,
        "comment": "Case study: order of params changes"
    },
    {
        "repo_name": "vimeo/stag-java",
        "commit_id": "4e1b1852a2ad5505ff7d5bafcb9d4ea0889980c7",
        "commit_url": "https://github.com/vimeo/stag-java/commit/4e1b1852a2ad5505ff7d5bafcb9d4ea0889980c7",
        "focal_db": {
            "id": "3844666",
            "rel_path": "stag-library-compiler/src/main/java/com/vimeo/stag/processor/utils/TypeUtils.java",
            "method_src": "@NotNull\n    public static LinkedHashMap<Element, TypeMirror> getConcreteMembers(@NotNull TypeMirror concreteInherited,\n                                                                        @NotNull Element genericInherited,\n                                                                        @NotNull Map<Element, TypeMirror> members) {\n\n        DebugLog.log(TAG, \"Inherited concrete type: \" + concreteInherited.toString());\n        DebugLog.log(TAG, \"Inherited generic type: \" + genericInherited.asType().toString());\n        List<? extends TypeMirror> concreteTypes = getParameterizedTypes(concreteInherited);\n        List<? extends TypeMirror> inheritedTypes = getParameterizedTypes(genericInherited);\n\n        LinkedHashMap<Element, TypeMirror> map = new LinkedHashMap<>();\n\n        for (Entry<Element, TypeMirror> member : members.entrySet()) {\n\n            DebugLog.log(TAG, \"\\t\\tEvaluating member - \" + member.getValue().toString());\n\n            if (isConcreteType(member.getValue())) {\n\n                DebugLog.log(TAG, \"\\t\\t\\tConcrete Type: \" + member.getValue().toString());\n                map.put(member.getKey(), member.getValue());\n\n            } else {\n\n                if (isParameterizedType(member.getValue())) {\n\n                    // HashMap<String, T> ...\n                    TypeMirror resolvedType = resolveTypeVars(member.getValue(), inheritedTypes, concreteTypes);\n                    map.put(member.getKey(), resolvedType);\n\n                    DebugLog.log(TAG, \"\\t\\t\\tGeneric Parameterized Type - \" + member.getValue().toString() +\n                                      \" resolved to - \" + resolvedType.toString());\n                } else {\n\n                    int index = inheritedTypes.indexOf(member.getKey().asType());\n                    TypeMirror concreteType = concreteTypes.get(index);\n                    map.put(member.getKey(), concreteType);\n\n                    DebugLog.log(TAG, \"\\t\\t\\tGeneric Type - \" + member.getValue().toString() +\n                                      \" resolved to - \" + concreteType.toString());\n                }\n            }\n        }\n        return map;\n    }",
            "method_tgt": "@NotNull\n    public static LinkedHashMap<VariableElement, TypeMirror> getConcreteMembers(@NotNull TypeMirror concreteInherited,\n                                                                        @NotNull TypeElement genericInherited,\n                                                                        @NotNull Map<VariableElement, TypeMirror> members) {\n\n        DebugLog.log(TAG, \"Inherited concrete type: \" + concreteInherited.toString());\n        DebugLog.log(TAG, \"Inherited generic type: \" + genericInherited.asType().toString());\n        List<? extends TypeMirror> concreteTypes = getParameterizedTypes(concreteInherited);\n        List<? extends TypeMirror> inheritedTypes = getParameterizedTypes(genericInherited);\n\n        LinkedHashMap<VariableElement, TypeMirror> map = new LinkedHashMap<>();\n\n        for (Entry<VariableElement, TypeMirror> member : members.entrySet()) {\n\n            DebugLog.log(TAG, \"\\t\\tEvaluating member - \" + member.getValue().toString());\n\n            if (isConcreteType(member.getValue())) {\n\n                DebugLog.log(TAG, \"\\t\\t\\tConcrete Type: \" + member.getValue().toString());\n                map.put(member.getKey(), member.getValue());\n\n            } else {\n\n                if (isParameterizedType(member.getValue())) {\n\n                    // HashMap<String, T> ...\n                    TypeMirror resolvedType = resolveTypeVars(member.getValue(), inheritedTypes, concreteTypes);\n                    map.put(member.getKey(), resolvedType);\n\n                    DebugLog.log(TAG, \"\\t\\t\\tGeneric Parameterized Type - \" + member.getValue().toString() +\n                                      \" resolved to - \" + resolvedType.toString());\n                } else {\n\n                    int index = inheritedTypes.indexOf(member.getKey().asType());\n                    TypeMirror concreteType = concreteTypes.get(index);\n                    map.put(member.getKey(), concreteType);\n\n                    DebugLog.log(TAG, \"\\t\\t\\tGeneric Type - \" + member.getValue().toString() +\n                                      \" resolved to - \" + concreteType.toString());\n                }\n            }\n        }\n        return map;\n    }"
        },
        "test_db": {
            "id": "3844669",
            "rel_path": "stag-library-compiler/src/test/java/com/vimeo/stag/processor/TypeUtilsUnitTest.java",
            "method_src": "@Test\n    public void getConcreteMembers_isCorrect() throws Exception {\n        Element genericElement = Utils.getElementFromClass(DummyGenericClass.class);\n        assertNotNull(genericElement);\n        Map<Element, TypeMirror> genericMembers = new HashMap<>();\n        for (Element element : genericElement.getEnclosedElements()) {\n            if (element instanceof VariableElement) {\n                genericMembers.put(element, element.asType());\n            }\n        }\n\n        TypeMirror concreteType =\n                TypeUtils.getInheritedType(Utils.getElementFromClass(DummyInheritedClass.class));\n\n        assertNotNull(concreteType);\n\n        TypeMirror genericType = Utils.getGenericVersionOfClass(DummyGenericClass.class);\n\n        assertNotNull(genericType);\n\n        LinkedHashMap<Element, TypeMirror> members =\n                TypeUtils.getConcreteMembers(concreteType, types.asElement(genericType), genericMembers);\n\n\n        TypeMirror stringType = Utils.getTypeMirrorFromClass(String.class);\n        assertNotNull(stringType);\n\n        for (Entry<Element, TypeMirror> entry : members.entrySet()) {\n            if (entry.getKey().getSimpleName().contentEquals(\"testObject\")) {\n\n                assertTrue(entry.getValue().toString().equals(stringType.toString()));\n\n            } else if (entry.getKey().getSimpleName().contentEquals(\"testList\")) {\n\n                assertTrue(entry.getValue()\n                                   .toString()\n                                   .equals(types.getDeclaredType(\n                                           (TypeElement) Utils.getElementFromClass(ArrayList.class),\n                                           stringType).toString()));\n\n            } else if (entry.getKey().getSimpleName().contentEquals(\"testMap\")) {\n\n                assertTrue(entry.getValue()\n                                   .toString()\n                                   .equals(types.getDeclaredType(\n                                           (TypeElement) Utils.getElementFromClass(HashMap.class), stringType,\n                                           stringType).toString()));\n\n            } else if (entry.getKey().getSimpleName().contentEquals(\"testSet\")) {\n\n                assertTrue(entry.getValue()\n                                   .toString()\n                                   .equals(types.getDeclaredType(\n                                           (TypeElement) Utils.getElementFromClass(HashSet.class), stringType)\n                                                   .toString()));\n            } else if (entry.getKey().getSimpleName().contentEquals(\"testArrayMap\")) {\n                TypeMirror listString = types.getDeclaredType((TypeElement) Utils.getElementFromClass(List.class), stringType);\n\n                assertTrue(entry.getValue()\n                        .toString()\n                        .equals(types.getDeclaredType(\n                                (TypeElement) Utils.getElementFromClass(HashMap.class), stringType, listString)\n                                .toString()));\n            } else if (entry.getKey().getSimpleName().contentEquals(\"testListMap\")) {\n                TypeMirror mapStringString = types.getDeclaredType((TypeElement) Utils.getElementFromClass(Map.class), stringType, stringType);\n                assertTrue(entry.getValue()\n                        .toString()\n                        .equals(types.getDeclaredType(\n                                (TypeElement) Utils.getElementFromClass(ArrayList.class), mapStringString)\n                                .toString()));\n            }\n        }\n    }",
            "method_tgt": "@Test\n    public void getConcreteMembers_isCorrect() throws Exception {\n        Element genericElement = Utils.getElementFromClass(DummyGenericClass.class);\n        assertNotNull(genericElement);\n        Map<Element, TypeMirror> genericMembers = new HashMap<>();\n        for (Element element : genericElement.getEnclosedElements()) {\n            if (element instanceof VariableElement) {\n                genericMembers.put(element, element.asType());\n            }\n        }\n\n        TypeMirror concreteType =\n                TypeUtils.getInheritedType(Utils.getElementFromClass(DummyInheritedClass.class));\n\n        assertNotNull(concreteType);\n\n        TypeMirror genericType = Utils.getGenericVersionOfClass(DummyGenericClass.class);\n\n        assertNotNull(genericType);\n\n        LinkedHashMap<Element, TypeMirror> members =\n                TypeUtils.getConcreteMembers(concreteType, (TypeElement) types.asElement(genericType), genericMembers);\n\n\n        TypeMirror stringType = Utils.getTypeMirrorFromClass(String.class);\n        assertNotNull(stringType);\n\n        for (Entry<Element, TypeMirror> entry : members.entrySet()) {\n            if (entry.getKey().getSimpleName().contentEquals(\"testObject\")) {\n\n                assertTrue(entry.getValue().toString().equals(stringType.toString()));\n\n            } else if (entry.getKey().getSimpleName().contentEquals(\"testList\")) {\n\n                assertTrue(entry.getValue()\n                                   .toString()\n                                   .equals(types.getDeclaredType(Utils.getElementFromClass(ArrayList.class),\n                                           stringType).toString()));\n\n            } else if (entry.getKey().getSimpleName().contentEquals(\"testMap\")) {\n\n                assertTrue(entry.getValue()\n                                   .toString()\n                                   .equals(types.getDeclaredType(Utils.getElementFromClass(HashMap.class), stringType,\n                                                                 stringType).toString()));\n\n            } else if (entry.getKey().getSimpleName().contentEquals(\"testSet\")) {\n\n                assertTrue(entry.getValue()\n                                   .toString()\n                                   .equals(types.getDeclaredType(Utils.getElementFromClass(HashSet.class), stringType)\n                                                   .toString()));\n            } else if (entry.getKey().getSimpleName().contentEquals(\"testArrayMap\")) {\n                TypeMirror listString = types.getDeclaredType(Utils.getElementFromClass(List.class), stringType);\n\n                assertTrue(entry.getValue()\n                        .toString()\n                        .equals(types.getDeclaredType(Utils.getElementFromClass(HashMap.class), stringType, listString)\n                                .toString()));\n            } else if (entry.getKey().getSimpleName().contentEquals(\"testListMap\")) {\n                TypeMirror mapStringString = types.getDeclaredType(Utils.getElementFromClass(Map.class), stringType, stringType);\n                assertTrue(entry.getValue()\n                        .toString()\n                        .equals(types.getDeclaredType(Utils.getElementFromClass(ArrayList.class), mapStringString)\n                                .toString()));\n            }\n        }\n    }"
        },
        "syn_diff": {
            "overall": 2,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        }
    },
    {
        "repo_name": "watson-developer-cloud/java-sdk",
        "commit_id": "6e70db2d324d6b39ea88a4af19d178eeec996656",
        "commit_url": "https://github.com/watson-developer-cloud/java-sdk/commit/6e70db2d324d6b39ea88a4af19d178eeec996656",
        "focal_db": {
            "id": 5633673,
            "rel_path": "natural-language-classifier/src/main/java/com/ibm/watson/developer_cloud/natural_language_classifier/v1/NaturalLanguageClassifier.java",
            "method_src": "public ServiceCall<Classifier> createClassifier(final String name, final String language, final File trainingData) {\n    Validator.isTrue((trainingData != null) && trainingData.exists(), \"trainingData cannot be null or not be found\");\n    Validator.isTrue((language != null) && !language.isEmpty(), \"language cannot be null or empty\");\n\n    final JsonObject contentJson = new JsonObject();\n\n    contentJson.addProperty(LANGUAGE, language);\n\n    if ((name != null) && !name.isEmpty()) {\n      contentJson.addProperty(NAME, name);\n    }\n\n    final RequestBody body = new MultipartBody.Builder().setType(MultipartBody.FORM)\n        .addPart(Headers.of(HttpHeaders.CONTENT_DISPOSITION, FORM_DATA_TRAINING_DATA),\n            RequestBody.create(HttpMediaType.BINARY_FILE, trainingData))\n        .addFormDataPart(TRAINING_METADATA, contentJson.toString()).build();\n\n    final Request request = RequestBuilder.post(PATH_CLASSIFIERS).body(body).build();\n    return createServiceCall(request, ResponseConverterUtils.getObject(Classifier.class));\n  }",
            "method_tgt": "public ServiceCall<Classifier> createClassifier(CreateClassifierOptions createClassifierOptions) {\n    Validator.notNull(createClassifierOptions, \"createClassifierOptions cannot be null\");\n    RequestBuilder builder = RequestBuilder.post(\"/v1/classifiers\");\n    MultipartBody.Builder multipartBuilder = new MultipartBody.Builder();\n    multipartBuilder.setType(MultipartBody.FORM);\n    RequestBody trainingMetadataBody = RequestUtils.inputStreamBody(createClassifierOptions.metadata(),\n        \"application/json\");\n    multipartBuilder.addFormDataPart(\"training_metadata\", createClassifierOptions.metadataFilename(),\n        trainingMetadataBody);\n    RequestBody trainingDataBody = RequestUtils.inputStreamBody(createClassifierOptions.trainingData(), \"text/csv\");\n    multipartBuilder.addFormDataPart(\"training_data\", createClassifierOptions.trainingDataFilename(), trainingDataBody);\n    builder.body(multipartBuilder.build());\n    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Classifier.class));\n  }"
        },
        "test_db": {
            "id": 5633700,
            "rel_path": "natural-language-classifier/src/test/java/com/ibm/watson/developer_cloud/natural_language_classifier/v1/NaturalLanguageClassifierTest.java",
            "method_src": "@Test\n  public void testCreateClassifier() throws InterruptedException {\n    server.enqueue(jsonResponse(classifier));\n    final Classifier response = service.createClassifier(classifierId, \"en\",\n        new File(\"src/test/resources/natural_language_classifier/weather_data_train.csv\")).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals(CLASSIFIERS_PATH, request.getPath());\n    assertEquals(classifier, response);\n  }",
            "method_tgt": "@Test\n  public void testCreateClassifier() throws InterruptedException, FileNotFoundException {\n    server.enqueue(jsonResponse(classifier));\n    File metadata = new File(RESOURCE + \"metadata.json\");\n    File trainingData = new File(RESOURCE + \"weather_data_train.csv\");\n    CreateClassifierOptions createOptions = new CreateClassifierOptions.Builder()\n        .metadata(metadata)\n        .trainingData(trainingData)\n        .trainingDataFilename(\"weather_data_train.csv\")\n        .build();\n    final Classifier response = service.createClassifier(createOptions).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals(CLASSIFIERS_PATH, request.getPath());\n    assertEquals(classifier, response);\n  }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        },
        "comment": "Good Case study"
    },
    {
        "repo_name": "watson-developer-cloud/java-sdk",
        "commit_id": "6e70db2d324d6b39ea88a4af19d178eeec996656",
        "commit_url": "https://github.com/watson-developer-cloud/java-sdk/commit/6e70db2d324d6b39ea88a4af19d178eeec996656",
        "focal_db": {
            "id": "5633673",
            "rel_path": "natural-language-classifier/src/main/java/com/ibm/watson/developer_cloud/natural_language_classifier/v1/NaturalLanguageClassifier.java",
            "method_src": "public ServiceCall<Classifier> createClassifier(final String name, final String language, final File trainingData) {\n    Validator.isTrue((trainingData != null) && trainingData.exists(), \"trainingData cannot be null or not be found\");\n    Validator.isTrue((language != null) && !language.isEmpty(), \"language cannot be null or empty\");\n\n    final JsonObject contentJson = new JsonObject();\n\n    contentJson.addProperty(LANGUAGE, language);\n\n    if ((name != null) && !name.isEmpty()) {\n      contentJson.addProperty(NAME, name);\n    }\n\n    final RequestBody body = new MultipartBody.Builder().setType(MultipartBody.FORM)\n        .addPart(Headers.of(HttpHeaders.CONTENT_DISPOSITION, FORM_DATA_TRAINING_DATA),\n            RequestBody.create(HttpMediaType.BINARY_FILE, trainingData))\n        .addFormDataPart(TRAINING_METADATA, contentJson.toString()).build();\n\n    final Request request = RequestBuilder.post(PATH_CLASSIFIERS).body(body).build();\n    return createServiceCall(request, ResponseConverterUtils.getObject(Classifier.class));\n  }",
            "method_tgt": "public ServiceCall<Classifier> createClassifier(CreateClassifierOptions createClassifierOptions) {\n    Validator.notNull(createClassifierOptions, \"createClassifierOptions cannot be null\");\n    RequestBuilder builder = RequestBuilder.post(\"/v1/classifiers\");\n    MultipartBody.Builder multipartBuilder = new MultipartBody.Builder();\n    multipartBuilder.setType(MultipartBody.FORM);\n    RequestBody trainingMetadataBody = RequestUtils.inputStreamBody(createClassifierOptions.metadata(),\n        \"application/json\");\n    multipartBuilder.addFormDataPart(\"training_metadata\", createClassifierOptions.metadataFilename(),\n        trainingMetadataBody);\n    RequestBody trainingDataBody = RequestUtils.inputStreamBody(createClassifierOptions.trainingData(), \"text/csv\");\n    multipartBuilder.addFormDataPart(\"training_data\", createClassifierOptions.trainingDataFilename(), trainingDataBody);\n    builder.body(multipartBuilder.build());\n    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Classifier.class));\n  }"
        },
        "test_db": {
            "id": "5633700",
            "rel_path": "natural-language-classifier/src/test/java/com/ibm/watson/developer_cloud/natural_language_classifier/v1/NaturalLanguageClassifierTest.java",
            "method_src": "@Test(expected = IllegalArgumentException.class)\n  public void testNullTrainingDataFile() {\n    service.createClassifier(null, null, new File(\"src/test/resources/notfound.txt\"));\n  }",
            "method_tgt": "@Test(expected = FileNotFoundException.class)\n  public void testNullTrainingDataFile() throws FileNotFoundException {\n    server.enqueue(jsonResponse(classifier));\n    File metadata = new File(RESOURCE + \"metadata.json\");\n    File trainingData = new File(RESOURCE + \"notfound.txt\");\n    CreateClassifierOptions createOptions = new CreateClassifierOptions.Builder()\n        .metadata(metadata)\n        .trainingData(trainingData)\n        .trainingDataFilename(\"notfound.txt\")\n        .build();\n    service.createClassifier(createOptions).execute();\n  }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 1,
        "comment": "Good Case study"
    },
    {
        "repo_name": "watson-developer-cloud/java-sdk",
        "commit_id": "6e70db2d324d6b39ea88a4af19d178eeec996656",
        "commit_url": "https://github.com/watson-developer-cloud/java-sdk/commit/6e70db2d324d6b39ea88a4af19d178eeec996656",
        "focal_db": {
            "id": "5633673",
            "rel_path": "natural-language-classifier/src/main/java/com/ibm/watson/developer_cloud/natural_language_classifier/v1/NaturalLanguageClassifier.java",
            "method_src": "public ServiceCall<Classification> classify(final String classifierId, final String text) {\n    Validator.isTrue((classifierId != null) && !classifierId.isEmpty(), \"classifierId cannot be null or empty\");\n    Validator.isTrue((text != null) && !text.isEmpty(), \"text cannot be null or empty\");\n\n    final JsonObject contentJson = new JsonObject();\n    contentJson.addProperty(TEXT, text);\n    final String path = String.format(PATH_CLASSIFY, classifierId);\n    final Request request = RequestBuilder.post(path).bodyJson(contentJson).build();\n    return createServiceCall(request, ResponseConverterUtils.getObject(Classification.class));\n  }",
            "method_tgt": "public ServiceCall<Classification> classify(ClassifyOptions classifyOptions) {\n    Validator.notNull(classifyOptions, \"classifyOptions cannot be null\");\n    RequestBuilder builder = RequestBuilder.post(String.format(\"/v1/classifiers/%s/classify\", classifyOptions\n        .classifierId()));\n    final JsonObject contentJson = new JsonObject();\n    contentJson.addProperty(\"text\", classifyOptions.text());\n    builder.bodyJson(contentJson);\n    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Classification.class));\n  }"
        },
        "test_db": {
            "id": "5633700",
            "rel_path": "natural-language-classifier/src/test/java/com/ibm/watson/developer_cloud/natural_language_classifier/v1/NaturalLanguageClassifierTest.java",
            "method_src": "@Test(expected = IllegalArgumentException.class)\n  public void testNullClassifier() {\n    service.classify(\"\", \"test\");\n  }",
            "method_tgt": "@Test(expected = IllegalArgumentException.class)\n  public void testNullClassifier() {\n    ClassifyOptions classifyOptions = new ClassifyOptions.Builder()\n        .text(\"test\")\n        .build();\n    service.classify(classifyOptions);\n  }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 2,
        "comment": "Good Case study"
    },
    {
        "repo_name": "watson-developer-cloud/java-sdk",
        "commit_id": "6e70db2d324d6b39ea88a4af19d178eeec996656",
        "commit_url": "https://github.com/watson-developer-cloud/java-sdk/commit/6e70db2d324d6b39ea88a4af19d178eeec996656",
        "focal_db": {
            "id": "5633673",
            "rel_path": "natural-language-classifier/src/main/java/com/ibm/watson/developer_cloud/natural_language_classifier/v1/NaturalLanguageClassifier.java",
            "method_src": "public ServiceCall<Classification> classify(final String classifierId, final String text) {\n    Validator.isTrue((classifierId != null) && !classifierId.isEmpty(), \"classifierId cannot be null or empty\");\n    Validator.isTrue((text != null) && !text.isEmpty(), \"text cannot be null or empty\");\n\n    final JsonObject contentJson = new JsonObject();\n    contentJson.addProperty(TEXT, text);\n    final String path = String.format(PATH_CLASSIFY, classifierId);\n    final Request request = RequestBuilder.post(path).bodyJson(contentJson).build();\n    return createServiceCall(request, ResponseConverterUtils.getObject(Classification.class));\n  }",
            "method_tgt": "public ServiceCall<Classification> classify(ClassifyOptions classifyOptions) {\n    Validator.notNull(classifyOptions, \"classifyOptions cannot be null\");\n    RequestBuilder builder = RequestBuilder.post(String.format(\"/v1/classifiers/%s/classify\", classifyOptions\n        .classifierId()));\n    final JsonObject contentJson = new JsonObject();\n    contentJson.addProperty(\"text\", classifyOptions.text());\n    builder.bodyJson(contentJson);\n    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Classification.class));\n  }"
        },
        "test_db": {
            "id": "5633700",
            "rel_path": "natural-language-classifier/src/test/java/com/ibm/watson/developer_cloud/natural_language_classifier/v1/NaturalLanguageClassifierTest.java",
            "method_src": "@Test(expected = IllegalArgumentException.class)\n  public void testNullText() {\n    service.classify(classifierId, null);\n  }",
            "method_tgt": "@Test(expected = IllegalArgumentException.class)\n  public void testNullText() {\n    ClassifyOptions classifyOptions = new ClassifyOptions.Builder()\n        .classifierId(classifierId)\n        .build();\n    service.classify(classifyOptions);\n  }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 3,
        "comment": "Good Case study"
    },
    {
        "repo_name": "watson-developer-cloud/java-sdk",
        "commit_id": "6e70db2d324d6b39ea88a4af19d178eeec996656",
        "commit_url": "https://github.com/watson-developer-cloud/java-sdk/commit/6e70db2d324d6b39ea88a4af19d178eeec996656",
        "focal_db": {
            "id": "5633673",
            "rel_path": "natural-language-classifier/src/main/java/com/ibm/watson/developer_cloud/natural_language_classifier/v1/NaturalLanguageClassifier.java",
            "method_src": "public ServiceCall<Void> deleteClassifier(String classifierId) {\n    Validator.isTrue((classifierId != null) && !classifierId.isEmpty(), \"classifierId cannot be null or empty\");\n\n    final Request request = RequestBuilder.delete(String.format(PATH_CLASSIFIER, classifierId)).build();\n    return createServiceCall(request, ResponseConverterUtils.getVoid());\n  }",
            "method_tgt": "public ServiceCall<Void> deleteClassifier(DeleteClassifierOptions deleteClassifierOptions) {\n    Validator.notNull(deleteClassifierOptions, \"deleteClassifierOptions cannot be null\");\n    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/classifiers/%s\", deleteClassifierOptions\n        .classifierId()));\n    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n  }"
        },
        "test_db": {
            "id": "5633700",
            "rel_path": "natural-language-classifier/src/test/java/com/ibm/watson/developer_cloud/natural_language_classifier/v1/NaturalLanguageClassifierTest.java",
            "method_src": "@Test(expected = IllegalArgumentException.class)\n  public void testNullDeleteClassifier() {\n    service.deleteClassifier(\"\");\n  }",
            "method_tgt": "@Test(expected = IllegalArgumentException.class)\n  public void testNullDeleteClassifier() {\n    DeleteClassifierOptions deleteOptions = new DeleteClassifierOptions.Builder()\n        .build();\n    service.deleteClassifier(deleteOptions);\n  }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 4,
        "comment": "Good Case study"
    },
    {
        "repo_name": "watson-developer-cloud/java-sdk",
        "commit_id": "bb1319cafd4f4538ecba9e76279cd276152c6e65",
        "commit_url": "https://github.com/watson-developer-cloud/java-sdk/commit/bb1319cafd4f4538ecba9e76279cd276152c6e65",
        "focal_db": {
            "id": "5636106",
            "rel_path": "src/main/java/com/ibm/watson/developer_cloud/text_to_speech/v1/TextToSpeech.java",
            "method_src": "public InputStream synthesize(final String text, final Voice voice, final String outputFormat) {\n    Validate.isTrue(text != null && !text.isEmpty(), \"text cannot be null or empty\");\n    Validate.isTrue(voice != null, \"voice cannot be null or empty\");\n\n    final RequestBuilder request = RequestBuilder.get(PATH_SYNTHESIZE);\n    request.withQuery(TEXT, text);\n    request.withQuery(VOICE, voice.getName());\n\n    if (outputFormat != null && !outputFormat.startsWith(\"audio/\"))\n      throw new IllegalArgumentException(\n          \"format needs to be an audio mime type, for example: audio/wav or audio/ogg; codecs=opus\");\n\n    request.withQuery(ACCEPT, outputFormat != null ? outputFormat : HttpMediaType.AUDIO_WAV);\n\n    final Response response = execute(request.build());\n    return ResponseUtil.getInputStream(response);\n  }",
            "method_tgt": "public ServiceCall<InputStream> synthesize(final String text, final Voice voice, final String outputFormat) {\n    return createServiceCall(createCall(synthesizeRequest(text, voice, outputFormat)),\n        new ResponseConverter<InputStream>() {\n          @Override public InputStream convert(okhttp3.Response response) {\n            return ResponseUtil.getInputStream(response);\n          }\n        });\n  }"
        },
        "test_db": {
            "id": "5636142",
            "rel_path": "src/test/java/com/ibm/watson/developer_cloud/text_to_speech/v1/TextToSpeechTest.java",
            "method_src": "@Test\n  public void testSynthesize() {\n    final File audio = new File(\"src/test/resources/speech_to_text/sample1.wav\");\n\n    try {\n      final List<Parameter> parameters = new ArrayList<Parameter>();\n      parameters.add(new Parameter(\"text\", text));\n      parameters.add(new Parameter(\"voice\", Voice.EN_LISA.getName()));\n      parameters.add(new Parameter(\"accept\", HttpMediaType.AUDIO_WAV));\n\n      mockServer.when(request().withQueryStringParameters(parameters).withPath(SYNTHESIZE_PATH))\n          .respond(\n              response().withHeaders(\n                  new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.AUDIO_WAV)).withBody(\n                  Files.toByteArray(audio)));\n\n      final InputStream in = service.synthesize(text, Voice.EN_LISA, HttpMediaType.AUDIO_WAV);\n      Assert.assertNotNull(in);\n\n      writeInputStreamToOutputStream(in, new FileOutputStream(\"target/output.wav\"));\n\n    } catch (final FileNotFoundException e) {\n      Assert.fail(e.getMessage());\n    } catch (final IOException e) {\n      Assert.fail(e.getMessage());\n    }\n  }",
            "method_tgt": "@Test\n  public void testSynthesize() {\n    final File audio = new File(\"src/test/resources/speech_to_text/sample1.wav\");\n\n    try {\n      final List<Parameter> parameters = new ArrayList<Parameter>();\n      parameters.add(new Parameter(\"text\", text));\n      parameters.add(new Parameter(\"voice\", Voice.EN_LISA.getName()));\n      parameters.add(new Parameter(\"accept\", HttpMediaType.AUDIO_WAV));\n\n      mockServer.when(request().withQueryStringParameters(parameters).withPath(SYNTHESIZE_PATH))\n          .respond(\n              response().withHeaders(\n                  new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.AUDIO_WAV)).withBody(\n                  Files.toByteArray(audio)));\n\n      final InputStream in = service.synthesize(text, Voice.EN_LISA, HttpMediaType.AUDIO_WAV).execute();\n      Assert.assertNotNull(in);\n\n      writeInputStreamToOutputStream(in, new FileOutputStream(\"target/output.wav\"));\n\n    } catch (final FileNotFoundException e) {\n      Assert.fail(e.getMessage());\n    } catch (final IOException e) {\n      Assert.fail(e.getMessage());\n    }\n  }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 0,
            "param_types": 0,
            "throw_types": 0
        },
        "aug": 0
    },
    {
        "repo_name": "watson-developer-cloud/java-sdk",
        "commit_id": "bb1319cafd4f4538ecba9e76279cd276152c6e65",
        "commit_url": "https://github.com/watson-developer-cloud/java-sdk/commit/bb1319cafd4f4538ecba9e76279cd276152c6e65",
        "focal_db": {
            "id": "5636106",
            "rel_path": "src/main/java/com/ibm/watson/developer_cloud/speech_to_text/v1/SpeechToText.java",
            "method_src": "public SpeechModel getModel(final String name) {\n    if (name == null)\n      throw new IllegalArgumentException(\"name was not specified\");\n\n    final Request request = RequestBuilder.get(String.format(PATH_MODEL, name)).build();\n    return executeRequest(request, SpeechModel.class);\n  }",
            "method_tgt": "public ServiceCall<SpeechModel> getModel(final String name) {\n    if (name == null)\n      throw new IllegalArgumentException(\"Name was not specified\");\n\n    final okhttp3.Request request = RequestBuilder.get(String.format(PATH_MODEL, name)).build3();\n    return createServiceCall(createCall(request), ResponseUtil.getObjectConverter(SpeechModel.class));\n  }"
        },
        "test_db": {
            "id": "5636142",
            "rel_path": "src/test/java/com/ibm/watson/developer_cloud/speech_to_text/v1/SpeechToTextTest.java",
            "method_src": "@Test\n  public void testGetModel() {\n\n    final SpeechModel speechModel = new SpeechModel(\"not-a-real-Model\");\n    speechModel.setRate(8000);\n\n    mockServer.when(request().withPath(GET_MODELS_PATH + \"/\" + speechModel.getName())).respond(\n        response().withHeaders(\n            new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.APPLICATION_JSON)).withBody(\n            GsonSingleton.getGsonWithoutPrettyPrinting().toJson(speechModel)));\n\n\n    SpeechModel model = service.getModel(\"not-a-real-Model\");\n    Assert.assertNotNull(model);\n    Assert.assertEquals(model, speechModel);\n\n    model = service.getModel(speechModel.getName());\n    Assert.assertNotNull(model);\n    Assert.assertEquals(model, speechModel);\n\n    try {\n      TestUtils.assertNoExceptionsOnGetters(model);\n    } catch (final Exception e) {\n      Assert.fail(e.getMessage());\n    }\n  }",
            "method_tgt": "@Test\n  public void testGetModel() {\n\n    final SpeechModel speechModel = new SpeechModel(\"not-a-real-Model\");\n    speechModel.setRate(8000);\n\n    mockServer.when(request().withPath(GET_MODELS_PATH + \"/\" + speechModel.getName())).respond(\n        response().withHeaders(\n            new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.APPLICATION_JSON)).withBody(\n            GsonSingleton.getGsonWithoutPrettyPrinting().toJson(speechModel)));\n\n\n    SpeechModel model = service.getModel(\"not-a-real-Model\").execute();\n    Assert.assertNotNull(model);\n    Assert.assertEquals(model, speechModel);\n\n    model = service.getModel(speechModel.getName()).execute();\n    Assert.assertNotNull(model);\n    Assert.assertEquals(model, speechModel);\n\n    try {\n      TestUtils.assertNoExceptionsOnGetters(model);\n    } catch (final Exception e) {\n      Assert.fail(e.getMessage());\n    }\n  }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 0,
            "param_types": 0,
            "throw_types": 0
        },
        "aug": 1
    },
    {
        "repo_name": "watson-developer-cloud/java-sdk",
        "commit_id": "bb1319cafd4f4538ecba9e76279cd276152c6e65",
        "commit_url": "https://github.com/watson-developer-cloud/java-sdk/commit/bb1319cafd4f4538ecba9e76279cd276152c6e65",
        "focal_db": {
            "id": "5636106",
            "rel_path": "src/main/java/com/ibm/watson/developer_cloud/speech_to_text/v1/SpeechToText.java",
            "method_src": "public SpeechResults recognize(File audio) {\n    return recognize(audio, (RecognizeOptions) null);\n  }",
            "method_tgt": "public ServiceCall<SpeechResults> recognize(File audio) {\n    return recognize(audio, (RecognizeOptions) null);\n  }"
        },
        "test_db": {
            "id": "5636142",
            "rel_path": "src/test/java/com/ibm/watson/developer_cloud/speech_to_text/v1/SpeechToTextTest.java",
            "method_src": "@Test\n  public void testRecognizeMissingAudioFile() throws URISyntaxException {\n\n    final SpeechResults speechResults = new SpeechResults();\n    speechResults.setResultIndex(0);\n\n    final Transcript transcript = new Transcript();\n    transcript.setFinal(true);\n\n    final SpeechAlternative speechAlternative = new SpeechAlternative();\n    speechAlternative\n        .setTranscript(\"thunderstorms could produce large hail isolated tornadoes and heavy rain\");\n\n    final List<SpeechAlternative> speechAlternatives = new ArrayList<SpeechAlternative>();\n    speechAlternatives.add(speechAlternative);\n\n    transcript.setAlternatives(speechAlternatives);\n    final List<Transcript> transcripts = new ArrayList<Transcript>();\n    transcripts.add(transcript);\n    speechResults.setResults(transcripts);\n\n    // File audio = new File(\"src/test/resources/sample1.wav\");\n\n    mockServer.when(\n        request().withMethod(\"POST\").withPath(RECOGNIZE_PATH)\n            .withHeaders(new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.AUDIO_WAV)))\n        .respond(\n            response().withHeader(APPLICATION_JSON).withBody(\n                GsonSingleton.getGsonWithoutPrettyPrinting().toJson(speechResults)));\n\n    boolean didItHappen = false;\n    try {\n      service.recognize(null);\n    } catch (final IllegalArgumentException e) {\n      didItHappen = true;\n    }\n    Assert.assertTrue(\"Check that 'IllegalArgumentException' is thrown.\", didItHappen);\n  }",
            "method_tgt": "@Test\n  public void testRecognizeMissingAudioFile() throws URISyntaxException {\n\n    final SpeechResults speechResults = new SpeechResults();\n    speechResults.setResultIndex(0);\n\n    final Transcript transcript = new Transcript();\n    transcript.setFinal(true);\n\n    final SpeechAlternative speechAlternative = new SpeechAlternative();\n    speechAlternative\n        .setTranscript(\"thunderstorms could produce large hail isolated tornadoes and heavy rain\");\n\n    final List<SpeechAlternative> speechAlternatives = new ArrayList<SpeechAlternative>();\n    speechAlternatives.add(speechAlternative);\n\n    transcript.setAlternatives(speechAlternatives);\n    final List<Transcript> transcripts = new ArrayList<Transcript>();\n    transcripts.add(transcript);\n    speechResults.setResults(transcripts);\n\n    // File audio = new File(\"src/test/resources/sample1.wav\");\n\n    mockServer.when(\n        request().withMethod(\"POST\").withPath(RECOGNIZE_PATH)\n            .withHeaders(new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.AUDIO_WAV)))\n        .respond(\n            response().withHeader(APPLICATION_JSON).withBody(\n                GsonSingleton.getGsonWithoutPrettyPrinting().toJson(speechResults)));\n\n    boolean didItHappen = false;\n    try {\n      service.recognize(null).execute();\n    } catch (final IllegalArgumentException e) {\n      didItHappen = true;\n    }\n    Assert.assertTrue(\"Check that 'IllegalArgumentException' is thrown.\", didItHappen);\n  }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 0,
            "param_types": 0,
            "throw_types": 0
        },
        "aug": 2
    },
    {
        "repo_name": "watson-developer-cloud/java-sdk",
        "commit_id": "bb1319cafd4f4538ecba9e76279cd276152c6e65",
        "commit_url": "https://github.com/watson-developer-cloud/java-sdk/commit/bb1319cafd4f4538ecba9e76279cd276152c6e65",
        "focal_db": {
            "id": "5636106",
            "rel_path": "src/main/java/com/ibm/watson/developer_cloud/text_to_speech/v1/TextToSpeech.java",
            "method_src": "public List<Voice> getVoices() {\n    final Request request = RequestBuilder.get(\"/v1/voices\").build();\n    final Response response = execute(request);\n    final JsonObject jsonObject = ResponseUtil.getJsonObject(response);\n    final List<Voice> voices = GsonSingleton.getGsonWithoutPrettyPrinting()\n        .fromJson(jsonObject.get(\"voices\"), listVoiceType);\n    return voices;\n  }",
            "method_tgt": "public ServiceCall<List<Voice>> getVoices() {\n    final okhttp3.Request request = RequestBuilder.get(\"/v1/voices\").build3();\n    return createServiceCall(createCall(request), ResponseUtil.getVoiceListConverter(listVoiceType));\n  }"
        },
        "test_db": {
            "id": "5636142",
            "rel_path": "src/test/java/com/ibm/watson/developer_cloud/text_to_speech/v1/TextToSpeechTest.java",
            "method_src": "@Test\n  public void testGetVoices() {\n\n    final Map<String, Object> response = new HashMap<String, Object>();\n    final List<Voice> voices = new ArrayList<Voice>();\n    final Voice voice = new Voice();\n    voice.setUrl(\"http://ibm.watson.com/text-to-speech/voices/en-US_TestMaleVoice\");\n    voice.setName(\"en-US_TestMaleVoice\");\n    voice.setGender(\"male\");\n    voice.setLanguage(\"en-US\");\n    voice.setDescription(\"TestMale\");\n\n    final Voice voice1 = new Voice();\n    voice1.setUrl(\"http://ibm.watson.com/text-to-speech/voices/en-US_TestFemaleVoice\");\n    voice1.setName(\"en-US_TestFemaleVoice\");\n    voice1.setGender(\"female\");\n    voice1.setLanguage(\"en-US\");\n    voice1.setDescription(\"TestFemale\");\n\n    voices.add(voice);\n    voices.add(voice1);\n\n    response.put(\"voices\", voices);\n\n    mockServer.when(request().withPath(GET_VOICES_PATH)).respond(\n        response().withHeaders(\n            new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.APPLICATION_JSON)).withBody(\n            GsonSingleton.getGsonWithoutPrettyPrinting().toJson(response)));\n\n    final List<Voice> result = service.getVoices();\n    Assert.assertNotNull(result);\n    Assert.assertFalse(result.isEmpty());\n    Assert.assertEquals(result, voices);\n  }",
            "method_tgt": "@Test\n  public void testGetVoices() {\n\n    final Map<String, Object> response = new HashMap<String, Object>();\n    final List<Voice> voices = new ArrayList<Voice>();\n    final Voice voice = new Voice();\n    voice.setUrl(\"http://ibm.watson.com/text-to-speech/voices/en-US_TestMaleVoice\");\n    voice.setName(\"en-US_TestMaleVoice\");\n    voice.setGender(\"male\");\n    voice.setLanguage(\"en-US\");\n    voice.setDescription(\"TestMale\");\n\n    final Voice voice1 = new Voice();\n    voice1.setUrl(\"http://ibm.watson.com/text-to-speech/voices/en-US_TestFemaleVoice\");\n    voice1.setName(\"en-US_TestFemaleVoice\");\n    voice1.setGender(\"female\");\n    voice1.setLanguage(\"en-US\");\n    voice1.setDescription(\"TestFemale\");\n\n    voices.add(voice);\n    voices.add(voice1);\n\n    response.put(\"voices\", voices);\n\n    mockServer.when(request().withPath(GET_VOICES_PATH)).respond(\n        response().withHeaders(\n            new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.APPLICATION_JSON)).withBody(\n            GsonSingleton.getGsonWithoutPrettyPrinting().toJson(response)));\n\n    final List<Voice> result = service.getVoices().execute();\n    Assert.assertNotNull(result);\n    Assert.assertFalse(result.isEmpty());\n    Assert.assertEquals(result, voices);\n  }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 0,
            "param_types": 0,
            "throw_types": 0
        },
        "aug": 3
    },
    {
        "repo_name": "watson-developer-cloud/java-sdk",
        "commit_id": "5af588b690b89abe408b1d71156c34ebf1a910e5",
        "commit_url": "https://github.com/watson-developer-cloud/java-sdk/commit/5af588b690b89abe408b1d71156c34ebf1a910e5",
        "focal_db": {
            "id": "5634030",
            "rel_path": "speech-to-text/src/main/java/com/ibm/watson/developer_cloud/speech_to_text/v1/SpeechToText.java",
            "method_src": "public ServiceCall<Void> deleteCorpus(String customizationId, String corpusName) {\n    Validator.notNull(customizationId, \"customizationId cannot be null\");\n    Validator.notNull(corpusName, \"corpusName cannot be null\");\n    RequestBuilder requestBuilder = RequestBuilder.delete(String.format(PATH_CORPUS, customizationId, corpusName));\n    return createServiceCall(requestBuilder.build(), ResponseConverterUtils.getVoid());\n  }",
            "method_tgt": "public ServiceCall<Void> deleteCorpus(DeleteCorpusOptions deleteCorpusOptions) {\n    Validator.notNull(deleteCorpusOptions, \"deleteCorpusOptions cannot be null\");\n    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/customizations/%s/corpora/%s\", deleteCorpusOptions\n        .customizationId(), deleteCorpusOptions.corpusName()));\n    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n  }"
        },
        "test_db": {
            "id": "5634111",
            "rel_path": "speech-to-text/src/test/java/com/ibm/watson/developer_cloud/speech_to_text/v1/SpeechToTextTest.java",
            "method_src": "@Test\n  public void testDeleteCorpus() throws InterruptedException, FileNotFoundException {\n    String id = \"foo\";\n    String corpus = \"cName\";\n\n    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(\"{}\"));\n\n    service.deleteCorpus(id, corpus).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals(\"DELETE\", request.getMethod());\n    assertEquals(String.format(PATH_CORPUS, id, corpus), request.getPath());\n  }",
            "method_tgt": "@Test\n  public void testDeleteCorpus() throws InterruptedException, FileNotFoundException {\n    String id = \"foo\";\n    String corpus = \"cName\";\n\n    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(\"{}\"));\n\n    DeleteCorpusOptions deleteOptions = new DeleteCorpusOptions.Builder()\n        .customizationId(id)\n        .corpusName(corpus)\n        .build();\n    service.deleteCorpus(deleteOptions).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals(\"DELETE\", request.getMethod());\n    assertEquals(String.format(PATH_CORPUS, id, corpus), request.getPath());\n  }"
        },
        "syn_diff": {
            "overall": 1,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        },
        "comment": "Case study"
    },
    {
        "repo_name": "watson-developer-cloud/java-sdk",
        "commit_id": "5af588b690b89abe408b1d71156c34ebf1a910e5",
        "commit_url": "https://github.com/watson-developer-cloud/java-sdk/commit/5af588b690b89abe408b1d71156c34ebf1a910e5",
        "focal_db": {
            "id": "5634030",
            "rel_path": "speech-to-text/src/main/java/com/ibm/watson/developer_cloud/speech_to_text/v1/SpeechToText.java",
            "method_src": "public ServiceCall<List<SpeechModel>> getModels() {\n    Request request = RequestBuilder.get(PATH_MODELS).build();\n    ResponseConverter<List<SpeechModel>> converter =\n        ResponseConverterUtils.getGenericObject(TYPE_LIST_MODELS, \"models\");\n    return createServiceCall(request, converter);\n  }",
            "method_tgt": "public ServiceCall<SpeechModels> listModels() {\n    return listModels(null);\n  }"
        },
        "test_db": {
            "id": "5634111",
            "rel_path": "speech-to-text/src/test/java/com/ibm/watson/developer_cloud/speech_to_text/v1/SpeechToTextTest.java",
            "method_src": "@Test\n  public void testGetModels() throws InterruptedException {\n    final SpeechModel speechModel = new SpeechModel(\"not-a-real-Model\");\n    speechModel.setRate(8000);\n\n    final SpeechModel speechModel1 = new SpeechModel(\"not-a-real-Model1\");\n    speechModel1.setRate(1600);\n\n    final SpeechModel speechModel2 = new SpeechModel(\"not-a-real-Model2\");\n    speechModel2.setRate(8000);\n\n    final List<SpeechModel> speechModels = ImmutableList.of(speechModel, speechModel1, speechModel2);\n    final Map<String, ?> response = ImmutableMap.of(\"models\", speechModels);\n\n    server.enqueue(\n        new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(response)));\n\n    final List<SpeechModel> models = service.getModels().execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertNotNull(models);\n    assertFalse(models.isEmpty());\n    assertEquals(models, response.get(\"models\"));\n    assertEquals(PATH_MODELS, request.getPath());\n  }",
            "method_tgt": "@Test\n  public void testGetModels() throws InterruptedException {\n    final SpeechModel speechModel = new SpeechModel();\n    speechModel.setName(\"not-a-real-Model\");\n    speechModel.setRate(8000);\n\n    final SpeechModel speechModel1 = new SpeechModel();\n    speechModel.setName(\"not-a-real-Model1\");\n    speechModel1.setRate(1600);\n\n    final SpeechModel speechModel2 = new SpeechModel();\n    speechModel.setName(\"not-a-real-Model2\");\n    speechModel2.setRate(8000);\n\n    final List<SpeechModel> speechModels = ImmutableList.of(speechModel, speechModel1, speechModel2);\n    final Map<String, ?> response = ImmutableMap.of(\"models\", speechModels);\n\n    server.enqueue(\n        new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(response)));\n\n    final SpeechModels models = service.listModels().execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertNotNull(models);\n    assertFalse(models.getModels().isEmpty());\n    assertEquals(models.getModels(), response.get(\"models\"));\n    assertEquals(PATH_MODELS, request.getPath());\n  }"
        },
        "syn_diff": {
            "overall": 2,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 1,
            "param_types": 0,
            "throw_types": 0
        },
        "aug": 1
    },
    {
        "repo_name": "watson-developer-cloud/java-sdk",
        "commit_id": "5af588b690b89abe408b1d71156c34ebf1a910e5",
        "commit_url": "https://github.com/watson-developer-cloud/java-sdk/commit/5af588b690b89abe408b1d71156c34ebf1a910e5",
        "focal_db": {
            "id": "5634030",
            "rel_path": "speech-to-text/src/main/java/com/ibm/watson/developer_cloud/speech_to_text/v1/SpeechToText.java",
            "method_src": "public ServiceCall<SpeechResults> recognize(File audio) {\n    return recognize(audio, (RecognizeOptions) null);\n  }",
            "method_tgt": "public ServiceCall<SpeechRecognitionResults> recognize(RecognizeOptions recognizeOptions) {\n    Validator.notNull(recognizeOptions, \"recognizeOptions cannot be null\");\n    Validator.isTrue(((recognizeOptions.audio() != null\n            && recognizeOptions.upload() == null)\n            || (recognizeOptions.audio() == null\n            && recognizeOptions.upload() != null)),\n        \"Exactly one of audio or upload must be supplied.\");\n    RequestBuilder builder = RequestBuilder.post(\"/v1/recognize\");\n    builder.header(\"Content-Type\", recognizeOptions.contentType());\n    if (recognizeOptions.transferEncoding() != null) {\n      builder.header(\"Transfer-Encoding\", recognizeOptions.transferEncoding());\n    }\n    if (recognizeOptions.model() != null) {\n      builder.query(\"model\", recognizeOptions.model());\n    }\n    if (recognizeOptions.customizationId() != null) {\n      builder.query(\"customization_id\", recognizeOptions.customizationId());\n    }\n    if (recognizeOptions.acousticCustomizationId() != null) {\n      builder.query(\"acoustic_customization_id\", recognizeOptions.acousticCustomizationId());\n    }\n    if (recognizeOptions.customizationWeight() != null) {\n      builder.query(\"customization_weight\", recognizeOptions.customizationWeight());\n    }\n    if (recognizeOptions.version() != null) {\n      builder.query(\"version\", recognizeOptions.version());\n    }\n    if (recognizeOptions.inactivityTimeout() != null) {\n      builder.query(\"inactivity_timeout\", recognizeOptions.inactivityTimeout());\n    }\n    if (recognizeOptions.keywords() != null) {\n      builder.query(\"keywords\", RequestUtils.join(recognizeOptions.keywords(), \",\"));\n    }\n    if (recognizeOptions.keywordsThreshold() != null) {\n      builder.query(\"keywords_threshold\", recognizeOptions.keywordsThreshold());\n    }\n    if (recognizeOptions.maxAlternatives() != null) {\n      builder.query(\"max_alternatives\", recognizeOptions.maxAlternatives());\n    }\n    if (recognizeOptions.wordAlternativesThreshold() != null) {\n      builder.query(\"word_alternatives_threshold\", recognizeOptions.wordAlternativesThreshold());\n    }\n    if (recognizeOptions.wordConfidence() != null) {\n      builder.query(\"word_confidence\", recognizeOptions.wordConfidence());\n    }\n    if (recognizeOptions.timestamps() != null) {\n      builder.query(\"timestamps\", recognizeOptions.timestamps());\n    }\n    if (recognizeOptions.profanityFilter() != null) {\n      builder.query(\"profanity_filter\", recognizeOptions.profanityFilter());\n    }\n    if (recognizeOptions.smartFormatting() != null) {\n      builder.query(\"smart_formatting\", recognizeOptions.smartFormatting());\n    }\n    if (recognizeOptions.speakerLabels() != null) {\n      builder.query(\"speaker_labels\", recognizeOptions.speakerLabels());\n    }\n    if (recognizeOptions.audio() != null) {\n      builder.body(RequestBody.create(MediaType.parse(recognizeOptions.contentType()), recognizeOptions.audio()));\n    }\n    MultipartBody.Builder multipartBuilder = new MultipartBody.Builder();\n    multipartBuilder.setType(MultipartBody.FORM);\n    if (recognizeOptions.upload() != null) {\n      RequestBody fileBody = RequestUtils.inputStreamBody(recognizeOptions.upload(), recognizeOptions\n          .contentType());\n      multipartBuilder.addFormDataPart(\"upload\", recognizeOptions.uploadFilename(), fileBody);\n      if (recognizeOptions.metadata() != null) {\n        multipartBuilder.addFormDataPart(\"metadata\", GsonSingleton.getGson().toJson(recognizeOptions.metadata()));\n      }\n      builder.body(multipartBuilder.build());\n    }\n    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(SpeechRecognitionResults.class));\n  }"
        },
        "test_db": {
            "id": "5634111",
            "rel_path": "speech-to-text/src/test/java/com/ibm/watson/developer_cloud/speech_to_text/v1/SpeechToTextTest.java",
            "method_src": "@Test\n  public void testRecognize() throws URISyntaxException, InterruptedException {\n\n    final SpeechResults speechResults = new SpeechResults();\n    speechResults.setResultIndex(0);\n    final Transcript transcript = new Transcript();\n    transcript.setFinal(true);\n    final SpeechAlternative speechAlternative = new SpeechAlternative();\n    speechAlternative.setTranscript(\"thunderstorms could produce large hail isolated tornadoes and heavy rain\");\n\n    final List<SpeechAlternative> speechAlternatives = ImmutableList.of(speechAlternative);\n    transcript.setAlternatives(speechAlternatives);\n\n    final List<Transcript> transcripts = ImmutableList.of(transcript);\n    speechResults.setResults(transcripts);\n\n    server.enqueue(\n        new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(speechResults)));\n\n    final SpeechResults result = service.recognize(SAMPLE_WAV).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertNotNull(result);\n    assertEquals(result, speechResults);\n    assertEquals(\"POST\", request.getMethod());\n    assertEquals(PATH_RECOGNIZE, request.getPath());\n    assertEquals(HttpMediaType.AUDIO_WAV, request.getHeader(CONTENT_TYPE));\n  }",
            "method_tgt": "@Test\n  public void testRecognize() throws URISyntaxException, InterruptedException {\n\n    final SpeechRecognitionResults speechResults = new SpeechRecognitionResults();\n    speechResults.setResultIndex(0);\n    final SpeechRecognitionResult transcript = new SpeechRecognitionResult();\n    transcript.setFinal(true);\n    final SpeechRecognitionAlternative speechAlternative = new SpeechRecognitionAlternative();\n    speechAlternative.setTranscript(\"thunderstorms could produce large hail isolated tornadoes and heavy rain\");\n\n    final List<SpeechRecognitionAlternative> speechAlternatives = ImmutableList.of(speechAlternative);\n    transcript.setAlternatives(speechAlternatives);\n\n    final List<SpeechRecognitionResult> transcripts = ImmutableList.of(transcript);\n    speechResults.setResults(transcripts);\n\n    server.enqueue(\n        new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(speechResults)));\n\n    RecognizeOptions recognizeOptions = new RecognizeOptions.Builder()\n        .audio(SAMPLE_WAV)\n        .contentType(RecognizeOptions.ContentType.AUDIO_WAV)\n        .build();\n    final SpeechRecognitionResults result = service.recognize(recognizeOptions).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertNotNull(result);\n    assertEquals(result, speechResults);\n    assertEquals(\"POST\", request.getMethod());\n    assertEquals(PATH_RECOGNIZE, request.getPath());\n    assertEquals(HttpMediaType.AUDIO_WAV, request.getHeader(CONTENT_TYPE));\n  }"
        },
        "syn_diff": {
            "overall": 2,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 2
    },
    {
        "repo_name": "watson-developer-cloud/java-sdk",
        "commit_id": "5af588b690b89abe408b1d71156c34ebf1a910e5",
        "commit_url": "https://github.com/watson-developer-cloud/java-sdk/commit/5af588b690b89abe408b1d71156c34ebf1a910e5",
        "focal_db": {
            "id": "5634030",
            "rel_path": "speech-to-text/src/main/java/com/ibm/watson/developer_cloud/speech_to_text/v1/SpeechToText.java",
            "method_src": "public ServiceCall<SpeechResults> recognize(File audio, RecognizeOptions options) {\n    Validator.isTrue((audio != null) && audio.exists(), \"audio file is null or does not exist\");\n\n    final double fileSize = audio.length() / Math.pow(1024, 2);\n    Validator.isTrue(fileSize < 100.0, \"The audio file is greater than 100MB.\");\n\n    String contentType = MediaTypeUtils.getMediaTypeFromFile(audio);\n    if ((options != null) && (options.contentType() != null)) {\n      contentType = options.contentType();\n    }\n    Validator.notNull(contentType, \"The audio format cannot be recognized\");\n\n    String path = PATH_RECOGNIZE;\n    if ((options != null) && (options.sessionId() != null) && !options.sessionId().isEmpty()) {\n      path = String.format(PATH_SESSION_RECOGNIZE, options.sessionId());\n    }\n\n    final RequestBuilder requestBuilder = RequestBuilder.post(path);\n    buildRecognizeRequest(requestBuilder, options);\n    requestBuilder.body(RequestBody.create(MediaType.parse(contentType), audio));\n    return createServiceCall(requestBuilder.build(), ResponseConverterUtils.getObject(SpeechResults.class));\n  }",
            "method_tgt": "public ServiceCall<SpeechRecognitionResults> recognize(RecognizeOptions recognizeOptions) {\n    Validator.notNull(recognizeOptions, \"recognizeOptions cannot be null\");\n    Validator.isTrue(((recognizeOptions.audio() != null\n            && recognizeOptions.upload() == null)\n            || (recognizeOptions.audio() == null\n            && recognizeOptions.upload() != null)),\n        \"Exactly one of audio or upload must be supplied.\");\n    RequestBuilder builder = RequestBuilder.post(\"/v1/recognize\");\n    builder.header(\"Content-Type\", recognizeOptions.contentType());\n    if (recognizeOptions.transferEncoding() != null) {\n      builder.header(\"Transfer-Encoding\", recognizeOptions.transferEncoding());\n    }\n    if (recognizeOptions.model() != null) {\n      builder.query(\"model\", recognizeOptions.model());\n    }\n    if (recognizeOptions.customizationId() != null) {\n      builder.query(\"customization_id\", recognizeOptions.customizationId());\n    }\n    if (recognizeOptions.acousticCustomizationId() != null) {\n      builder.query(\"acoustic_customization_id\", recognizeOptions.acousticCustomizationId());\n    }\n    if (recognizeOptions.customizationWeight() != null) {\n      builder.query(\"customization_weight\", recognizeOptions.customizationWeight());\n    }\n    if (recognizeOptions.version() != null) {\n      builder.query(\"version\", recognizeOptions.version());\n    }\n    if (recognizeOptions.inactivityTimeout() != null) {\n      builder.query(\"inactivity_timeout\", recognizeOptions.inactivityTimeout());\n    }\n    if (recognizeOptions.keywords() != null) {\n      builder.query(\"keywords\", RequestUtils.join(recognizeOptions.keywords(), \",\"));\n    }\n    if (recognizeOptions.keywordsThreshold() != null) {\n      builder.query(\"keywords_threshold\", recognizeOptions.keywordsThreshold());\n    }\n    if (recognizeOptions.maxAlternatives() != null) {\n      builder.query(\"max_alternatives\", recognizeOptions.maxAlternatives());\n    }\n    if (recognizeOptions.wordAlternativesThreshold() != null) {\n      builder.query(\"word_alternatives_threshold\", recognizeOptions.wordAlternativesThreshold());\n    }\n    if (recognizeOptions.wordConfidence() != null) {\n      builder.query(\"word_confidence\", recognizeOptions.wordConfidence());\n    }\n    if (recognizeOptions.timestamps() != null) {\n      builder.query(\"timestamps\", recognizeOptions.timestamps());\n    }\n    if (recognizeOptions.profanityFilter() != null) {\n      builder.query(\"profanity_filter\", recognizeOptions.profanityFilter());\n    }\n    if (recognizeOptions.smartFormatting() != null) {\n      builder.query(\"smart_formatting\", recognizeOptions.smartFormatting());\n    }\n    if (recognizeOptions.speakerLabels() != null) {\n      builder.query(\"speaker_labels\", recognizeOptions.speakerLabels());\n    }\n    if (recognizeOptions.audio() != null) {\n      builder.body(RequestBody.create(MediaType.parse(recognizeOptions.contentType()), recognizeOptions.audio()));\n    }\n    MultipartBody.Builder multipartBuilder = new MultipartBody.Builder();\n    multipartBuilder.setType(MultipartBody.FORM);\n    if (recognizeOptions.upload() != null) {\n      RequestBody fileBody = RequestUtils.inputStreamBody(recognizeOptions.upload(), recognizeOptions\n          .contentType());\n      multipartBuilder.addFormDataPart(\"upload\", recognizeOptions.uploadFilename(), fileBody);\n      if (recognizeOptions.metadata() != null) {\n        multipartBuilder.addFormDataPart(\"metadata\", GsonSingleton.getGson().toJson(recognizeOptions.metadata()));\n      }\n      builder.body(multipartBuilder.build());\n    }\n    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(SpeechRecognitionResults.class));\n  }"
        },
        "test_db": {
            "id": "5634111",
            "rel_path": "speech-to-text/src/test/java/com/ibm/watson/developer_cloud/speech_to_text/v1/SpeechToTextTest.java",
            "method_src": "@Test\n  public void testRecognizeWithCustomization() throws FileNotFoundException, InterruptedException {\n    String id = \"foo\";\n    String recString =\n        getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/recognition.json\"));\n    JsonObject recognition = new JsonParser().parse(recString).getAsJsonObject();\n\n    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(recString));\n\n    RecognizeOptions options = new RecognizeOptions.Builder().customizationId(id).build();\n    SpeechResults result = service.recognize(SAMPLE_WAV, options).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals(\"POST\", request.getMethod());\n    assertEquals(PATH_RECOGNIZE + \"?customization_id=\" + id, request.getPath());\n    assertEquals(recognition, GSON.toJsonTree(result));\n  }",
            "method_tgt": "@Test\n  public void testRecognizeWithCustomization() throws FileNotFoundException, InterruptedException {\n    String id = \"foo\";\n    String recString =\n        getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/recognition.json\"));\n    JsonObject recognition = new JsonParser().parse(recString).getAsJsonObject();\n\n    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(recString));\n\n    RecognizeOptions recognizeOptions = new RecognizeOptions.Builder()\n        .audio(SAMPLE_WAV)\n        .contentType(RecognizeOptions.ContentType.AUDIO_WAV)\n        .customizationId(id)\n        .build();\n    SpeechRecognitionResults result = service.recognize(recognizeOptions).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals(\"POST\", request.getMethod());\n    assertEquals(PATH_RECOGNIZE + \"?customization_id=\" + id, request.getPath());\n    assertEquals(recognition, GSON.toJsonTree(result));\n  }"
        },
        "syn_diff": {
            "overall": 2,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 0,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 3
    },
    {
        "repo_name": "watson-developer-cloud/java-sdk",
        "commit_id": "5af588b690b89abe408b1d71156c34ebf1a910e5",
        "commit_url": "https://github.com/watson-developer-cloud/java-sdk/commit/5af588b690b89abe408b1d71156c34ebf1a910e5",
        "focal_db": {
            "id": "5634030",
            "rel_path": "speech-to-text/src/main/java/com/ibm/watson/developer_cloud/speech_to_text/v1/SpeechToText.java",
            "method_src": "public ServiceCall<List<Customization>> getCustomizations(String language) {\n    RequestBuilder requestBuilder = RequestBuilder.get(PATH_CUSTOMIZATIONS);\n\n    if (language != null) {\n      requestBuilder.query(LANGUAGE, language);\n    }\n    ResponseConverter<List<Customization>> converter =\n        ResponseConverterUtils.getGenericObject(TYPE_LIST_CUSTOMIZATION, \"customizations\");\n\n    return createServiceCall(requestBuilder.build(), converter);\n  }",
            "method_tgt": "public ServiceCall<LanguageModels> listLanguageModels(ListLanguageModelsOptions listLanguageModelsOptions) {\n    RequestBuilder builder = RequestBuilder.get(\"/v1/customizations\");\n    if (listLanguageModelsOptions != null) {\n      if (listLanguageModelsOptions.language() != null) {\n        builder.query(\"language\", listLanguageModelsOptions.language());\n      }\n    }\n    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(LanguageModels.class));\n  }"
        },
        "test_db": {
            "id": "5634111",
            "rel_path": "speech-to-text/src/test/java/com/ibm/watson/developer_cloud/speech_to_text/v1/SpeechToTextTest.java",
            "method_src": "@Test\n  public void testGetCustomizations() throws InterruptedException, FileNotFoundException {\n    String customizationsAsString =\n        getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/customizations.json\"));\n    JsonObject customizations = new JsonParser().parse(customizationsAsString).getAsJsonObject();\n\n    server.enqueue(\n        new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(customizationsAsString));\n\n    List<Customization> result = service.getCustomizations(\"en-us\").execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals(\"GET\", request.getMethod());\n    assertEquals(PATH_CUSTOMIZATIONS + \"?language=en-us\", request.getPath());\n    assertEquals(customizations.get(\"customizations\").getAsJsonArray().size(), result.size());\n    assertEquals(customizations.get(\"customizations\"), GSON.toJsonTree(result));\n  }",
            "method_tgt": "@Test\n  public void testListLanguageModels() throws InterruptedException, FileNotFoundException {\n    String customizationsAsString =\n        getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/customizations.json\"));\n    JsonObject customizations = new JsonParser().parse(customizationsAsString).getAsJsonObject();\n\n    server.enqueue(\n        new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(customizationsAsString));\n\n    ListLanguageModelsOptions listOptions = new ListLanguageModelsOptions.Builder()\n        .language(\"en-us\")\n        .build();\n    LanguageModels result = service.listLanguageModels(listOptions).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals(\"GET\", request.getMethod());\n    assertEquals(PATH_CUSTOMIZATIONS + \"?language=en-us\", request.getPath());\n    assertEquals(customizations.get(\"customizations\").getAsJsonArray().size(), result.getCustomizations().size());\n    assertEquals(customizations.get(\"customizations\"), GSON.toJsonTree(result.getCustomizations()));\n  }"
        },
        "syn_diff": {
            "overall": 3,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 1,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 5,
        "comment": "Best Case Study"
    },
    {
        "repo_name": "watson-developer-cloud/java-sdk",
        "commit_id": "5af588b690b89abe408b1d71156c34ebf1a910e5",
        "commit_url": "https://github.com/watson-developer-cloud/java-sdk/commit/5af588b690b89abe408b1d71156c34ebf1a910e5",
        "focal_db": {
            "id": "5634030",
            "rel_path": "speech-to-text/src/main/java/com/ibm/watson/developer_cloud/speech_to_text/v1/SpeechToText.java",
            "method_src": "public ServiceCall<Customization> getCustomization(String customizationId) {\n    Validator.notNull(customizationId, \"customizationId cannot be null\");\n    RequestBuilder requestBuilder = RequestBuilder.get(String.format(PATH_CUSTOMIZATION, customizationId));\n    return createServiceCall(requestBuilder.build(), ResponseConverterUtils.getObject(Customization.class));\n  }",
            "method_tgt": "public ServiceCall<LanguageModel> getLanguageModel(GetLanguageModelOptions getLanguageModelOptions) {\n    Validator.notNull(getLanguageModelOptions, \"getLanguageModelOptions cannot be null\");\n    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/customizations/%s\", getLanguageModelOptions\n        .customizationId()));\n    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(LanguageModel.class));\n  }"
        },
        "test_db": {
            "id": "5634111",
            "rel_path": "speech-to-text/src/test/java/com/ibm/watson/developer_cloud/speech_to_text/v1/SpeechToTextTest.java",
            "method_src": "@Test\n  public void testGetCustomization() throws InterruptedException, FileNotFoundException {\n    String id = \"foo\";\n    Customization customization =\n        loadFixture(\"src/test/resources/speech_to_text/customization.json\", Customization.class);\n\n    server.enqueue(\n        new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(customization)));\n\n    Customization result = service.getCustomization(id).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals(\"GET\", request.getMethod());\n    assertEquals(String.format(PATH_CUSTOMIZATION, id), request.getPath());\n    assertEquals(result.toString(), customization.toString());\n  }",
            "method_tgt": "@Test\n  public void testGetLanguageModel() throws InterruptedException, FileNotFoundException {\n    String id = \"foo\";\n    LanguageModel model =\n        loadFixture(\"src/test/resources/speech_to_text/customization.json\", LanguageModel.class);\n\n    server.enqueue(\n        new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(model)));\n\n    GetLanguageModelOptions getOptions = new GetLanguageModelOptions.Builder()\n        .customizationId(id)\n        .build();\n    LanguageModel result = service.getLanguageModel(getOptions).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals(\"GET\", request.getMethod());\n    assertEquals(String.format(PATH_CUSTOMIZATION, id), request.getPath());\n    assertEquals(result.toString(), model.toString());\n  }"
        },
        "syn_diff": {
            "overall": 3,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 1,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 6
    },
    {
        "repo_name": "watson-developer-cloud/java-sdk",
        "commit_id": "5af588b690b89abe408b1d71156c34ebf1a910e5",
        "commit_url": "https://github.com/watson-developer-cloud/java-sdk/commit/5af588b690b89abe408b1d71156c34ebf1a910e5",
        "focal_db": {
            "id": "5634030",
            "rel_path": "speech-to-text/src/main/java/com/ibm/watson/developer_cloud/speech_to_text/v1/SpeechToText.java",
            "method_src": "public ServiceCall<Customization> createCustomization(String name, SpeechModel baseModel, String description) {\n    return createCustomization(name, baseModel, description, null);\n  }",
            "method_tgt": "public ServiceCall<LanguageModel> createLanguageModel(CreateLanguageModelOptions createLanguageModelOptions) {\n    Validator.notNull(createLanguageModelOptions, \"createLanguageModelOptions cannot be null\");\n    RequestBuilder builder = RequestBuilder.post(\"/v1/customizations\");\n    builder.header(\"Content-Type\", createLanguageModelOptions.contentType());\n    if (createLanguageModelOptions.contentType().equalsIgnoreCase(\n        CreateLanguageModelOptions.ContentType.APPLICATION_JSON)) {\n      builder.bodyJson(GsonSingleton.getGson().toJsonTree(createLanguageModelOptions.createLanguageModel())\n          .getAsJsonObject());\n    } else {\n      builder.bodyContent(createLanguageModelOptions.body(), createLanguageModelOptions.contentType());\n    }\n    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(LanguageModel.class));\n  }"
        },
        "test_db": {
            "id": "5634111",
            "rel_path": "speech-to-text/src/test/java/com/ibm/watson/developer_cloud/speech_to_text/v1/SpeechToTextTest.java",
            "method_src": "@Test\n  public void testCreateCustomization() throws InterruptedException, FileNotFoundException {\n    Customization customization =\n        loadFixture(\"src/test/resources/speech_to_text/customization.json\", Customization.class);\n\n    server.enqueue(\n        new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(customization)));\n\n    Customization result = service\n        .createCustomization(customization.getName(), SpeechModel.EN_GB_BROADBANDMODEL, customization.getDescription())\n        .execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals(\"POST\", request.getMethod());\n    assertEquals(PATH_CUSTOMIZATIONS, request.getPath());\n    assertEquals(result.toString(), customization.toString());\n  }",
            "method_tgt": "@Test\n  public void testCreateLanguageModel() throws InterruptedException, FileNotFoundException {\n    LanguageModel model =\n        loadFixture(\"src/test/resources/speech_to_text/customization.json\", LanguageModel.class);\n\n    server.enqueue(\n        new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(model)));\n\n    CreateLanguageModel newModel = new CreateLanguageModel.Builder()\n        .name(model.getName())\n        .baseModelName(\"en-GB_BroadbandModel\")\n        .description(model.getDescription())\n        .build();\n    CreateLanguageModelOptions createOptions = new CreateLanguageModelOptions.Builder()\n        .createLanguageModel(newModel)\n        .build();\n    LanguageModel result = service.createLanguageModel(createOptions).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals(\"POST\", request.getMethod());\n    assertEquals(PATH_CUSTOMIZATIONS, request.getPath());\n    assertEquals(result.toString(), model.toString());\n  }"
        },
        "syn_diff": {
            "overall": 3,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 1,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 7
    },
    {
        "repo_name": "watson-developer-cloud/java-sdk",
        "commit_id": "5af588b690b89abe408b1d71156c34ebf1a910e5",
        "commit_url": "https://github.com/watson-developer-cloud/java-sdk/commit/5af588b690b89abe408b1d71156c34ebf1a910e5",
        "focal_db": {
            "id": "5634030",
            "rel_path": "speech-to-text/src/main/java/com/ibm/watson/developer_cloud/speech_to_text/v1/SpeechToText.java",
            "method_src": "public ServiceCall<Void> deleteCustomization(String customizationId) {\n    Validator.notNull(customizationId, \"customizationId cannot be null\");\n    RequestBuilder requestBuilder = RequestBuilder.delete(String.format(PATH_CUSTOMIZATION, customizationId));\n    return createServiceCall(requestBuilder.build(), ResponseConverterUtils.getVoid());\n  }",
            "method_tgt": "public ServiceCall<Void> deleteLanguageModel(DeleteLanguageModelOptions deleteLanguageModelOptions) {\n    Validator.notNull(deleteLanguageModelOptions, \"deleteLanguageModelOptions cannot be null\");\n    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/customizations/%s\", deleteLanguageModelOptions\n        .customizationId()));\n    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n  }"
        },
        "test_db": {
            "id": "5634111",
            "rel_path": "speech-to-text/src/test/java/com/ibm/watson/developer_cloud/speech_to_text/v1/SpeechToTextTest.java",
            "method_src": "@Test\n  public void testDeleteCustomization() throws InterruptedException {\n    String id = \"foo\";\n\n    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(\"{}\"));\n\n    service.deleteCustomization(id).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals(\"DELETE\", request.getMethod());\n    assertEquals(String.format(PATH_CUSTOMIZATION, id), request.getPath());\n  }",
            "method_tgt": "@Test\n  public void testDeleteLanguageModel() throws InterruptedException {\n    String id = \"foo\";\n\n    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(\"{}\"));\n\n    DeleteLanguageModelOptions deleteOptions = new DeleteLanguageModelOptions.Builder()\n        .customizationId(id)\n        .build();\n    service.deleteLanguageModel(deleteOptions).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals(\"DELETE\", request.getMethod());\n    assertEquals(String.format(PATH_CUSTOMIZATION, id), request.getPath());\n  }"
        },
        "syn_diff": {
            "overall": 2,
            "modifiers": 0,
            "type_params": 0,
            "type": 0,
            "name": 1,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 8
    },
    {
        "repo_name": "watson-developer-cloud/java-sdk",
        "commit_id": "5af588b690b89abe408b1d71156c34ebf1a910e5",
        "commit_url": "https://github.com/watson-developer-cloud/java-sdk/commit/5af588b690b89abe408b1d71156c34ebf1a910e5",
        "focal_db": {
            "id": "5634030",
            "rel_path": "speech-to-text/src/main/java/com/ibm/watson/developer_cloud/speech_to_text/v1/SpeechToText.java",
            "method_src": "public ServiceCall<List<Corpus>> getCorpora(String customizationId) {\n    Validator.notNull(customizationId, \"customizationId cannot be null\");\n    RequestBuilder requestBuilder = RequestBuilder.get(String.format(PATH_CORPORA, customizationId));\n    ResponseConverter<List<Corpus>> converter = ResponseConverterUtils.getGenericObject(TYPE_CORPORA, \"corpora\");\n\n    return createServiceCall(requestBuilder.build(), converter);\n  }",
            "method_tgt": "public ServiceCall<Corpora> listCorpora(ListCorporaOptions listCorporaOptions) {\n    Validator.notNull(listCorporaOptions, \"listCorporaOptions cannot be null\");\n    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/customizations/%s/corpora\", listCorporaOptions\n        .customizationId()));\n    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Corpora.class));\n  }"
        },
        "test_db": {
            "id": "5634111",
            "rel_path": "speech-to-text/src/test/java/com/ibm/watson/developer_cloud/speech_to_text/v1/SpeechToTextTest.java",
            "method_src": "@Test\n  public void testGetCorpora() throws InterruptedException, FileNotFoundException {\n    String id = \"foo\";\n    String corporaAsString =\n        getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/corpora.json\"));\n    JsonObject corpora = new JsonParser().parse(corporaAsString).getAsJsonObject();\n\n    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(corporaAsString));\n\n    List<Corpus> result = service.getCorpora(id).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals(\"GET\", request.getMethod());\n    assertEquals(String.format(PATH_CORPORA, id), request.getPath());\n    assertEquals(corpora.get(\"corpora\"), GSON.toJsonTree(result));\n  }",
            "method_tgt": "@Test\n  public void testListCorpora() throws InterruptedException, FileNotFoundException {\n    String id = \"foo\";\n    String corporaAsString =\n        getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/corpora.json\"));\n    JsonObject corpora = new JsonParser().parse(corporaAsString).getAsJsonObject();\n\n    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(corporaAsString));\n\n    ListCorporaOptions listOptions = new ListCorporaOptions.Builder()\n        .customizationId(id)\n        .build();\n    Corpora result = service.listCorpora(listOptions).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals(\"GET\", request.getMethod());\n    assertEquals(String.format(PATH_CORPORA, id), request.getPath());\n    assertEquals(corpora.get(\"corpora\"), GSON.toJsonTree(result.getCorpora()));\n  }"
        },
        "syn_diff": {
            "overall": 3,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 1,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 9
    },
    {
        "repo_name": "watson-developer-cloud/java-sdk",
        "commit_id": "5af588b690b89abe408b1d71156c34ebf1a910e5",
        "commit_url": "https://github.com/watson-developer-cloud/java-sdk/commit/5af588b690b89abe408b1d71156c34ebf1a910e5",
        "focal_db": {
            "id": "5634030",
            "rel_path": "speech-to-text/src/main/java/com/ibm/watson/developer_cloud/speech_to_text/v1/SpeechToText.java",
            "method_src": "public ServiceCall<List<WordData>> getWords(String customizationId, Word.Type type) {\n    return getWords(customizationId, type, null);\n  }",
            "method_tgt": "public ServiceCall<Words> listWords(ListWordsOptions listWordsOptions) {\n    Validator.notNull(listWordsOptions, \"listWordsOptions cannot be null\");\n    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/customizations/%s/words\", listWordsOptions\n        .customizationId()));\n    if (listWordsOptions.wordType() != null) {\n      builder.query(\"word_type\", listWordsOptions.wordType());\n    }\n    if (listWordsOptions.sort() != null) {\n      builder.query(\"sort\", listWordsOptions.sort());\n    }\n    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Words.class));\n  }"
        },
        "test_db": {
            "id": "5634111",
            "rel_path": "speech-to-text/src/test/java/com/ibm/watson/developer_cloud/speech_to_text/v1/SpeechToTextTest.java",
            "method_src": "@Test\n  public void testGetWords() throws InterruptedException, FileNotFoundException {\n    String id = \"foo\";\n    String wordsAsStr = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/words.json\"));\n    JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject();\n\n    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr));\n\n    List<WordData> result = service.getWords(id, null).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals(\"GET\", request.getMethod());\n    assertEquals(String.format(PATH_WORDS, id), request.getPath());\n    assertEquals(words.get(\"words\"), GSON.toJsonTree(result));\n  }",
            "method_tgt": "@Test\n  public void testListWords() throws InterruptedException, FileNotFoundException {\n    String id = \"foo\";\n    String wordsAsStr = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/words.json\"));\n    JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject();\n\n    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr));\n\n    ListWordsOptions listOptions = new ListWordsOptions.Builder()\n        .customizationId(id)\n        .build();\n    Words result = service.listWords(listOptions).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals(\"GET\", request.getMethod());\n    assertEquals(String.format(PATH_WORDS, id), request.getPath());\n    assertEquals(words.get(\"words\"), GSON.toJsonTree(result.getWords()));\n  }"
        },
        "syn_diff": {
            "overall": 3,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 1,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 10
    },
    {
        "repo_name": "watson-developer-cloud/java-sdk",
        "commit_id": "5af588b690b89abe408b1d71156c34ebf1a910e5",
        "commit_url": "https://github.com/watson-developer-cloud/java-sdk/commit/5af588b690b89abe408b1d71156c34ebf1a910e5",
        "focal_db": {
            "id": "5634030",
            "rel_path": "speech-to-text/src/main/java/com/ibm/watson/developer_cloud/speech_to_text/v1/SpeechToText.java",
            "method_src": "public ServiceCall<List<WordData>> getWords(String customizationId, Word.Type type) {\n    return getWords(customizationId, type, null);\n  }",
            "method_tgt": "public ServiceCall<Words> listWords(ListWordsOptions listWordsOptions) {\n    Validator.notNull(listWordsOptions, \"listWordsOptions cannot be null\");\n    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/customizations/%s/words\", listWordsOptions\n        .customizationId()));\n    if (listWordsOptions.wordType() != null) {\n      builder.query(\"word_type\", listWordsOptions.wordType());\n    }\n    if (listWordsOptions.sort() != null) {\n      builder.query(\"sort\", listWordsOptions.sort());\n    }\n    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Words.class));\n  }"
        },
        "test_db": {
            "id": "5634111",
            "rel_path": "speech-to-text/src/test/java/com/ibm/watson/developer_cloud/speech_to_text/v1/SpeechToTextTest.java",
            "method_src": "@Test\n  public void testGetWordsType() throws InterruptedException, FileNotFoundException {\n    String id = \"foo\";\n    String wordsAsStr = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/words.json\"));\n    JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject();\n\n    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr));\n\n    List<WordData> result = service.getWords(id, Type.ALL).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals(\"GET\", request.getMethod());\n    assertEquals(String.format(PATH_WORDS, id) + \"?word_type=all\", request.getPath());\n    assertEquals(words.get(\"words\"), GSON.toJsonTree(result));\n  }",
            "method_tgt": "@Test\n  public void testListWordsType() throws InterruptedException, FileNotFoundException {\n    String id = \"foo\";\n    String wordsAsStr = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/words.json\"));\n    JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject();\n\n    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr));\n\n    ListWordsOptions listOptions = new ListWordsOptions.Builder()\n        .customizationId(id)\n        .wordType(ListWordsOptions.WordType.ALL)\n        .build();\n    Words result = service.listWords(listOptions).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals(\"GET\", request.getMethod());\n    assertEquals(String.format(PATH_WORDS, id) + \"?word_type=all\", request.getPath());\n    assertEquals(words.get(\"words\"), GSON.toJsonTree(result.getWords()));\n  }"
        },
        "syn_diff": {
            "overall": 3,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 1,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 11
    },
    {
        "repo_name": "watson-developer-cloud/java-sdk",
        "commit_id": "5af588b690b89abe408b1d71156c34ebf1a910e5",
        "commit_url": "https://github.com/watson-developer-cloud/java-sdk/commit/5af588b690b89abe408b1d71156c34ebf1a910e5",
        "focal_db": {
            "id": "5634030",
            "rel_path": "speech-to-text/src/main/java/com/ibm/watson/developer_cloud/speech_to_text/v1/SpeechToText.java",
            "method_src": "public ServiceCall<List<WordData>> getWords(String customizationId, Word.Type type, Word.Sort sort) {\n    Validator.notNull(customizationId, \"customizationId cannot be null\");\n    RequestBuilder requestBuilder = RequestBuilder.get(String.format(PATH_WORDS, customizationId));\n\n    if (type != null) {\n      requestBuilder.query(WORD_TYPE, type.toString().toLowerCase());\n    }\n    if (sort != null) {\n      requestBuilder.query(WORD_SORT, sort.getSort());\n    }\n\n    ResponseConverter<List<WordData>> converter = ResponseConverterUtils.getGenericObject(TYPE_WORDS, WORDS);\n    return createServiceCall(requestBuilder.build(), converter);\n  }",
            "method_tgt": "public ServiceCall<Words> listWords(ListWordsOptions listWordsOptions) {\n    Validator.notNull(listWordsOptions, \"listWordsOptions cannot be null\");\n    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/customizations/%s/words\", listWordsOptions\n        .customizationId()));\n    if (listWordsOptions.wordType() != null) {\n      builder.query(\"word_type\", listWordsOptions.wordType());\n    }\n    if (listWordsOptions.sort() != null) {\n      builder.query(\"sort\", listWordsOptions.sort());\n    }\n    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Words.class));\n  }"
        },
        "test_db": {
            "id": "5634111",
            "rel_path": "speech-to-text/src/test/java/com/ibm/watson/developer_cloud/speech_to_text/v1/SpeechToTextTest.java",
            "method_src": "@Test\n  public void testGetWordsSort() throws InterruptedException, FileNotFoundException {\n    String id = \"foo\";\n    String wordsAsStr = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/words.json\"));\n    JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject();\n\n    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr));\n\n    List<WordData> result = service.getWords(id, null, Sort.ALPHA).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals(\"GET\", request.getMethod());\n    assertEquals(String.format(PATH_WORDS, id) + \"?sort=alphabetical\", request.getPath());\n    assertEquals(words.get(\"words\"), GSON.toJsonTree(result));\n  }",
            "method_tgt": "@Test\n  public void testListWordsSort() throws InterruptedException, FileNotFoundException {\n    String id = \"foo\";\n    String wordsAsStr = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/words.json\"));\n    JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject();\n\n    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr));\n\n    ListWordsOptions listOptions = new ListWordsOptions.Builder()\n        .customizationId(id)\n        .sort(ListWordsOptions.Sort.ALPHABETICAL)\n        .build();\n    Words result = service.listWords(listOptions).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals(\"GET\", request.getMethod());\n    assertEquals(String.format(PATH_WORDS, id) + \"?sort=alphabetical\", request.getPath());\n    assertEquals(words.get(\"words\"), GSON.toJsonTree(result.getWords()));\n  }"
        },
        "syn_diff": {
            "overall": 3,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 1,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 12
    },
    {
        "repo_name": "watson-developer-cloud/java-sdk",
        "commit_id": "5af588b690b89abe408b1d71156c34ebf1a910e5",
        "commit_url": "https://github.com/watson-developer-cloud/java-sdk/commit/5af588b690b89abe408b1d71156c34ebf1a910e5",
        "focal_db": {
            "id": "5634030",
            "rel_path": "speech-to-text/src/main/java/com/ibm/watson/developer_cloud/speech_to_text/v1/SpeechToText.java",
            "method_src": "public ServiceCall<List<WordData>> getWords(String customizationId, Word.Type type, Word.Sort sort) {\n    Validator.notNull(customizationId, \"customizationId cannot be null\");\n    RequestBuilder requestBuilder = RequestBuilder.get(String.format(PATH_WORDS, customizationId));\n\n    if (type != null) {\n      requestBuilder.query(WORD_TYPE, type.toString().toLowerCase());\n    }\n    if (sort != null) {\n      requestBuilder.query(WORD_SORT, sort.getSort());\n    }\n\n    ResponseConverter<List<WordData>> converter = ResponseConverterUtils.getGenericObject(TYPE_WORDS, WORDS);\n    return createServiceCall(requestBuilder.build(), converter);\n  }",
            "method_tgt": "public ServiceCall<Words> listWords(ListWordsOptions listWordsOptions) {\n    Validator.notNull(listWordsOptions, \"listWordsOptions cannot be null\");\n    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/customizations/%s/words\", listWordsOptions\n        .customizationId()));\n    if (listWordsOptions.wordType() != null) {\n      builder.query(\"word_type\", listWordsOptions.wordType());\n    }\n    if (listWordsOptions.sort() != null) {\n      builder.query(\"sort\", listWordsOptions.sort());\n    }\n    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Words.class));\n  }"
        },
        "test_db": {
            "id": "5634111",
            "rel_path": "speech-to-text/src/test/java/com/ibm/watson/developer_cloud/speech_to_text/v1/SpeechToTextTest.java",
            "method_src": "@Test\n  public void testGetWordsTypeSort() throws InterruptedException, FileNotFoundException {\n    String id = \"foo\";\n    String wordsAsStr = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/words.json\"));\n    JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject();\n\n    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr));\n\n    List<WordData> result = service.getWords(id, Type.ALL, Sort.ALPHA).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals(\"GET\", request.getMethod());\n    assertEquals(String.format(PATH_WORDS, id) + \"?word_type=all&sort=alphabetical\", request.getPath());\n    assertEquals(words.get(\"words\"), GSON.toJsonTree(result));\n  }",
            "method_tgt": "@Test\n  public void testListWordsTypeSort() throws InterruptedException, FileNotFoundException {\n    String id = \"foo\";\n    String wordsAsStr = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/words.json\"));\n    JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject();\n\n    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr));\n\n    ListWordsOptions listOptions = new ListWordsOptions.Builder()\n        .customizationId(id)\n        .sort(ListWordsOptions.Sort.ALPHABETICAL)\n        .wordType(ListWordsOptions.WordType.ALL)\n        .build();\n    Words result = service.listWords(listOptions).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals(\"GET\", request.getMethod());\n    assertEquals(String.format(PATH_WORDS, id) + \"?word_type=all&sort=alphabetical\", request.getPath());\n    assertEquals(words.get(\"words\"), GSON.toJsonTree(result.getWords()));\n  }"
        },
        "syn_diff": {
            "overall": 3,
            "modifiers": 0,
            "type_params": 0,
            "type": 1,
            "name": 1,
            "param_types": 1,
            "throw_types": 0
        },
        "aug": 13
    }
]