[
    {
        "id": 0,
        "Anal": "The method \"getGroupFromGrpcClient\" now requires an additional parameter of type `AlluxioConfiguration`.",
        "Stmts": "Assert.assertEquals(\"\", SecurityUtils.getGroupFromGrpcClient());\nAssert.assertEquals(\"test_client_user\", SecurityUtils.getGroupFromGrpcClient());",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    String owner = SecurityUtils.getOwnerFromGrpcClient();\n-    String group = SecurityUtils.getGroupFromGrpcClient();\n+    String owner = SecurityUtils.getOwnerFromGrpcClient(ServerConfiguration.global());\n+    String group = SecurityUtils.getGroupFromGrpcClient(ServerConfiguration.global());",
                "-      mOwner = SecurityUtils.getOwnerFromGrpcClient();\n-      mGroup = SecurityUtils.getGroupFromGrpcClient();\n+    if (SecurityUtils.isAuthenticationEnabled(ServerConfiguration.global())) {\n+      mOwner = SecurityUtils.getOwnerFromGrpcClient(ServerConfiguration.global());\n+      mGroup = SecurityUtils.getGroupFromGrpcClient(ServerConfiguration.global());",
                "-    try (Closeable r = new AuthenticatedUserRule(user.getUser()).toResource()) {\n-      CreateDirectoryContext context = CreateDirectoryContext.defaults(CreateDirectoryPOptions.newBuilder().setRecursive(recursive)).setOwner(SecurityUtils.getOwnerFromGrpcClient()).setGroup(SecurityUtils.getGroupFromGrpcClient());\n+    try (Closeable r = new AuthenticatedUserRule(user.getUser(), ServerConfiguration.global()).toResource()) {\n+      CreateDirectoryContext context = CreateDirectoryContext.defaults(CreateDirectoryPOptions.newBuilder().setRecursive(recursive)).setOwner(SecurityUtils.getOwnerFromGrpcClient(ServerConfiguration.global())).setGroup(SecurityUtils.getGroupFromGrpcClient(ServerConfiguration.global()));"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class AlluxioConfiguration (optional references)",
                "contexts": [
                    "Duration getDuration(PropertyKey key);",
                    "Map<String, String> toMap(ConfigurationValueOptions opts);",
                    "String get(PropertyKey key, ConfigurationValueOptions options);"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-      User user = AuthenticatedClientUser.get();\n+      User user = AuthenticatedClientUser.get(conf);",
                    "-      return LoginUser.get().getName();\n+      return LoginUser.get(conf).getName();",
                    "-      return CommonUtils.getPrimaryGroupName(LoginUser.get().getName());\n+      return CommonUtils.getPrimaryGroupName(LoginUser.get(conf).getName(), conf);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    Assert.assertEquals(\"test_client_user\", SecurityUtils.getOwnerFromGrpcClient());\n+    Assert.assertEquals(\"test_client_user\", SecurityUtils.getOwnerFromGrpcClient(mConfiguration));",
                    "-    Assert.assertEquals(\"test_login_user\", SecurityUtils.getGroupFromLoginModule());\n+    Assert.assertEquals(\"test_login_user\", SecurityUtils.getGroupFromLoginModule(mConfiguration));",
                    "-    Configuration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.NOSASL.getAuthName());\n-    Assert.assertEquals(\"\", SecurityUtils.getGroupFromLoginModule());\n-    Configuration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());\n-    Configuration.set(PropertyKey.SECURITY_LOGIN_USERNAME, \"test_login_user\");\n-    Configuration.set(PropertyKey.SECURITY_GROUP_MAPPING_CLASS, IdentityUserGroupsMapping.class.getName());\n+    mConfiguration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.NOSASL.getAuthName());\n+    Assert.assertEquals(\"\", SecurityUtils.getGroupFromLoginModule(mConfiguration));\n+    mConfiguration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());\n+    mConfiguration.set(PropertyKey.SECURITY_LOGIN_USERNAME, \"test_login_user\");\n+    mConfiguration.set(PropertyKey.SECURITY_GROUP_MAPPING_CLASS, IdentityUserGroupsMapping.class.getName());"
                ]
            }
        ]
    },
    {
        "id": 1,
        "Anal": "The method \"getTmpDir\" now requires a parameter of type `List<String>` named \"tmpDirs\".",
        "Stmts": "assertEquals(singleDir, CommonUtils.getTmpDir());\nresults.add(CommonUtils.getTmpDir());",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    mFile = new File(PathUtils.concatPath(CommonUtils.getTmpDir(), UUID.randomUUID()));\n+    mFile = new File(PathUtils.concatPath(CommonUtils.getTmpDir(mTmpDirs), UUID.randomUUID()));",
                "-  public S3AOutputStream(String bucketName, String key, TransferManager manager) throws IOException {\n+  public S3AOutputStream(String bucketName, String key, TransferManager manager, List<String> tmpDirs, boolean sseEnabled) throws IOException {\n-    mFile = new File(PathUtils.concatPath(CommonUtils.getTmpDir(), UUID.randomUUID()));\n+    mSseEnabled = sseEnabled;\n+    mFile = new File(PathUtils.concatPath(CommonUtils.getTmpDir(tmpDirs), UUID.randomUUID()));",
                "-  public OSSOutputStream(String bucketName, String key, OSSClient client) throws IOException {\n+  public OSSOutputStream(String bucketName, String key, OSSClient client, List<String> tmpDirs) throws IOException {\n-    mFile = new File(PathUtils.concatPath(CommonUtils.getTmpDir(), UUID.randomUUID()));\n+    mFile = new File(PathUtils.concatPath(CommonUtils.getTmpDir(tmpDirs), UUID.randomUUID()));"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public static boolean isLocalHost(WorkerNetAddress address) {\n-    return address.getHost().equals(NetworkAddressUtils.getClientHostName());\n-  }\n-  public static String convertMsToDate(long millis) {\n-    DateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT_PATTERN);\n+  public static boolean isLocalHost(WorkerNetAddress address, AlluxioConfiguration conf) {\n+    return address.getHost().equals(NetworkAddressUtils.getClientHostName(conf));\n+  }\n+  public static String convertMsToDate(long millis, String dateFormatPattern) {\n+    DateFormat dateFormat = new SimpleDateFormat(dateFormatPattern);",
                    "-  public static String getWorkerDataDirectory(String storageDir) {\n-    return PathUtils.concatPath(storageDir.trim(), Configuration.get(PropertyKey.WORKER_DATA_FOLDER));\n+  public static String getWorkerDataDirectory(String storageDir, AlluxioConfiguration conf) {\n+    return PathUtils.concatPath(storageDir.trim(), conf.get(PropertyKey.WORKER_DATA_FOLDER));",
                    "-  public static String getPrimaryGroupName(String userName) throws IOException {\n-    List<String> groups = getGroups(userName);\n+  public static String getPrimaryGroupName(String userName, AlluxioConfiguration conf) throws IOException {\n+    List<String> groups = getGroups(userName, conf);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "+    InstancedConfiguration conf = ConfigurationTestUtils.defaults();",
                    "-    Mockito.when(GroupMappingService.Factory.get()).thenReturn(cachedGroupService);\n-    List<String> groups = CommonUtils.getGroups(userName);\n+    Mockito.when(GroupMappingService.Factory.get(conf)).thenReturn(cachedGroupService);\n+    List<String> groups = CommonUtils.getGroups(userName, conf);",
                    "-    String primaryGroup = CommonUtils.getPrimaryGroupName(userName);\n+    String primaryGroup = CommonUtils.getPrimaryGroupName(userName, conf);"
                ]
            }
        ]
    },
    {
        "id": 2,
        "Anal": "The method name \"formatPermission\" changes to \"formatMode\", and the first parameter \"permission\" changes to \"mode\".",
        "Stmts": "Assert.assertEquals(\"-rw-rw-rw-\", FormatUtils.formatPermission((short)0666, false));\nAssert.assertEquals(\"drw-rw-rw-\", FormatUtils.formatPermission((short)0666, true));\nAssert.assertEquals(\"-rwxrwxrwx\", FormatUtils.formatPermission((short)0777, false));\nAssert.assertEquals(\"drwxrwxrwx\", FormatUtils.formatPermission((short)0777, true));\nAssert.assertEquals(\"-r--r--r--\", FormatUtils.formatPermission((short)0444, false));\nAssert.assertEquals(\"dr--r--r--\", FormatUtils.formatPermission((short)0444, true));\nAssert.assertEquals(\"-r-xr-xr-x\", FormatUtils.formatPermission((short)0555, false));\nAssert.assertEquals(\"dr-xr-xr-x\", FormatUtils.formatPermission((short)0555, true));\nAssert.assertEquals(\"-rwxr-xr--\", FormatUtils.formatPermission((short)0754, false));\nAssert.assertEquals(\"drwxr-xr--\", FormatUtils.formatPermission((short)0754, true));",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    mPermission = FormatUtils.formatPermission(Mode.createNoAccess().toShort(), true);\n+    mPermission = FormatUtils.formatMode(Mode.createNoAccess().toShort(), true);",
                "-    mPermission = FormatUtils.formatPermission((short)status.getPermission(), status.isFolder());\n+    mPermission = FormatUtils.formatMode((short)status.getPermission(), status.isFolder());",
                "-    return String.format(Constants.LS_FORMAT, FormatUtils.formatPermission((short)permission, isDir), testUser, testGroup, FormatUtils.getSizeFromBytes(size), CommandUtils.convertMsToDate(createTime), fileType, path);\n+    return String.format(Constants.LS_FORMAT, FormatUtils.formatMode((short)permission, isDir), testUser, testGroup, FormatUtils.getSizeFromBytes(size), CommandUtils.convertMsToDate(createTime), fileType, path);"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": []
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 3,
        "Anal": "The method \"applyUMask\" no longer takes a \"Configuration\" object as a parameter.",
        "Stmts": "Configuration conf = new Configuration();\nconf.set(Constants.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());\nconf.set(Constants.SECURITY_AUTHORIZATION_PERMISSION_ENABLED, \"true\");\npermissionStatus = permissionStatus.applyUMask(umaskPermission, conf);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    return super.setPermissionStatus(permissionStatus.applyUMask(UMASK, MasterContext.getConf()));\n+    if (!SecurityUtils.isAuthorizationEnabled(MasterContext.getConf())) {\n+      return super.setPermissionStatus(permissionStatus);\n+    }\n+    return super.setPermissionStatus(permissionStatus.applyUMask(UMASK));"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+  }\n+  public static PermissionStatus getAsLoginUser(Configuration conf) throws IOException {\n+    if (!SecurityUtils.isAuthenticationEnabled(conf)) {\n+      return new PermissionStatus(\"\", \"\", FileSystemPermission.getFullFsPermission());",
                    "-    if (remote) {\n-      User user = AuthenticatedClientUser.get(conf);\n-      if (user == null) {\n-        throw new IOException(ExceptionMessage.AUTHORIZED_CLIENT_USER_IS_NULL.getMessage());\n-      }\n-      return new PermissionStatus(user.getName(), CommonUtils.getPrimaryGroupName(conf, user.getName()), FileSystemPermission.getDefault().applyUMask(conf));\n+    User user = AuthenticatedClientUser.get(conf);\n+    if (user == null) {\n+      throw new IOException(ExceptionMessage.AUTHORIZED_CLIENT_USER_IS_NULL.getMessage());\n+    }",
                    "-  public static PermissionStatus get(Configuration conf, boolean remote) throws IOException {\n-    if (!SecurityUtils.isSecurityEnabled(conf)) {\n+  public static PermissionStatus getDefault(Configuration conf) throws IOException {\n+    if (!SecurityUtils.isAuthenticationEnabled(conf)) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    permissionStatus = PermissionStatus.get(conf, false);\n+    permissionStatus = PermissionStatus.getAsLoginUser(conf);",
                    "-    permissionStatus = PermissionStatus.get(conf, true);\n+    permissionStatus = PermissionStatus.getDefault(conf);",
                    "-    conf.set(Constants.SECURITY_AUTHORIZATION_PERMISSION_ENABLED, \"false\");\n-    permissionStatus = PermissionStatus.get(conf, true);\n+    permissionStatus = PermissionStatus.getDefault(conf);"
                ]
            }
        ]
    },
    {
        "id": 4,
        "Anal": "The third parameter \"options\" of the method \"mount\" changes from `MountOptions` to `MountPOptions`.",
        "Stmts": "MountOptions mountOptions = MountOptions.defaults();\nmFileSystem.mount(alluxioPath, ufsPath, mountOptions);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    MountOptions mountOptions = MountOptions.defaults();\n+    MountPOptions mountOptions = MountPOptions.getDefaultInstance();\n       mFileSystem.mount(alluxioPath, ufsPath, mountOptions);",
                "-    MountOptions options1 = MountOptions.defaults().setProperties(UFS_CONF1);\n+    MountPOptions options1 = MountPOptions.newBuilder().putAllProperties(UFS_CONF1).build();\n-    MountOptions options2 = MountOptions.defaults().setProperties(UFS_CONF2);\n+    MountPOptions options2 = MountPOptions.newBuilder().putAllProperties(UFS_CONF2).build();\n     mFileSystem.mount(mMountPoint2, new AlluxioURI(mUfsUri2), options2);",
                "-    mount(alluxioPath, ufsPath, MountOptions.defaults());\n-  }\n-  @Override\n-  public void mount(AlluxioURI alluxioPath, AlluxioURI ufsPath, MountOptions options) throws IOException, AlluxioException {\n+    mount(alluxioPath, ufsPath, MountPOptions.getDefaultInstance());"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class MountPOptions (optional references)",
                "contexts": [
                    "public static alluxio.grpc.MountPOptions getDefaultInstance();",
                    "public alluxio.grpc.MountPOptions getDefaultInstanceForType();",
                    "public static alluxio.grpc.MountPOptions parseFrom( java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException;",
                    "public boolean hasCommonOptions();"
                ]
            },
            {
                "info": "Defined in class MountPOptions.PropertiesDefaultEntryHolder.Builder (optional references)",
                "contexts": [
                    "public Builder setCommonOptions(alluxio.grpc.FileSystemMasterCommonPOptions value);",
                    "public Builder setCommonOptions( alluxio.grpc.FileSystemMasterCommonPOptions.Builder builderForValue);"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    delete(path, DeleteOptions.defaults());\n-  }\n-  @Override\n-  public void delete(AlluxioURI path, DeleteOptions options)throws DirectoryNotEmptyException, FileDoesNotExistException, IOException, AlluxioException {\n+    delete(path, DeletePOptions.getDefaultInstance());\n+  }\n+  @Override\n+  public void delete(AlluxioURI path, DeletePOptions options)throws DirectoryNotEmptyException, FileDoesNotExistException, IOException, AlluxioException {",
                    "-    free(path, FreeOptions.defaults());\n-  }\n-  @Override\n-  public void free(AlluxioURI path, FreeOptions options) throws FileDoesNotExistException, IOException, AlluxioException {\n+    free(path, FreePOptions.getDefaultInstance());\n+  }\n+  @Override\n+  public void free(AlluxioURI path, FreePOptions options) throws FileDoesNotExistException, IOException, AlluxioException {",
                    "-  void delete(AlluxioURI path, DeleteOptions options)throws DirectoryNotEmptyException, FileDoesNotExistException, IOException, AlluxioException;\n+  void delete(AlluxioURI path, DeletePOptions options)throws DirectoryNotEmptyException, FileDoesNotExistException, IOException, AlluxioException;"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    MountOptions mountOptions = MountOptions.defaults();\n+    MountPOptions mountOptions = MountPOptions.getDefaultInstance();",
                    "-    OpenFileOptions openOptions = OpenFileOptions.defaults();\n-    mFileSystem.openFile(file, openOptions);\n+    mFileSystem.openFile(file, OpenFilePOptions.getDefaultInstance());",
                    "-    OpenFileOptions openOptions = OpenFileOptions.defaults();\n-    try {\n-      mFileSystem.openFile(file, openOptions);\n+    try {\n+      mFileSystem.openFile(file, OpenFilePOptions.getDefaultInstance());"
                ]
            }
        ]
    },
    {
        "id": 5,
        "Anal": "The sixth parameter \"options\" of the method \"workerRegister\" changes from `RegisterWorkerTOptions` to `RegisterWorkerPOptions`.",
        "Stmts": "mBlockMaster.workerRegister(worker1, tiers, worker1TotalBytesOnTiers, worker1UsedBytesOnTiers, NO_BLOCKS_ON_TIERS, new RegisterWorkerTOptions());\nmBlockMaster.workerRegister(worker2, tiers, worker2TotalBytesOnTiers, worker2UsedBytesOnTiers, NO_BLOCKS_ON_TIERS, new RegisterWorkerTOptions());",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    mBlockMaster.workerRegister(worker1, tiers, WORKER1_TOTAL_BYTES_ON_TIERS, WORKER1_USED_BYTES_ON_TIERS, NO_BLOCKS_ON_TIERS, new RegisterWorkerTOptions());\n-    mBlockMaster.workerRegister(worker2, tiers, WORKER2_TOTAL_BYTES_ON_TIERS, WORKER2_USED_BYTES_ON_TIERS, NO_BLOCKS_ON_TIERS, new RegisterWorkerTOptions());\n+    mBlockMaster.workerRegister(worker1, tiers, WORKER1_TOTAL_BYTES_ON_TIERS, WORKER1_USED_BYTES_ON_TIERS, NO_BLOCKS_ON_TIERS, RegisterWorkerPOptions.getDefaultInstance());",
                "-    mBlockMaster.workerRegister(worker1, tiers, WORKER1_TOTAL_BYTES_ON_TIERS, WORKER1_USED_BYTES_ON_TIERS, NO_BLOCKS_ON_TIERS, new RegisterWorkerTOptions());\n-    mBlockMaster.workerRegister(worker2, tiers, WORKER2_TOTAL_BYTES_ON_TIERS, WORKER2_USED_BYTES_ON_TIERS, NO_BLOCKS_ON_TIERS, new RegisterWorkerTOptions());\n+    mBlockMaster.workerRegister(worker1, tiers, WORKER1_TOTAL_BYTES_ON_TIERS, WORKER1_USED_BYTES_ON_TIERS, NO_BLOCKS_ON_TIERS, RegisterWorkerPOptions.getDefaultInstance());\n+    mBlockMaster.workerRegister(worker2, tiers, WORKER2_TOTAL_BYTES_ON_TIERS, WORKER2_USED_BYTES_ON_TIERS, NO_BLOCKS_ON_TIERS, RegisterWorkerPOptions.getDefaultInstance());",
                "-    mBlockMaster.workerRegister(worker1, ImmutableList.of(\"MEM\"), ImmutableMap.of(\"MEM\", 100L), ImmutableMap.of(\"MEM\", 10L), NO_BLOCKS_ON_TIERS, new RegisterWorkerTOptions());\n+    mBlockMaster.workerRegister(worker1, ImmutableList.of(\"MEM\"), ImmutableMap.of(\"MEM\", 100L), ImmutableMap.of(\"MEM\", 10L), NO_BLOCKS_ON_TIERS, RegisterWorkerPOptions.getDefaultInstance());\n-    mBlockMaster.workerRegister(worker1, ImmutableList.of(\"MEM\"), ImmutableMap.of(\"MEM\", 100L), ImmutableMap.of(\"MEM\", 10L), NO_BLOCKS_ON_TIERS, new RegisterWorkerTOptions());\n+    mBlockMaster.workerRegister(worker1, ImmutableList.of(\"MEM\"), ImmutableMap.of(\"MEM\", 100L), ImmutableMap.of(\"MEM\", 10L), NO_BLOCKS_ON_TIERS, RegisterWorkerPOptions.getDefaultInstance());"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class RegisterWorkerPOptions (optional references)",
                "contexts": [
                    "public static alluxio.grpc.RegisterWorkerPOptions getDefaultInstance();",
                    "public alluxio.grpc.RegisterWorkerPOptions getDefaultInstanceForType();",
                    "public static alluxio.grpc.RegisterWorkerPOptions parseFrom( byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException;",
                    "public static com.google.protobuf.Parser<RegisterWorkerPOptions> parser();"
                ]
            },
            {
                "info": "Defined in class RegisterWorkerPOptions.Builder (optional references)",
                "contexts": [
                    "public alluxio.grpc.RegisterWorkerPOptions build();",
                    "public alluxio.grpc.RegisterWorkerPOptions buildPartial();"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-      return new Command(CommandType.Register, new ArrayList<Long>());\n+      return Command.newBuilder().setCommandType(CommandType.Register).build();",
                    "-        return new Command(CommandType.Nothing, new ArrayList<Long>());\n-      }\n-      return new Command(CommandType.Free, toRemoveBlocks);\n+        return Command.newBuilder().setCommandType(CommandType.Nothing).build();\n+      }\n+      return Command.newBuilder().setCommandType(CommandType.Free).addAllData(toRemoveBlocks).build();",
                    "-  public Map<String, TProcessor> getServices() {\n-    Map<String, TProcessor> services = new HashMap<>();\n-    services.put(Constants.BLOCK_MASTER_CLIENT_SERVICE_NAME, new BlockMasterClientService.Processor<>(new BlockMasterClientServiceHandler(this)));\n-    services.put(Constants.BLOCK_MASTER_WORKER_SERVICE_NAME, new BlockMasterWorkerService.Processor<>(new BlockMasterWorkerServiceHandler(this)));\n+  public Map<ServiceType, GrpcService> getServices() {\n+    Map<ServiceType, GrpcService> services = new HashMap<>();\n+    services.put(ServiceType.BLOCK_MASTER_CLIENT_SERVICE, new GrpcService(new BlockMasterClientServiceHandler(this)));\n+    services.put(ServiceType.BLOCK_MASTER_WORKER_SERVICE, new GrpcService(new BlockMasterWorkerServiceHandler(this)));"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    mBlockMaster.workerRegister(worker1, Arrays.asList(\"MEM\"), ImmutableMap.of(\"MEM\", 100L), ImmutableMap.of(\"MEM\", 0L), NO_BLOCKS_ON_TIERS, new RegisterWorkerTOptions());\n+    mBlockMaster.workerRegister(worker1, Arrays.asList(\"MEM\"), ImmutableMap.of(\"MEM\", 100L), ImmutableMap.of(\"MEM\", 0L), NO_BLOCKS_ON_TIERS, RegisterWorkerPOptions.getDefaultInstance());",
                    "-    mBlockMaster.workerRegister(worker1, ImmutableList.of(\"MEM\"), ImmutableMap.of(\"MEM\", 100L), ImmutableMap.of(\"MEM\", 10L), NO_BLOCKS_ON_TIERS, new RegisterWorkerTOptions());\n+    mBlockMaster.workerRegister(worker1, ImmutableList.of(\"MEM\"), ImmutableMap.of(\"MEM\", 100L), ImmutableMap.of(\"MEM\", 10L), NO_BLOCKS_ON_TIERS, RegisterWorkerPOptions.getDefaultInstance());",
                    "-    mBlockMaster.workerRegister(worker, Arrays.asList(\"MEM\"), ImmutableMap.of(\"MEM\", 100L), initialUsedBytesOnTiers, NO_BLOCKS_ON_TIERS, new RegisterWorkerTOptions());\n+    mBlockMaster.workerRegister(worker, Arrays.asList(\"MEM\"), ImmutableMap.of(\"MEM\", 100L), initialUsedBytesOnTiers, NO_BLOCKS_ON_TIERS, RegisterWorkerPOptions.getDefaultInstance());"
                ]
            }
        ]
    },
    {
        "id": 6,
        "Anal": "The method \"setUserFromThriftClient\" no longer accepts a `Configuration` parameter.",
        "Stmts": "permission.setUserFromThriftClient(conf);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "+    Configuration.defaultInit();\n-    conf.set(Constants.SECURITY_AUTHENTICATION_TYPE, AuthType.NOSASL.getAuthName());\n-    permission.setUserFromThriftClient(conf);\n+    Configuration.set(Constants.SECURITY_AUTHENTICATION_TYPE, AuthType.NOSASL.getAuthName());\n+    permission.setUserFromThriftClient();",
                "-    conf.set(Constants.SECURITY_GROUP_MAPPING, IdentityUserGroupsMapping.class.getName());\n+    Configuration.set(Constants.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());\n+    Configuration.set(Constants.SECURITY_GROUP_MAPPING, IdentityUserGroupsMapping.class.getName());\n-    permission.setUserFromThriftClient(conf);\n+    permission.setUserFromThriftClient();",
                "-    mPermission = Permission.defaults().setUserFromThriftClient(MasterContext.getConf());\n+    mPermission = Permission.defaults().setUserFromThriftClient();"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    String loginUserName = LoginUser.get(conf).getName();\n+    String loginUserName = LoginUser.get().getName();",
                    "-    mGroupName = CommonUtils.getPrimaryGroupName(conf, loginUserName);\n+    mGroupName = CommonUtils.getPrimaryGroupName(loginUserName);",
                    "-  public Permission applyFileUMask(Configuration conf) {\n-    mMode = mMode.applyUMask(Mode.getUMask(conf)).applyUMask(FILE_UMASK);\n+  public Permission applyFileUMask() {\n+    mMode = mMode.applyUMask(Mode.getUMask()).applyUMask(FILE_UMASK);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    permission.setUserFromThriftClient(conf);\n+    permission.setUserFromThriftClient();",
                    "-    conf.set(Constants.SECURITY_AUTHENTICATION_TYPE, AuthType.NOSASL.getAuthName());\n-    permission.setUserFromThriftClient(conf);\n+    Configuration.set(Constants.SECURITY_AUTHENTICATION_TYPE, AuthType.NOSASL.getAuthName());\n+    permission.setUserFromThriftClient();",
                    "-    Configuration conf = new Configuration();\n-    conf.set(Constants.SECURITY_AUTHENTICATION_TYPE, AuthType.NOSASL.getAuthName());\n+    Configuration.defaultInit();\n+    Configuration.set(Constants.SECURITY_AUTHENTICATION_TYPE, AuthType.NOSASL.getAuthName());"
                ]
            }
        ]
    },
    {
        "id": 7,
        "Anal": "The method \"createBlockPath\" has an additional parameter \"workerDataFolderPermissions\".",
        "Stmts": "FileUtils.createBlockPath(tempFile.getAbsolutePath());",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    FileUtils.createBlockPath(blockFile.getAbsolutePath());\n+    FileUtils.createBlockPath(blockFile.getAbsolutePath(), mWorkerDataFolderPerms);",
                "-    FileUtils.createBlockPath(blockFile.getAbsolutePath());\n+    FileUtils.createBlockPath(blockFile.getAbsolutePath(), mWorkerDataFolderPerms);\n-    FileUtils.createBlockPath(blockFile.getAbsolutePath());\n+    FileUtils.createBlockPath(blockFile.getAbsolutePath(), mWorkerDataFolderPerms);",
                "-    FileUtils.createBlockPath(blockPath);\n+    FileUtils.createBlockPath(blockPath, ServerConfiguration.get(PropertyKey.WORKER_DATA_FOLDER_PERMISSIONS));"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public static boolean createStorageDirPath(String path) throws IOException {\n+  public static boolean createStorageDirPath(String path, String workerDataFolderPermissions) throws IOException {",
                    "-    String perms = Configuration.get(PropertyKey.WORKER_DATA_FOLDER_PERMISSIONS);\n-    changeLocalFilePermission(absolutePath, perms);\n+    changeLocalFilePermission(absolutePath, workerDataFolderPermissions);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-        FileUtils.createBlockPath(mPath);\n+        FileUtils.createBlockPath(mPath, mWorkerDataFolderPerms);",
                    "+  private String mWorkerDataFolderPerms = ConfigurationUtils.defaults().get(PropertyKey.WORKER_DATA_FOLDER_PERMISSIONS);",
                    "-    FileUtils.createBlockPath(blockFile.getAbsolutePath());\n+    FileUtils.createBlockPath(blockFile.getAbsolutePath(), mWorkerDataFolderPerms);"
                ]
            }
        ]
    },
    {
        "id": 8,
        "Anal": "The method name \"toArray\" has been changed to \"finish\".",
        "Stmts": "assertEquals(CAP, il.toArray().length);\nassertEquals(il.size(), il.toArray().length);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    Item[] its = Arrays.copyOf(values, s);\n+    Item[] its = new Item[s];\n+    System.arraycopy(values, 0, its, 0, values.length);",
                    "-    values[next] = i;\n-    if (++next == values.length)\n+    values[size] = i;\n+    if (++size == values.length)",
                    "-  private int next = 0 << 0;\n+  private int size = 0 << 0;"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-  private static final int CAP = 1 << 8;\n+  private static final int CAP = 1 << 4;"
                ]
            }
        ]
    },
    {
        "id": 9,
        "Anal": "The parameter \"nodes\" of the method \"handleFailure\" changes from `Map` to `Set`.",
        "Stmts": "Map map = new HashMap<String, Boolean>();\nclient.handleFailure(map);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "+    try {\n+      if (!pollReport.getIsFailurePresent()) {\n+        if (!latestLayout.getUnresponsiveServers().isEmpty()) {\n+          log.info(\"Received response from unresponsive server\");\n+          localManagementClient.handleFailure(pollReport.getFailingNodes()).get();",
                "+          }\n+        }\n+        log.debug(\"Failure already taken care of.\");\n+      } else {\n+        localManagementClient.handleFailure(pollReport.getFailingNodes()).get();",
                "+      } else if (!pollReport.getFailingNodes().isEmpty() && !latestLayout.getUnresponsiveServers().isEmpty()) {\n+        log.info(\"Failures detected. Failed nodes : {}\", pollReport.toString());\n+        for (String failedServer : pollReport.getFailingNodes()) {\n+          if (!latestLayout.getUnresponsiveServers().contains(failedServer)) {\n+            localManagementClient.handleFailure(pollReport.getFailingNodes()).get();"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": []
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 10,
        "Anal": "The return type of the method \"getServerStatus\" changes from `HashMap<String, Boolean>` to `PollReport`.",
        "Stmts": "Map<String, Boolean> result = failureDetectorPolicy.getServerStatus();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "+    PollReport pollReport = failureDetectorPolicy.getServerStatus();\n+    analyzePollReportAndTriggerHandler(pollReport);\n+  }\n+  private void analyzePollReportAndTriggerHandler(PollReport pollReport) {\n+    if (!startFailureHandler) {",
                "+      Set<String> tempResult = failureDetectorPolicy.getServerStatus().getFailingNodes();\n+      if (tempResult != null) {\n+        tempResult.forEach(actualResult::add);"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class PollReport.PollReportBuilder (optional references)",
                "contexts": [
                    "public PollReportBuilder setIsStatusChangePresent();"
                ]
            },
            {
                "info": "Defined in class PollReport (optional references)",
                "contexts": [
                    "@Data private final ImmutableMap<String, Long> outOfPhaseEpochNodes;",
                    "@Data private final Set<String> failingNodes;"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  HashMap<String, Boolean> getServerStatus();\n+  PollReport getServerStatus();"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-      Map<String, Boolean> tempMap = failureDetectorPolicy.getServerStatus();\n-      if (tempMap != null) {\n-        tempMap.forEach(actualResult::putIfAbsent);\n+      Set<String> tempResult = failureDetectorPolicy.getServerStatus().getFailingNodes();\n+      if (tempResult != null) {\n+        tempResult.forEach(actualResult::add);",
                    "-    Map<String, Boolean> actualResult = new HashMap<>();\n+    Set<String> actualResult = new HashSet<>();",
                    "-    Map<String, Boolean> expectedResult = new HashMap<>();\n-    expectedResult.put(getEndpoint(SERVERS.PORT_0), false);\n-    expectedResult.put(getEndpoint(SERVERS.PORT_1), false);\n-    expectedResult.put(getEndpoint(SERVERS.PORT_2), false);\n+    Set<String> expectedResult = new HashSet<>();\n+    expectedResult.add(getEndpoint(SERVERS.PORT_0));\n+    expectedResult.add(getEndpoint(SERVERS.PORT_1));\n+    expectedResult.add(getEndpoint(SERVERS.PORT_2));"
                ]
            }
        ]
    },
    {
        "id": 11,
        "Anal": "The return type of the method \"getServerStatus\" changes from `HashMap<String, Boolean>` to `PollReport`.",
        "Stmts": "Map<String, Boolean> expectedResult = new HashMap<>();\nexpectedResult.put(getEndpoint(SERVERS.PORT_0), false);\nexpectedResult.put(getEndpoint(SERVERS.PORT_1), false);\nexpectedResult.put(getEndpoint(SERVERS.PORT_2), false);\npollAndMatchExpectedResult(expectedResult);\nexpectedResult.remove(getEndpoint(SERVERS.PORT_0));\npollAndMatchExpectedResult(expectedResult);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "+    PollReport pollReport = failureDetectorPolicy.getServerStatus();\n+    analyzePollReportAndTriggerHandler(pollReport);\n+  }\n+  private void analyzePollReportAndTriggerHandler(PollReport pollReport) {\n+    if (!startFailureHandler) {",
                "+      Set<String> tempResult = failureDetectorPolicy.getServerStatus().getFailingNodes();\n+      if (tempResult != null) {\n+        tempResult.forEach(actualResult::add);",
                "+    PollReport result = failureDetectorPolicy.getServerStatus();\n+    assertThat(result.getIsFailurePresent()).isFalse();"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class PollReport.PollReportBuilder (optional references)",
                "contexts": [
                    "public PollReportBuilder setIsStatusChangePresent();",
                    "public PollReportBuilder setOutOfPhaseEpochNodes(Map<String, Long> outOfPhaseEpochNodes);",
                    "public PollReportBuilder setFailingNodes(Set<String> failingNodes);"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  HashMap<String, Boolean> getServerStatus();\n+  PollReport getServerStatus();"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-  private void pollAndMatchExpectedResult(Map<String, Boolean> expectedResult) throws InterruptedException {\n+  private void pollAndMatchExpectedResult(Set<String> expectedResult) throws InterruptedException {",
                    "-    Map<String, Boolean> actualResult = new HashMap<>();\n+    Set<String> actualResult = new HashSet<>();",
                    "-    Map<String, Boolean> result = failureDetectorPolicy.getServerStatus();\n-    assertThat(result).isNull();\n+    PollReport result = failureDetectorPolicy.getServerStatus();\n+    assertThat(result.getIsFailurePresent()).isFalse();"
                ]
            }
        ]
    },
    {
        "id": 12,
        "Anal": "The method name changes from `getItemId` to `getResourceId`.",
        "Stmts": "assertTrue(\"testGetItemId 0\", mv.getItemId() >= 0);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    row.setColumn(\"item_id\", itemId);\n+    row.setColumn(\"resource_id\", resourceId);\n+    row.setColumn(\"resource_type_id\", resourceTypeId);",
                    "-  private int itemId;\n+  private int resourceId;\n+  private int resourceTypeId;",
                    "-      itemId = row.getIntColumn(\"item_id\");\n+      resourceId = row.getIntColumn(\"resource_id\");\n+      resourceTypeId = row.getIntColumn(\"resource_type_id\");"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    mv.setItemId(itemId);\n-    assertThat(\"testSetItemId 0\", mv.getItemId(), equalTo(itemId));\n+    mv.setResourceId(itemId);\n+    mv.setResourceTypeId(Constants.ITEM);\n+    assertThat(\"testSetItemId 0\", mv.getResourceId(), equalTo(itemId));",
                    "-      this.mv.setItemId(Item.create(context).getID());\n+      this.mv.setResourceId(Item.create(context).getID());\n+      this.mv.setResourceTypeId(Constants.ITEM);"
                ]
            }
        ]
    },
    {
        "id": 13,
        "Anal": "The method name \"setItemId\" changes to \"setResourceId\" and the parameter name \"itemId\" changes to \"resourceId\".",
        "Stmts": "int itemId = 55;\nmv.setItemId(itemId);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "+    for (int dcIdx = 0; dcIdx < getMetadata().size(); dcIdx++) {\n+      if (!storedDC[dcIdx]) {\n+        DCValue dcv = getMetadata().get(dcIdx);\n+        MetadataValue metadata = new MetadataValue();\n+        metadata.setResourceId(getID());"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    row.setColumn(\"item_id\", itemId);\n+    row.setColumn(\"resource_id\", resourceId);\n+    row.setColumn(\"resource_type_id\", resourceTypeId);",
                    "-  private int itemId;\n+  private int resourceId;\n+  private int resourceTypeId;",
                    "-      itemId = row.getIntColumn(\"item_id\");\n+      resourceId = row.getIntColumn(\"resource_id\");\n+      resourceTypeId = row.getIntColumn(\"resource_type_id\");"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    assertTrue(\"testGetItemId 0\", mv.getItemId() >= 0);\n+    assertTrue(\"testGetItemId 0\", mv.getResourceId() >= 0);",
                    "-      this.mv.setItemId(Item.create(context).getID());\n+      this.mv.setResourceId(Item.create(context).getID());\n+      this.mv.setResourceTypeId(Constants.ITEM);"
                ]
            }
        ]
    },
    {
        "id": 14,
        "Anal": "The method \"getFormat\" now requires a parameter of type \"Context\".",
        "Stmts": "bs.getFormat();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-      for (Bitstream bs : bundle.getBitstreams()) {\n-        String fmt = bs.getFormat().getShortDescription();\n+      for (BundleBitstream bundleBitstream : bundle.getBitstreams()) {\n+        Bitstream bs = bundleBitstream.getBitstream();\n+        String fmt = bs.getFormat(Curator.curationContext()).getShortDescription();",
                "+      if (bi.size() > 0) {\n+        handle = bi.get(0).getHandle();\n-      String ext[] = bitstream.getFormat().getExtensions();\n-      bsName = \"bitstream_\" + sid + (ext.length > 0 ? ext[0] : \"\");\n+      List<String> ext = bitstream.getFormat(context).getExtensions();",
                "-      for (Bitstream bs : bitstreams) {\n+      for (BundleBitstream bundleBitstream : bitstreams) {\n+        Bitstream bs = bundleBitstream.getBitstream();\n-        arLink.setAttribute(\"type\", bs.getFormat().getMIMEType());\n+        arLink.setAttribute(\"type\", bs.getFormat(context).getMIMEType());"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class Context (optional references)",
                "contexts": [
                    "protected Context(EventService eventService, DBConnection dbConnection);",
                    "public Context();",
                    "public Context(short options);"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+  public void setDeleted(boolean deleted) {\n+    this.deleted = deleted;",
                    "+  @Column(name = \"size_bytes\") private long sizeBytes;\n+  @Column(name = \"deleted\") private boolean deleted = false;\n+  @Column(name = \"internal_id\", length = 256) private String internalId;\n+  @Column(name = \"store_number\") private int storeNumber;\n+  @ManyToOne(fetch = FetchType.EAGER) @JoinColumn(name = \"bitstream_format_id\") private BitstreamFormat bitstreamFormat;\n+  @OneToMany(mappedBy = \"bitstream\", fetch = FetchType.LAZY) @OrderBy(\"bitstreamOrder asc\") private List<BundleBitstream> bundles = new ArrayList<>();\n+  @OneToOne(fetch = FetchType.LAZY, mappedBy = \"logo\") private Community community;\n+  @OneToOne(fetch = FetchType.LAZY, mappedBy = \"logo\") private Collection collection;\n+  @Transient private BitstreamService bitstreamService;\n+  public Bitstream() {}",
                    "+  @Override"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    assertThat(\"testSetFormat 0\", bs.getFormat(), notNullValue());\n-    assertThat(\"testSetFormat 1\", bs.getFormat(), equalTo(BitstreamFormat.find(context, id)));\n+    assertThat(\"testSetFormat 0\", bs.getFormat(context), notNullValue());\n+    assertThat(\"testSetFormat 1\", bs.getFormat(context), equalTo(bitstreamFormatService.find(context, id)));",
                    "-    assertThat(\"testBSFind 1\", found.getFormat().getMIMEType(), equalTo(\"application/octet-stream\"));\n+    assertThat(\"testBSFind 1\", found.getFormat(context).getMIMEType(), equalTo(\"application/octet-stream\"));",
                    "-    assertThat(\"testGetFormatDescription 0\", bs.getFormatDescription(), notNullValue());\n-    assertThat(\"testGetFormatDescription 1\", bs.getFormatDescription(), not(equalTo(\"\")));\n-    assertThat(\"testGetFormatDescription 2\", bs.getFormatDescription(), equalTo(format));\n+    assertThat(\"testGetFormatDescription 0\", bs.getFormatDescription(context), notNullValue());\n+    assertThat(\"testGetFormatDescription 1\", bs.getFormatDescription(context), not(equalTo(\"\")));\n+    assertThat(\"testGetFormatDescription 2\", bs.getFormatDescription(context), equalTo(format));"
                ]
            }
        ]
    },
    {
        "id": 15,
        "Anal": "The method name changes from \"getValueId\" to \"getID\" and the return type changes from primitive type `int` to wrapper class `Integer`.",
        "Stmts": "mv.getValueId();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "+    hash = 47 * hash + this.getID();",
                "+    if (this.getID() != other.getID()) {",
                "+    log.info(LogManager.getHeader(context, \"update_metadatavalue\", \"metadata_value_id=\" + metadataValue.getID()));"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    hash = 47 * hash + this.valueId;\n-    hash = 47 * hash + this.getValueId();\n+    hash = 47 * hash + this.id;\n+    hash = 47 * hash + this.getID();",
                    "-    if (this.getValueId() != other.getValueId()) {\n+    if (this.getID() != other.getID()) {",
                    "+public interface ReloadableEntity<T extends Serializable> {\n+  T getID();\n+}"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    assertThat(\"testGetFieldId 0\", instance.getValueId(), equalTo(0));\n-    assertThat(\"testGetFieldId 1\", mv.getMetadataField().getFieldID(), equalTo(mf.getFieldID()));\n+    assertThat(\"testGetFieldId 0\", instance.getID(), equalTo(0));\n+    assertThat(\"testGetFieldId 1\", mv.getMetadataField().getID(), equalTo(mf.getID()));",
                    "-    int id = mv.getValueId();\n+    int id = mv.getID();",
                    "-    assertThat(\"testFind 1\", found.getValueId(), equalTo(id));\n+    assertThat(\"testFind 1\", found.getID(), equalTo(id));"
                ]
            }
        ]
    },
    {
        "id": 16,
        "Anal": "The parameter \"responseException\" of the method \"getErrorCode\" changes from `HttpResponseException` to `ResponseException`.",
        "Stmts": "Mockito.when(responseException.getContent()).thenReturn(\"{\\\"type\\\":\\\"other\\\",\\\"message\\\":\\\"some other object\\\"}\");\nErrorResponseUtil.getErrorCode(responseException);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": []
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    } catch (HttpResponseException ex) {\n+    } catch (ResponseException ex) {",
                    "-  public void testGetErrorCode_knownErrorCode() throws HttpResponseException {\n+  public void testGetErrorCode_knownErrorCode() throws ResponseException {",
                    "-  @Mock HttpResponseException responseException;\n+  @Mock private ResponseException responseException;"
                ]
            }
        ]
    },
    {
        "id": 17,
        "Anal": "The parameter \"responseException\" of the method \"getErrorCode\" changes from `HttpResponseException` to `ResponseException`.",
        "Stmts": "Mockito.when(responseException.getContent()).thenReturn(\"{\\\"errors\\\":[{\\\"code\\\":\\\"MANIFEST_INVALID\\\",\\\"message\\\":\\\"manifest invalid\\\",\\\"detail\\\":{}}]}\");\nAssert.assertSame(ErrorCodes.MANIFEST_INVALID, ErrorResponseUtil.getErrorCode(responseException));",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": []
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    } catch (HttpResponseException ex) {\n+    } catch (ResponseException ex) {",
                    "-  @Mock HttpResponseException responseException;\n+  @Mock private ResponseException responseException;"
                ]
            }
        ]
    },
    {
        "id": 18,
        "Anal": "The method \"changeProtectionKey\" has two new parameters added: `Number160 versionKey`, `Number160 basedOnKey`, and `byte[] hash`. The position of the `int ttl` parameter has also been moved.",
        "Stmts": "FuturePut changeFuture1 = node.getDataManager().changeProtectionKey(locationKey, domainKey, contentKey, data1v2.getTimeToLive(), keypair1, keypair2);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    } catch (IOException | InvalidKeyException | SignatureException e) {\n+    } catch (IOException | InvalidKeyException | SignatureException | NoSuchAlgorithmException | NoSuchPaddingException | IllegalBlockSizeException | BadPaddingException e) {",
                    "-  boolean changeProtectionKey(String locationKey, String contentKey, int ttl, KeyPair oldKey, KeyPair newKey);\n+  boolean changeProtectionKey(String locationKey, String contentKey, Number160 versionKey, Number160 basedOnKey, int ttl, KeyPair oldKey, KeyPair newKey, byte[] hash);",
                    "-  public boolean changeProtectionKey(String locationKey, String contentKey, int ttl, KeyPair oldKey, KeyPair newKey) {\n+  public boolean changeProtectionKey(String locationKey, String contentKey, Number160 versionKey, Number160 basedOnKey, int ttl, KeyPair oldKey, KeyPair newKey, byte[] hash) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-  private static final int networkSize = 10;\n+  private static final int networkSize = 3;"
                ]
            }
        ]
    },
    {
        "id": 19,
        "Anal": "The exception thrown by the method \"onCreateOrUpdateCommand\" changes from `GenieException` to `GeniePreconditionException`.",
        "Stmts": "this.c.onCreateOrUpdateCommand();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  private void validate(final CommandStatus status, final String executable) throws GenieException {\n+  private void validate(final CommandStatus status, final String executable, final String error) throws GeniePreconditionException {",
                    "+    if (StringUtils.isNotBlank(error)) {\n+      builder.append(error);\n+    }",
                    "-  public void validate() throws GenieException {\n-    super.validate();\n-    this.validate(this.status, this.executable);\n+  public void validate() throws GeniePreconditionException {\n+    String error = null;\n+    try {\n+      super.validate();\n+    } catch (final GeniePreconditionException ge) {\n+      error = ge.getMessage();\n+    }"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-  @Test(expected = GenieException.class)\n-  public void testOnCreateOrUpdateCommandNoExecutable() throws GenieException {\n+  @Test(expected = GeniePreconditionException.class)\n+  public void testOnCreateOrUpdateCommandNoExecutable() throws GeniePreconditionException {",
                    "-  @Test(expected = GenieException.class)\n-  public void testOnCreateOrUpdateCommandNoStatus() throws GenieException {\n+  @Test(expected = GeniePreconditionException.class)\n+  public void testOnCreateOrUpdateCommandNoStatus() throws GeniePreconditionException {",
                    "-  @Test(expected = GenieException.class)\n-  public void testOnCreateOrUpdateCommandWithNothing() throws GenieException {\n+  @Test(expected = GeniePreconditionException.class)\n+  public void testOnCreateOrUpdateCommandWithNothing() throws GeniePreconditionException {"
                ]
            }
        ]
    },
    {
        "id": 20,
        "Anal": "The method \"deriveSecret\" has an additional parameter \"hashAlgorithm\" added as the second parameter and the last parameter \"hashValue\" is replaced by \"toHash\".",
        "Stmts": "byte[] hashValue = ArrayConverter.hexStringToByteArray(\"52c04472bdfe929772c98b91cf425f78f47659be9d4a7d68b9e29d162935e9b9\");\nbyte[] result = HKDFunction.deriveSecret(macAlgorithm, prk, labelIn, hashValue);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "+    byte[] saltMasterSecret = HKDFunction.deriveSecret(macAlg.getJavaName(), digestAlgo.getJavaName(), tlsContext.getHandshakeSecret(), HKDFunction.DERIVED, ArrayConverter.hexStringToByteArray(\"\"));\n-    byte[] clientApplicationTrafficSecret = HKDFunction.deriveSecret(macAlg.getJavaName(), masterSecret, HKDFunction.CLIENT_APPLICATION_TRAFFIC_SECRET, tlsContext.getDigest().digest(tlsContext.getSelectedProtocolVersion(), tlsContext.getSelectedCipherSuite()));\n+    byte[] clientApplicationTrafficSecret = HKDFunction.deriveSecret(macAlg.getJavaName(), digestAlgo.getJavaName(), masterSecret, HKDFunction.CLIENT_APPLICATION_TRAFFIC_SECRET, tlsContext.getDigest().getRawBytes());\n-    byte[] serverApplicationTrafficSecret = HKDFunction.deriveSecret(macAlg.getJavaName(), masterSecret, HKDFunction.SERVER_APPLICATION_TRAFFIC_SECRET, tlsContext.getDigest().digest(tlsContext.getSelectedProtocolVersion(), tlsContext.getSelectedCipherSuite()));\n+    byte[] serverApplicationTrafficSecret = HKDFunction.deriveSecret(macAlg.getJavaName(), digestAlgo.getJavaName(), masterSecret, HKDFunction.SERVER_APPLICATION_TRAFFIC_SECRET, tlsContext.getDigest().getRawBytes());",
                "-    byte[] saltMasterSecret = HKDFunction.deriveSecret(macAlg.getJavaName(), tlsContext.getHandshakeSecret(), HKDFunction.DERIVED, ArrayConverter.hexStringToByteArray(\"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\"));\n+    DigestAlgorithm digestAlgo = AlgorithmResolver.getDigestAlgorithm(tlsContext.getSelectedProtocolVersion(), tlsContext.getSelectedCipherSuite());\n+    byte[] saltMasterSecret = HKDFunction.deriveSecret(macAlg.getJavaName(), digestAlgo.getJavaName(), tlsContext.getHandshakeSecret(), HKDFunction.DERIVED, ArrayConverter.hexStringToByteArray(\"\"));\n-    byte[] clientApplicationTrafficSecret = HKDFunction.deriveSecret(macAlg.getJavaName(), masterSecret, HKDFunction.CLIENT_APPLICATION_TRAFFIC_SECRET, tlsContext.getDigest().digest(tlsContext.getSelectedProtocolVersion(), tlsContext.getSelectedCipherSuite()));\n+    byte[] clientApplicationTrafficSecret = HKDFunction.deriveSecret(macAlg.getJavaName(), digestAlgo.getJavaName(), masterSecret, HKDFunction.CLIENT_APPLICATION_TRAFFIC_SECRET, tlsContext.getDigest().getRawBytes());",
                "-    byte[] clientHandshakeTrafficSecret = HKDFunction.deriveSecret(macAlg.getJavaName(), handshakeSecret, HKDFunction.CLIENT_HANDSHAKE_TRAFFIC_SECRET, context.getDigest().digest(context.getSelectedProtocolVersion(), context.getSelectedCipherSuite()));\n+    byte[] clientHandshakeTrafficSecret = HKDFunction.deriveSecret(macAlg.getJavaName(), digestAlgo.getJavaName(), handshakeSecret, HKDFunction.CLIENT_HANDSHAKE_TRAFFIC_SECRET, context.getDigest().getRawBytes());\n-    byte[] serverHandshakeTrafficSecret = HKDFunction.deriveSecret(macAlg.getJavaName(), handshakeSecret, HKDFunction.SERVER_HANDSHAKE_TRAFFIC_SECRET, context.getDigest().digest(context.getSelectedProtocolVersion(), context.getSelectedCipherSuite()));\n+    byte[] serverHandshakeTrafficSecret = HKDFunction.deriveSecret(macAlg.getJavaName(), digestAlgo.getJavaName(), handshakeSecret, HKDFunction.SERVER_HANDSHAKE_TRAFFIC_SECRET, context.getDigest().getRawBytes());"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    byte[] result = expand(macAlgorithm, prk, info, outLen);\n-    return result;\n+    return expand(macAlgorithm, prk, info, outLen);",
                    "-      byte[] out = mac.doFinal();\n-      return out;\n+      return mac.doFinal();"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    byte[] resultCorrect = ArrayConverter.hexStringToByteArray(\"a353bfcdf9695a2a09c2e293\");\n+    byte[] resultCorrect = ArrayConverter.hexStringToByteArray(\"04C5DA6EC39FC1653E085FA83E51C6AF\");",
                    "-    byte[] prk = ArrayConverter.hexStringToByteArray(\"b2c2663ed59e833b17c68823516f11f1cb311855045d3ce46bfe8ac8889268d9\");\n+    byte[] prk = ArrayConverter.hexStringToByteArray(\"E056D47C7DB9C04BBECE6AC9525163DE72B7D25B6B0899366F8FA741A5C01709\");",
                    "-    String labelIn = HKDFunction.IV;\n-    int outLen = 12;\n+    String labelIn = HKDFunction.KEY;\n+    int outLen = 16;"
                ]
            }
        ]
    },
    {
        "id": 21,
        "Anal": "The return type of the method \"next\" changes from `DateTimeAdjuster` to `WithAdjuster`.",
        "Stmts": "DateTimeAdjuster next = DateTimeAdjusters.next(SUNDAY);\nassertTrue(next instanceof Serializable);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "+    final WithAdjuster mondayInFirstWeek = DateTimeAdjusters.next(MONDAY);"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class WithAdjuster (optional references)",
                "contexts": [
                    "DateTime doAdjustment(DateTime dateTime);"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public static DateTimeAdjuster nextOrCurrent(DayOfWeek dow) {\n+  public static WithAdjuster nextOrCurrent(DayOfWeek dow) {",
                    "-  private static enum Impl implements DateTimeAdjuster {\n+  private static enum Impl implements WithAdjuster {",
                    "-  public static DateTimeAdjuster previousOrCurrent(DayOfWeek dow) {\n+  public static WithAdjuster previousOrCurrent(DayOfWeek dow) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    DateTimeAdjuster nextOrCurrent = DateTimeAdjusters.nextOrCurrent(SUNDAY);\n+    WithAdjuster nextOrCurrent = DateTimeAdjusters.nextOrCurrent(SUNDAY);",
                    "-    DateTimeAdjuster previousOrCurrent = DateTimeAdjusters.previousOrCurrent(SUNDAY);\n+    WithAdjuster previousOrCurrent = DateTimeAdjusters.previousOrCurrent(SUNDAY);",
                    "-    DateTimeAdjuster dayOfWeekInMonth = DateTimeAdjusters.dayOfWeekInMonth(1, SUNDAY);\n+    WithAdjuster dayOfWeekInMonth = DateTimeAdjusters.dayOfWeekInMonth(1, SUNDAY);"
                ]
            }
        ]
    },
    {
        "id": 22,
        "Anal": "The return type of the method \"parseToEngine\" changes to \"DateTimeBuilder\" from \"CalendricalEngine\".",
        "Stmts": "CalendricalEngine result = test.parseToEngine(\"ONE30\");\nassertEquals(result.getInput().size(), 1);\nassertEquals(result.getInput().get(0), DAY_OF_MONTH.field(30L));",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "+    test.parseToBuilder((String)null);\n-    test.parseToEngine(\"ONE30\");\n+    test.parseToBuilder(\"ONE30\");",
                "+    CalendricalEngine result = test.parseToBuilder(new StringBuilder(\"ONE30\"));",
                "+        return formatter.parseToBuilder(source);\n-      return context != null ? context.toCalendricalEngine() : null;\n+      return context != null ? context.toBuilder() : null;"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class DateTimeBuilder (optional references)",
                "contexts": [
                    "public Map<Class<?>, CalendricalObject> getObjectMap();",
                    "public void addObject(CalendricalObject calendrical);",
                    "@SuppressWarnings(\"unchecked\") @Override public <T> T extract(Class<T> type);"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    DateTimes.checkNotNull(rules, \"CalendricalRule array must not be null\");\n-    if (rules.length < 2) {\n-      throw new IllegalArgumentException(\"At least two rules must be specified\");\n+    DateTimes.checkNotNull(types, \"Class array must not be null\");\n+    if (types.length < 2) {\n+      throw new IllegalArgumentException(\"At least two types must be specified\");",
                    "-      throw new CalendricalException(\"Unable to convert parsed text to any specified rule: \" + Arrays.toString(rules));\n+      throw new CalendricalException(\"Unable to convert parsed text to any specified type: \" + Arrays.toString(types));",
                    "-      if (obj instanceof Calendrical == false) {\n-        throw new IllegalArgumentException(\"Format target must implement Calendrical\");\n+      if (obj instanceof CalendricalObject == false) {\n+        throw new IllegalArgumentException(\"Format target must implement CalendricalObject\");"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    CalendricalEngine result = test.parseToEngine(new StringBuilder(\"ONE30\"));\n+    CalendricalEngine result = test.parseToBuilder(new StringBuilder(\"ONE30\"));",
                    "-    test.parseToEngine(\"ONE30\");\n+    test.parseToBuilder(\"ONE30\");",
                    "-      test.parseToEngine(\"ONE30SomethingElse\");\n+      test.parseToBuilder(\"ONE30SomethingElse\");"
                ]
            }
        ]
    },
    {
        "id": 23,
        "Anal": "The return type of the method \"firstDayOfMonth\" changes from `DateTimeAdjuster` to `WithAdjuster`.",
        "Stmts": "DateTimeAdjuster firstDayOfMonth = DateTimeAdjusters.firstDayOfMonth();\nassertTrue(firstDayOfMonth instanceof Serializable);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [
            {
                "info": "Defined in class WithAdjuster (optional references)",
                "contexts": [
                    "DateTime doAdjustment(DateTime dateTime);"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public static DateTimeAdjuster nextOrCurrent(DayOfWeek dow) {\n+  public static WithAdjuster nextOrCurrent(DayOfWeek dow) {",
                    "-  private static enum Impl implements DateTimeAdjuster {\n+  private static enum Impl implements WithAdjuster {",
                    "-  public static DateTimeAdjuster previousOrCurrent(DayOfWeek dow) {\n+  public static WithAdjuster previousOrCurrent(DayOfWeek dow) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    DateTimeAdjuster firstInMonth = DateTimeAdjusters.firstInMonth(SUNDAY);\n+    WithAdjuster firstInMonth = DateTimeAdjusters.firstInMonth(SUNDAY);",
                    "-    DateTimeAdjuster firstDayOfMonth = DateTimeAdjusters.firstDayOfNextMonth();\n+    WithAdjuster firstDayOfMonth = DateTimeAdjusters.firstDayOfNextMonth();",
                    "-    DateTimeAdjuster firstDayOfMonth = DateTimeAdjusters.firstDayOfNextYear();\n+    WithAdjuster firstDayOfMonth = DateTimeAdjusters.firstDayOfNextYear();"
                ]
            }
        ]
    },
    {
        "id": 24,
        "Anal": "The parameter \"dateTime\" of the method \"print\" changes from `DateTimeAccessor` to `TemporalAccessor`.",
        "Stmts": "test.print((DateTimeAccessor)null);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    DateTimeAccessor test = buildAccessor(base, offsetId, null);\n+    TemporalAccessor test = buildAccessor(base, offsetId, null);\n-    DateTimeAccessor test = buildAccessor(base, offsetId, null);\n+    TemporalAccessor test = buildAccessor(base, offsetId, null);\n     assertEquals(DateTimeFormatters.rfc1123().withLocale(Locale.FRENCH).print(test), expected);",
                "-    DateTimeAccessor test = buildAccessor(year, month, day, null, null, null, null, offsetId, zoneId);\n+    TemporalAccessor test = buildAccessor(year, month, day, null, null, null, null, offsetId, zoneId);\n       assertEquals(DateTimeFormatters.isoLocalDate().print(test), expected);",
                "-    DateTimeAccessor test = buildAccessor(LocalDateTime.of(2008, 6, 3, 11, 5, 30), \"+02:00\", \"Europe/Paris\");\n+    TemporalAccessor test = buildAccessor(LocalDateTime.of(2008, 6, 3, 11, 5, 30), \"+02:00\", \"Europe/Paris\");\n-    DateTimeAccessor test = buildAccessor(LocalDateTime.of(123456, 6, 3, 11, 5, 30), \"Z\", null);\n+    TemporalAccessor test = buildAccessor(LocalDateTime.of(123456, 6, 3, 11, 5, 30), \"Z\", null);\n     assertEquals(DateTimeFormatters.isoOrdinalDate().print(test), \"+123456-155Z\");"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class TemporalAccessor.Query (optional references)",
                "contexts": [
                    "R doQuery(TemporalAccessor dateTime);"
                ]
            },
            {
                "info": "Defined in class TemporalAccessor (optional references)",
                "contexts": [
                    "<R> R query(Query<R> query);",
                    "boolean isSupported(TemporalField field);"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-        formatter.printTo((DateTimeAccessor)obj, toAppendTo);\n+        formatter.printTo((TemporalAccessor)obj, toAppendTo);",
                    "-  public DateTimeAccessor parseBest(CharSequence text, Class<?>... types) {\n+  public TemporalAccessor parseBest(CharSequence text, Class<?>... types) {",
                    "-  public void printTo(DateTimeAccessor dateTime, Appendable appendable) {\n+  public void printTo(TemporalAccessor dateTime, Appendable appendable) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    test.printTo((DateTimeAccessor)null, buf);\n+    test.printTo((TemporalAccessor)null, buf);",
                    "-    DateTimeAccessor result = test.parseBest(\"2011-06-30+03:00\", OffsetDate.class, LocalDate.class);\n+    TemporalAccessor result = test.parseBest(\"2011-06-30+03:00\", OffsetDate.class, LocalDate.class);",
                    "-    DateTimeAccessor result = test.parseBest(\"2011-06-30\", OffsetDate.class, LocalDate.class);\n+    TemporalAccessor result = test.parseBest(\"2011-06-30\", OffsetDate.class, LocalDate.class);"
                ]
            }
        ]
    },
    {
        "id": 25,
        "Anal": "The parameter \"dateTime\" of the method \"print\" changes from `DateTimeAccessor` to `TemporalAccessor`.",
        "Stmts": "String result = test.print(LocalDate.of(2008, 6, 30));",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    DateTimeAccessor test = buildAccessor(LocalDateTime.of(123456, 6, 3, 11, 5, 30), \"Z\", null);\n+    TemporalAccessor test = buildAccessor(LocalDateTime.of(123456, 6, 3, 11, 5, 30), \"Z\", null);\n-    DateTimeAccessor test = buildAccessor(LocalDate.of(2008, 6, 3), null, null);\n+    TemporalAccessor test = buildAccessor(LocalDate.of(2008, 6, 3), null, null);\n     assertEquals(DateTimeFormatters.basicIsoDate().print(test), \"20080603\");",
                "-    DateTimeAccessor test = buildAccessor(LocalDateTime.of(2008, 6, 3, 11, 5, 30), null, null);\n+    TemporalAccessor test = buildAccessor(LocalDateTime.of(2008, 6, 3, 11, 5, 30), null, null);\n-    DateTimeAccessor test = buildAccessor(LocalDateTime.of(2008, 6, 3, 11, 5, 30), \"Z\", null);\n+    TemporalAccessor test = buildAccessor(LocalDateTime.of(2008, 6, 3, 11, 5, 30), \"Z\", null);\n     assertEquals(DateTimeFormatters.isoOrdinalDate().print(test), \"2008-155Z\");",
                "-    DateTimeAccessor test = buildAccessor(LocalDateTime.of(2008, 6, 3, 11, 5, 30), null, null);\n+    TemporalAccessor test = buildAccessor(LocalDateTime.of(2008, 6, 3, 11, 5, 30), null, null);\n-    DateTimeAccessor test = buildAccessor(LocalDateTime.of(2008, 6, 3, 11, 5, 30), \"Z\", null);\n+    TemporalAccessor test = buildAccessor(LocalDateTime.of(2008, 6, 3, 11, 5, 30), \"Z\", null);\n     assertEquals(DateTimeFormatters.basicIsoDate().print(test), \"20080603Z\");"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class TemporalAccessor.Query (optional references)",
                "contexts": [
                    "R doQuery(TemporalAccessor dateTime);"
                ]
            },
            {
                "info": "Defined in class TemporalAccessor (optional references)",
                "contexts": [
                    "<R> R query(Query<R> query);",
                    "boolean isSupported(TemporalField field);"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-        formatter.printTo((DateTimeAccessor)obj, toAppendTo);\n+        formatter.printTo((TemporalAccessor)obj, toAppendTo);",
                    "-  public DateTimeAccessor parseBest(CharSequence text, Class<?>... types) {\n+  public TemporalAccessor parseBest(CharSequence text, Class<?>... types) {",
                    "-  public void printTo(DateTimeAccessor dateTime, Appendable appendable) {\n+  public void printTo(TemporalAccessor dateTime, Appendable appendable) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    DateTimeAccessor result = test.parseBest(\"2011-06-30+03:00\", OffsetDate.class, LocalDate.class);\n+    TemporalAccessor result = test.parseBest(\"2011-06-30+03:00\", OffsetDate.class, LocalDate.class);",
                    "-    DateTimeAccessor result = test.parseBest(\"2011-06-30\", OffsetDate.class, LocalDate.class);\n+    TemporalAccessor result = test.parseBest(\"2011-06-30\", OffsetDate.class, LocalDate.class);",
                    "-    test.printTo((DateTimeAccessor)null, buf);\n+    test.printTo((TemporalAccessor)null, buf);"
                ]
            }
        ]
    },
    {
        "id": 26,
        "Anal": "The return type of the method \"parseBest\" changes from `DateTimeAccessor` to `TemporalAccessor`.",
        "Stmts": "DateTimeAccessor result = test.parseBest(\"2011-06-30+03:00\", OffsetDate.class, LocalDate.class);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "+    TemporalAccessor result = test.parseBest(\"2011-06-30\", OffsetDate.class, LocalDate.class);"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class TemporalAccessor (optional references)",
                "contexts": [
                    "<R> R query(Query<R> query);",
                    "int get(TemporalField field);"
                ]
            },
            {
                "info": "Defined in class TemporalAccessor.Query (optional references)",
                "contexts": [
                    "R doQuery(TemporalAccessor dateTime);"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-        formatter.printTo((DateTimeAccessor)obj, toAppendTo);\n+        formatter.printTo((TemporalAccessor)obj, toAppendTo);",
                    "-  public String print(DateTimeAccessor dateTime) {\n+  public String print(TemporalAccessor dateTime) {",
                    "-  public void printTo(DateTimeAccessor dateTime, Appendable appendable) {\n+  public void printTo(TemporalAccessor dateTime, Appendable appendable) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    DateTimeAccessor result = test.parseBest(\"2011-06-30\", OffsetDate.class, LocalDate.class);\n+    TemporalAccessor result = test.parseBest(\"2011-06-30\", OffsetDate.class, LocalDate.class);",
                    "-    DateTimeAccessor result = (DateTimeAccessor)format.parseObject(\"ONEXXX\", pos);\n+    TemporalAccessor result = (TemporalAccessor)format.parseObject(\"ONEXXX\", pos);",
                    "-    test.printTo((DateTimeAccessor)null, buf);\n+    test.printTo((TemporalAccessor)null, buf);"
                ]
            }
        ]
    },
    {
        "id": 27,
        "Anal": "The method name \"matchesCalendrical\" changes to \"matches\".",
        "Stmts": "assertEquals(DateTimeField.of(YEAR, 2008).matchesCalendrical(date), true);\nassertEquals(DateTimeField.of(YEAR, 2006).matchesCalendrical(date), false);\nassertEquals(DateTimeField.of(MONTH_OF_YEAR, 6).matchesCalendrical(date), true);\nassertEquals(DateTimeField.of(MONTH_OF_YEAR, 7).matchesCalendrical(date), false);\nassertEquals(DateTimeField.of(MONTH_OF_YEAR, -1).matchesCalendrical(date), false);\nassertEquals(DateTimeField.of(DAY_OF_MONTH, 30).matchesCalendrical(date), true);\nassertEquals(DateTimeField.of(DAY_OF_MONTH, 12).matchesCalendrical(date), false);\nassertEquals(DateTimeField.of(DAY_OF_WEEK, 1).matchesCalendrical(date), true);\nassertEquals(DateTimeField.of(DAY_OF_WEEK, 2).matchesCalendrical(date), false);\nassertEquals(DateTimeField.of(HOUR_OF_DAY, 2).matchesCalendrical(date), false);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "+    assertEquals(DateTimeField.of(HOUR_OF_DAY, 2).matches(date), false);\n+  }\n+  @Test(expectedExceptions = NullPointerException.class, groups = {\"tck\"})\n+  public void test_matches_null() {\n+    DateTimeField.of(DAY_OF_WEEK, 2).matches(null);"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": []
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-  public void test_matchesCalendrical_null() {\n-    DateTimeField.of(DAY_OF_WEEK, 2).matchesCalendrical(null);\n+  public void test_matches_null() {\n+    DateTimeField.of(DAY_OF_WEEK, 2).matches(null);"
                ]
            }
        ]
    },
    {
        "id": 28,
        "Anal": "The method \"appendValueReduced\" has an additional parameter \"maxWidth\" added.",
        "Stmts": "builder.appendValueReduced(null, 2, 2000);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-        appendValueReduced(field, 2, 2000);\n+        appendValueReduced(field, 2, 2, 2000);",
                "-    builder.appendValueReduced(null, 2, 2000);\n+    builder.appendValueReduced(null, 2, 2, 2000);\n-    builder.appendValueReduced(YEAR, 2, 2000);\n+    builder.appendValueReduced(YEAR, 2, 2, 2000);",
                "-    builder.appendValue(MONTH_OF_YEAR, 1, 2, SignStyle.NORMAL).appendValueReduced(YEAR, 2, 2000);\n+    builder.appendValue(MONTH_OF_YEAR, 1, 2, SignStyle.NORMAL).appendValueReduced(YEAR, 2, 2, 2000);"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    ReducedPrinterParser(TemporalField field, int width, int baseValue) {\n-      super(field, width, width, SignStyle.NOT_NEGATIVE);\n+    ReducedPrinterParser(TemporalField field, int width, int maxWidth, int baseValue) {\n+      super(field, width, maxWidth, SignStyle.NOT_NEGATIVE);",
                    "-        appendValueReduced(field, 2, 2000);\n+        appendValueReduced(field, 2, 2, 2000);",
                    "+    }\n+    return this;\n+  }\n+  public DateTimeFormatterBuilder appendValueReduced(TemporalField field, int width, int maxWidth, ChronoLocalDate baseDate) {\n+    Objects.requireNonNull(field, \"field\");\n+    Objects.requireNonNull(baseDate, \"baseDate\");\n+    ReducedPrinterParser pp = new ReducedPrinterParser(field, width, maxWidth, baseDate.get(ChronoField.YEAR));\n+    if (width == maxWidth) {\n+      appendFixedWidth(width, pp);\n+    } else {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    builder.appendValueReduced(YEAR, 2, 2000);\n+    builder.appendValueReduced(YEAR, 2, 2, 2000);",
                    "-    builder.appendValue(MONTH_OF_YEAR, 1, 2, SignStyle.NORMAL).appendValueReduced(YEAR, 2, 2000);\n+    builder.appendValue(MONTH_OF_YEAR, 1, 2, SignStyle.NORMAL).appendValueReduced(YEAR, 2, 2, 2000);"
                ]
            }
        ]
    },
    {
        "id": 29,
        "Anal": "The method \"appendValueReduced\" has an additional parameter \"maxWidth\" added as the third parameter.",
        "Stmts": "builder.appendValueReduced(YEAR, 2, 2000);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    builder.appendValueReduced(null, 2, 2000);\n+    builder.appendValueReduced(null, 2, 2, 2000);",
                "-        appendValueReduced(field, 2, 2000);\n+        appendValueReduced(field, 2, 2, 2000);",
                "-    builder.appendValue(MONTH_OF_YEAR, 1, 2, SignStyle.NORMAL).appendValueReduced(YEAR, 2, 2000);\n+    builder.appendValue(MONTH_OF_YEAR, 1, 2, SignStyle.NORMAL).appendValueReduced(YEAR, 2, 2, 2000);"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+    }\n+    return this;\n+  }\n+  public DateTimeFormatterBuilder appendValueReduced(TemporalField field, int width, int maxWidth, ChronoLocalDate baseDate) {\n+    Objects.requireNonNull(field, \"field\");\n+    Objects.requireNonNull(baseDate, \"baseDate\");\n+    ReducedPrinterParser pp = new ReducedPrinterParser(field, width, maxWidth, baseDate.get(ChronoField.YEAR));\n+    if (width == maxWidth) {\n+      appendFixedWidth(width, pp);\n+    } else {",
                    "-    ReducedPrinterParser(TemporalField field, int width, int baseValue) {\n-      super(field, width, width, SignStyle.NOT_NEGATIVE);\n+    ReducedPrinterParser(TemporalField field, int width, int maxWidth, int baseValue) {\n+      super(field, width, maxWidth, SignStyle.NOT_NEGATIVE);",
                    "-        appendValueReduced(field, 2, 2000);\n+        appendValueReduced(field, 2, 2, 2000);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    builder.appendValueReduced(null, 2, 2000);\n+    builder.appendValueReduced(null, 2, 2, 2000);",
                    "-    builder.appendValue(MONTH_OF_YEAR, 1, 2, SignStyle.NORMAL).appendValueReduced(YEAR, 2, 2000);\n+    builder.appendValue(MONTH_OF_YEAR, 1, 2, SignStyle.NORMAL).appendValueReduced(YEAR, 2, 2, 2000);"
                ]
            }
        ]
    },
    {
        "id": 30,
        "Anal": "The method name \"getAvailableGroupIds\" changes to \"getAvailableZoneIds\".",
        "Stmts": "Set<String> groups = ZoneRulesProvider.getAvailableGroupIds();\nSet<String> groups2 = ZoneRulesProvider.getAvailableGroupIds();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-      position += matchedGroupLen;\n-      ZoneRulesProvider provider = ZoneRulesProvider.getProvider(matchedGroupId);\n-      Entry<Integer, SubstringTree> entry = preparedTree.get(matchedGroupId);\n-      Set<String> regionIds = provider.getAvailableRegionIds();\n+      Set<String> regionIds = ZoneRulesProvider.getAvailableZoneIds();",
                "-    assertEquals(post.contains(\"TEMPMOCK.-_\"), true);\n-    assertEquals(ZoneRulesProvider.getProvider(\"TEMPMOCK.-_\").getGroupId(), \"TEMPMOCK.-_\");\n-    assertEquals(ZoneRulesProvider.getProvider(\"TEMPMOCK.-_\").getRules(\"World%@~.-_\", \"1.-_\").isFixedOffset(), true);\n+    assertEquals(pre.contains(\"FooLocation\"), false);\n+    Set<String> post = ZoneRulesProvider.getAvailableZoneIds();",
                "-    Set<String> pre = ZoneRulesProvider.getAvailableGroupIds();\n-    assertEquals(pre.contains(\"TEMPMOCK.-_\"), false);\n+    Set<String> pre = ZoneRulesProvider.getAvailableZoneIds();"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-      registerProvider(provider);\n+      registerProvider0(provider);\n+    }\n+    PROVIDERS.addAll(loaded);\n+  }\n+  public static ZoneRules getRules(String zoneId) {\n+    Objects.requireNonNull(zoneId, \"zoneId\");\n+    return getProvider(zoneId).provideRules(zoneId);\n+  }\n+  public static NavigableMap<String, ZoneRules> getVersions(String zoneId) {",
                    "-    return group;\n+    return changed;",
                    "+  }\n+  public static void registerProvider(ZoneRulesProvider provider) {\n+    Objects.requireNonNull(provider, \"provider\");\n+    registerProvider0(provider);\n+    PROVIDERS.add(provider);\n+  }\n+  private static void registerProvider0(ZoneRulesProvider provider) {\n+    for (String zoneId : provider.provideZoneIds()) {\n+      Objects.requireNonNull(zoneId, \"zoneId\");\n+      ZoneRulesProvider old = ZONES.putIfAbsent(zoneId, provider.provideBind(zoneId));"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    public Set<String> getAvailableRegionIds() {\n-      return new HashSet<String>(Arrays.asList(\"World%@~.-_\"));\n+    protected ZoneRulesProvider provideBind(String zoneId) {\n+      return this;",
                    "-    Set<String> pre = ZoneRulesProvider.getAvailableGroupIds();\n-    assertEquals(pre.contains(\"TEMPMOCK.-_\"), false);\n+    Set<String> pre = ZoneRulesProvider.getAvailableZoneIds();\n+    assertEquals(pre.contains(\"FooLocation\"), false);",
                    "-    assertEquals(pre.contains(\"TEMPMOCK.-_\"), false);\n-    Set<String> post = ZoneRulesProvider.getAvailableGroupIds();\n-    assertEquals(post.contains(\"TEMPMOCK.-_\"), true);\n-    assertEquals(ZoneRulesProvider.getProvider(\"TEMPMOCK.-_\").getGroupId(), \"TEMPMOCK.-_\");\n-    assertEquals(ZoneRulesProvider.getProvider(\"TEMPMOCK.-_\").getRules(\"World%@~.-_\", \"1.-_\").isFixedOffset(), true);\n+    assertEquals(pre.contains(\"FooLocation\"), false);\n+    Set<String> post = ZoneRulesProvider.getAvailableZoneIds();\n+    assertEquals(post.contains(\"FooLocation\"), true);\n+    assertEquals(ZoneRulesProvider.getRules(\"FooLocation\"), ZoneOffset.of(\"+01:45\").getRules());"
                ]
            }
        ]
    },
    {
        "id": 31,
        "Anal": "The method name \"isSPNegoMessage\" has been changed to \"isSPNegTokenInitMessage\".",
        "Stmts": "Assert.assertFalse(header.isSPNegoMessage());\nAssert.assertFalse(header.isSPNegoMessage());\nAssert.assertTrue(header.isSPNegoMessage());",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    return this.isNtlmType1Message() || this.isSPNegoMessage();\n+    return this.isNtlmType1Message() || this.isSPNegTokenInitMessage();"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    return this.isNtlmType1Message() || this.isSPNegoMessage();\n+    return this.isNtlmType1Message() || this.isSPNegTokenInitMessage();"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 32,
        "Anal": "The second parameter \"stack\" of the method \"findByClusterStackAndVersion\" changes from `String` to `StackId`.",
        "Stmts": "Assert.assertEquals(3, hostVersionDAO.findByClusterStackAndVersion(\"test_cluster1\", \"HDP-2.2\", \"2.2.0.0-995\").size());\nAssert.assertEquals(3, hostVersionDAO.findByClusterStackAndVersion(\"test_cluster1\", \"HDP-2.2\", \"2.2.0.1-996\").size());\nAssert.assertEquals(3, hostVersionDAO.findByClusterStackAndVersion(\"test_cluster1\", \"HDP-2.2\", \"2.2.1.0-500\").size());",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [
            {
                "info": "Defined in class StackId (optional references)",
                "contexts": [
                    "public StackId();",
                    "public StackId(String stackId);",
                    "public StackId(StackEntity stackEntity);"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    query.setParameter(\"stack\", stack);\n+    query.setParameter(\"stackName\", stackId.getStackName());\n+    query.setParameter(\"stackVersion\", stackId.getStackVersion());",
                    "-  public HostVersionEntity findByClusterStackVersionAndHost(String clusterName, String stack, String version, String hostName) {\n+  public HostVersionEntity findByClusterStackVersionAndHost(String clusterName, StackId stackId, String version, String hostName) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    Assert.assertEquals(hostVersionEntity1, hostVersionDAO.findByClusterStackVersionAndHost(\"test_cluster1\", \"HDP-2.2\", \"2.2.0.0-995\", \"test_host1\"));\n-    Assert.assertEquals(hostVersionEntity2, hostVersionDAO.findByClusterStackVersionAndHost(\"test_cluster1\", \"HDP-2.2\", \"2.2.0.0-995\", \"test_host2\"));\n-    Assert.assertEquals(hostVersionEntity3, hostVersionDAO.findByClusterStackVersionAndHost(\"test_cluster1\", \"HDP-2.2\", \"2.2.0.0-995\", \"test_host3\"));\n-    Assert.assertEquals(null, hostVersionDAO.findByClusterStackVersionAndHost(\"non_existent_cluster\", \"HDP-2.2\", \"2.2.0.0-995\", \"test_host3\"));\n-    Assert.assertEquals(null, hostVersionDAO.findByClusterStackVersionAndHost(\"test_cluster1\", \"non_existent_stack\", \"2.2.0.0-995\", \"test_host3\"));\n-    Assert.assertEquals(null, hostVersionDAO.findByClusterStackVersionAndHost(\"test_cluster1\", \"HDP-2.2\", \"non_existent_version\", \"test_host3\"));\n-    Assert.assertEquals(null, hostVersionDAO.findByClusterStackVersionAndHost(\"test_cluster1\", \"HDP-2.2\", \"non_existent_version\", \"non_existent_host\"));\n+    Assert.assertEquals(hostVersionEntity1, hostVersionDAO.findByClusterStackVersionAndHost(\"test_cluster1\", HDP_22_STACK, \"2.2.0.0-995\", \"test_host1\"));\n+    Assert.assertEquals(hostVersionEntity2, hostVersionDAO.findByClusterStackVersionAndHost(\"test_cluster1\", HDP_22_STACK, \"2.2.0.0-995\", \"test_host2\"));\n+    Assert.assertEquals(hostVersionEntity3, hostVersionDAO.findByClusterStackVersionAndHost(\"test_cluster1\", HDP_22_STACK, \"2.2.0.0-995\", \"test_host3\"));",
                    "+    Assert.assertEquals(null, hostVersionDAO.findByClusterStackVersionAndHost(\"test_cluster1\", BAD_STACK, \"2.2.0.0-995\", \"test_host3\"));\n+    Assert.assertEquals(null, hostVersionDAO.findByClusterStackVersionAndHost(\"test_cluster1\", HDP_22_STACK, \"non_existent_version\", \"test_host3\"));\n+    Assert.assertEquals(null, hostVersionDAO.findByClusterStackVersionAndHost(\"test_cluster1\", HDP_22_STACK, \"non_existent_version\", \"non_existent_host\"));",
                    "-    HostVersionEntity hostVersionEntity1 = new HostVersionEntity(\"test_host1\", helper.getOrCreateRepositoryVersion(\"HDP-2.2\", \"2.2.0.0-995\"), RepositoryVersionState.CURRENT);\n+    HostVersionEntity hostVersionEntity1 = new HostVersionEntity(\"test_host1\", helper.getOrCreateRepositoryVersion(HDP_22_STACK, \"2.2.0.0-995\"), RepositoryVersionState.CURRENT);"
                ]
            }
        ]
    },
    {
        "id": 33,
        "Anal": "The parameter \"stack\" of the method \"findByStack\" changes from `String` to `StackId`.",
        "Stmts": "Assert.assertEquals(0, repositoryVersionDAO.findByStack(\"non existing\").size());\nAssert.assertEquals(1, repositoryVersionDAO.findByStack(\"stack\").size());",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    List<RepositoryVersionEntity> existingRepoVersions = repositoryVersionDAO.findByStack(requiredStack.getStackId());\n+    List<RepositoryVersionEntity> existingRepoVersions = repositoryVersionDAO.findByStack(requiredStack);",
                "-        requestedEntities.addAll(s_repositoryVersionDAO.findByStack(stackId.getStackId()));\n+        requestedEntities.addAll(s_repositoryVersionDAO.findByStack(stackId));",
                "-        requestedEntities.addAll(s_repositoryVersionDAO.findByStack(stackId.getStackId()));\n+        requestedEntities.addAll(s_repositoryVersionDAO.findByStack(stackId));\n-            requestedEntities.addAll(s_repositoryVersionDAO.findByStack(up.getTargetStack()));\n+            StackId targetStackId = new StackId(up.getTargetStack());\n+            requestedEntities.addAll(s_repositoryVersionDAO.findByStack(targetStackId));"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class StackId (optional references)",
                "contexts": [
                    "public StackId();",
                    "public StackId(String stackId);",
                    "public StackId(StackInfo stackInfo);",
                    "public void setStackId(String stackId);",
                    "public String getStackId();",
                    "public String getStackName();"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public RepositoryVersionEntity create(String stack, String version, String displayName, String upgradePack, String operatingSystems) throws AmbariException {\n-    if (stack == null || stack.isEmpty() || version == null || version.isEmpty() || displayName == null || displayName.isEmpty()) {\n+  public RepositoryVersionEntity create(StackEntity stackEntity, String version, String displayName, String upgradePack, String operatingSystems) throws AmbariException {\n+    if (stackEntity == null || version == null || version.isEmpty() || displayName == null || displayName.isEmpty()) {",
                    "-      throw new AmbariException(\"Repository version for stack \" + stack + \" and version \" + version + \" already exists\");\n+      throw new AmbariException(\"Repository version for stack \" + stackEntity + \" and version \" + version + \" already exists\");",
                    "-    RepositoryVersionEntity newEntity = new RepositoryVersionEntity(stack, version, displayName, upgradePack, operatingSystems);\n+    RepositoryVersionEntity newEntity = new RepositoryVersionEntity(stackEntity, version, displayName, upgradePack, operatingSystems);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    Assert.assertNull(repositoryVersionDAO.findByStackAndVersion(\"non existing\", \"non existing\"));\n-    Assert.assertNotNull(repositoryVersionDAO.findByStackAndVersion(\"stack\", \"version\"));\n+    Assert.assertNull(repositoryVersionDAO.findByStackAndVersion(BAD_STACK, \"non existing\"));\n+    Assert.assertNotNull(repositoryVersionDAO.findByStackAndVersion(HDP_206, \"version\"));",
                    "-    final RepositoryVersionEntity entity = repositoryVersionDAO.findByStackAndVersion(\"stack\", \"version\");\n+    final RepositoryVersionEntity entity = repositoryVersionDAO.findByStackAndVersion(HDP_206, \"version\");",
                    "-    Assert.assertNotNull(repositoryVersionDAO.findByStackAndVersion(\"stack\", \"version\"));\n-    final RepositoryVersionEntity entity = repositoryVersionDAO.findByStackAndVersion(\"stack\", \"version\");\n+    Assert.assertNotNull(repositoryVersionDAO.findByStackAndVersion(HDP_206, \"version\"));\n+    final RepositoryVersionEntity entity = repositoryVersionDAO.findByStackAndVersion(HDP_206, \"version\");"
                ]
            }
        ]
    },
    {
        "id": 34,
        "Anal": "The method name \"hexDigitToBoolArray\" has been changed to \"hexDigitToBinary\".",
        "Stmts": "assertBoolArrayEquals(new boolean[] {false, false, false, false}, Conversion.hexDigitToBoolArray('0'));\nConversion.hexDigitToBoolArray('G');",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public static char boolArrayBeMsb0ToHexDigit(boolean[] src) {\n-    return boolArrayBeMsb0ToHexDigit(src, 0);\n-  }\n-  public static char boolArrayBeMsb0ToHexDigit(boolean[] src, int srcPos) {\n+  public static char binaryBeMsb0ToHexDigit(boolean[] src) {\n+    return binaryBeMsb0ToHexDigit(src, 0);\n+  }\n+  public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) {",
                    "-  public static short boolArrayToShort(boolean[] src, int srcPos, short dstInit, int dstPos, int nBools) {\n+  public static short binaryToShort(boolean[] src, int srcPos, short dstInit, int dstPos, int nBools) {",
                    "-  public static byte boolArrayToByte(boolean[] src, int srcPos, byte dstInit, int dstPos, int nBools) {\n+  public static byte binaryToByte(boolean[] src, int srcPos, byte dstInit, int dstPos, int nBools) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    assertBoolArrayEquals(new boolean[] {true, true, true, true}, Conversion.hexDigitMsb0ToBoolArray('f'));\n-    try {\n-      Conversion.hexDigitMsb0ToBoolArray('G');\n+  public void testHexDigitMsb0ToBinary() {\n+    assertBinaryEquals(new boolean[] {false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0'));\n+    assertBinaryEquals(new boolean[] {false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1'));\n+    assertBinaryEquals(new boolean[] {false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2'));\n+    assertBinaryEquals(new boolean[] {false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3'));\n+    assertBinaryEquals(new boolean[] {false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4'));\n+    assertBinaryEquals(new boolean[] {false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5'));",
                    "+    assertBinaryEquals(new boolean[] {false, true, true, true}, Conversion.hexDigitMsb0ToBinary('7'));\n+    assertBinaryEquals(new boolean[] {true, false, false, false}, Conversion.hexDigitMsb0ToBinary('8'));\n+    assertBinaryEquals(new boolean[] {true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9'));\n+    assertBinaryEquals(new boolean[] {true, false, true, false}, Conversion.hexDigitMsb0ToBinary('A'));\n+    assertBinaryEquals(new boolean[] {true, false, true, false}, Conversion.hexDigitMsb0ToBinary('a'));\n+    assertBinaryEquals(new boolean[] {true, false, true, true}, Conversion.hexDigitMsb0ToBinary('B'));\n+    assertBinaryEquals(new boolean[] {true, false, true, true}, Conversion.hexDigitMsb0ToBinary('b'));\n+    assertBinaryEquals(new boolean[] {true, true, false, false}, Conversion.hexDigitMsb0ToBinary('C'));\n+    assertBinaryEquals(new boolean[] {true, true, false, false}, Conversion.hexDigitMsb0ToBinary('c'));\n+    assertBinaryEquals(new boolean[] {true, true, false, true}, Conversion.hexDigitMsb0ToBinary('D'));",
                    "-    assertEquals(0x0000000000000000L, Conversion.boolArrayToLong(src, 0, 0L, 0, 0));\n-    assertEquals(0x000000000000000CL, Conversion.boolArrayToLong(src, 0, 0L, 0, 1 * 4));\n-    assertEquals(0x000000001C0F1FDCL, Conversion.boolArrayToLong(src, 0, 0L, 0, 8 * 4));\n-    assertEquals(0x0000000001C0F1FDL, Conversion.boolArrayToLong(src, 1 * 4, 0L, 0, 8 * 4));\n-    assertEquals(0x123456798ABCDEF0L, Conversion.boolArrayToLong(src, 0, 0x123456798ABCDEF0L, 0, 0));\n-    assertEquals(0x1234567876BCDEF0L, Conversion.boolArrayToLong(src, 15 * 4, 0x123456798ABCDEF0L, 24, 3 * 4));\n-  }\n-  @Test\n-  public void testBoolArrayToInt() {\n+    assertEquals(0x0000000000000000L, Conversion.binaryToLong(src, 0, 0L, 0, 0));"
                ]
            }
        ]
    },
    {
        "id": 35,
        "Anal": "The method \"createSSLEngineFactory\" has been renamed to \"createInternalServerSSLEngineFactory\" and the parameter \"clientMode\" has been removed.",
        "Stmts": "final SSLEngineFactory serverSSLEngineFactory = SSLUtils.createServerSSLEngineFactory(serverConfig);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "+  @Test\n+  public void testInternalSSLTrustStoreOnly() throws Exception {\n+    final Configuration config = createInternalSslConfigWithTrustStore();\n+    try {\n+      SSLUtils.createInternalServerSSLEngineFactory(config);",
                "+  @Test\n+  public void testInternalSSLKeyStoreOnly() throws Exception {\n+    final Configuration config = createInternalSslConfigWithKeyStore();\n+    try {\n+      SSLUtils.createInternalServerSSLEngineFactory(config);",
                "+  public void testInternalSSLDisables() throws Exception {\n+    final Configuration config = createInternalSslConfigWithKeyAndTrustStores();\n+    config.setBoolean(SecurityOptions.SSL_INTERNAL_ENABLED, false);\n+    try {\n+      SSLUtils.createInternalServerSSLEngineFactory(config);"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+    String keystoreFilePath = getAndCheckOption(config, SecurityOptions.SSL_INTERNAL_KEYSTORE, SecurityOptions.SSL_KEYSTORE);\n+    String keystorePassword = getAndCheckOption(config, SecurityOptions.SSL_INTERNAL_KEYSTORE_PASSWORD, SecurityOptions.SSL_KEYSTORE_PASSWORD);\n+    String certPassword = getAndCheckOption(config, SecurityOptions.SSL_INTERNAL_KEY_PASSWORD, SecurityOptions.SSL_KEY_PASSWORD);\n+    String trustStoreFilePath = getAndCheckOption(config, SecurityOptions.SSL_INTERNAL_TRUSTSTORE, SecurityOptions.SSL_TRUSTSTORE);\n+    String trustStorePassword = getAndCheckOption(config, SecurityOptions.SSL_INTERNAL_TRUSTSTORE_PASSWORD, SecurityOptions.SSL_TRUSTSTORE_PASSWORD);\n+    String sslProtocolVersion = config.getString(SecurityOptions.SSL_PROTOCOL);\n+    KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+    try (InputStream keyStoreFile = Files.newInputStream(new File(keystoreFilePath).toPath())) {\n+      keyStore.load(keyStoreFile, keystorePassword.toCharArray());\n+    }",
                    "-    return clientSSLContext;\n+    String keystoreFilePath = getAndCheckOption(config, SecurityOptions.SSL_REST_KEYSTORE, SecurityOptions.SSL_KEYSTORE);\n+    String keystorePassword = getAndCheckOption(config, SecurityOptions.SSL_REST_KEYSTORE_PASSWORD, SecurityOptions.SSL_KEYSTORE_PASSWORD);\n+    String certPassword = getAndCheckOption(config, SecurityOptions.SSL_REST_KEY_PASSWORD, SecurityOptions.SSL_KEY_PASSWORD);\n+    String sslProtocolVersion = config.getString(SecurityOptions.SSL_PROTOCOL);\n+    KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+    try (InputStream keyStoreFile = Files.newInputStream(new File(keystoreFilePath).toPath())) {\n+      keyStore.load(keyStoreFile, keystorePassword.toCharArray());\n+    }\n+    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());",
                    "+    sslContext.init(null, tmf.getTrustManagers(), null);\n+    return sslContext;\n+  }\n+  private static String getAndCheckOption(Configuration config, ConfigOption<String> primaryOption, ConfigOption<String> fallbackOption) {\n+    String value = config.getString(primaryOption, config.getString(fallbackOption));\n+    if (value != null) {\n+      return value;\n+    } else {\n+      throw new IllegalConfigurationException(\"The config option \" + primaryOption.key() + \" or \" + fallbackOption.key() + \" is missing.\");\n+    }"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "+    final Configuration config = createInternalSslConfigWithKeyAndTrustStores();\n+    config.setString(SecurityOptions.SSL_INTERNAL_KEYSTORE_PASSWORD, \"badpw\");\n+    try {\n+      SSLUtils.createInternalServerSSLEngineFactory(config);\n+      fail(\"exception expected\");\n+    } catch (Exception ignored) {}\n+    try {\n+      SSLUtils.createInternalClientSSLEngineFactory(config);\n+      fail(\"exception expected\");\n+    } catch (Exception ignored) {}",
                    "+  }\n+  @Test\n+  public void testRESTServerSSLBadKeyPassword() {\n+    Configuration serverConfig = createRestSslConfigWithKeyStore();\n+    serverConfig.setString(SecurityOptions.SSL_REST_KEY_PASSWORD, \"badpassword\");\n+    try {\n+      SSLUtils.createRestServerSSLEngineFactory(serverConfig);\n+      fail(\"exception expected\");\n+    } catch (Exception ignored) {}\n+  }",
                    "+  public void testRESTServerSSL() throws Exception {\n+    Configuration serverConfig = createRestSslConfigWithKeyStore();\n+    SSLEngineFactory ssl = SSLUtils.createRestServerSSLEngineFactory(serverConfig);\n+    assertNotNull(ssl);\n+  }\n+  @Test\n+  public void testRESTServerSSLDisabled() throws Exception {\n+    Configuration serverConfig = createRestSslConfigWithKeyStore();\n+    serverConfig.setBoolean(SecurityOptions.SSL_REST_ENABLED, false);\n+    try {"
                ]
            }
        ]
    },
    {
        "id": 36,
        "Anal": "The return type of the method \"getSnapshottingSettings\" changes from `JobSnapshottingSettings` to `JobCheckpointingSettings`.",
        "Stmts": "JobSnapshottingSettings snapshottingSettings = new JobSnapshottingSettings(Collections.singletonList(new JobVertexID()), Collections.singletonList(new JobVertexID()), Collections.singletonList(new JobVertexID()), 181238123L, 19191992L, 191929L, 123, ExternalizedCheckpointSettings.none(), null, false);\nassertEquals(snapshottingSettings, tracker.getSnapshottingSettings());",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "       return checkpointStatsTracker.getSnapshottingSettings();"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class JobCheckpointingSettings (optional references)",
                "contexts": [
                    "@Override public String toString();",
                    "public long getCheckpointTimeout();",
                    "public int getMaxConcurrentCheckpoints();"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public CheckpointStatsTracker(int numRememberedCheckpoints, List<ExecutionJobVertex> jobVertices, JobSnapshottingSettings jobSnapshottingSettings, MetricGroup metricGroup) {\n+  public CheckpointStatsTracker(int numRememberedCheckpoints, List<ExecutionJobVertex> jobVertices, JobCheckpointingSettings jobCheckpointingSettings, MetricGroup metricGroup) {",
                    "-  private final JobSnapshottingSettings jobSnapshottingSettings;\n+  private final JobCheckpointingSettings jobCheckpointingSettings;",
                    "-    this.jobSnapshottingSettings = checkNotNull(jobSnapshottingSettings);\n+    this.jobCheckpointingSettings = checkNotNull(jobCheckpointingSettings);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    new CheckpointStatsTracker(0, Collections.singletonList(jobVertex), mock(JobSnapshottingSettings.class), metricGroup);\n+    new CheckpointStatsTracker(0, Collections.singletonList(jobVertex), mock(JobCheckpointingSettings.class), metricGroup);",
                    "-    return new CheckpointStatsTracker(0, Collections.singletonList(jobVertex), mock(JobSnapshottingSettings.class), new UnregisteredMetricsGroup());\n+    return new CheckpointStatsTracker(0, Collections.singletonList(jobVertex), mock(JobCheckpointingSettings.class), new UnregisteredMetricsGroup());",
                    "-    CheckpointStatsTracker tracker = new CheckpointStatsTracker(0, Collections.singletonList(jobVertex), mock(JobSnapshottingSettings.class), new UnregisteredMetricsGroup());\n+    CheckpointStatsTracker tracker = new CheckpointStatsTracker(0, Collections.singletonList(jobVertex), mock(JobCheckpointingSettings.class), new UnregisteredMetricsGroup());"
                ]
            }
        ]
    },
    {
        "id": 37,
        "Anal": "The return type of the method \"getInputs\" changes from `List<Output>` to `List<Operator<?>.Output>`.",
        "Stmts": "final List<Operator.Output> result = fixture.getInputs();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "+        for (final Operator<?>.Output input : operator.getInputs())\n-      final Operator unconnectedNode = unconnectedInputs.get(index);\n+      final Operator<?> unconnectedNode = unconnectedInputs.get(index);\n-        final List<Operator.Output> missingInputs = new ArrayList<Operator.Output>(unconnectedNode.getInputs());\n+        final List<Operator<?>.Output> missingInputs = new ArrayList<Operator<?>.Output>(unconnectedNode.getInputs());",
                "+    assertEquals(Arrays.asList((Operator<?>)null), fixture.getInputs());\n-    final Operator input1 = new OpImpl(0);\n-    final Operator input2 = new OpImpl(1);\n-    final Operator fixture = new OpImpl(0).withInputs(input1, input2);\n+    final Operator<?> input1 = new OpImpl(0);",
                "+    assertEquals(1, fixture.getInputs().size());\n+    assertEquals(Arrays.asList((Operator<?>)null), fixture.getInputs());\n-    final Operator input1 = new OpImpl(0);\n-    final Operator input2 = new OpImpl(1);\n-    final Operator fixture = new OpImpl(0).withInputs(input1, input2);"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  private transient List<Operator<Self>.Output> inputs = new ArrayList<Operator<Self>.Output>();\n+  private transient List<Operator<?>.Output> inputs = new ArrayList<Operator<?>.Output>();",
                    "-      final Output other = (Output)obj;\n+      @SuppressWarnings(\"unchecked\") final Operator<Self>.Output other = (Operator<Self>.Output)obj;",
                    "-        final ListIterator<Output> e = Operator.this.inputs.listIterator();\n+        final ListIterator<Operator<?>.Output> e = Operator.this.inputs.listIterator();"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    final Operator fixture = new OpImpl(0);\n-    final List<Operator.Output> result = fixture.getOutputs();\n+    final Operator<?> fixture = new OpImpl(0);\n+    final List<Operator<?>.Output> result = fixture.getOutputs();",
                    "-    final Operator fixture = new OpImpl(0);\n-    final Operator.Output result = fixture.getSource();\n+    final Operator<?> fixture = new OpImpl(0);\n+    final Operator<?>.Output result = fixture.getSource();",
                    "-    final Operator input1 = new OpImpl(0);\n-    final Operator input2 = new OpImpl(1);\n-    final Operator fixture = new OpImpl(0).withInputs(input1, input2);\n+    final Operator<?> input1 = new OpImpl(0);\n+    final Operator<?> input2 = new OpImpl(1);\n+    final Operator<?> fixture = new OpImpl(0).withInputs(input1, input2);"
                ]
            }
        ]
    },
    {
        "id": 38,
        "Anal": "The method \"clearAndPut\" now returns a List of Runnables and throws a MailboxStateException. It also changes the parameter name from \"shutdownAction\" to \"priorityLetter\".",
        "Stmts": "mailbox.clearAndPut(POISON_LETTER);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "+      List<Runnable> droppedRunnables = mailbox.clearAndPut(priorityLetter);\n+      FutureUtils.cancelRunnableFutures(droppedRunnables);\n+    } catch (MailboxStateException msex) {\n+      LOG.debug(\"Mailbox already closed in cancel().\", msex);\n+    }",
                "+    testUnblocksInternal(() -> mailbox.clearAndPut(() -> {}), unblockMethod, MailboxStateException.class);\n+  }\n+  private void testUnblocksInternal(RunnableWithException testMethod, Consumer<Mailbox> unblockMethod, Class<?> expectedExceptionClass) throws InterruptedException {\n+    final Thread[] blockedThreads = new Thread[CAPACITY * 2];\n+    final Exception[] exceptions = new Exception[blockedThreads.length];"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+    checkPutStateConditions();\n+    headIndex = decreaseIndexWithWrapAround(headIndex);\n+    this.ringBuffer[headIndex] = letter;\n+    ++count;\n+    notEmpty.signal();\n+  }\n+  private void putTailInternal(Runnable letter) throws MailboxStateException {\n+    assert lock.isHeldByCurrentThread();\n+    checkPutStateConditions();",
                    "-        putInternal(letter);\n+        putTailInternal(letter);",
                    "+  }"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "+    setUp();\n+    testUnblocksInternal(() -> mailbox.clearAndPut(() -> {}), unblockMethod, MailboxStateException.class);\n+  }\n+  private void testUnblocksInternal(RunnableWithException testMethod, Consumer<Mailbox> unblockMethod, Class<?> expectedExceptionClass) throws InterruptedException {\n+    final Thread[] blockedThreads = new Thread[CAPACITY * 2];\n+    final Exception[] exceptions = new Exception[blockedThreads.length];\n+    CountDownLatch countDownLatch = new CountDownLatch(blockedThreads.length);\n+    for (int i = 0; i < blockedThreads.length; ++i) {\n+      final int id = i;\n+      Thread blocked = new Thread(() -> {",
                    "+          mailbox.putFirst(instanceB);\n+        }\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      } catch (MailboxStateException ignore) {}\n+    });\n+    blockingPut.start();\n+    latch.await();\n+    Assert.assertSame(instanceA, mailbox.takeMail());\n+    blockingPut.join();",
                    "+  private void testLifecyclePuttingInternal() throws Exception {\n+    try {\n+      mailbox.tryPutMail(() -> {});\n+      Assert.fail();\n+    } catch (MailboxStateException ignore) {}\n+    try {\n+      mailbox.tryPutFirst(() -> {});\n+      Assert.fail();\n+    } catch (MailboxStateException ignore) {}\n+    try {"
                ]
            }
        ]
    },
    {
        "id": 39,
        "Anal": "The parameter \"millis\" of the method \"sleep\" changes from `long` to `Duration`.",
        "Stmts": "long expectedSleepTimeMs = new Random().nextInt(100);\nSysUtils.sleep(expectedSleepTimeMs);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-      int port = socket.getLocalPort();\n-      return port;\n+      return socket.getLocalPort();"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 40,
        "Anal": "The method \"getContainers\" has been updated to include two new parameters: `Resource maxContainerResource` and `Resource padding`. These parameters have been added between the existing parameters `PackingPlan currentPackingPlan` and `Map<String, TreeSet<Integer>> componentIndexes`.",
        "Stmts": "Map<Integer, Container> containers = PackingPlanBuilder.getContainers(packingPlan, paddingPercentage, new HashMap<String, TreeSet<Integer>>(), new TreeSet<Integer>());",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-      Resource resource = new Resource(Math.round(containerCpu), containerRam, containerDiskInBytes);\n-      PackingPlan.ContainerPlan containerPlan = new PackingPlan.ContainerPlan(containerId, instancePlans, resource);\n+      Resource totalUsedResources = container.getTotalUsedResources();\n+      Resource resource = new Resource(Math.round(totalUsedResources.getCpu()), totalUsedResources.getRam(), totalUsedResources.getDisk());\n+      PackingPlan.ContainerPlan containerPlan = new PackingPlan.ContainerPlan(containerId, container.getInstances(), resource);",
                    "-          newContainerMap.put(containerId, new Container(containerId, this.maxContainerResource, this.requestedContainerPadding));\n+          this.containers.put(containerId, new Container(containerId, this.maxContainerResource, this.requestedContainerPadding));",
                    "-    Resource instanceResource = PackingUtils.getResourceRequirement(componentName, this.componentRamMap, this.defaultInstanceResource, this.maxContainerResource, this.requestedContainerPadding);\n+    Resource instanceResource = componentResourceMap.getOrDefault(componentName, defaultInstanceResource);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    @SuppressWarnings({\"unchecked\", \"rawtypes\"}) Pair<Integer, InstanceId>[] added = new Pair[] {new Pair<>(3, new InstanceId(\"componentB\", 4, 1))};\n+    @SuppressWarnings({\"unchecked\", \"rawtypes\"}) Pair<Integer, InstanceId>[] added = new Pair[] {new Pair<>(3, new InstanceId(\"componentB\", 4, 1)), new Pair<>(3, new InstanceId(\"componentB\", 5, 2))};",
                    "-    testContainers.add(new Container(3, null, 5));\n-    testContainers.add(new Container(6, null, 20));\n-    testContainers.add(new Container(4, null, 20));\n+    testContainers.add(new Container(3, null, new Resource(5, ByteAmount.fromGigabytes(5), ByteAmount.fromGigabytes(5))));\n+    testContainers.add(new Container(6, null, new Resource(20, ByteAmount.fromGigabytes(20), ByteAmount.fromGigabytes(20))));\n+    testContainers.add(new Container(4, null, new Resource(20, ByteAmount.fromGigabytes(20), ByteAmount.fromGigabytes(20))));",
                    "-      return container.getPaddingPercentage();\n+      return container.getPadding().getCpu();"
                ]
            }
        ]
    },
    {
        "id": 41,
        "Anal": "The method \"assign\" has been updated to include a new parameter \"stellarContext\" of type `Context`.",
        "Stmts": "executor.assign(\"foo\", \"2\", message);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    executor.assign(\"two\", \"2\", message);\n+    executor.assign(\"two\", \"2\", message, Context.EMPTY_CONTEXT());",
                "-    executor.assign(\"two\", \"2\", message);\n-    executor.assign(\"four\", \"4\", message);\n-    executor.assign(\"sum\", \"two + four\", message);\n+    executor.assign(\"two\", \"2\", message, Context.EMPTY_CONTEXT());",
                "-      expressions.forEach((var, expr) -> executor.assign(var, expr, message));\n+      expressions.forEach((var, expr) -> executor.assign(var, expr, message, stellarContext));"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class Context (optional references)",
                "contexts": [
                    "public static Context EMPTY_CONTEXT();",
                    "public Optional<Object> getCapability(Enum<?> capability);",
                    "public Optional<Object> getCapability(String capability);"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public <T> T execute(String expr, JSONObject message, Class<T> clazz) {\n-    Object resultObject = execute(expr, message);\n+  public <T> T execute(String expr, JSONObject message, Class<T> clazz, Context stellarContext) {\n+    Object resultObject = execute(expr, message, stellarContext);",
                    "-      return processor.parse(expr, resolver, StellarFunctions.FUNCTION_RESOLVER(), Context.EMPTY_CONTEXT());\n+      return processor.parse(expr, resolver, StellarFunctions.FUNCTION_RESOLVER(), stellarContext);",
                    "-  private Object execute(String expr, JSONObject msg) {\n+  private Object execute(String expr, JSONObject msg, Context stellarContext) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    executor.assign(\"foo\", \"ip_src_addr\", message);\n+    executor.assign(\"foo\", \"ip_src_addr\", message, Context.EMPTY_CONTEXT());",
                    "-    executor.execute(\"2\", message, Double.class);\n-    executor.execute(\"2\", message, Float.class);\n-    executor.execute(\"2\", message, Short.class);\n-    executor.execute(\"2\", message, Long.class);\n+    executor.execute(\"2\", message, Double.class, Context.EMPTY_CONTEXT());\n+    executor.execute(\"2\", message, Float.class, Context.EMPTY_CONTEXT());\n+    executor.execute(\"2\", message, Short.class, Context.EMPTY_CONTEXT());\n+    executor.execute(\"2\", message, Long.class, Context.EMPTY_CONTEXT());",
                    "-    executor.assign(\"two\", \"2\", message);\n-    executor.assign(\"four\", \"4\", message);\n-    executor.assign(\"sum\", \"two + four\", message);\n+    executor.assign(\"two\", \"2\", message, Context.EMPTY_CONTEXT());\n+    executor.assign(\"four\", \"4\", message, Context.EMPTY_CONTEXT());\n+    executor.assign(\"sum\", \"two + four\", message, Context.EMPTY_CONTEXT());"
                ]
            }
        ]
    },
    {
        "id": 42,
        "Anal": "The method \"execute\" has been updated to include a new parameter \"stellarContext\" of type `Context`.",
        "Stmts": "String actual = executor.execute(\"TO_UPPER('lowercase')\", message, String.class);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    boolean actual = executor.execute(\"IS_INTEGER(2)\", message, Boolean.class);\n+    boolean actual = executor.execute(\"IS_INTEGER(2)\", message, Boolean.class, Context.EMPTY_CONTEXT());",
                "-    if (StringUtils.isBlank(onlyIf) || executor.execute(onlyIf, message, Boolean.class)) {\n+    if (StringUtils.isBlank(onlyIf) || executor.execute(onlyIf, message, Boolean.class, stellarContext)) {\n-      String entity = executor.execute(profile.getForeach(), message, String.class);\n+      String entity = executor.execute(profile.getForeach(), message, String.class, stellarContext);",
                "-    if (StringUtils.isBlank(onlyIf) || executor.execute(onlyIf, message, Boolean.class)) {\n+    if (StringUtils.isBlank(onlyIf) || executor.execute(onlyIf, message, Boolean.class, stellarContext)) {"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class Context (optional references)",
                "contexts": [
                    "public static Context EMPTY_CONTEXT();",
                    "public void addCapability(String s, Capability capability);"
                ]
            },
            {
                "info": "Defined in class Context.Capability.Builder (optional references)",
                "contexts": [
                    "public Builder with(Enum<?> s, Capability capability);"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-      return processor.parse(expr, resolver, StellarFunctions.FUNCTION_RESOLVER(), Context.EMPTY_CONTEXT());\n+      return processor.parse(expr, resolver, StellarFunctions.FUNCTION_RESOLVER(), stellarContext);",
                    "-  private Object execute(String expr, JSONObject msg) {\n+  private Object execute(String expr, JSONObject msg, Context stellarContext) {",
                    "-  void assign(String variable, String expression, JSONObject message);\n-  <T> T execute(String expression, JSONObject message, Class<T> clazz);\n+  void assign(String variable, String expression, JSONObject message, Context stellarContext);\n+  <T> T execute(String expression, JSONObject message, Class<T> clazz, Context stellarContext);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    boolean actual = executor.execute(\"IS_INTEGER(2)\", message, Boolean.class);\n+    boolean actual = executor.execute(\"IS_INTEGER(2)\", message, Boolean.class, Context.EMPTY_CONTEXT());",
                    "-    executor.execute(\"2\", message, Double.class);\n-    executor.execute(\"2\", message, Float.class);\n-    executor.execute(\"2\", message, Short.class);\n-    executor.execute(\"2\", message, Long.class);\n+    executor.execute(\"2\", message, Double.class, Context.EMPTY_CONTEXT());\n+    executor.execute(\"2\", message, Float.class, Context.EMPTY_CONTEXT());\n+    executor.execute(\"2\", message, Short.class, Context.EMPTY_CONTEXT());\n+    executor.execute(\"2\", message, Long.class, Context.EMPTY_CONTEXT());",
                    "-    executor.execute(\"2 + 2\", message, Boolean.class);\n+    executor.execute(\"2 + 2\", message, Boolean.class, Context.EMPTY_CONTEXT());"
                ]
            }
        ]
    },
    {
        "id": 43,
        "Anal": "The method \"removePartition\" now throws a `MetadataServiceException`.",
        "Stmts": "pdms.removePartition(newHCatDependency, false);\npdms.removePartition(newHCatDependency);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "       removePartition(partition, true);"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-      _registerMessageReceiver(_getTopic(partition));\n+      _registerMessageReceiver(partition);",
                    "+      }\n+    }\n+    return result;",
                    "-  private void _registerMessageReceiver(String topic) throws Exception {\n-    MessageReceiver recvr = new MessageReceiver(new HCatMessageHandler());\n-    log.debug(\"Registering topic :\" + topic);\n-    recvr.registerTopic(topic);\n+  private void _registerMessageReceiver(PartitionWrapper partition) throws MetadataServiceException {\n+    String topic = _getTopic(partition);\n+    try {\n+      MessageReceiver recvr = Services.get().get(JMSAccessorService.class).getTopicReceiver(topic);\n+      if (recvr == null) {\n+        recvr = new MessageReceiver(new HCatMessageHandler());"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    String newHCatDependency = \"hcat://hcat.yahoo.com:5080/mydb/clicks/?datastamp=12&region=us\";\n+    String newHCatDependency = \"hcat://hcat.yahoo.com:5080/database/mydb/table/clicks/partition/datastamp=12,region=us\";",
                    "-    String newHCatDependency1 = \"hcat://hcat.yahoo.com:5080/mydb/clicks/?datastamp=12\";\n-    String newHCatDependency2 = \"hcat://hcat.yahoo.com:5080/mydb/clicks/?datastamp=12&region=us\";\n+    String newHCatDependency1 = \"hcat://hcat.yahoo.com:5080/database/mydb/table/clicks/partition/datastamp=12\";\n+    String newHCatDependency2 = \"hcat://hcat.yahoo.com:5080/database/mydb/table/clicks/partition/datastamp=12,region=us\";",
                    "+  protected Services setupServicesForHCatalog() throws ServiceException {\n+    Services services = new Services();\n+    Configuration conf = services.getConf();\n+    conf.set(Services.CONF_SERVICE_EXT_CLASSES, \"org.apache.oozie.service.PartitionDependencyManagerService,\"\n+                                                    + \"org.apache.oozie.service.JMSAccessorService,\"\n+                                                    + \"org.apache.oozie.service.MetaDataAccessorService\");\n+    conf.set(JMSAccessorService.JMS_CONNECTIONS_PROPERTIES, \"default=java.naming.factory.initial#\" + ActiveMQConnFactory + \";\"\n+                                                                + \"java.naming.provider.url#\" + localActiveMQBroker);\n+    return services;\n+  }"
                ]
            }
        ]
    },
    {
        "id": 44,
        "Anal": "The parameter of the method \"parseServiceRequestPath\" changes from `String` to `HttpServletRequest`.",
        "Stmts": "ServiceRequestPathInfo info = GatewayServlet.parseServiceRequestPath(null);\ninfo = GatewayServlet.parseServiceRequestPath(\"/invalidpath\");\ninfo = GatewayServlet.parseServiceRequestPath(\"/invalid/path\");\ninfo = GatewayServlet.parseServiceRequestPath(\"/Org1/Service1/1.0\");\ninfo = GatewayServlet.parseServiceRequestPath(\"/MyOrg/Service-99/2.7\");\ninfo = GatewayServlet.parseServiceRequestPath(\"/MyOrg/Service-99/2.7/resource\");\ninfo = GatewayServlet.parseServiceRequestPath(\"/MyOrg/Service-99/2.7/path/to/resource\");\ninfo = GatewayServlet.parseServiceRequestPath(\"/MyOrg/Service-99/2.7/path/to/resource?query=1234\");",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    ServiceRequestPathInfo pathInfo = parseServiceRequestPath(request.getPathInfo());\n+    ServiceRequestPathInfo pathInfo = parseServiceRequestPath(request);",
                "+    }\n+    if (apiVersionHeader != null) {\n+      mockReq.setHeader(\"X-API-Version\", apiVersionHeader);\n+    }\n+    return GatewayServlet.parseServiceRequestPath(mockReq);"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    ServiceRequestPathInfo pathInfo = parseServiceRequestPath(request.getPathInfo());\n+    ServiceRequestPathInfo pathInfo = parseServiceRequestPath(request);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "+  private ServiceRequestPathInfo parseServiceRequestPath(String path) {\n+    return parseServiceRequestPath(path, null, null);\n+  }\n+  private ServiceRequestPathInfo parseServiceRequestPath(String path, String acceptHeader, String apiVersionHeader) {\n+    MockHttpServletRequest mockReq = new MockHttpServletRequest(path);\n+    if (acceptHeader != null) {\n+      mockReq.setHeader(\"Accept\", acceptHeader);\n+    }\n+    if (apiVersionHeader != null) {\n+      mockReq.setHeader(\"X-API-Version\", apiVersionHeader);",
                    "+    return GatewayServlet.parseServiceRequestPath(mockReq);\n+  }"
                ]
            }
        ]
    },
    {
        "id": 45,
        "Anal": "The method \"visitLabels\" changes from accepting an `AcceptsLabelAttribute` parameter to returning a `Collection<DepEdge>`.",
        "Stmts": "VisitationRecorder recorder = new VisitationRecorder(\"srcs\");\nmapper.visitLabels(recorder);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": []
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    }\n+  protected static List<String> getLabelsForAttribute(AttributeMap attributeMap, String attributeName) throws InterruptedException {\n+    return attributeMap.visitLabels().stream().filter((d) -> d.getAttribute().getName().equals(attributeName)).map(AttributeMap.DepEdge::getLabel).map(Label::toString).collect(Collectors.toList());"
                ]
            }
        ]
    },
    {
        "id": 46,
        "Anal": "There is no change in the focal method as per the provided syntactic diff.",
        "Stmts": "",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": []
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    VisitationRecorder recorder = new VisitationRecorder(\"malloc\");\n-    AggregatingAttributeMapper.of(rule).visitLabels(recorder);\n-    assertThat(recorder.labelsVisited).containsExactly(\"//conditions:a\", getDefaultMallocLabel(rule).toString());\n+    assertThat(getLabelsForAttribute(AggregatingAttributeMapper.of(rule), \"malloc\")).containsExactly(\"//conditions:a\", getDefaultMallocLabel(rule).toString());"
                ]
            }
        ]
    },
    {
        "id": 47,
        "Anal": "The parameters of the method \"divideInternally\" have been replaced by a single parameter of type `SubunitClustererParameters`.",
        "Stmts": "boolean divided = sc1.divideInternally(0.8, 3.0, 20);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-        clusters.get(c).divideInternally(params.getCoverageThreshold(), params.getRmsdThreshold(), params.getMinimumSequenceLength());\n+        clusters.get(c).divideInternally(params);"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class SubunitClustererParameters (optional references)",
                "contexts": [
                    "public SubunitClustererParameters();",
                    "public SubunitClustererParameters(boolean iUseGlobalMetrics);",
                    "public void setMinimumSequenceLength(int minimumSequenceLength);",
                    "public int getMinimumSequenceLength();",
                    "public void setMinimumSequenceLengthFraction( double minimumSequenceLengthFraction);",
                    "public void setSequenceCoverageThreshold(double sequenceCoverageThreshold);",
                    "public void setStructureCoverageThreshold(double structureCoverageThreshold);",
                    "public double getStructureCoverageThreshold();",
                    "public void setRMSDThreshold(double rmsdThreshold);",
                    "public double getRMSDThreshold();",
                    "public void setUseRMSD(boolean useRMSD);"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+      double gaps2 = aligner.getPair().getAlignedSequence(2).getNumGapPositions();\n+      double lengthAlignment = aligner.getPair().getLength();\n+      double lengthThis = aligner.getQuery().getLength();\n+      double lengthOther = aligner.getTarget().getLength();\n+      sequenceCoverage = (lengthAlignment - gaps1 - gaps2) / Math.max(lengthThis, lengthOther);\n+      if (sequenceCoverage < params.getSequenceCoverageThreshold())\n+        return false;\n+    }",
                    "+    double sequenceIdentity;\n+    if (params.isUseGlobalMetrics()) {\n+      sequenceIdentity = aligner.getPair().getPercentageOfIdentity(true);\n+    } else {\n+      sequenceIdentity = aligner.getPair().getPercentageOfIdentity(false);\n+    }\n+    if (sequenceIdentity < params.getSequenceIdentityThreshold())\n+      return false;\n+    double sequenceCoverage = 0;\n+    if (params.isUseSequenceCoverage()) {",
                    "+    } catch (NoSuchMethodException e) {}\n+    if (setOptimizeAlignment != null) {\n+      try {\n+        setOptimizeAlignment.invoke(aligner_params, params.isOptimizeAlignment());\n+      } catch (IllegalAccessException | InvocationTargetException e) {\n+        logger.warn(\"Could not set alignment optimisation switch\");\n+      }\n+    }"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    boolean merged = sc1.mergeStructure(sc2, 3.0, 0.9);\n+    boolean merged = sc1.mergeStructure(sc2, clustererParameters);",
                    "-    boolean merged13 = sc1.mergeStructure(sc3, 3.0, 0.9);\n-    boolean merged24 = sc2.mergeStructure(sc4, 3.0, 0.9);\n+    SubunitClustererParameters clustererParameters = new SubunitClustererParameters();\n+    clustererParameters.setRMSDThreshold(3.0);\n+    clustererParameters.setStructureCoverageThreshold(0.9);\n+    boolean merged13 = sc1.mergeStructure(sc3, clustererParameters);\n+    boolean merged24 = sc2.mergeStructure(sc4, clustererParameters);",
                    "-    boolean merged = sc1.mergeSequence(sc2, 0.9, 0.9);\n+    SubunitClustererParameters clustererParameters = new SubunitClustererParameters();\n+    clustererParameters.setSequenceIdentityThreshold(0.9);\n+    clustererParameters.setSequenceCoverageThreshold(0.9);\n+    boolean merged = sc1.mergeSequence(sc2, clustererParameters);"
                ]
            }
        ]
    },
    {
        "id": 48,
        "Anal": "The method \"mergeStructure\" changes its parameters from `(SubunitCluster other, double maxRmsd, double minCoverage)` to `(SubunitCluster other, SubunitClustererParameters params)`.",
        "Stmts": "boolean merged13 = sc1.mergeStructure(sc3, 3.0, 0.9);\nboolean merged24 = sc2.mergeStructure(sc4, 3.0, 0.9);\nboolean merged = sc1.mergeStructure(sc2, 3.0, 0.9);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-          if (clusters.get(c1).mergeStructure(clusters.get(c2), params.getRmsdThreshold(), params.getCoverageThreshold()))\n+          if (clusters.get(c1).mergeStructure(clusters.get(c2), params)) {",
                "-        if (c1.get(i).mergeStructure(c2.get(j), cParams.getRmsdThreshold(), cParams.getCoverageThreshold(), aParams.getAligner()))\n+        if (c1.get(i).mergeStructure(c2.get(j), cParams)) {",
                "-          if (clusters.get(c1).mergeStructure(clusters.get(c2), params.getRmsdThreshold(), params.getCoverageThreshold()))\n+          if (clusters.get(c1).mergeStructure(clusters.get(c2), params))"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class SubunitClustererParameters (optional references)",
                "contexts": [
                    "public SubunitClustererParameters();",
                    "public SubunitClustererParameters(boolean iUseGlobalMetrics);",
                    "public void setUseStructureCoverage(boolean useStructureCoverage);",
                    "public boolean isUseStructureCoverage();",
                    "public void setUseSequenceCoverage(boolean useSequenceCoverage);",
                    "public void setUseRMSD(boolean useRMSD);",
                    "public boolean isUseRMSD();",
                    "public void setRMSDThreshold(double rmsdThreshold);"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+      double gaps2 = aligner.getPair().getAlignedSequence(2).getNumGapPositions();\n+      double lengthAlignment = aligner.getPair().getLength();\n+      double lengthThis = aligner.getQuery().getLength();\n+      double lengthOther = aligner.getTarget().getLength();\n+      sequenceCoverage = (lengthAlignment - gaps1 - gaps2) / Math.max(lengthThis, lengthOther);\n+      if (sequenceCoverage < params.getSequenceCoverageThreshold())\n+        return false;\n+    }",
                    "+    double sequenceIdentity;\n+    if (params.isUseGlobalMetrics()) {\n+      sequenceIdentity = aligner.getPair().getPercentageOfIdentity(true);\n+    } else {\n+      sequenceIdentity = aligner.getPair().getPercentageOfIdentity(false);\n+    }\n+    if (sequenceIdentity < params.getSequenceIdentityThreshold())\n+      return false;\n+    double sequenceCoverage = 0;\n+    if (params.isUseSequenceCoverage()) {",
                    "+  public boolean mergeSequence(SubunitCluster other, SubunitClustererParameters params) throws CompoundNotFoundException {\n+    PairwiseSequenceAlignerType alignerType = PairwiseSequenceAlignerType.LOCAL;\n+    if (params.isUseGlobalMetrics()) {\n+      alignerType = PairwiseSequenceAlignerType.GLOBAL;\n+    }\n+    return mergeSequence(other, params, alignerType, new SimpleGapPenalty(), SubstitutionMatrixHelper.getBlosum62());\n+  }\n+  public boolean mergeSequence(SubunitCluster other, SubunitClustererParameters params, PairwiseSequenceAlignerType alignerType, GapPenalty gapPenalty, SubstitutionMatrix<AminoAcidCompound> subsMatrix) throws CompoundNotFoundException {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    boolean merged = sc1.mergeSequence(sc2, 0.9, 0.9);\n+    SubunitClustererParameters clustererParameters = new SubunitClustererParameters();\n+    clustererParameters.setSequenceIdentityThreshold(0.9);\n+    clustererParameters.setSequenceCoverageThreshold(0.9);\n+    boolean merged = sc1.mergeSequence(sc2, clustererParameters);",
                    "-    merged = sc1.mergeSequence(sc3, 0.9, 0.9);\n+    merged = sc1.mergeSequence(sc3, clustererParameters);",
                    "-    merged = sc1.mergeSequence(sc4, 0.9, 0.9);\n+    merged = sc1.mergeSequence(sc4, clustererParameters);"
                ]
            }
        ]
    },
    {
        "id": 49,
        "Anal": "The method \"getPercentageOfIdentity\" now requires a boolean parameter \"countGaps\".",
        "Stmts": "assertEquals(global.getPercentageOfIdentity(), 1.0, 0.01);\nassertEquals(local.getPercentageOfIdentity(), 1.0, 0.01);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "+    double sequenceIdentity;\n+    if (params.isUseGlobalMetrics()) {\n+      sequenceIdentity = aligner.getPair().getPercentageOfIdentity(true);\n+    } else {\n+      sequenceIdentity = aligner.getPair().getPercentageOfIdentity(false);",
                "-    if (seqid < minSeqid)\n-      return false;\n+    double sequenceIdentity;\n+    if (params.isUseGlobalMetrics()) {\n+      sequenceIdentity = aligner.getPair().getPercentageOfIdentity(true);"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": []
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 50,
        "Anal": "The parameter \"filename\" of the method \"deploy\" changes from `String` to `Class<? extends Application>`.",
        "Stmts": "HttpResponse response = deploy(\"WordCount.jar\");",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-      Assert.assertEquals(200, GatewayFastTestsSuite.POST(\"/v2/apps/WordCountApp/flows/WordCountFlow/start\", null).getStatusLine().getStatusCode());\n-      Assert.assertEquals(200, GatewayFastTestsSuite.POST(\"/v2/apps/WordCountApp/flows/WordCountFlow/stop\", null).getStatusLine().getStatusCode());\n-      Assert.assertEquals(200, GatewayFastTestsSuite.POST(\"/v2/apps/WordCountApp/flows/WordCountFlow/start\", null).getStatusLine().getStatusCode());\n-      Assert.assertEquals(200, GatewayFastTestsSuite.POST(\"/v2/apps/WordCountApp/flows/WordCountFlow/stop\", null).getStatusLine().getStatusCode());\n-      Assert.assertEquals(200, GatewayFastTestsSuite.DELETE(\"/v2/apps/WordCountApp\").getStatusLine().getStatusCode());\n-      response = GatewayFastTestsSuite.GET(\"/v2/apps/WordCountApp/flows/WordCountFlow/history\");\n+      Assert.assertEquals(200, GatewayFastTestsSuite.POST(\"/v2/apps/WordCount/flows/WordCounter/start\", null).getStatusLine().getStatusCode());\n+      Assert.assertEquals(200, GatewayFastTestsSuite.POST(\"/v2/apps/WordCount/flows/WordCounter/stop\", null).getStatusLine().getStatusCode());\n+      Assert.assertEquals(200, GatewayFastTestsSuite.POST(\"/v2/apps/WordCount/flows/WordCounter/start\", null).getStatusLine().getStatusCode());\n+      Assert.assertEquals(200, GatewayFastTestsSuite.POST(\"/v2/apps/WordCount/flows/WordCounter/stop\", null).getStatusLine().getStatusCode());",
                    "-      Assert.assertEquals(200, GatewayFastTestsSuite.POST(\"/v2/apps/WordCountApp/flows/WordCountFlow/stop\", null).getStatusLine().getStatusCode());\n-      Assert.assertEquals(\"STOPPED\", getRunnableStatus(\"flows\", \"WordCountApp\", \"WordCountFlow\"));\n-      Assert.assertEquals(200, GatewayFastTestsSuite.DELETE(\"/v2/apps/WordCountApp\").getStatusLine().getStatusCode());\n-      Assert.assertEquals(404, GatewayFastTestsSuite.DELETE(\"/v2/apps/WordCountApp\").getStatusLine().getStatusCode());\n+      Assert.assertEquals(200, GatewayFastTestsSuite.POST(\"/v2/apps/WordCount/flows/WordCounter/stop\", null).getStatusLine().getStatusCode());\n+      Assert.assertEquals(\"STOPPED\", getRunnableStatus(\"flows\", \"WordCount\", \"WordCounter\"));\n+      Assert.assertEquals(200, GatewayFastTestsSuite.DELETE(\"/v2/apps/WordCount\").getStatusLine().getStatusCode());\n+      Assert.assertEquals(404, GatewayFastTestsSuite.DELETE(\"/v2/apps/WordCount\").getStatusLine().getStatusCode());",
                    "-    Assert.assertEquals(200, GatewayFastTestsSuite.DELETE(\"/v2/apps/WordCountApp\").getStatusLine().getStatusCode());\n+    Assert.assertEquals(200, GatewayFastTestsSuite.DELETE(\"/v2/apps/WordCount\").getStatusLine().getStatusCode());"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    HttpResponse response = deploy(\"WordCount.jar\");\n+    HttpResponse response = deploy(WordCount.class);",
                    "-      HttpResponse response = deploy(\"WordCount.jar\");\n+      HttpResponse response = deploy(WordCount.class);",
                    "-      response = GatewayFastTestsSuite.GET(\"/v2/apps/WordCountApp/flows/WordCountFlow\");\n+      response = GatewayFastTestsSuite.GET(\"/v2/apps/WordCount/flows/WordCounter\");"
                ]
            }
        ]
    },
    {
        "id": 51,
        "Anal": "The method name \"HypergeometricCdf\" has been changed to \"hypergeometricCdf\".",
        "Stmts": "double result = DiscreteDistributions.HypergeometricCdf(k, n, Kp, Np);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    double result = DiscreteDistributions.Hypergeometric(k, n, Kp, Np);\n-    assertEquals(expResult, result, TestConfiguration.DOUBLE_ACCURACY_HIGH);\n-  }\n+    double result = DiscreteDistributions.hypergeometric(k, n, Kp, Np);",
                "-    double result = DiscreteDistributions.Geometric(k, p);\n-    assertEquals(expResult, result, TestConfiguration.DOUBLE_ACCURACY_HIGH);\n-  }\n+    double result = DiscreteDistributions.geometric(k, p);",
                "-    double result = DiscreteDistributions.GeometricCdf(k, p);\n-    assertEquals(expResult, result, TestConfiguration.DOUBLE_ACCURACY_HIGH);\n-  }\n+    double result = DiscreteDistributions.geometricCdf(k, p);"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    double BT = Math.exp(ContinuousDistributions.LogGamma(S) - ContinuousDistributions.LogGamma(B) - ContinuousDistributions.LogGamma(A) + A * Math.log(Z) + B * Math.log(1 - Z));\n+    double BT = Math.exp(ContinuousDistributions.logGamma(S) - ContinuousDistributions.logGamma(B) - ContinuousDistributions.logGamma(A) + A * Math.log(Z) + B * Math.log(1 - Z));",
                    "-  public static double UniformCdf(int k, int n) {\n+  public static double uniformCdf(int k, int n) {",
                    "-  public static double Poisson(int k, double lamda) {\n+  public static double poisson(int k, double lamda) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    double result = DiscreteDistributions.Hypergeometric(k, n, Kp, Np);\n+    double result = DiscreteDistributions.hypergeometric(k, n, Kp, Np);",
                    "-    double result = DiscreteDistributions.BernoulliCdf(k, p);\n+    double result = DiscreteDistributions.bernoulliCdf(k, p);",
                    "-    double result = DiscreteDistributions.GeometricCdf(k, p);\n+    double result = DiscreteDistributions.geometricCdf(k, p);"
                ]
            }
        ]
    },
    {
        "id": 52,
        "Anal": "The method \"getColumns\" has been renamed to \"getXDataTypes\" and the return type has changed from `Map<Object, ColumnType>` to `Map<Object, TypeInference.DataType>`.",
        "Stmts": "Map<Object, Dataset.ColumnType> expResult = new LinkedHashMap<>();\nMap<Object, Dataset.ColumnType> result = instance.getColumns();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "   protected static void extractDummies(Dataset data, Map<Object, Object> referenceLevels) {\n-    Map<Object, Dataset.ColumnType> columnTypes = data.getColumns();\n+    Map<Object, TypeInference.DataType> columnTypes = data.getXDataTypes();",
                "+      minColumnValues.put(Dataset.yColumnName, min);\n+      maxColumnValues.put(Dataset.yColumnName, max);\n-    Dataset.ColumnType columnType = Dataset.value2ColumnType(data.get(data.iterator().next()).getY());\n-    if (columnType == Dataset.ColumnType.NUMERICAL) {\n+    if (data.getYDataType() == TypeInference.DataType.NUMERICAL) {",
                "   private static DataTable2D bivariateMatrix(Dataset dataSet, BivariateType type) {\n-    Map<Object, Dataset.ColumnType> variable2Type = dataSet.getColumns();\n-    Object[] allVariables = variable2Type.keySet().toArray();\n+    Map<Object, TypeInference.DataType> columnTypes = dataSet.getXDataTypes();\n+    Object[] allVariables = columnTypes.keySet().toArray();"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  private final Map<Object, ColumnType> columns;\n+  private TypeInference.DataType yDataType;\n+  private final Map<Object, TypeInference.DataType> xDataTypes;",
                    "-  public int size() {\n+  public int getVariableNumber() {\n+    return xDataTypes.size();\n+  }\n+  public int getRecordNumber() {",
                    "-    columns.clear();\n+    yDataType = null;\n+    xDataTypes.clear();"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    FlatDataList result = instance.extractColumnValues(column);\n+    FlatDataList result = instance.extractXColumnValues(column);",
                    "-    TransposeDataList result = instance.extractColumnValuesByY(column);\n+    TransposeDataList result = instance.extractXColumnValuesByY(column);"
                ]
            }
        ]
    },
    {
        "id": 53,
        "Anal": "The method name \"allStoredEventsSince\" changes to \"findStoredEventsSince\".",
        "Stmts": "List<StoredEvent> result = instance.allStoredEventsSince(occurredFrom);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public List<StoredEvent> allStoredEventsBetween(Date occurredFrom, Date occurredTo) {\n+  public List<StoredEvent> findStoredEventsBetween(Date occurredFrom, Date occurredTo) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-  public void testAllStoredEventsBetween() {\n-    System.out.println(\"allStoredEventsBetween\");\n+  public void testFindStoredEventsBetween() {\n+    System.out.println(\"findStoredEventsBetween\");",
                    "-    List<StoredEvent> result = instance.allStoredEventsBetween(occurredFrom, occurredTo);\n+    List<StoredEvent> result = instance.findStoredEventsBetween(occurredFrom, occurredTo);"
                ]
            }
        ]
    },
    {
        "id": 54,
        "Anal": "The parameter \"m\" of the method \"putAll\" changes from `Map<? extends K, ? extends Object>` to `Map<? extends String, ? extends Object>`.",
        "Stmts": "MultiMap<String> input = new MultiMap<String>();\ninput.put(\"food\", \"apple\");\ninput.put(\"color\", \"red\");\ninput.put(\"amount\", \"bushel\");\nmm.putAll(input);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public Set<Entry<K, Object>> entrySet() {\n+  @Override\n+  public Set<Entry<String, Object>> entrySet() {",
                    "-  public Object put(K name, Object value) {\n+  @Override\n+  public Object put(String name, Object value) {",
                    "+  @Override"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    MultiMap<String> mm = new MultiMap<String>();\n+    MultiMap mm = new MultiMap();",
                    "-    MultiMap<String> mm = new MultiMap<String>();\n-    assertMapSize(mm, 0);\n-    MultiMap<String> input = new MultiMap<String>();\n+    MultiMap mm = new MultiMap();\n+    assertMapSize(mm, 0);\n+    MultiMap input = new MultiMap();",
                    "-  private void assertValues(MultiMap<String> mm, String key, Object... expectedValues) {\n-    List<Object> values = mm.getValues(key);\n+  private void assertValues(MultiMap mm, String key, Object... expectedValues) {\n+    List<String> values = mm.getValues(key);"
                ]
            }
        ]
    },
    {
        "id": 55,
        "Anal": "The visibility of the method \"transact\" has been changed from public to package-private.",
        "Stmts": "",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public <R> R transact(Work<R> work) {\n+  <R> R transact(Work<R> work) {",
                    "-  public <R> R transactNewReadOnly(Work<R> work) {\n+  <R> R transactNewReadOnly(Work<R> work) {",
                    "-  public <R> R transactNew(Work<R> work) {\n+  <R> R transactNew(Work<R> work) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    ofy().transact(() -> ofy().save().entity(object).now());\n+    tm().transact(() -> ofy().save().entity(object).now());",
                    "-    IllegalArgumentException thrown = assertThrows(IllegalArgumentException.class, () -> ofy().transact(() -> {\n+    IllegalArgumentException thrown = assertThrows(IllegalArgumentException.class, () -> tm().transact(() -> {",
                    "-          return;\n+          return null;"
                ]
            }
        ]
    },
    {
        "id": 56,
        "Anal": "The method name \"promote\" has been changed to \"setPrimary\".",
        "Stmts": "Keyset keyset = KeysetManager.withKeysetHandle(handle).promote(newPrimaryKeyId).getKeysetHandle().getKeyset();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-        return this;\n-      }\n-    }\n-    throw new GeneralSecurityException(\"key not found: \" + keyId);\n+    return setPrimary(keyId);"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+        if (key.getStatus() != KeyStatusType.ENABLED && key.getStatus() != KeyStatusType.DISABLED && key.getStatus() != KeyStatusType.DESTROYED) {\n+          throw new GeneralSecurityException(\"cannot destroy key with id \" + keyId + \" and status \" + key.getStatus());\n+        }",
                    "+        if (key.getStatus() != KeyStatusType.ENABLED && key.getStatus() != KeyStatusType.DISABLED) {\n+          throw new GeneralSecurityException(\"cannot disable key with id \" + keyId + \" and status \" + key.getStatus());\n+        }",
                    "+        if (key.getStatus() != KeyStatusType.ENABLED && key.getStatus() != KeyStatusType.DISABLED) {\n+          throw new GeneralSecurityException(\"cannot enable key with id \" + keyId + \" and status \" + key.getStatus());\n+        }"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "+      assertThat(e.toString()).contains(\"cannot set key as primary because it's not enabled\");\n+    }\n+  }\n+  @Test\n+  public void testPromote_shouldPromote() throws Exception {\n+    int primaryKeyId = 42;\n+    int newPrimaryKeyId = 43;\n+    KeysetHandle handle = KeysetHandle.fromKeyset(TestUtil.createKeyset(createEnabledKey(primaryKeyId), createEnabledKey(newPrimaryKeyId)));\n+    Keyset keyset = KeysetManager.withKeysetHandle(handle).promote(newPrimaryKeyId).getKeysetHandle().getKeyset();\n+    assertThat(keyset.getKeyCount()).isEqualTo(2);",
                    "+    }\n+  }\n+  @Test\n+  public void testSetPrimary_keyUnknownStatus_shouldThrowException() throws Exception {\n+    int primaryKeyId = 42;\n+    int newPrimaryKeyId = 43;\n+    KeysetHandle handle = KeysetHandle.fromKeyset(TestUtil.createKeyset(createEnabledKey(primaryKeyId), createUnknownStatusKey(newPrimaryKeyId)));\n+    try {\n+      KeysetManager.withKeysetHandle(handle).setPrimary(newPrimaryKeyId);\n+      fail(\"Expected GeneralSecurityException\");",
                    "+    }\n+  }\n+  @Test\n+  public void testDestroy_keyUnknownStatus_shouldThrowException() throws Exception {\n+    int primaryKeyId = 42;\n+    int otherKeyId = 43;\n+    KeysetHandle handle = KeysetHandle.fromKeyset(TestUtil.createKeyset(createEnabledKey(primaryKeyId), createUnknownStatusKey(otherKeyId)));\n+    try {\n+      KeysetManager.withKeysetHandle(handle).destroy(otherKeyId).getKeysetHandle().getKeyset();\n+      fail(\"Expected GeneralSecurityException\");"
                ]
            }
        ]
    },
    {
        "id": 57,
        "Anal": "The return type of the method \"currentlyPreparedTxs\" changes from `Map<GridCacheVersion, WALPointer>` to `Set<GridCacheVersion>`.",
        "Stmts": "Map<GridCacheVersion, WALPointer> currentlyPreparedTxs = tracker.currentlyPreparedTxs();\nassertEquals(2, currentlyPreparedTxs.size());\nassertTrue(currentlyPreparedTxs.containsKey(nearXidVersion(1)));\nassertTrue(currentlyPreparedTxs.containsKey(nearXidVersion(3)));\n\nMap<GridCacheVersion, WALPointer> currentlyPreparedTxs = tracker.currentlyPreparedTxs();\nassertEquals(1, currentlyPreparedTxs.size());\nassertTrue(currentlyPreparedTxs.containsKey(nearXidVersion(1)));",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "       preparedOn2 = tracker.currentlyPreparedTxs();",
                "+      Set<GridCacheVersion> currentlyPreparedTxs = tracker.currentlyPreparedTxs();\n-      assertTrue(currentlyPreparedTxs.containsKey(nearXidVersion(2)));\n+      assertTrue(currentlyPreparedTxs.contains(nearXidVersion(2)));",
                "+      Set<GridCacheVersion> currentlyPreparedTxs = tracker.currentlyPreparedTxs();"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-      notCommittedInTimeoutTxs.putAll(currentlyPreparedTxs);\n-      Set<GridCacheVersion> pendingTxs = new HashSet<>(notCommittedInTimeoutTxs.keySet());\n+      notCommittedInTimeoutTxs.addAll(preparedCommittedTxsCounters.keySet());\n+      Set<GridCacheVersion> pendingTxs = new HashSet<>(notCommittedInTimeoutTxs);",
                    "-  private final ConcurrentHashMap<GridCacheVersion, WALPointer> currentlyPreparedTxs = new ConcurrentHashMap<>();\n-  private final ConcurrentHashMap<GridCacheVersion, AtomicInteger> preparedCommittedTxsCounters = new ConcurrentHashMap<>();\n-  private volatile ConcurrentHashMap<GridCacheVersion, WALPointer> trackedPreparedTxs = new ConcurrentHashMap<>();\n-  private volatile ConcurrentHashMap<GridCacheVersion, WALPointer> trackedCommittedTxs = new ConcurrentHashMap<>();\n+  private final ConcurrentHashMap<GridCacheVersion, Integer> preparedCommittedTxsCounters = new ConcurrentHashMap<>();\n+  private volatile GridConcurrentHashSet<GridCacheVersion> trackedPreparedTxs = new GridConcurrentHashSet<>();\n+  private volatile GridConcurrentHashSet<GridCacheVersion> trackedCommittedTxs = new GridConcurrentHashSet<>();",
                    "-          trackedCommittedTxs.put(nearXidVer, preparedPtr);\n+          trackedCommittedTxs.add(nearXidVer);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-      Map<GridCacheVersion, WALPointer> currentlyPreparedTxs = tracker.currentlyPreparedTxs();\n+      Set<GridCacheVersion> currentlyPreparedTxs = tracker.currentlyPreparedTxs();",
                    "-    tracker.onTxPrepared(nearXidVersion(txId), new FileWALPointer(0, txId * 10, 1));\n+    tracker.onTxPrepared(nearXidVersion(txId));",
                    "-      assertTrue(currentlyPreparedTxs.containsKey(nearXidVersion(2)));\n+      assertTrue(currentlyPreparedTxs.contains(nearXidVersion(2)));"
                ]
            }
        ]
    },
    {
        "id": 58,
        "Anal": "The return type of the method \"solve\" changes from a 2D array of doubles (`double[][]`) to `DenseMatrix`.",
        "Stmts": "double[][] x = Math.solve(A, B2);\nassertEquals(X2.length, x.length);\nassertEquals(X2[0].length, x[0].length);\nfor (int i = 0; i < X2.length; i++) {\n    for (int j = 0; j < X2[i].length; j++) {\n      assertEquals(X2[i][j], x[i][j], 1E-7);\n    }\n}",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [
            {
                "info": "Defined in class DenseMatrix (optional references)",
                "contexts": [
                    "public double[][] array();",
                    "public double get(int i, int j);",
                    "default public double apply(int i, int j);",
                    "public abstract DenseMatrix set(int i, int j, double x);",
                    "default public double[] diag();",
                    "public double det();",
                    "public double trace();"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-      qr.solve(inv);\n-    }\n-    return inv;\n+      return qr.inverse();\n+    }",
                    "-    return EigenValueDecomposition.decompose(A);\n-  }\n-  public static EigenValueDecomposition eigen(double[][] A, boolean symmetric) {\n-    return EigenValueDecomposition.decompose(A, symmetric);\n-  }\n-  public static EigenValueDecomposition eigen(double[][] A, boolean symmetric, boolean onlyValues) {\n-    return EigenValueDecomposition.decompose(A, symmetric, onlyValues);\n+    return new EigenValueDecomposition(A);\n+  }\n+  public static EigenValueDecomposition eigen(double[][] A, boolean onlyValues) {",
                    "-    return SingularValueDecomposition.decompose(x).norm();\n+    return new SingularValueDecomposition(x).norm();"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-        assertEquals(Math.abs(U[i][j]), Math.abs(result.getU()[i][j]), 1E-7);\n-      }\n-    }\n-    assertEquals(V.length, result.getV().length);\n-    assertEquals(V[0].length, result.getV()[0].length);\n+        assertEquals(Math.abs(U[i][j]), Math.abs(result.getU().get(i, j)), 1E-7);\n+      }\n+    }\n+    assertEquals(V.length, result.getV().nrows());\n+    assertEquals(V[0].length, result.getV().ncols());",
                    "-        assertEquals(Math.abs(V[i][j]), Math.abs(result.getV()[i][j]), 1E-7);\n+        assertEquals(Math.abs(V[i][j]), Math.abs(result.getV().get(i, j)), 1E-7);",
                    "-        assertEquals(Math.abs(eigenVectors[i][j]), Math.abs(result.getEigenVectors()[i][j]), 1E-7);\n+        assertEquals(Math.abs(eigenVectors[i][j]), Math.abs(result.getEigenVectors().get(i, j)), 1E-7);"
                ]
            }
        ]
    },
    {
        "id": 59,
        "Anal": "The method name \"colSum\" has been changed to \"colSums\".",
        "Stmts": "double[] result = Math.colSum(A);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public static double[] colSd(double[][] data) {\n+  public static double[] colSds(double[][] data) {",
                    "-  public static double[] rowSd(double[][] data) {\n+  public static double[] rowSds(double[][] data) {",
                    "+  public static double[][] transpose(double[][] A) {\n+    int m = A.length;\n+    int n = A[0].length;\n+    double[][] matrix = new double[n][m];\n+    for (int i = 0; i < m; i++) {\n+      for (int j = 0; j < n; j++) {\n+        matrix[j][i] = A[i][j];\n+      }\n+    }\n+    return matrix;"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    double[] result = Math.colMean(A);\n+    double[] result = Math.colMeans(A);",
                    "-    double[] result = Math.rowSum(A);\n-    for (int i = 0; i < r.length; i++) {\n-      assertEquals(result[i], r[i], 1E-7);\n-    }\n-  }\n-  @Test\n-  public void testRowMean() {\n-    System.out.println(\"rowMean\");\n+    double[] result = Math.rowSums(A);\n+    for (int i = 0; i < r.length; i++) {",
                    "+  public void testTranspose() {\n+    System.out.println(\"transpose\");\n+    double[][] A = {{0.7220180, 0.07121225, 0.6881997}, {-0.2648886, -0.89044952, 0.3700456}, {-0.6391588, 0.44947578, 0.6240573}};\n+    double[][] B = {{0.72201800, -0.2648886, -0.6391588}, {0.07121225, -0.8904495, 0.4494758}, {0.68819970, 0.3700456, 0.6240573}};\n+    assertTrue(Math.equals(Math.transpose(A), B, 1E-7));\n+  }\n+  @Test"
                ]
            }
        ]
    },
    {
        "id": 60,
        "Anal": "The return type of the method \"addAllAsync\" changes from `ICompletableFuture<Long>` to `CompletionStage<Long>`.",
        "Stmts": "long result = ringbuffer.addAllAsync(items, OVERWRITE).get();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "+    long result = ringbuffer.addAllAsync(items, OVERWRITE).toCompletableFuture().get();",
                "+        long result = ringbuffer.addAllAsync(items, FAIL).toCompletableFuture().get();",
                "     serverRingbuffer.addAllAsync(asList(\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\"), OVERWRITE);\n-    f.get();\n+    f.toCompletableFuture().get();"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public ICompletableFuture<ReadResultSet<E>> readManyAsync(long startSequence, int minCount, int maxCount, @Nullable IFunction<E, Boolean> filter) {\n+  public CompletionStage<ReadResultSet<E>> readManyAsync(long startSequence, int minCount, int maxCount, @Nullable IFunction<E, Boolean> filter) {",
                    "-  protected final <E> InternalCompletableFuture<E> invokeOnPartition(Operation operation) {\n+  protected final <E> InvocationFuture<E> invokeOnPartition(Operation operation) {",
                    "-    InternalCompletableFuture<Long> f = invokeOnPartition(op);\n-    return f.join();\n+    InvocationFuture<Long> f = invokeOnPartition(op);\n+    return f.joinInternal();"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    long result = ringbuffer.addAllAsync(items, OVERWRITE).get();\n+    long result = ringbuffer.addAllAsync(items, OVERWRITE).toCompletableFuture().get();",
                    "-    long sequence = ringbuffer.addAsync(\"item\", OVERWRITE).get();\n+    long sequence = ringbuffer.addAsync(\"item\", OVERWRITE).toCompletableFuture().get();",
                    "-      long sequence = ringbuffer.addAsync(item, OVERWRITE).get();\n+      long sequence = ringbuffer.addAsync(item, OVERWRITE).toCompletableFuture().get();"
                ]
            }
        ]
    },
    {
        "id": 61,
        "Anal": "The method \"getUntaggedName\" in the \"VersioningService\" class has been changed from a non-static method to a static method.",
        "Stmts": "VersioningService instance = new VersioningService();\nString result = instance.getUntaggedName(expression);\nresult = instance.getUntaggedName(expression);\nresult = instance.getUntaggedName(expression);\ntry {\n    result = instance.getUntaggedName(expression);\n} catch (VersioningSyntaxException e) {}",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+      if (!name.equals(untagged)) {\n+        throw new VersioningException(LOCALSTRINGS.getLocalString(\"application.noversion\", \"Application {0} has no version registered\", untagged));\n+      }",
                    "-  public final List<String> matchExpression(List<String> listVersion, String appName) throws VersioningException {\n+  public static final List<String> matchExpression(List<String> listVersion, String appName) throws VersioningException {",
                    "-  public List<String> getVersions(String untaggedName, List<ApplicationRef> allApplicationRefs) {\n+  public static final List<String> getVersions(String untaggedName, List<ApplicationRef> allApplicationRefs) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-      String result = instance.getExpression(expression);\n+      String result = VersioningService.getExpression(expression);",
                    "-  public void testGetVersions() {\n-    VersioningService instance = new VersioningService();\n+  public void testGetVersions() throws VersioningException {",
                    "-    result = instance.matchExpression(listVersion, expression);\n+    result = VersioningService.matchExpression(listVersion, expression);"
                ]
            }
        ]
    },
    {
        "id": 62,
        "Anal": "The method name \"modifyVApp\" has been changed to \"editVApp\".",
        "Stmts": "Task modifyVApp = vAppApi.modifyVApp(vApp.getHref(), newVApp);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  Task modifyProductSections(URI vAppURI, ProductSectionList sectionList);\n+  Task editProductSections(URI vAppURI, ProductSectionList sectionList);",
                    "-  Task modifyNetworkConfigSection(URI vAppURI, NetworkConfigSection section);\n+  Task editNetworkConfigSection(URI vAppURI, NetworkConfigSection section);",
                    "-  Task deleteVApp(URI vAppURI);\n-  ControlAccessParams modifyControlAccess(URI vAppURI, ControlAccessParams params);\n+  Task removeVApp(URI vAppURI);\n+  ControlAccessParams editControlAccess(URI vAppURI, ControlAccessParams params);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    Task modifyStartupSection = vAppApi.modifyStartupSection(vApp.getHref(), newSection);\n-    assertTrue(retryTaskSuccess.apply(modifyStartupSection), String.format(TASK_COMPLETE_TIMELY, \"modifyStartupSection\"));\n+    Task editStartupSection = vAppApi.editStartupSection(vApp.getHref(), newSection);\n+    assertTrue(retryTaskSuccess.apply(editStartupSection), String.format(TASK_COMPLETE_TIMELY, \"editStartupSection\"));",
                    "-    Task modifyProductSections = vAppApi.modifyProductSections(vApp.getHref(), newSections);\n-    assertTrue(retryTaskSuccess.apply(modifyProductSections), String.format(TASK_COMPLETE_TIMELY, \"modifyProductSections\"));\n+    Task editProductSections = vAppApi.editProductSections(vApp.getHref(), newSections);\n+    assertTrue(retryTaskSuccess.apply(editProductSections), String.format(TASK_COMPLETE_TIMELY, \"editProductSections\"));",
                    "-    Task modifyLeaseSettingsSection = vAppApi.modifyLeaseSettingsSection(vApp.getHref(), newSection);\n-    assertTrue(retryTaskSuccess.apply(modifyLeaseSettingsSection), String.format(TASK_COMPLETE_TIMELY, \"modifyLeaseSettingsSection\"));\n+    Task editLeaseSettingsSection = vAppApi.editLeaseSettingsSection(vApp.getHref(), newSection);\n+    assertTrue(retryTaskSuccess.apply(editLeaseSettingsSection), String.format(TASK_COMPLETE_TIMELY, \"editLeaseSettingsSection\"));"
                ]
            }
        ]
    },
    {
        "id": 63,
        "Anal": "The return type of the method \"listFlavorsInDetail\" changes from `Set<? extends Flavor>` to `PagedIterable<? extends Flavor>`.",
        "Stmts": "Set<? extends Flavor> response = api.listFlavorsInDetail();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "+      Set<? extends Flavor> response = api.listInDetail().concat().toImmutableSet();\n-        Flavor details = api.getFlavor(flavor.getId());\n+        Flavor details = api.get(flavor.getId());",
                "+  @GET @SelectJson(\"flavor\") @Consumes(MediaType.APPLICATION_JSON) @Path(\"/flavors/{id}\") @ExceptionParser(ReturnNullOnNotFoundOr404.class) ListenableFuture<? extends Flavor> get(@PathParam(\"id\") String id);",
                "+    return DEFAULT_FLAVOR_ORDERING.min(flavorApi.listInDetail().concat()).getId();"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class PagedIterable (optional references)",
                "contexts": [
                    "public FluentIterable<E> concat();"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  Set<? extends Resource> listFlavors();\n-  Flavor getFlavor(String id);\n+  PagedIterable<? extends Resource> list();\n+  PaginatedCollection<? extends Resource> list(PaginationOptions options);\n+  PaginatedCollection<? extends Flavor> listInDetail(PaginationOptions options);\n+  Flavor get(String id);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-      Set<? extends Flavor> response = api.listFlavorsInDetail();\n+      Set<? extends Flavor> response = api.listInDetail().concat().toImmutableSet();",
                    "-      Set<? extends Resource> response = api.listFlavors();\n+      Set<? extends Resource> response = api.list().concat().toImmutableSet();",
                    "-    return DEFAULT_FLAVOR_ORDERING.min(flavorApi.listFlavorsInDetail()).getId();\n+    return DEFAULT_FLAVOR_ORDERING.min(flavorApi.listInDetail().concat()).getId();"
                ]
            }
        ]
    },
    {
        "id": 64,
        "Anal": "The method \"listFlavors\" has been renamed to \"list\" and its return type has changed from `Set<? extends Resource>` to `PagedIterable<? extends Resource>`.",
        "Stmts": "",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "+      testFlavor = Iterables.getLast(flavorApi.list().concat());\n+      Map<String, String> before = api.getMetadata(testFlavor.getId());\n-      assertTrue(api.setAllExtraSpecs(testFlavor.getId(), specs));\n-      assertEquals(api.getAllExtraSpecs(testFlavor.getId()), specs);\n+      assertTrue(api.updateMetadata(testFlavor.getId(), specs));",
                "+  @GET @SelectJson(\"flavor\") @Consumes(MediaType.APPLICATION_JSON) @Path(\"/flavors/{id}\") @ExceptionParser(ReturnNullOnNotFoundOr404.class) ListenableFuture<? extends Flavor> get(@PathParam(\"id\") String id);",
                "+    assertEquals(apiWhenFlavorsExist.getFlavorApiForZone(\"az-1.region-a.geo-1\").list().concat().toString(), new ParseFlavorListTest().expected().toString());\n-    assertTrue(apiWhenNoServersExist.getFlavorApiForZone(\"az-1.region-a.geo-1\").listFlavors().isEmpty());\n+    assertTrue(apiWhenNoServersExist.getFlavorApiForZone(\"az-1.region-a.geo-1\").list().concat().isEmpty());\n-    assertEquals(apiWhenFlavorsExist.getFlavorApiForZone(\"az-1.region-a.geo-1\").getFlavor(\"52415800-8b69-11e0-9b19-734f1195ff37\").toString(), new ParseFlavorTest().expected().toString());\n+    assertEquals(apiWhenFlavorsExist.getFlavorApiForZone(\"az-1.region-a.geo-1\").get(\"52415800-8b69-11e0-9b19-734f1195ff37\").toString(), new ParseFlavorTest().expected().toString());"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class PagedIterable (optional references)",
                "contexts": [
                    "public FluentIterable<E> concat();"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  Set<? extends Flavor> listFlavorsInDetail();\n-  Flavor getFlavor(String id);\n+  PaginatedCollection<? extends Resource> list(PaginationOptions options);\n+  PagedIterable<? extends Flavor> listInDetail();\n+  PaginatedCollection<? extends Flavor> listInDetail(PaginationOptions options);\n+  Flavor get(String id);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-        Flavor details = api.getFlavor(flavor.getId());\n+        Flavor details = api.get(flavor.getId());",
                    "-    return DEFAULT_FLAVOR_ORDERING.min(flavorApi.listFlavorsInDetail()).getId();\n+    return DEFAULT_FLAVOR_ORDERING.min(flavorApi.listInDetail().concat()).getId();",
                    "-    ServerCreated server = serverApi.createServer(\"test\", imageIdForZone(zoneId), flavorRefForZone(zoneId));\n+    ServerCreated server = serverApi.create(\"test\", imageIdForZone(zoneId), flavorRefForZone(zoneId));"
                ]
            }
        ]
    },
    {
        "id": 65,
        "Anal": "The exception thrown by the method \"getChecksum\" changes from `FileNotFoundException` to `IOException`.",
        "Stmts": "} catch (FileNotFoundException ex) {\n    exceptionThrown = true;\n}",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "     byte[] b = getChecksum(\"SHA1\", file);",
                "     byte[] b = getChecksum(\"MD5\", file);"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public static String getSHA1Checksum(File file) throws FileNotFoundException, NoSuchAlgorithmException {\n+  public static String getSHA1Checksum(File file) throws IOException, NoSuchAlgorithmException {",
                    "-  public static String getMD5Checksum(File file) throws FileNotFoundException, NoSuchAlgorithmException {\n+  public static String getMD5Checksum(File file) throws IOException, NoSuchAlgorithmException {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 66,
        "Anal": "The method \"analyze\" now requires an additional parameter of type `Engine`.",
        "Stmts": "instance.analyze(result);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-                aa.analyze(d, this);\n-              } else {\n-                a.analyze(d);\n-              }\n+              a.analyze(d, this);"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class Engine (optional references)",
                "contexts": [
                    "public Engine();",
                    "public Engine(boolean autoUpdate);",
                    "public void analyzeDependencies();"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  void analyze(Dependency dependency) throws AnalysisException;\n+  void analyze(Dependency dependency, Engine engine) throws AnalysisException;"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 67,
        "Anal": "The method \"removeProperty\" changes from a static method to a non-static method.",
        "Stmts": "Settings.removeProperty(key);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    Settings.removeProperty(KEYS.SUPPRESSION_FILE);\n+    getSettings().removeProperty(KEYS.SUPPRESSION_FILE);"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  private Settings(String propertiesFilePath) {\n+  public Settings() {\n+    initialize(PROPERTIES_FILE);\n+  }\n+  public Settings(String propertiesFilePath) {\n+    initialize(propertiesFilePath);\n+  }\n+  private final void initialize(String propertiesFilePath) {",
                    "-  public static String getString(String key) {\n-    return System.getProperty(key, LOCAL_SETTINGS.get().props.getProperty(key));\n-  }\n-  public static String[] getArray(final String key) {\n+  public String getString(String key) {\n+    return System.getProperty(key, props.getProperty(key));\n+  }\n+  public String[] getArray(final String key) {",
                    "-  public static void initialize() {\n-    LOCAL_SETTINGS.set(new Settings(PROPERTIES_FILE));\n-  }\n-  public static void initialize(String propertiesFilePath) {\n-    LOCAL_SETTINGS.set(new Settings(propertiesFilePath));\n-  }\n-  public static void cleanup() {\n+  public void cleanup() {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    Settings.setArrayIfNotEmpty(\"key\", array);\n-    assertThat(\"Expected the property to not be set\", Settings.getString(\"key\"), nullValue());\n+    getSettings().setArrayIfNotEmpty(\"key\", array);\n+    assertThat(\"Expected the property to not be set\", getSettings().getString(\"key\"), nullValue());",
                    "-    Settings.setString(key, \"false\");\n+    getSettings().setString(key, \"false\");",
                    "-    result = Settings.getString(key, defaultValue);\n+    result = getSettings().getString(key, defaultValue);"
                ]
            }
        ]
    },
    {
        "id": 68,
        "Anal": "The method name \"inAbbrevJournalNames\" has been changed to \"tokenPositionsAbbrevJournalNames\".",
        "Stmts": "List<OffsetPosition> journalsPositions = target.inAbbrevJournalNames(input);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-        abbrevJournalPositions = lexicon.inAbbrevJournalNames(text);\n-        conferencePositions = lexicon.inConferenceNames(text);\n-        publisherPositions = lexicon.inPublisherNames(text);\n+        journalPositions = lexicon.tokenPositionsJournalNames(text);\n+        abbrevJournalPositions = lexicon.tokenPositionsAbbrevJournalNames(text);",
                "-      abbrevJournalsPositions = lexicon.inAbbrevJournalNames(allString);\n-      conferencesPositions = lexicon.inConferenceNames(allString);\n-      publishersPositions = lexicon.inPublisherNames(allString);\n+      journalsPositions = lexicon.tokenPositionsJournalNames(allString);\n+      abbrevJournalsPositions = lexicon.tokenPositionsAbbrevJournalNames(allString);",
                "-    List<OffsetPosition> journalsPositions = target.inAbbrevJournalNames(input);\n+    List<OffsetPosition> journalsPositions = target.tokenPositionsAbbrevJournalNames(input);"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public List<OffsetPosition> inJournalNames(String s) {\n+  public List<OffsetPosition> tokenPositionsJournalNames(String s) {",
                    "-    List<OffsetPosition> results = personTitlePattern.matcher(s);\n-    return results;\n-  }\n-  public List<OffsetPosition> inPersonTitleLayoutToken(List<LayoutToken> s) {\n+    List<OffsetPosition> results = personTitlePattern.matchLayoutToken(s);\n+    return results;\n+  }\n+  public List<OffsetPosition> tokenPositionsPersonSuffix(List<LayoutToken> s) {\n+    if (personSuffixPattern == null) {\n+      initPersonSuffix();",
                    "-    result = inDOIPatternLayoutToken(tokens, text);\n-    List<OffsetPosition> positions = inArXivPatternLayoutToken(tokens, text);\n+    result = tokenPositionsDOIPattern(tokens, text);\n+    List<OffsetPosition> positions = tokenPositionsArXivPattern(tokens, text);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    List<OffsetPosition> journalsPositions = target.inAbbrevJournalNames(input);\n+    List<OffsetPosition> journalsPositions = target.tokenPositionsAbbrevJournalNames(input);",
                    "-    List<OffsetPosition> positions = target.inAbbrevJournalNamesLayoutToken(tokens);\n+    List<OffsetPosition> positions = target.tokenPositionsAbbrevJournalNames(tokens);",
                    "-    List<OffsetPosition> journalsPositions = target.inJournalNames(input);\n+    List<OffsetPosition> journalsPositions = target.tokenPositionsJournalNames(input);"
                ]
            }
        ]
    },
    {
        "id": 69,
        "Anal": "The parameter \"tokens\" of the method \"matcher\" changes from `List<String>` to `List<LayoutToken>`.",
        "Stmts": "final List<OffsetPosition> offsetPositions = target.matcher(Arrays.asList(\"I\", \"m\", \"walking\", \"in\", \"The\", \"Bronx\"));",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    if (cityPattern == null) {\n-      initCities();\n-    }\n-    List<OffsetPosition> results = cityPattern.matcherLayoutToken(s);\n+    List<OffsetPosition> results = cityPattern.matchLayoutToken(s);",
                "-    List<OffsetPosition> results = organisationPattern.matcher(s);\n-    return results;\n-  }\n-  public List<OffsetPosition> inOrganisationNamesLayoutToken(List<LayoutToken> s) {\n+    List<OffsetPosition> results = organisationPattern.matchLayoutToken(s);",
                "-    if (publisherPattern == null) {\n-      initPublishers();\n-    }\n-    List<OffsetPosition> results = publisherPattern.matcherLayoutToken(s);\n+    List<OffsetPosition> results = publisherPattern.matchLayoutToken(s);"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class LayoutToken (optional references)",
                "contexts": [
                    "public LayoutToken();",
                    "public LayoutToken(String text);",
                    "public LayoutToken(LayoutToken token);",
                    "public void setX(double d);",
                    "public double getX();",
                    "public void setOffset(int offset);"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-        continue;\n-      }\n-      token = token.toLowerCase();\n+    for (LayoutToken token : tokens) {\n+      if (token.getText().equals(\" \")) {\n+        currentPos++;\n+        continue;\n+      }\n+      if (delimiters.indexOf(token.getText()) != -1) {\n+        currentPos++;",
                    "+      }\n+      String tokenString = token.getText().toLowerCase();",
                    "-  public List<OffsetPosition> match(String text) {\n+  public List<OffsetPosition> matchCharacter(String text) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    final List<OffsetPosition> positions = target.match(input);\n+    final List<OffsetPosition> positions = target.matchCharacter(input);",
                    "-    final List<OffsetPosition> offsetPositions = target.match(Arrays.asList(input.split(\" \")));\n+    List<LayoutToken> tokenisedInput = GrobidAnalyzer.getInstance().tokenizeWithLayoutToken(input);\n+    final List<OffsetPosition> offsetPositions = target.matchCharacterLayoutToken(tokenisedInput);",
                    "-    assertThat(offsetPositions.get(0).start, is(2));\n-    assertThat(offsetPositions.get(0).end, is(3));\n-    assertThat(offsetPositions.get(1).start, is(3));\n-    assertThat(offsetPositions.get(1).end, is(3));\n+    assertThat(offsetPositions.get(0).start, is(4));\n+    assertThat(offsetPositions.get(0).end, is(6));\n+    assertThat(offsetPositions.get(1).start, is(6));\n+    assertThat(offsetPositions.get(1).end, is(6));"
                ]
            }
        ]
    },
    {
        "id": 70,
        "Anal": "The method name \"match\" changes to \"matchCharacter\".",
        "Stmts": "final List<OffsetPosition> positions = target.match(input);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    List<OffsetPosition> results = orgFormPattern.matcher(s);\n-    return results;\n-  }\n-  public List<OffsetPosition> inOrgFormNames(List<String> s) {\n+    List<OffsetPosition> results = orgFormPattern.matchCharacter(s);",
                "-    List<OffsetPosition> results = organisationPattern.matcherLayoutToken(s);\n-    return results;\n-  }\n+    List<OffsetPosition> results = organisationPattern.matchCharacter(s);",
                "-    List<OffsetPosition> results = locationPattern.matcher(s);\n-    return results;\n-  }\n-  public List<OffsetPosition> inLocationNames(List<String> s) {\n+    List<OffsetPosition> results = locationPattern.matchCharacter(s);"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-        continue;\n-      }\n-      token = token.toLowerCase();\n+    for (LayoutToken token : tokens) {\n+      if (token.getText().equals(\" \")) {\n+        currentPos++;\n+        continue;\n+      }\n+      if (delimiters.indexOf(token.getText()) != -1) {\n+        currentPos++;",
                    "+      }\n+      String tokenString = token.getText().toLowerCase();",
                    "-  public List<OffsetPosition> match(List<String> tokens) {\n+  public List<OffsetPosition> matchCharacterLayoutToken(List<LayoutToken> tokens) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    final List<OffsetPosition> offsetPositions = target.match(Arrays.asList(input.split(\" \")));\n+    List<LayoutToken> tokenisedInput = GrobidAnalyzer.getInstance().tokenizeWithLayoutToken(input);\n+    final List<OffsetPosition> offsetPositions = target.matchCharacterLayoutToken(tokenisedInput);",
                    "-    final List<OffsetPosition> offsetPositions = target.matcher(Arrays.asList(\"I\", \"m\", \"walking\", \"in\", \"The\", \"Bronx\"));\n+    final String input = \"I'm walking in The Bronx\";\n+    List<LayoutToken> tokenisedInput = GrobidAnalyzer.getInstance().tokenizeWithLayoutToken(input);\n+    final List<OffsetPosition> offsetPositions = target.matchLayoutToken(tokenisedInput);",
                    "-    final String input = \"This is <p>\";\n-    final List<OffsetPosition> offsetPositions = target.match(Arrays.asList(input.split(\" \")));\n-    assertThat(offsetPositions, hasSize(0));\n+    assertThat(offsetPositions.get(0).start, is(8));\n+    assertThat(offsetPositions.get(0).end, is(10));\n+    assertThat(offsetPositions.get(1).start, is(10));\n+    assertThat(offsetPositions.get(1).end, is(10));"
                ]
            }
        ]
    },
    {
        "id": 71,
        "Anal": "The parameter \"tokens\" of the method \"match\" changes from `List<String>` to `List<LayoutToken>`.",
        "Stmts": "final List<OffsetPosition> offsetPositions = target.match(Arrays.asList(input.split(\" \")));",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    }\n-    List<OffsetPosition> results = locationPattern.matcherLayoutToken(s);\n-    return results;\n-  }\n+    List<OffsetPosition> results = locationPattern.matchCharacterLayoutToken(s);",
                "-    }\n-    List<OffsetPosition> results = orgFormPattern.match(s);\n-    return results;\n-  }\n+    List<OffsetPosition> results = orgFormPattern.matchCharacterLayoutToken(s);",
                "+  public List<OffsetPosition> charPositionsOrganisationNames(List<LayoutToken> s) {\n+    if (organisationPattern == null) {\n+      initOrganisations();\n+    }\n+    List<OffsetPosition> results = organisationPattern.matchCharacterLayoutToken(s);"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class LayoutToken (optional references)",
                "contexts": [
                    "public LayoutToken();",
                    "public LayoutToken(String text);",
                    "public LayoutToken(LayoutToken token);",
                    "public void setX(double d);",
                    "public double getX();",
                    "public void setOffset(int offset);"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public List<OffsetPosition> match(String text) {\n+  public List<OffsetPosition> matchCharacter(String text) {",
                    "+  }\n+  public int loadTerm(String term) {\n+    return loadTerm(term, true);",
                    "-  public List<OffsetPosition> matcher(String text) {\n+  public List<OffsetPosition> matchToken(String text) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    final List<OffsetPosition> positions = target.match(input);\n+    final List<OffsetPosition> positions = target.matchCharacter(input);",
                    "-    final List<OffsetPosition> offsetPositions = target.match(Arrays.asList(input.split(\" \")));\n+    List<LayoutToken> tokenisedInput = GrobidAnalyzer.getInstance().tokenizeWithLayoutToken(input);\n+    final List<OffsetPosition> offsetPositions = target.matchCharacterLayoutToken(tokenisedInput);",
                    "-    final List<OffsetPosition> offsetPositions = target.matcher(Arrays.asList(\"I\", \"m\", \"walking\", \"in\", \"The\", \"Bronx\"));\n+    final String input = \"I'm walking in The Bronx\";\n+    List<LayoutToken> tokenisedInput = GrobidAnalyzer.getInstance().tokenizeWithLayoutToken(input);\n+    final List<OffsetPosition> offsetPositions = target.matchLayoutToken(tokenisedInput);"
                ]
            }
        ]
    },
    {
        "id": 72,
        "Anal": "The method \"downloadFileFromServer\" has an additional parameter \"targetFileDir\" of type String.",
        "Stmts": "String valueString = fetcherMgr.downloadFileFromServer(requestUrl, RestfulMgrMock.defaultFileName);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  String downloadFileFromServer(String url, String fileName) throws Exception;\n+  String downloadFileFromServer(String url, String fileName, String copy2TargetDirPath) throws Exception;"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 73,
        "Anal": "The parameter \"image\" of the method \"setImage\" changes from `ImageFloat32` to `GrayF32`.",
        "Stmts": "ImageFloat32 image = new ImageFloat32(640, 480);\nalg.setImage(image);\nss.initialize(image);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    public ImageFloat32 derivX = new ImageFloat32(1, 1);\n-    public ImageFloat32 derivY = new ImageFloat32(1, 1);\n+    public GrayF32 derivX = new GrayF32(1, 1);\n+    public GrayF32 derivY = new GrayF32(1, 1);",
                    "-  ImageGradient<ImageFloat32, ImageFloat32> gradient = FactoryDerivative.three_F32();\n+  ImageGradient<GrayF32, GrayF32> gradient = FactoryDerivative.three_F32();"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    alg.setImage(new ImageFloat32(640, 480));\n+    alg.setImage(new GrayF32(640, 480));"
                ]
            }
        ]
    },
    {
        "id": 74,
        "Anal": "The method name \"fit\" has been changed to \"prune\".",
        "Stmts": "alg.fit(contours, corners, output);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+    if (indexA == indexB) {\n+      return 100000.0;\n+    }",
                    "-    int length = circularDistance(indexA, indexB);\n-    for (int k = 1; k < length; k++) {\n-      Point2D_I32 c = getContour(indexA + k);\n+    int length = circularDistance(indexA, indexB) - 1;\n+    int numSamples = Math.min(length, maxPointSamples);\n+    if (length > 1) {\n+      for (int k = 0; k < numSamples; k++) {\n+        int offset = k * (numSamples - 1) / (length - 1);\n+        Point2D_I32 c = getContour(indexA + 1 + offset);\n+        point.set(c.x, c.y);",
                    "+  int maxPointSamples = 20;"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    alg.fit(contours, corners, output);\n+    alg.prune(contours, corners, output);",
                    "+  }\n+  @Test\n+  public void removeDuplicates() {\n+    List<Point2D_I32> contours = createSquare(10, 12, 20, 30);\n+    GrowQueue_I32 corners = createSquareCorners(10, 12, 20, 30);\n+    corners.add(corners.get(0));\n+    corners.add(corners.get(2));\n+    MinimizeEnergyPrune alg = new MinimizeEnergyPrune(4);\n+    alg.contour = contours;\n+    alg.removeDuplicates(corners);",
                    "+    corners.removeTail();\n+    corners.insert(3, corners.get(2) + 3);\n+    alg.computeSegmentEnergy(corners);\n+    found = alg.energyRemoveCorner(3, corners);\n+    assertEquals(expected, found, 1e-8);\n+    corners = createSquareCorners(10, 12, 20, 30);"
                ]
            }
        ]
    },
    {
        "id": 75,
        "Anal": "The method \"computeCostInnerD\" has an additional parameter \"workCostLr\" of type short array.",
        "Stmts": "alg.computeCostInnerD(costXD, idxCost, idxWork, rangeD);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+      this.x0 = x0;\n+      this.y0 = y0;\n+      this.dx = dx;\n+      this.dy = dy;\n+    }\n+  }",
                    "-    saveWorkToAggregated(x0, y0, dx, dy, lengthPath);\n-  }\n-  void saveWorkToAggregated(int x0, int y0, int dx, int dy, int length) {\n+    saveWorkToAggregated(x0, y0, dx, dy, lengthPath, workCostLr);\n+  }\n+  void saveWorkToAggregated(int x0, int y0, int dx, int dy, int length, short[] workCostLr) {",
                    "+      for (int i = minInclusive; i < maxExclusive; i++) {\n+        Trajectory t = trajectories.get(i);\n+        scorePath(t.x0, t.y0, t.dx, t.dy, workspace.workCostLr);\n+      }\n+    }\n+  }\n+  void scorePath(int x0, int y0, int dx, int dy, short[] workCostLr) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    return alg.workCostLr[alg.lengthD * pathIdx + d] & 0xFFFF;\n+    short[] workCostLr = alg.workspace.get(0).workCostLr;\n+    return workCostLr[alg.lengthD * pathIdx + d] & 0xFFFF;",
                    "-    alg.scorePath(0, 0, 1, 1);\n+    alg.scorePath(0, 0, 1, 1, null);",
                    "-    void scorePath(int x0, int y0, int dx, int dy) {\n+    void scorePath(int x0, int y0, int dx, int dy, short[] work) {"
                ]
            }
        ]
    },
    {
        "id": 76,
        "Anal": "The method \"gaussian\" has an additional parameter \"sigma\" of type double added between \"orderY\" and \"radius\".",
        "Stmts": "SteerableKernel<Kernel2D_F32> alg = FactorySteerable.gaussian(Kernel2D_F32.class, orderX, orderY, 10);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-        SteerableKernel<Kernel2D_F32> algValidate = FactorySteerable.gaussian(Kernel2D_F32.class, orderX, orderY, 10);\n+        SteerableKernel<Kernel2D_F32> algValidate = FactorySteerable.gaussian(Kernel2D_F32.class, orderX, orderY, -1, 10);"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": []
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-        SteerableKernel<Kernel2D_F32> algValidate = FactorySteerable.gaussian(Kernel2D_F32.class, orderX, orderY, 10);\n+        SteerableKernel<Kernel2D_F32> algValidate = FactorySteerable.gaussian(Kernel2D_F32.class, orderX, orderY, -1, 10);"
                ]
            }
        ]
    },
    {
        "id": 77,
        "Anal": "The method \"fullView\" has been renamed to \"transform_F32\" and a new parameter \"type\" of type `AdjustmentType` has been added as the first parameter.",
        "Stmts": "PointTransform_F32 adjToDist = LensDistortionOps.fullView(param, null, true);\nPointTransform_F32 distToAdj = LensDistortionOps.fullView(param, null, false);\nadjToDist = LensDistortionOps.fullView(param, null, true);\ndistToAdj = LensDistortionOps.fullView(param, null, false);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-      undistToDist = fullView(param, paramAdj, true);\n+      undistToDist = transform_F32(type, param, paramAdj, true);",
                    "-  }\n-  private static PointTransform_F32 adjustmentTransform(IntrinsicParameters param, IntrinsicParameters paramAdj, boolean adjToDistorted, PointTransform_F32 remove_p_to_p, DenseMatrix64F A) {\n+  private static PointTransform_F32 adjustmentTransform_F32(IntrinsicParameters param, IntrinsicParameters paramAdj, boolean adjToDistorted, PointTransform_F32 remove_p_to_p, DenseMatrix64F A) {",
                    "+    }\n+  }\n+  private static PointTransform_F64 adjustmentTransform_F64(IntrinsicParameters param, IntrinsicParameters paramAdj, boolean adjToDistorted, PointTransform_F64 remove_p_to_p, DenseMatrix64F A) {\n+    DenseMatrix64F A_inv = null;\n+    if (!adjToDistorted || paramAdj != null) {\n+      A_inv = new DenseMatrix64F(3, 3);\n+      if (!CommonOps.invert(A, A_inv)) {\n+        throw new RuntimeException(\"Failed to invert adjustment matrix.  Probably bad.\");\n+      }\n+    }"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    PointTransform_F32 adjToDist = LensDistortionOps.allInside(param, null, true);\n-    PointTransform_F32 distToAdj = LensDistortionOps.allInside(param, null, false);\n+    PointTransform_F32 adjToDist = LensDistortionOps.transform_F32(AdjustmentType.SHRINK, param, null, true);\n+    PointTransform_F32 distToAdj = LensDistortionOps.transform_F32(AdjustmentType.SHRINK, param, null, false);",
                    "-    PointTransform_F32 distToAdj = LensDistortionOps.fullView(orig, adjusted, false);\n+    PointTransform_F32 distToAdj = LensDistortionOps.transform_F32(AdjustmentType.FULL_VIEW, orig, adjusted, false);",
                    "-    adjToDist = LensDistortionOps.allInside(param, null, true);\n-    distToAdj = LensDistortionOps.allInside(param, null, false);\n+    adjToDist = LensDistortionOps.transform_F32(AdjustmentType.SHRINK, param, null, true);\n+    distToAdj = LensDistortionOps.transform_F32(AdjustmentType.SHRINK, param, null, false);"
                ]
            }
        ]
    },
    {
        "id": 78,
        "Anal": "The method \"allInside\" has been renamed to \"transform_F32\" and a new parameter \"type\" of type `AdjustmentType` has been added as the first parameter.",
        "Stmts": "PointTransform_F32 adjToDist = LensDistortionOps.allInside(param, null, true);\nPointTransform_F32 distToAdj = LensDistortionOps.allInside(param, null, false);\nadjToDist = LensDistortionOps.allInside(param, null, true);\ndistToAdj = LensDistortionOps.allInside(param, null, false);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-      undistToDist = fullView(param, paramAdj, true);\n+      undistToDist = transform_F32(type, param, paramAdj, true);",
                    "+    }\n+  }\n+  private static PointTransform_F64 adjustmentTransform_F64(IntrinsicParameters param, IntrinsicParameters paramAdj, boolean adjToDistorted, PointTransform_F64 remove_p_to_p, DenseMatrix64F A) {\n+    DenseMatrix64F A_inv = null;\n+    if (!adjToDistorted || paramAdj != null) {\n+      A_inv = new DenseMatrix64F(3, 3);\n+      if (!CommonOps.invert(A, A_inv)) {\n+        throw new RuntimeException(\"Failed to invert adjustment matrix.  Probably bad.\");\n+      }\n+    }",
                    "-    case ALL_INSIDE:\n-      undistToDist = allInside(param, paramAdj, true);\n-      break;\n+    case SHRINK:"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    PointTransform_F32 adjToDist = LensDistortionOps.fullView(param, null, true);\n-    PointTransform_F32 distToAdj = LensDistortionOps.fullView(param, null, false);\n+    PointTransform_F32 adjToDist = LensDistortionOps.transform_F32(AdjustmentType.FULL_VIEW, param, null, true);\n+    PointTransform_F32 distToAdj = LensDistortionOps.transform_F32(AdjustmentType.FULL_VIEW, param, null, false);",
                    "-    adjToDist = LensDistortionOps.fullView(param, null, true);\n-    distToAdj = LensDistortionOps.fullView(param, null, false);\n+    adjToDist = LensDistortionOps.transform_F32(AdjustmentType.FULL_VIEW, param, null, true);\n+    distToAdj = LensDistortionOps.transform_F32(AdjustmentType.FULL_VIEW, param, null, false);",
                    "-    PointTransform_F32 distToAdj = LensDistortionOps.allInside(orig, adjusted, false);\n+    PointTransform_F32 distToAdj = LensDistortionOps.transform_F32(AdjustmentType.SHRINK, orig, adjusted, false);"
                ]
            }
        ]
    },
    {
        "id": 79,
        "Anal": "The parameters \"integral\" and \"intensity\" of the method \"hessian\" change from `ImageFloat32` to `GrayF32`.",
        "Stmts": "ImageFloat32 integral = new ImageFloat32(width, height);\nImageFloat32 found = new ImageFloat32(width, height);\nImageFloat32 expected = new ImageFloat32(width, height);\nIntegralImageFeatureIntensity.hessian(integral, skip, size, found);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public static void hessian(ImageSInt32 integral, int skip, int size, ImageFloat32 intensity) {\n+  public static void hessian(GrayS32 integral, int skip, int size, GrayF32 intensity) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    ImageSInt32 original = new ImageSInt32(width, height);\n-    ImageSInt32 integral = new ImageSInt32(width, height);\n-    ImageFloat32 found = new ImageFloat32(width, height);\n-    ImageFloat32 expected = new ImageFloat32(width, height);\n+    GrayS32 original = new GrayS32(width, height);\n+    GrayS32 integral = new GrayS32(width, height);\n+    GrayF32 found = new GrayF32(width, height);\n+    GrayF32 expected = new GrayF32(width, height);"
                ]
            }
        ]
    },
    {
        "id": 80,
        "Anal": "The method name \"findErrorLocatorBM\" has been changed to \"findErrorLocatorPolynomialBM\".",
        "Stmts": "alg.findErrorLocatorBM(syndromes, nsyn, errorLocator);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+  }",
                    "-    findErrorLocatorBM(syndromes.data, syndromes.size, errorLocatorPoly);\n+    findErrorLocatorPolynomialBM(syndromes.data, syndromes.size, errorLocatorPoly);",
                    "-  public void correctErrors(GrowQueue_I8 message, int syndromes[], GrowQueue_I32 locations) {}\n+  public void correctErrors(GrowQueue_I8 message, GrowQueue_I8 ecc, GrowQueue_I8 errorLocator, GrowQueue_I32 errorLocations) {\n+    GrowQueue_I32 coefLocations = new GrowQueue_I32(errorLocations.size);\n+    for (int i = 0; i < errorLocations.size; i++) {\n+      coefLocations.data[message.size - i - 1] = errorLocations.get(i);\n+    }\n+  }\n+  void findErrorEvaluator(int syndromes[], int syndromeLength, GrowQueue_I8 errorLocator) {}"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    alg.findErrorLocatorBM(syndromes, nsyn, errorLocator);\n+    alg.findErrorLocatorPolynomialBM(syndromes, nsyn, errorLocator);",
                    "+  public void findErrorLocatorPolynomialBM_compareToDirect() {\n+    GrowQueue_I8 found = new GrowQueue_I8();\n+    GrowQueue_I8 expected = new GrowQueue_I8();\n+    for (int i = 0; i < 30; i++) {\n+      int N = 50;\n+      GrowQueue_I8 message = randomMessage(N);\n+      GrowQueue_I8 ecc = new GrowQueue_I8();\n+      int nsyn = 10;\n+      int syndromes[] = new int[nsyn];\n+      ReidSolomonCodes alg = new ReidSolomonCodes(8, primitive8);",
                    "+      alg.computeECC(message, ecc);\n+      int where = rand.nextInt(N);\n+      message.data[where] ^= 0x12;\n+      alg.computeSyndromes(message, ecc, syndromes);\n+      GrowQueue_I32 whereList = new GrowQueue_I32(1);\n+      whereList.add(where);\n+      alg.findErrorLocatorPolynomialBM(syndromes, nsyn, found);\n+      alg.findErrorLocatorPolynomial(N + ecc.size, whereList, expected);\n+      assertEquals(found.size, expected.size);\n+      for (int j = 0; j < found.size; j++) {"
                ]
            }
        ]
    },
    {
        "id": 81,
        "Anal": "The generic type parameter \"T\" of the method \"scaleSpace\" changes from `ImageSingleBand` to `ImageGray`.",
        "Stmts": "PyramidFloat<ImageFloat32> pyramid = FactoryPyramid.scaleSpacePyramid(ss, ImageFloat32.class);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public static <T extends ImageSingleBand> PyramidFloat<T> floatGaussian(double scaleFactors[], double[] sigmas, Class<T> imageType) {\n+  public static <T extends ImageGray> PyramidFloat<T> floatGaussian(double scaleFactors[], double[] sigmas, Class<T> imageType) {",
                    "-  public static <T extends ImageSingleBand> PyramidFloat<T> scaleSpacePyramid(double scaleSpace[], Class<T> imageType) {\n+  public static <T extends ImageGray> PyramidFloat<T> scaleSpacePyramid(double scaleSpace[], Class<T> imageType) {",
                    "-  public static <T extends ImageSingleBand> PyramidDiscrete<T> discreteGaussian(int[] scaleFactors, double sigma, int radius, boolean saveOriginalReference, Class<T> imageType) {\n+  public static <T extends ImageGray> PyramidDiscrete<T> discreteGaussian(int[] scaleFactors, double sigma, int radius, boolean saveOriginalReference, Class<T> imageType) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 82,
        "Anal": "The exception thrown by the method \"copy\" changes from `IOException, StoreException` to a more general `Exception`.",
        "Stmts": "storeCopier.copy(new StoreFindTokenFactory(STORE_KEY_FACTORY).getNewFindToken());",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    Message transform(Message message);\n+    Message transform(Message message) throws Exception;"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 83,
        "Anal": "The method \"replenishConnections\" has an additional parameter \"maxNewConnectionsPerHost\" of type int.",
        "Stmts": "connectionTracker.replenishConnections(this::mockNewConnection);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": []
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 84,
        "Anal": "The method name \"getMuleHomeFile\" has been changed to \"getMuleHome\".",
        "Stmts": "File muleHome = MuleContainerBootstrapUtils.getMuleHomeFile();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-  public static File getMuleAppsFile() {\n-    return isStandalone() ? new File(getMuleHomeFile(), MULE_APPS_FILENAME) : null;\n+  public static File getMuleAppsDir() {\n+    return isStandalone() ? new File(getMuleHome(), MULE_APPS_FILENAME) : null;",
                "-      File domainDir = new File(MuleContainerBootstrapUtils.getMuleHomeFile(), \"lib/shared/\" + domain);\n+      File domainDir = new File(MuleContainerBootstrapUtils.getMuleHome(), \"lib/shared/\" + domain);"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public static File getMuleAppsFile() {\n-    return isStandalone() ? new File(getMuleHomeFile(), MULE_APPS_FILENAME) : null;\n+  public static File getMuleAppsDir() {\n+    return isStandalone() ? new File(getMuleHome(), MULE_APPS_FILENAME) : null;"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    File muleApps = MuleContainerBootstrapUtils.getMuleAppsFile();\n+    File muleApps = MuleContainerBootstrapUtils.getMuleAppsDir();"
                ]
            }
        ]
    },
    {
        "id": 85,
        "Anal": "The method \"saveOrUpdateUserDetail\" has been renamed to \"saveUser\" and the fourth parameter \"followersStr\" has been removed.",
        "Stmts": "userController.saveOrUpdateUserDetail(currUser, model, currUser, null);\nuserController.saveOrUpdateUserDetail(admin, model, temp, null);\nuserController.saveOrUpdateUserDetail(admin, model, temp, null);\nuserController.saveOrUpdateUserDetail(currUser, model, currUser, \"temp1, temp2\");",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    userController.saveOrUpdateUserDetail(getAdminUser(), model, newUser, null);\n+    userController.saveUser(getAdminUser(), model, newUser);",
                "-    userController.saveOrUpdateUserDetail(currUser, model, updatedUser, null);\n+    userController.saveUser(currUser, model, updatedUser);"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+  }\n+  private User saveUser(User user) {\n+    if (StringUtils.isBlank(user.getPassword())) {\n+      return userService.saveUserWithoutPasswordEncoding(user);\n+    } else {\n+      return userService.saveUser(user);\n+    }",
                    "-  public String getUserList(ModelMap model, @RequestParam(required = false) String roleName, @PageableDefaults(pageNumber = 0, value = 10) Pageable pageable, @RequestParam(required = false) String keywords) {\n+  public String getUsers(ModelMap model, @RequestParam(required = false) Role role, @PageableDefaults(pageNumber = 0, value = 10) Pageable pageable, @RequestParam(required = false) String keywords) {",
                    "-  @RequestMapping(value = \"/api/\", method = RequestMethod.POST)\n+  @RequestMapping(value = {\"/api/\", \"/api\"}, method = RequestMethod.POST)"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    userController.saveOrUpdateUserDetail(currUser, model, updatedUser, null);\n+    userController.saveUser(currUser, model, updatedUser);",
                    "-    userController.saveOrUpdateUserDetail(getAdminUser(), model, newUser, null);\n+    userController.saveUser(getAdminUser(), model, newUser);",
                    "-    userController.getUserList(model, null, page, \"user\");\n+    userController.getUsers(model, null, page, \"user\");"
                ]
            }
        ]
    },
    {
        "id": 86,
        "Anal": "The method name \"put\" changes to \"putBoolean\".",
        "Stmts": "buffer.put(true);\nbuffer.put(false);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-      buffer.put(true);\n-      buffer.putSVar(exceptionId);\n+      buffer.putBoolean(true);",
                "-      buffer.put(true);\n-      buffer.putSVar(span.getExceptionId());\n+      buffer.putBoolean(true);",
                "-      buffer.put(true);\n-      buffer.putSVar(spanEventBo.getExceptionId());\n+      buffer.putBoolean(true);"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-      put((byte)0);\n+      putByte((byte)0);",
                    "-      put((short)bytes.length);\n-      put(bytes);\n+      putShort((short)bytes.length);\n+      putBytes(bytes);",
                    "-      putSVar(NULL);\n-    } else {\n-      putSVar(bytes.length);\n-      put(bytes);\n+      putSVInt(NULL);\n+    } else {\n+      putSVInt(bytes.length);\n+      putBytes(bytes);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    buffer.put(1);\n-    buffer.put(2);\n+    buffer.putInt(1);\n+    buffer.putInt(2);",
                    "-    buffer.put(1);\n+    buffer.putInt(1);",
                    "-    buffer.put(expected);\n+    buffer.putInt(expected);"
                ]
            }
        ]
    },
    {
        "id": 87,
        "Anal": "The method \"cloneForDiscontinuing\" now throws `IllegalAccessException` and `InstantiationException`.",
        "Stmts": "Order orderThatCanDiscontinueTheOrder = anOrder.cloneForDiscontinuing();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "     Order orderThatCanDiscontinueTheOrder = anOrder.cloneForDiscontinuing();",
                "     Order newOrder = orderToDiscontinue.cloneForDiscontinuing();",
                "-  public void cloneForDiscontinuing_shouldSetThisCareSettingToNewOrder() {\n+  public void cloneForDiscontinuing_shouldSetThisCareSettingToNewOrder() throws Exception {\n+  @Test\n+  public void cloneForDiscontinuing_shouldReturnAnInstanceOfTheSameType() throws Exception {\n+    Order order = new TestOrder();"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": []
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-  public void cloneForDiscontinuing_shouldSetActionToDiscontinueOnNewOrder() {\n+  public void cloneForDiscontinuing_shouldSetActionToDiscontinueOnNewOrder() throws Exception {",
                    "-  public void cloneForDiscontinuing_shouldSetPreviousOrderOnNewOrder() {\n+  public void cloneForDiscontinuing_shouldSetPreviousOrderOnNewOrder() throws Exception {",
                    "+  @Test\n+  public void cloneForDiscontinuing_shouldReturnAnInstanceOfTheSameType() throws Exception {\n+    Order order = new TestOrder();\n+    assertEquals(order.getClass(), order.cloneForDiscontinuing().getClass());\n+  }"
                ]
            }
        ]
    },
    {
        "id": 88,
        "Anal": "An additional parameter \"pluginConfig\" of type `YangPluginConfig` has been added to the method \"getConstructor\".",
        "Stmts": "String method = getConstructor(CLASS_NAME, testAttr, GENERATE_SERVICE_AND_MANAGER);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-  private void addConstructor(JavaAttributeInfo attr) throws IOException {\n-    appendToFile(getConstructorImplTempFileHandle(), getConstructor(getGeneratedJavaClassName(), attr, getGeneratedJavaFiles()));\n+  private void addConstructor(JavaAttributeInfo attr, YangPluginConfig pluginConfig) throws IOException {\n+    appendToFile(getConstructorImplTempFileHandle(), getConstructor(getGeneratedJavaClassName(), attr, getGeneratedJavaFiles(), pluginConfig));",
                "+import org.onosproject.yangutils.translator.tojava.utils.YangPluginConfig;\n import static org.onosproject.yangutils.translator.tojava.utils.MethodsGenerator.getConstructor;"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class YangPluginConfig (optional references)",
                "contexts": [
                    "public YangPluginConfig();",
                    "public String getCodeGenDir();",
                    "public void setConflictResolver(YangToJavaNamingConflictUtil conflictResolver);"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    if (!outputName.equals(VOID)) {\n-      outputName = getCapitalCase(outputName);\n-    }\n-    String method = getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + outputName + SPACE + rpcName + OPEN_PARENTHESIS + inputName + SPACE + RPC_INPUT_VAR_NAME + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + YANG_UTILS_TODO + NEW_LINE;\n+  public static String getRpcServiceMethod(String rpcName, String inputName, String outputName, YangPluginConfig pluginConfig) {\n+    rpcName = getCamelCase(rpcName, pluginConfig.getConflictResolver());\n+    if (!inputName.equals(EMPTY_STRING)) {\n+      inputName = inputName + SPACE + RPC_INPUT_VAR_NAME;\n+    }\n+    return FOUR_SPACE_INDENTATION + outputName + SPACE + rpcName + OPEN_PARENTHESIS + inputName + CLOSE_PARENTHESIS + SEMI_COLAN;",
                    "-      method += EIGHT_SPACE_INDENTATION + RETURN + SPACE + NULL + SEMI_COLAN + NEW_LINE;\n+      method += EIGHT_SPACE_INDENTATION + RETURN + SPACE + parseTypeForReturnValue(outputName) + SEMI_COLAN + NEW_LINE;",
                    "-    return getJavaDoc(type, attributeName, attr.isListAttr()) + getSetterForInterface(attributeName, attrType, className, attr.isListAttr(), generatedJavaFiles);\n-  }\n-  public static String getConstructorString(String name) {\n-    return getJavaDoc(CONSTRUCTOR, name, false);\n-  }\n-  public static String getDefaultConstructorString(String name, String modifierType) {\n-    return getJavaDoc(DEFAULT_CONSTRUCTOR, name, false) + getDefaultConstructor(name, modifierType) + NEW_LINE;\n+    return getJavaDoc(type, attributeName, attr.isListAttr(), pluginConfig) + getSetterForInterface(attributeName, attrType, className, attr.isListAttr(), generatedJavaFiles);\n+  }\n+  public static String getConstructorString(String name, YangPluginConfig pluginConfig) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    String method = getConstructorStart(CLASS_NAME);\n+    YangPluginConfig pluginConfig = new YangPluginConfig();\n+    String method = getConstructorStart(CLASS_NAME, pluginConfig);",
                    "-    String test = getTypeConstructorStringAndJavaDoc(testAttr, CLASS_NAME);\n+    String test = getTypeConstructorStringAndJavaDoc(testAttr, CLASS_NAME, pluginConfig);",
                    "+    assertThat(true, is(method.contains(PUBLIC + SPACE + VOID + SPACE + SET_METHOD_PREFIX + getCapitalCase(CLASS_NAME) + OPEN_PARENTHESIS + STRING_DATA_TYPE + SPACE + ATTRIBUTE_NAME)));"
                ]
            }
        ]
    },
    {
        "id": 89,
        "Anal": "The return type of the method \"getTunnelInfos\" changes from `Map<TunnelId, PceccTunnelInfo>` to `Map<TunnelId, ResourceConsumer>`.",
        "Stmts": "Map<TunnelId, PceccTunnelInfo> tunnelInfoMap = distrPceStore.getTunnelInfos();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [
            {
                "info": "Defined in class ResourceConsumer (optional references)",
                "contexts": [
                    "ResourceConsumerId consumerId();"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    globalNodeLabelMap = storageService.<DeviceId, LabelResourceId>consistentMapBuilder().withName(\"onos-pce-globalnodelabelmap\").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(LabelResourceId.class).build())).build();\n-    adjLabelMap = storageService.<Link, LabelResourceId>consistentMapBuilder().withName(\"onos-pce-adjlabelmap\").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(Link.class, LabelResource.class, LabelResourceId.class).build())).build();\n-    tunnelInfoMap = storageService.<TunnelId, PceccTunnelInfo>consistentMapBuilder().withName(\"onos-pce-tunnelinfomap\").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(TunnelId.class, PceccTunnelInfo.class, DefaultLspLocalLabelInfo.class, TunnelConsumerId.class, LabelResourceId.class).build())).build();\n+    tunnelInfoMap = storageService.<TunnelId, ResourceConsumer>consistentMapBuilder().withName(\"onos-pce-tunnelinfomap\").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(TunnelId.class, TunnelConsumerId.class).build())).build();",
                    "-  LabelResourceId getGlobalNodeLabel(DeviceId id);\n-  LabelResourceId getAdjLabel(Link link);\n-  PceccTunnelInfo getTunnelInfo(TunnelId tunnelId);\n-  void addGlobalNodeLabel(DeviceId deviceId, LabelResourceId labelId);\n-  void addAdjLabel(Link link, LabelResourceId labelId);\n-  void addTunnelInfo(TunnelId tunnelId, PceccTunnelInfo pceccTunnelInfo);\n+  ResourceConsumer getTunnelInfo(TunnelId tunnelId);\n+  void addTunnelInfo(TunnelId tunnelId, ResourceConsumer tunnelConsumerId);",
                    "-  Map<DeviceId, LabelResourceId> getGlobalNodeLabels();\n-  Map<Link, LabelResourceId> getAdjLabels();\n-  Map<TunnelId, PceccTunnelInfo> getTunnelInfos();\n+  Map<TunnelId, ResourceConsumer> getTunnelInfos();"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    assertThat(distrPceStore.getTunnelInfo(tunnelId1), is(pceccTunnelInfo1));\n-    distrPceStore.addTunnelInfo(tunnelId2, pceccTunnelInfo2);\n+    assertThat(distrPceStore.getTunnelInfo(tunnelId1), is(tunnelConsumerId1));\n+    distrPceStore.addTunnelInfo(tunnelId2, tunnelConsumerId2);",
                    "-    assertThat(distrPceStore.getTunnelInfo(tunnelId1), is(pceccTunnelInfo1));\n+    assertThat(distrPceStore.getTunnelInfo(tunnelId1), is(tunnelConsumerId1));",
                    "-    distrPceStore.addTunnelInfo(tunnelId1, pceccTunnelInfo1);\n+    distrPceStore.addTunnelInfo(tunnelId1, tunnelConsumerId1);"
                ]
            }
        ]
    },
    {
        "id": 90,
        "Anal": "The return type of the method \"getTunnelInfo\" changes from `PceccTunnelInfo` to `ResourceConsumer`.",
        "Stmts": "assertThat(distrPceStore.getTunnelInfo(tunnelId1), is(pceccTunnelInfo1));\nassertThat(distrPceStore.getTunnelInfo(tunnelId2), is(pceccTunnelInfo2));",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "+    assertThat(distrPceStore.getTunnelInfo(tunnelId1), is(tunnelConsumerId1));\n+    distrPceStore.addTunnelInfo(tunnelId2, tunnelConsumerId2);\n-    assertThat(distrPceStore.getTunnelInfo(tunnelId2), is(pceccTunnelInfo2));\n+    assertThat(distrPceStore.getTunnelInfo(tunnelId2), is(tunnelConsumerId2));",
                "+    resourceService.release(pceStore.getTunnelInfo(oldTunnel.tunnelId()));\n-    PceccTunnelInfo tunnelInfo = pceStore.getTunnelInfo(newTunnel.tunnelId());\n-    if (tunnelInfo == null || tunnelInfo.tunnelConsumerId() == null) {\n+    ResourceConsumer consumer = pceStore.getTunnelInfo(newTunnel.tunnelId());\n+    if (consumer == null) {",
                "+    assertThat(distrPceStore.getTunnelInfo(tunnelId2), is(tunnelConsumerId2));"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class ResourceConsumer (optional references)",
                "contexts": [
                    "ResourceConsumerId consumerId();"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    globalNodeLabelMap = storageService.<DeviceId, LabelResourceId>consistentMapBuilder().withName(\"onos-pce-globalnodelabelmap\").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(LabelResourceId.class).build())).build();\n-    adjLabelMap = storageService.<Link, LabelResourceId>consistentMapBuilder().withName(\"onos-pce-adjlabelmap\").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(Link.class, LabelResource.class, LabelResourceId.class).build())).build();\n-    tunnelInfoMap = storageService.<TunnelId, PceccTunnelInfo>consistentMapBuilder().withName(\"onos-pce-tunnelinfomap\").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(TunnelId.class, PceccTunnelInfo.class, DefaultLspLocalLabelInfo.class, TunnelConsumerId.class, LabelResourceId.class).build())).build();\n+    tunnelInfoMap = storageService.<TunnelId, ResourceConsumer>consistentMapBuilder().withName(\"onos-pce-tunnelinfomap\").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(TunnelId.class, TunnelConsumerId.class).build())).build();",
                    "-  LabelResourceId getGlobalNodeLabel(DeviceId id);\n-  LabelResourceId getAdjLabel(Link link);\n-  PceccTunnelInfo getTunnelInfo(TunnelId tunnelId);\n-  void addGlobalNodeLabel(DeviceId deviceId, LabelResourceId labelId);\n-  void addAdjLabel(Link link, LabelResourceId labelId);\n-  void addTunnelInfo(TunnelId tunnelId, PceccTunnelInfo pceccTunnelInfo);\n+  ResourceConsumer getTunnelInfo(TunnelId tunnelId);\n+  void addTunnelInfo(TunnelId tunnelId, ResourceConsumer tunnelConsumerId);",
                    "-  Map<DeviceId, LabelResourceId> getGlobalNodeLabels();\n-  Map<Link, LabelResourceId> getAdjLabels();\n-  Map<TunnelId, PceccTunnelInfo> getTunnelInfos();\n+  Map<TunnelId, ResourceConsumer> getTunnelInfos();"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    assertThat(distrPceStore.getTunnelInfo(tunnelId1), is(pceccTunnelInfo1));\n-    distrPceStore.addTunnelInfo(tunnelId2, pceccTunnelInfo2);\n+    assertThat(distrPceStore.getTunnelInfo(tunnelId1), is(tunnelConsumerId1));\n+    distrPceStore.addTunnelInfo(tunnelId2, tunnelConsumerId2);",
                    "-    distrPceStore.addTunnelInfo(tunnelId1, pceccTunnelInfo1);\n+    distrPceStore.addTunnelInfo(tunnelId1, tunnelConsumerId1);",
                    "-    Map<TunnelId, PceccTunnelInfo> tunnelInfoMap = distrPceStore.getTunnelInfos();\n+    Map<TunnelId, ResourceConsumer> tunnelInfoMap = distrPceStore.getTunnelInfos();"
                ]
            }
        ]
    },
    {
        "id": 91,
        "Anal": "The second parameter \"pceccTunnelInfo\" of the method \"addTunnelInfo\" changes from `PceccTunnelInfo` to `ResourceConsumer`.",
        "Stmts": "distrPceStore.addTunnelInfo(tunnelId1, pceccTunnelInfo1);\ndistrPceStore.addTunnelInfo(tunnelId2, pceccTunnelInfo2);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-          reserveBandwidth(tunnel.path(), bwConstraintValue, null);\n+          TunnelConsumerId consumerId = reserveBandwidth(tunnel.path(), bwConstraintValue, null);\n+          if (consumerId != null) {\n+            pceStore.addTunnelInfo(tunnel.tunnelId(), consumerId);",
                "-      PceccTunnelInfo pceccTunnelInfo = new PceccTunnelInfo(null, consumerId);\n-      pceStore.addTunnelInfo(tunnelId, pceccTunnelInfo);\n+      pceStore.addTunnelInfo(tunnelId, consumerId);",
                "-      Tunnel tunnelForlabelDownload = new DefaultTunnel(null, tunnel.src(), tunnel.dst(), MPLS, INIT, null, updatedTunnelId, tunnel.tunnelName(), computedPath, labelStack, annotationBuilder.build());\n-      if (!crHandler.allocateLabel(tunnelForlabelDownload)) {\n-        log.error(\"Unable to allocate labels for the tunnel {}.\", tunnel.toString());\n-      }\n+      pceStore.addTunnelInfo(updatedTunnelId, consumerId);"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class ResourceConsumer (optional references)",
                "contexts": [
                    "ResourceConsumerId consumerId();"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    globalNodeLabelMap = storageService.<DeviceId, LabelResourceId>consistentMapBuilder().withName(\"onos-pce-globalnodelabelmap\").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(LabelResourceId.class).build())).build();\n-    adjLabelMap = storageService.<Link, LabelResourceId>consistentMapBuilder().withName(\"onos-pce-adjlabelmap\").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(Link.class, LabelResource.class, LabelResourceId.class).build())).build();\n-    tunnelInfoMap = storageService.<TunnelId, PceccTunnelInfo>consistentMapBuilder().withName(\"onos-pce-tunnelinfomap\").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(TunnelId.class, PceccTunnelInfo.class, DefaultLspLocalLabelInfo.class, TunnelConsumerId.class, LabelResourceId.class).build())).build();\n+    tunnelInfoMap = storageService.<TunnelId, ResourceConsumer>consistentMapBuilder().withName(\"onos-pce-tunnelinfomap\").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(TunnelId.class, TunnelConsumerId.class).build())).build();",
                    "-  LabelResourceId getGlobalNodeLabel(DeviceId id);\n-  LabelResourceId getAdjLabel(Link link);\n-  PceccTunnelInfo getTunnelInfo(TunnelId tunnelId);\n-  void addGlobalNodeLabel(DeviceId deviceId, LabelResourceId labelId);\n-  void addAdjLabel(Link link, LabelResourceId labelId);\n-  void addTunnelInfo(TunnelId tunnelId, PceccTunnelInfo pceccTunnelInfo);\n+  ResourceConsumer getTunnelInfo(TunnelId tunnelId);\n+  void addTunnelInfo(TunnelId tunnelId, ResourceConsumer tunnelConsumerId);",
                    "-  Map<DeviceId, LabelResourceId> getGlobalNodeLabels();\n-  Map<Link, LabelResourceId> getAdjLabels();\n-  Map<TunnelId, PceccTunnelInfo> getTunnelInfos();\n+  Map<TunnelId, ResourceConsumer> getTunnelInfos();"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    Map<TunnelId, PceccTunnelInfo> tunnelInfoMap = distrPceStore.getTunnelInfos();\n+    Map<TunnelId, ResourceConsumer> tunnelInfoMap = distrPceStore.getTunnelInfos();",
                    "-    assertThat(distrPceStore.getTunnelInfo(tunnelId1), is(pceccTunnelInfo1));\n+    assertThat(distrPceStore.getTunnelInfo(tunnelId1), is(tunnelConsumerId1));",
                    "-  private PceccTunnelInfo pceccTunnelInfo1;\n-  private PceccTunnelInfo pceccTunnelInfo2;\n+  private ResourceConsumer tunnelConsumerId1 = TunnelConsumerId.valueOf(10);\n+  private ResourceConsumer tunnelConsumerId2 = TunnelConsumerId.valueOf(20);"
                ]
            }
        ]
    },
    {
        "id": 92,
        "Anal": "The parameters of the method \"buildNdpSolicit\" have changed from byte arrays to `Ip6Address` for targetIp, sourceIp, destinationIp and `MacAddress` for sourceMac, destinationMac.",
        "Stmts": "Ethernet ethPacket = NeighborSolicitation.buildNdpSolicit(TARGET_IP.toOctets(), SRC_IP.toOctets(), DST_IP.toOctets(), SRC_MAC.toBytes(), DST_MAC.toBytes(), VLAN_ID);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    Ethernet ethPacket = NeighborSolicitation.buildNdpSolicit(TARGET_IP.toOctets(), Ip6Address.ZERO.toOctets(), DST_IP.toOctets(), SRC_MAC.toBytes(), DST_MAC.toBytes(), VLAN_ID);\n+    Ethernet ethPacket = NeighborSolicitation.buildNdpSolicit(TARGET_IP, Ip6Address.ZERO, DST_IP, SRC_MAC, DST_MAC, VLAN_ID);"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class Ip6Address (optional references)",
                "contexts": [
                    "public static final Ip6Address ZERO = Ip6Address.valueOf(\"::\");",
                    "public static Ip6Address valueOf(byte[] value);",
                    "public static Ip6Address valueOf(byte[] value, int offset);",
                    "public static Ip6Address valueOf(InetAddress inetAddress);",
                    "public static Ip6Address valueOf(String value);",
                    "public static Ip6Address makeMaskPrefix(int prefixLength);",
                    "public static Ip6Address makeMaskedAddress(final Ip6Address address, int prefixLength);",
                    "protected IpAddress();",
                    "protected IpAddress(Version version, byte[] value);",
                    "public static IpAddress valueOf(String value);",
                    "public Version version();",
                    "public boolean isIp6();",
                    "public static final int BIT_LENGTH = IpAddress.INET6_BIT_LENGTH;"
                ]
            },
            {
                "info": "Defined in class MacAddress (optional references)",
                "contexts": [
                    "public MacAddress(final byte[] address);",
                    "public static MacAddress valueOf(final byte[] address);",
                    "public static final MacAddress ONOS = valueOf(\"a4:23:05:00:00:00\");",
                    "public static final MacAddress ONOS_LLDP = valueOf(\"a5:23:05:00:00:01\");",
                    "public static final MacAddress IPV4_MULTICAST = valueOf(\"01:00:5e:00:00:00\");",
                    "public static final MacAddress NONE = ONOS;",
                    "public static final Set<MacAddress> LLDP = ImmutableSet.of( MacAddress.valueOf(\"01:80:c2:00:00:00\"), MacAddress.valueOf(\"01:80:c2:00:00:03\"), MacAddress.valueOf(\"01:80:c2:00:00:0e\"));",
                    "public static final int MAC_ADDRESS_LENGTH = 6;",
                    "@Deprecated public boolean isLinkLocal();",
                    "public byte[] oui();",
                    "public boolean isOnos();"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+  @Deprecated\n+  public static Ethernet buildNdpSolicit(byte[] targetIp, byte[] sourceIp, byte[] destinationIp, byte[] sourceMac, byte[] destinationMac, VlanId vlan) {\n+    if (targetIp.length != Ip6Address.BYTE_LENGTH || sourceIp.length != Ip6Address.BYTE_LENGTH || destinationIp.length != Ip6Address.BYTE_LENGTH || sourceMac.length != MacAddress.MAC_ADDRESS_LENGTH || destinationMac.length != MacAddress.MAC_ADDRESS_LENGTH) {\n+      return null;\n+    }\n+    Ethernet ethernet = new Ethernet();\n+    ethernet.setEtherType(Ethernet.TYPE_IPV6).setDestinationMACAddress(destinationMac).setSourceMACAddress(sourceMac);\n+    ethernet.setVlanID(vlan.id());\n+    IPv6 ipv6 = new IPv6();\n+    ipv6.setSourceAddress(sourceIp);",
                    "+  protected static final byte NDP_HOP_LIMIT = (byte)0x255;\n+  protected static final byte RESERVED_CODE = (byte)0x0;",
                    "+    ipv6.setHopLimit((byte)255);\n+    ICMP6 icmp6 = new ICMP6();\n+    icmp6.setIcmpType(ICMP6.NEIGHBOR_SOLICITATION);\n+    icmp6.setIcmpCode((byte)0);\n+    NeighborSolicitation ns = new NeighborSolicitation();\n+    ns.setTargetAddress(targetIp);\n+    if (!Arrays.equals(sourceIp, Ip6Address.ZERO.toOctets())) {\n+      ns.addOption(NeighborDiscoveryOptions.TYPE_SOURCE_LL_ADDRESS, sourceMac);\n+    }\n+    icmp6.setPayload(ns);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    Ethernet ethPacket = NeighborSolicitation.buildNdpSolicit(TARGET_IP.toOctets(), Ip6Address.ZERO.toOctets(), DST_IP.toOctets(), SRC_MAC.toBytes(), DST_MAC.toBytes(), VLAN_ID);\n+    Ethernet ethPacket = NeighborSolicitation.buildNdpSolicit(TARGET_IP, Ip6Address.ZERO, DST_IP, SRC_MAC, DST_MAC, VLAN_ID);"
                ]
            }
        ]
    },
    {
        "id": 93,
        "Anal": "The parameters of the method \"buildNdpSolicit\" have changed from byte arrays to specific types: `Ip6Address` for targetIp, sourceIp, and destinationIp, and `MacAddress` for sourceMac and destinationMac.",
        "Stmts": "Ethernet ethPacket = NeighborSolicitation.buildNdpSolicit(TARGET_IP.toOctets(), Ip6Address.ZERO.toOctets(), DST_IP.toOctets(), SRC_MAC.toBytes(), DST_MAC.toBytes(), VLAN_ID);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    Ethernet ethPacket = NeighborSolicitation.buildNdpSolicit(TARGET_IP.toOctets(), SRC_IP.toOctets(), DST_IP.toOctets(), SRC_MAC.toBytes(), DST_MAC.toBytes(), VLAN_ID);\n-    IPv6 ipPacket = (IPv6)ethPacket.getPayload();\n-    ICMP6 icmp6Packet = (ICMP6)ipPacket.getPayload();\n-    NeighborSolicitation nsPacket = (NeighborSolicitation)icmp6Packet.getPayload();\n+    final Ethernet ethPacket = NeighborSolicitation.buildNdpSolicit(TARGET_IP, SRC_IP, DST_IP, SRC_MAC, DST_MAC, VLAN_ID);"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class Ip6Address (optional references)",
                "contexts": [
                    "public static final Ip6Address ZERO = Ip6Address.valueOf(\"::\");",
                    "public static Ip6Address valueOf(byte[] value);",
                    "public static Ip6Address valueOf(byte[] value, int offset);",
                    "public static Ip6Address valueOf(InetAddress inetAddress);",
                    "public static Ip6Address valueOf(String value);",
                    "public static Ip6Address makeMaskPrefix(int prefixLength);",
                    "public static Ip6Address makeMaskedAddress(final Ip6Address address, int prefixLength);",
                    "public Version version();",
                    "protected IpAddress();",
                    "protected IpAddress(Version version, byte[] value);",
                    "public boolean isIp6();",
                    "public static final int BIT_LENGTH = IpAddress.INET6_BIT_LENGTH;",
                    "public static IpAddress valueOf(String value);"
                ]
            },
            {
                "info": "Defined in class MacAddress (optional references)",
                "contexts": [
                    "public MacAddress(final byte[] address);",
                    "public static MacAddress valueOf(final byte[] address);",
                    "public static final MacAddress ONOS = valueOf(\"a4:23:05:00:00:00\");",
                    "public static final MacAddress NONE = ONOS;",
                    "public static final MacAddress IPV4_MULTICAST = valueOf(\"01:00:5e:00:00:00\");",
                    "public static final MacAddress ONOS_LLDP = valueOf(\"a5:23:05:00:00:01\");",
                    "public static final Set<MacAddress> LLDP = ImmutableSet.of( MacAddress.valueOf(\"01:80:c2:00:00:00\"), MacAddress.valueOf(\"01:80:c2:00:00:03\"), MacAddress.valueOf(\"01:80:c2:00:00:0e\"));",
                    "public static final int MAC_ADDRESS_LENGTH = 6;",
                    "public boolean isOnos();",
                    "public byte[] oui();",
                    "@Deprecated public boolean isLinkLocal();"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+  @Deprecated\n+  public static Ethernet buildNdpSolicit(byte[] targetIp, byte[] sourceIp, byte[] destinationIp, byte[] sourceMac, byte[] destinationMac, VlanId vlan) {\n+    if (targetIp.length != Ip6Address.BYTE_LENGTH || sourceIp.length != Ip6Address.BYTE_LENGTH || destinationIp.length != Ip6Address.BYTE_LENGTH || sourceMac.length != MacAddress.MAC_ADDRESS_LENGTH || destinationMac.length != MacAddress.MAC_ADDRESS_LENGTH) {\n+      return null;\n+    }\n+    Ethernet ethernet = new Ethernet();\n+    ethernet.setEtherType(Ethernet.TYPE_IPV6).setDestinationMACAddress(destinationMac).setSourceMACAddress(sourceMac);\n+    ethernet.setVlanID(vlan.id());\n+    IPv6 ipv6 = new IPv6();\n+    ipv6.setSourceAddress(sourceIp);",
                    "+  protected static final byte NDP_HOP_LIMIT = (byte)0x255;\n+  protected static final byte RESERVED_CODE = (byte)0x0;",
                    "+    ipv6.setHopLimit((byte)255);\n+    ICMP6 icmp6 = new ICMP6();\n+    icmp6.setIcmpType(ICMP6.NEIGHBOR_SOLICITATION);\n+    icmp6.setIcmpCode((byte)0);\n+    NeighborSolicitation ns = new NeighborSolicitation();\n+    ns.setTargetAddress(targetIp);\n+    if (!Arrays.equals(sourceIp, Ip6Address.ZERO.toOctets())) {\n+      ns.addOption(NeighborDiscoveryOptions.TYPE_SOURCE_LL_ADDRESS, sourceMac);\n+    }\n+    icmp6.setPayload(ns);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    Ethernet ethPacket = NeighborSolicitation.buildNdpSolicit(TARGET_IP.toOctets(), SRC_IP.toOctets(), DST_IP.toOctets(), SRC_MAC.toBytes(), DST_MAC.toBytes(), VLAN_ID);\n-    IPv6 ipPacket = (IPv6)ethPacket.getPayload();\n-    ICMP6 icmp6Packet = (ICMP6)ipPacket.getPayload();\n-    NeighborSolicitation nsPacket = (NeighborSolicitation)icmp6Packet.getPayload();\n+    final Ethernet ethPacket = NeighborSolicitation.buildNdpSolicit(TARGET_IP, SRC_IP, DST_IP, SRC_MAC, DST_MAC, VLAN_ID);\n+    assertTrue(ethPacket.getDestinationMAC().equals(DST_MAC));\n+    assertTrue(ethPacket.getSourceMAC().equals(SRC_MAC));\n+    assertTrue(ethPacket.getEtherType() == Ethernet.TYPE_IPV6);\n+    assertTrue(ethPacket.getVlanID() == VLAN_ID.id());\n+    final IPv6 ipPacket = (IPv6)ethPacket.getPayload();",
                    "+    assertArrayEquals(ipPacket.getDestinationAddress(), DST_IP.toOctets());\n+    final ICMP6 icmp6Packet = (ICMP6)ipPacket.getPayload();\n+    final NeighborSolicitation nsPacket = (NeighborSolicitation)icmp6Packet.getPayload();\n+    assertArrayEquals(nsPacket.getTargetAddress(), TARGET_IP.toOctets());"
                ]
            }
        ]
    },
    {
        "id": 94,
        "Anal": "The third parameter \"revision\" of the method \"getRootPackage\" changes from `String` to `Date`.",
        "Stmts": "String rootPackage = getRootPackage((byte)1, CHILD_PACKAGE, DATE1, conflictResolver);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    String rootPackage = getRootPackage((byte)1, INVALID_NAME_SPACE1, DATE1, conflictResolver);\n+    Date date = simpleDateFormat.parse(DATE1);\n+    String rootPackage = getRootPackage((byte)1, INVALID_NAME_SPACE1, date, conflictResolver);\n-    String rootPackage1 = getRootPackage((byte)1, INVALID_NAME_SPACE2, DATE1, conflictResolver);\n+    String rootPackage1 = getRootPackage((byte)1, INVALID_NAME_SPACE2, date, conflictResolver);",
                "+    String rootPackage = getRootPackage((byte)1, INVALID_NAME_SPACE1, date, conflictResolver);\n-    String rootPackage1 = getRootPackage((byte)1, INVALID_NAME_SPACE2, DATE1, conflictResolver);\n+    String rootPackage1 = getRootPackage((byte)1, INVALID_NAME_SPACE2, date, conflictResolver);\n-    String rootPackage2 = getRootPackage((byte)1, INVALID_NAME_SPACE3, DATE1, conflictResolver);\n+    String rootPackage2 = getRootPackage((byte)1, INVALID_NAME_SPACE3, date, conflictResolver);",
                "+    String rootPackage1 = getRootPackage((byte)1, INVALID_NAME_SPACE2, date, conflictResolver);\n-    String rootPackage2 = getRootPackage((byte)1, INVALID_NAME_SPACE3, DATE1, conflictResolver);\n+    String rootPackage2 = getRootPackage((byte)1, INVALID_NAME_SPACE3, date, conflictResolver);\n-    String rootPackage3 = getRootPackage((byte)1, INVALID_NAME_SPACE2, DATE1, conflictResolver);\n+    String rootPackage3 = getRootPackage((byte)1, INVALID_NAME_SPACE2, date, conflictResolver);"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+    return rev;",
                    "-      return rev;\n-    } else {\n-      throw new TranslatorException(\"Date in revision is not proper: \" + date);\n+      rev = rev + val;",
                    "-    if (Integer.parseInt(revisionArr[INDEX_ONE]) <= MAX_MONTHS && Integer.parseInt(revisionArr[INDEX_TWO]) <= MAX_DAYS) {\n-      for (int i = INDEX_ONE; i < revisionArr.length; i++) {\n-        Integer val = Integer.parseInt(revisionArr[i]);\n-        if (val < VALUE_CHECK) {\n-          rev = rev + ZERO;\n-        }\n-        rev = rev + val;\n+    for (int i = INDEX_ONE; i < revisionArr.length; i++) {\n+      Integer val = Integer.parseInt(revisionArr[i]);\n+      if (val < VALUE_CHECK) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    String rootPackage1 = getRootPackage((byte)1, INVALID_NAME_SPACE_FOR_INVALID_PREFIX, DATE1, conflictResolver);\n+    Date date = simpleDateFormat.parse(DATE1);\n+    String rootPackage1 = getRootPackage((byte)1, INVALID_NAME_SPACE_FOR_INVALID_PREFIX, date, conflictResolver);",
                    "-    String rootPackage = getRootPackage((byte)1, INVALID_NAME_SPACE1, DATE1, conflictResolver);\n+    Date date = simpleDateFormat.parse(DATE1);\n+    String rootPackage = getRootPackage((byte)1, INVALID_NAME_SPACE1, date, conflictResolver);",
                    "-    String rootPackage1 = getRootPackage((byte)1, INVALID_NAME_SPACE2, DATE1, conflictResolver);\n+    String rootPackage1 = getRootPackage((byte)1, INVALID_NAME_SPACE2, date, conflictResolver);"
                ]
            }
        ]
    },
    {
        "id": 95,
        "Anal": "The third parameter \"revision\" of the method \"getRootPackage\" changes from `String` to `Date`.",
        "Stmts": "String rootPkgWithRev = getRootPackage((byte)1, CHILD_PACKAGE, DATE2, null);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "+    String rootPackage1 = getRootPackage((byte)1, INVALID_NAME_SPACE2, date, conflictResolver);\n-    String rootPackage2 = getRootPackage((byte)1, INVALID_NAME_SPACE3, DATE1, conflictResolver);\n+    String rootPackage2 = getRootPackage((byte)1, INVALID_NAME_SPACE3, date, conflictResolver);\n-    String rootPackage3 = getRootPackage((byte)1, INVALID_NAME_SPACE2, DATE1, conflictResolver);\n+    String rootPackage3 = getRootPackage((byte)1, INVALID_NAME_SPACE2, date, conflictResolver);",
                "+    String rootPackage = getRootPackage((byte)1, INVALID_NAME_SPACE1, date, conflictResolver);\n-    String rootPackage1 = getRootPackage((byte)1, INVALID_NAME_SPACE2, DATE1, conflictResolver);\n+    String rootPackage1 = getRootPackage((byte)1, INVALID_NAME_SPACE2, date, conflictResolver);\n-    String rootPackage2 = getRootPackage((byte)1, INVALID_NAME_SPACE3, DATE1, conflictResolver);\n+    String rootPackage2 = getRootPackage((byte)1, INVALID_NAME_SPACE3, date, conflictResolver);",
                "-    String rootPackage = getRootPackage((byte)1, INVALID_NAME_SPACE1, DATE1, conflictResolver);\n+    Date date = simpleDateFormat.parse(DATE1);\n+    String rootPackage = getRootPackage((byte)1, INVALID_NAME_SPACE1, date, conflictResolver);\n-    String rootPackage1 = getRootPackage((byte)1, INVALID_NAME_SPACE2, DATE1, conflictResolver);\n+    String rootPackage1 = getRootPackage((byte)1, INVALID_NAME_SPACE2, date, conflictResolver);"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+    return rev;",
                    "-      return rev;\n-    } else {\n-      throw new TranslatorException(\"Date in revision is not proper: \" + date);\n+      rev = rev + val;",
                    "-    if (Integer.parseInt(revisionArr[INDEX_ONE]) <= MAX_MONTHS && Integer.parseInt(revisionArr[INDEX_TWO]) <= MAX_DAYS) {\n-      for (int i = INDEX_ONE; i < revisionArr.length; i++) {\n-        Integer val = Integer.parseInt(revisionArr[i]);\n-        if (val < VALUE_CHECK) {\n-          rev = rev + ZERO;\n-        }\n-        rev = rev + val;\n+    for (int i = INDEX_ONE; i < revisionArr.length; i++) {\n+      Integer val = Integer.parseInt(revisionArr[i]);\n+      if (val < VALUE_CHECK) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    String rootPackage = getRootPackage((byte)1, CHILD_PACKAGE, DATE1, conflictResolver);\n+    Date date = simpleDateFormat.parse(DATE1);\n+    String rootPackage = getRootPackage((byte)1, CHILD_PACKAGE, date, conflictResolver);",
                    "-    String rootPackage1 = getRootPackage((byte)1, INVALID_NAME_SPACE2, DATE1, conflictResolver);\n+    String rootPackage1 = getRootPackage((byte)1, INVALID_NAME_SPACE2, date, conflictResolver);",
                    "-    String rootPackage = getRootPackage((byte)1, INVALID_NAME_SPACE1, DATE1, conflictResolver);\n+    Date date = simpleDateFormat.parse(DATE1);\n+    String rootPackage = getRootPackage((byte)1, INVALID_NAME_SPACE1, date, conflictResolver);"
                ]
            }
        ]
    },
    {
        "id": 96,
        "Anal": "An additional parameter \"pluginConfig\" of type `YangPluginConfig` has been added to the method \"addPackageInfo\".",
        "Stmts": "addPackageInfo(dirPath, CHECK1, CREATE_PATH, false);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    addPackageInfo(dirPath, CHECK1, CREATE_PATH, false);\n+    addPackageInfo(dirPath, CHECK1, CREATE_PATH, false, getStubPluginConfig());",
                "-    addPackageInfo(dirPath, CHECK1, PATH + CREATE_PATH, false);\n+    addPackageInfo(dirPath, CHECK1, PATH + CREATE_PATH, false, getStubPluginConfig());",
                "-          addPackageInfo(pack, pkgInfo, getJavaPackageFromPackagePath(pkg), true);\n+          addPackageInfo(pack, pkgInfo, getJavaPackageFromPackagePath(pkg), true, ((JavaFileInfoContainer)parent).getJavaFileInfo().getPluginConfig());\n-          addPackageInfo(pack, pkgInfo, getJavaPackageFromPackagePath(pkg), false);\n+          addPackageInfo(pack, pkgInfo, getJavaPackageFromPackagePath(pkg), false, ((JavaFileInfoContainer)yangNode).getJavaFileInfo().getPluginConfig());"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class YangPluginConfig (optional references)",
                "contexts": [
                    "public YangPluginConfig();",
                    "public void setCodeGenDir(String codeGenDir);",
                    "public void setConflictResolver(YangToJavaNamingConflictUtil conflictResolver);"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+    for (String str : strArray) {\n+      tempBuilder.append(str + string);\n+      if (tempBuilder.length() > lineSize) {\n+        String tempString = stringBuilder.toString();\n+        stringBuilder.delete(ZERO, stringBuilder.length());\n+        tempString = trimAtLast(tempString, string);\n+        stringBuilder.append(tempString);\n+        if (string.equals(PERIOD)) {\n+          stringBuilder.append(NEW_LINE + TWELVE_SPACE_INDENTATION + PERIOD + str + string);\n+        } else {",
                    "+    if (line.length() > lineSize) {\n+      String[] strArray = line.split(SPACE);\n+      stringBuilder = updateString(strArray, stringBuilder, SPACE, lineSize);\n+    } else {\n+      stringBuilder.append(line + NEW_LINE);\n+    }\n+    String[] strArray = stringBuilder.toString().split(NEW_LINE);\n+    StringBuilder tempBuilder = new StringBuilder();\n+    for (String str : strArray) {\n+      if (str.length() > SUB_LINE_SIZE) {",
                    "+      stringBuilder = updateString(strArray, stringBuilder, PERIOD, lineSize);\n+    } else {\n+      stringBuilder.append(line + NEW_LINE);\n+    }\n+    String[] strArray = stringBuilder.toString().split(NEW_LINE);\n+    StringBuilder tempBuilder = new StringBuilder();\n+    for (String str : strArray) {\n+      if (str.length() > SUB_LINE_SIZE) {\n+        if (line.contains(PERIOD) && !line.contains(PERIOD + HASH + OPEN_PARENTHESIS)) {\n+          String[] strArr = str.split(Pattern.quote(PERIOD));"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    addPackageInfo(dirPath, CHECK1, PATH + CREATE_PATH, false);\n+    addPackageInfo(dirPath, CHECK1, PATH + CREATE_PATH, false, getStubPluginConfig());",
                    "-    addPackageInfo(dirPath, CHECK1, CREATE_PATH, false);\n+    addPackageInfo(dirPath, CHECK1, CREATE_PATH, false, getStubPluginConfig());",
                    "-    addPackageInfo(dirPath, CHECK1, PATH + CREATE_PATH, true);\n+    addPackageInfo(dirPath, CHECK1, PATH + CREATE_PATH, true, getStubPluginConfig());"
                ]
            }
        ]
    },
    {
        "id": 97,
        "Anal": "An additional boolean parameter \"isChildNode\" has been added to the method \"addPackageInfo\".",
        "Stmts": "addPackageInfo(dirPath, \"check1\", CREATE_PATH);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    thrown.expectMessage(\"Exception occured while creating package info file.\");\n-    addPackageInfo(dirPath, \"check1\", CREATE_PATH);\n-    File filePath1 = new File(dirPath + File.separator + \"package-info.java\");\n+    thrown.expectMessage(MSG);\n+    addPackageInfo(dirPath, CHECK1, CREATE_PATH, false);",
                "-    addPackageInfo(dirPath, \"check1\", \"src/main/yangmodel/\" + CREATE_PATH);\n-    File filePath = new File(dirPath + File.separator + \"package-info.java\");\n+    addPackageInfo(dirPath, CHECK1, PATH + CREATE_PATH, false);",
                "+  @Test\n+  public void addPackageInfoWithChildNode() throws IOException {\n+    File dirPath = new File(CREATE_PATH);\n+    dirPath.mkdirs();\n+    addPackageInfo(dirPath, CHECK1, PATH + CREATE_PATH, true);"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+    }\n+  }\n+  public static void searchAndDeleteTempDir(String root) throws IOException {\n+    List<File> store = new LinkedList<>();\n+    Stack<String> stack = new Stack<>();\n+    stack.push(root);\n+    while (!stack.empty()) {\n+      root = stack.pop();\n+      File file = new File(root);\n+      File[] filelist = file.listFiles();",
                    "+        continue;\n+      }\n+      for (File current : filelist) {\n+        if (current.isDirectory()) {\n+          stack.push(current.toString());\n+          if (current.getName().endsWith(\"-Temp\")) {\n+            store.add(current);\n+          }\n+        }\n+      }",
                    "+    for (File dir : store) {\n+      dir.delete();"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    addPackageInfo(dirPath, \"check1\", \"src/main/yangmodel/\" + CREATE_PATH);\n-    File filePath = new File(dirPath + File.separator + \"package-info.java\");\n+    addPackageInfo(dirPath, CHECK1, PATH + CREATE_PATH, false);\n+    File filePath = new File(dirPath + File.separator + PKG_INFO);\n+    assertThat(filePath.isFile(), is(true));\n+  }\n+  @Test\n+  public void addPackageInfoWithChildNode() throws IOException {\n+    File dirPath = new File(CREATE_PATH);\n+    dirPath.mkdirs();",
                    "-    thrown.expectMessage(\"Exception occured while creating package info file.\");\n-    addPackageInfo(dirPath, \"check1\", CREATE_PATH);\n-    File filePath1 = new File(dirPath + File.separator + \"package-info.java\");\n+    thrown.expectMessage(MSG);\n+    addPackageInfo(dirPath, CHECK1, CREATE_PATH, false);\n+    File filePath1 = new File(dirPath + File.separator + PKG_INFO);",
                    "+  private static final String CHECK1 = \"check1\";\n+  private static final String PKG_INFO = \"package-info.java\";\n+  private static final String PATH = \"src/main/yangmodel/\";\n+  private static final String MSG = \"Exception occured while creating package info file.\";"
                ]
            }
        ]
    },
    {
        "id": 98,
        "Anal": "The method \"setExcludePorts\" has been replaced by the method \"setSuppressHost\", with the parameter type changing from `Set<String>` to `Set<ConnectPoint>`.",
        "Stmts": "config.setExcludePorts(builder.build());\nSet<String> excludePorts = config.excludePorts();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [
            {
                "info": "Defined in class ConnectPoint (optional references)",
                "contexts": [
                    "public ConnectPoint(ElementId elementId, PortNumber portNumber);",
                    "public static ConnectPoint deviceConnectPoint(String string);",
                    "public static ConnectPoint hostConnectPoint(String string);",
                    "public PortNumber port();",
                    "public HostId hostId();",
                    "public IpElementId ipElementId();"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    return toStringHelper(this).add(\"vRouterMacs\", vRouterMacs()).add(\"excludePorts\", excludePorts()).toString();\n+    return toStringHelper(this).add(\"vRouterMacs\", vRouterMacs()).add(\"vRouterId\", vRouterId()).add(\"suppressSubnet\", suppressSubnet()).add(\"suppressHost\", suppressHost()).toString();",
                    "-  private static final String EXCLUDE_PORTS = \"excludePorts\";\n+  private static final String SUPPRESS_SUBNET = \"suppressSubnet\";\n+  private static final String SUPPRESS_HOST = \"suppressHost\";",
                    "-    return hasOnlyFields(VROUTER_MACS, VROUTER_ID, EXCLUDE_PORTS) && vRouterMacs() != null && vRouterId() != null && excludePorts() != null;\n+    return hasOnlyFields(VROUTER_MACS, VROUTER_ID, SUPPRESS_SUBNET, SUPPRESS_HOST) && vRouterMacs() != null && vRouterId() != null && suppressSubnet() != null && suppressHost() != null;"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-                                            + \"\\\"excludePorts\\\" : [\"\n-                                            + \"    \\\"port1\\\",\"\n-                                            + \"    \\\"port2\\\"\"\n+                                            + \"\\\"suppressSubnet\\\" : [\"\n+                                            + \"    \\\"of:1/1\\\",\"\n+                                            + \"    \\\"of:1/2\\\"\"\n+                                            + \"],\"\n+                                            + \"\\\"suppressHost\\\" : [\"\n+                                            + \"    \\\"of:1/1\\\",\"\n+                                            + \"    \\\"of:1/2\\\"\"",
                    "-                                                    + \"\\\"excludePorts\\\" : [\"\n-                                                    + \"    \\\"port1\\\",\"\n-                                                    + \"    \\\"port2\\\"\"\n+                                                    + \"\\\"suppressSubnet\\\" : [\"\n+                                                    + \"    \\\"of:1/1\\\",\"\n+                                                    + \"    \\\"wrongport\\\"\"",
                    "-  public void testExcludePorts() throws Exception {\n-    Set<String> excludePorts = config.excludePorts();\n-    assertThat(excludePorts.size(), is(2));\n-    assertTrue(excludePorts.contains(PORT_NAME_1));\n-    assertTrue(excludePorts.contains(PORT_NAME_2));\n+  public void testSuppressSubnet() throws Exception {\n+    Set<ConnectPoint> suppressSubnet = config.suppressSubnet();\n+    assertNotNull(\"suppressSubnet should not be null\", suppressSubnet);\n+    assertThat(suppressSubnet.size(), is(2));\n+    assertTrue(suppressSubnet.contains(PORT_1));"
                ]
            }
        ]
    },
    {
        "id": 99,
        "Anal": "The parameter \"selected\" of the method \"setSelectedDatabaseConnection\" changes from `String` to `DatabaseItem`.",
        "Stmts": "String database = \"testing\";\ncontroller.setSelectedDatabaseConnection(database);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    controller.getJobMeta().addDatabase(new DatabaseMeta(database, \"MYSQL\", null, null, null, null, null, null));\n-    controller.setSelectedDatabaseConnection(database);\n+    DatabaseItem test = new DatabaseItem(\"test\");\n+    controller.getJobMeta().addDatabase(new DatabaseMeta(test.getName(), \"MYSQL\", null, null, null, null, null, null));\n+    controller.setSelectedDatabaseConnection(test);",
                "+  public void updateDatabaseItemsList() {\n+    AbstractSqoopJobEntryController controller = new TestSqoopJobEntryController();\n+    DatabaseItem test = new DatabaseItem(\"test\");\n+    controller.getJobMeta().addDatabase(new DatabaseMeta(test.getName(), \"MYSQL\", null, null, null, null, null, null));\n+    controller.setSelectedDatabaseConnection(test);",
                "+    controller.populateDatabases();\n+    assertEquals(2, controller.getDatabaseConnections().size());\n+    assertEquals(controller.NO_DATABASE, controller.getDatabaseConnections().get(0));\n+    assertEquals(test, controller.getDatabaseConnections().get(1));\n+    controller.setSelectedDatabaseConnection(test);"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class DatabaseItem (optional references)",
                "contexts": [
                    "public DatabaseItem(String name);",
                    "public DatabaseItem(String name, String displayName);",
                    "public String getName();",
                    "public String getDisplayName();",
                    "@Override public int hashCode();"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+  public void init() throws XulException, InvocationTargetException {\n+    NO_DATABASE = new DatabaseItem(\"@@none@@\", BaseMessages.getString(AbstractSqoopJobEntry.class, \"DatabaseName.ChooseAvailable\"));\n+    USE_ADVANCED_OPTIONS = new DatabaseItem(\"@@advanced@@\", BaseMessages.getString(AbstractSqoopJobEntry.class, \"DatabaseName.UseAdvancedOptions\"));\n+    bindings = new ArrayList<Binding>();\n+    suppressEventHandling = true;\n+    try {\n+      populateDatabases();\n+      setModeToggleLabel(BaseMessages.getString(AbstractSqoopJobEntry.class, MODE_I18N_STRINGS[0]));\n+      customizeModeToggleLabel(getModeToggleLabelElementId());\n+      createBindings(config, container, bindingFactory, bindings);",
                    "+    bindingFactory.createBinding(config, \"username\", this, \"usernameChanged\");\n+    bindingFactory.createBinding(config, \"password\", this, \"passwordChanged\");",
                    "+    } else {\n+      if (databaseConnections.contains(NO_DATABASE)) {\n+        databaseConnections.remove(NO_DATABASE);\n+      }\n+    }\n+    if (getConfig().getConnectFromAdvanced() != null || getConfig().getUsernameFromAdvanced() != null || getConfig().getPasswordFromAdvanced() != null) {\n+      if (!databaseConnections.contains(USE_ADVANCED_OPTIONS)) {\n+        databaseConnections.add(0, USE_ADVANCED_OPTIONS);\n+      }\n+    } else {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    String database = \"testing\";\n-    controller.getConfig().setDatabase(database);\n-    assertEquals(database, controller.getSelectedDatabaseConnection());\n+    DatabaseItem test = new DatabaseItem(\"test\");\n+    controller.getJobMeta().addDatabase(new DatabaseMeta(test.getName(), \"MYSQL\", null, null, null, null, null, null));\n+    controller.setSelectedDatabaseConnection(test);\n+    assertEquals(test, controller.getSelectedDatabaseConnection());\n+    assertEquals(test.getName(), controller.getConfig().getDatabase());\n+  }\n+  @Test",
                    "+    AbstractSqoopJobEntryController controller = new TestSqoopJobEntryController();\n+    DatabaseItem test = new DatabaseItem(\"test\");\n+    controller.getJobMeta().addDatabase(new DatabaseMeta(test.getName(), \"MYSQL\", null, null, null, null, null, null));\n+    controller.setSelectedDatabaseConnection(test);\n+    controller.populateDatabases();\n+    assertEquals(1, controller.getDatabaseConnections().size());\n+    assertEquals(test, controller.getDatabaseConnections().get(0));\n+    controller.getConfig().setConnectFromAdvanced(\"testing\");\n+    controller.updateDatabaseItemsList();\n+    assertEquals(2, controller.getDatabaseConnections().size());",
                    "+    controller.getConfig().setPassword(password);\n+    controller.setPasswordChanged(\"testing\");\n+    assertNull(controller.getConfig().getDatabase());\n+    assertEquals(password, controller.getConfig().getPassword());\n+    assertEquals(password, controller.getConfig().getPasswordFromAdvanced());\n+  }\n+  @Test\n+  public void setPasswordChanged_ignoring_change_events() {\n+    AbstractSqoopJobEntryController controller = new TestSqoopJobEntryController();\n+    String database = \"testing\";"
                ]
            }
        ]
    },
    {
        "id": 100,
        "Anal": "The third parameter \"sourceHandle\" of the method \"concat\" changes from `SegmentHandle` to `String`.",
        "Stmts": "val sourceWriteHandle = s.openWrite(sourceSegment).join();\ns.concat(firstSegmentHandle, firstSegmentLength.get(), sourceWriteHandle, TIMEOUT).join();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "+    public CompletableFuture<Void> seal(SegmentHandle handle, Duration timeout) {\n-    public CompletableFuture<Void> concat(SegmentHandle targetHandle, long offset, SegmentHandle sourceHandle, Duration timeout) {\n+    public CompletableFuture<Void> concat(SegmentHandle targetHandle, long offset, String sourceSegment, Duration timeout) {\n-      return this.baseStorage.concat(targetHandle, offset, sourceHandle, timeout);\n+      return this.baseStorage.concat(targetHandle, offset, sourceSegment, timeout);"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  CompletableFuture<SegmentProperties> seal(SegmentHandle handle, Duration timeout);\n+  CompletableFuture<Void> seal(SegmentHandle handle, Duration timeout);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-      assertThrows(\"write() did not throw for handle pointing to inexistent segment.\", () -> s.write(createHandle(segmentName + \"_1\", false), 0, new ByteArrayInputStream(\"h\".getBytes()), 1, TIMEOUT), ex -> ex instanceof StreamSegmentNotExistsException);\n+      assertThrows(\"write() did not throw for handle pointing to inexistent segment.\", () -> s.write(createHandle(segmentName + \"_1\", false, DEFAULT_EPOCH), 0, new ByteArrayInputStream(\"h\".getBytes()), 1, TIMEOUT), ex -> ex instanceof StreamSegmentNotExistsException);",
                    "-        val segmentInfo = s.seal(writeHandle, TIMEOUT).join();\n-        Assert.assertTrue(\"seal() did not return a segmentInfo with isSealed == true.\", segmentInfo.isSealed());\n-        val segmentInfo1 = s.seal(writeHandle, TIMEOUT).join();\n-        Assert.assertTrue(\"seal() did not return a segmentInfo with isSealed == true for an already sealed segment.\", segmentInfo1.isSealed());\n+        s.seal(writeHandle, TIMEOUT).join();\n+        s.seal(writeHandle, TIMEOUT).join();",
                    "-      s.initialize(0);\n-      assertThrows(\"seal() did not throw for non-existent segment name.\", () -> s.seal(createHandle(\"foo\", false), TIMEOUT), ex -> ex instanceof StreamSegmentNotExistsException);\n+      s.initialize(DEFAULT_EPOCH);\n+      assertThrows(\"seal() did not throw for non-existent segment name.\", () -> s.seal(createHandle(\"foo\", false, DEFAULT_EPOCH), TIMEOUT), ex -> ex instanceof StreamSegmentNotExistsException);"
                ]
            }
        ]
    },
    {
        "id": 101,
        "Anal": "The return type of the method \"removeFinishedWrites\" changes from `boolean` to `EnumSet<CleanupStatus>`.",
        "Stmts": "boolean result1 = q.removeFinishedWrites();\nAssert.assertTrue(\"Unexpected value from removeFinishedWrites when there were writes left in the queue.\", result1);\nboolean result2 = q.removeFinishedWrites();\nAssert.assertEquals(\"Unexpected result from removeFinishedWrites.\", !writes.isEmpty(), result2);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  synchronized List<Write> clear() {\n+  synchronized List<Write> close() {",
                    "-    long firstLedgerId = this.writes.peekFirst().getLedgerMetadata().getLedgerId();\n+    long firstLedgerId = this.writes.peekFirst().getWriteLedger().metadata.getLedgerId();",
                    "+    Exceptions.checkNotClosed(this.closed, this);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    val removedWrites = q.clear();\n+    val removedWrites = q.close();",
                    "-    q.add(new Write(new ByteArraySegment(new byte[BookKeeperConfig.MAX_APPEND_LENGTH]), new TestWriteLedger(0), CompletableFuture.completedFuture(null)));\n-    val addStats = q.getStatistics();\n-    Assert.assertEquals(\"Unexpected getSize after clear+add.\", 1, addStats.getSize());\n-    Assert.assertEquals(\"Unexpected getAverageFillRate after clear+add.\", 1, addStats.getAverageItemFillRate(), 0);\n+    AssertExtensions.assertThrows(\"add() worked after close().\", () -> q.add(new Write(new ByteArraySegment(new byte[1]), new TestWriteLedger(0), CompletableFuture.completedFuture(null))), ex -> ex instanceof ObjectClosedException);\n+    AssertExtensions.assertThrows(\"getWritesToExecute() worked after close().\", () -> q.getWritesToExecute(1), ex -> ex instanceof ObjectClosedException);\n+    AssertExtensions.assertThrows(\"removeFinishedWrites() worked after close().\", q::removeFinishedWrites, ex -> ex instanceof ObjectClosedException);",
                    "-    result3.forEach(w -> w.complete(new TestLogAddress(0)));\n+    result3.forEach(w -> w.setEntryId(0));\n+    result3.forEach(Write::complete);"
                ]
            }
        ]
    },
    {
        "id": 102,
        "Anal": "The return type of the method \"createUser\" changes from `IdResponse` to `IdResult`.",
        "Stmts": "IdResponse response = accountWebServiceClient.createUser(userDTO);\nassertEquals(WSResponse.PARAMETER_ERROR, response.getCode());\nresponse = accountWebServiceClient.createUser(userDTO);\nassertEquals(WSResponse.PARAMETER_ERROR, response.getCode());",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "+    IdResult response = accountWebServiceClient.createUser(userDTO);\n-    GetUserResponse response2 = accountWebServiceClient.getUser(response.getId());\n+    GetUserResult response2 = accountWebServiceClient.getUser(response.getId());"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class IdResult (optional references)",
                "contexts": [
                    "public String getCode();",
                    "public IdResult();",
                    "public IdResult(Long id);"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    response.setDefaultError();\n-    return response;\n+    result.setDefaultError();\n+    return result;",
                    "-  public SearchUserResponse searchUser(String loginName, String name) {\n-    SearchUserResponse response = new SearchUserResponse();\n+  public SearchUserResult searchUser(String loginName, String name) {\n+    SearchUserResult result = new SearchUserResult();",
                    "-      response.setUser(dto);\n-      return response;\n+      result.setUser(dto);\n+      return result;"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    IdResponse response = accountWebServiceClient.createUser(userDTO);\n+    IdResult response = accountWebServiceClient.createUser(userDTO);",
                    "-    GetUserResponse response2 = accountWebServiceClient.getUser(response.getId());\n+    GetUserResult response2 = accountWebServiceClient.getUser(response.getId());",
                    "-    GetUserResponse response = accountWebServiceClient.getUser(1L);\n+    GetUserResult response = accountWebServiceClient.getUser(1L);"
                ]
            }
        ]
    },
    {
        "id": 103,
        "Anal": "The return type of the method \"getUser\" changes from `GetUserResponse` to `GetUserResult`.",
        "Stmts": "GetUserResponse response = accountWebServiceClient.getUser(1L);\nassertEquals(\"admin\", response.getUser().getLoginName());",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [
            {
                "info": "Defined in class GetUserResult (optional references)",
                "contexts": [
                    "public UserDTO getUser();",
                    "public static final String SUCESS = \"0\";",
                    "public void setUser(UserDTO user);",
                    "public String getMessage();",
                    "public String getCode();"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    response.setDefaultError();\n-    return response;\n+    result.setDefaultError();\n+    return result;",
                    "-  public SearchUserResponse searchUser(String loginName, String name) {\n-    SearchUserResponse response = new SearchUserResponse();\n+  public SearchUserResult searchUser(String loginName, String name) {\n+    SearchUserResult result = new SearchUserResult();",
                    "-      response.setUserList(dtoList);\n-      return response;\n+      result.setUserList(dtoList);\n+      return result;"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    GetUserResponse response2 = accountWebServiceClient.getUser(response.getId());\n+    GetUserResult response2 = accountWebServiceClient.getUser(response.getId());",
                    "-    IdResponse response = accountWebServiceClient.createUser(userDTO);\n+    IdResult response = accountWebServiceClient.createUser(userDTO);",
                    "-    SearchUserResponse response = accountWebServiceClient.searchUser(null, null);\n+    SearchUserResult response = accountWebServiceClient.searchUser(null, null);"
                ]
            }
        ]
    },
    {
        "id": 104,
        "Anal": "The method \"changeReplicationFactor\" no longer takes a second parameter \"handler\" of type `Handler<AsyncResult<Void>>`. Instead, it now returns a `Future<Void>`.",
        "Stmts": "sub.changeReplicationFactor(topic, ar -> {\n  context.assertFalse(ar.succeeded());\n  final String message = ar.cause().getMessage();\n  context.assertTrue(message.contains(\"lacks an executable arg[0]\") && message.contains(\"/some/executable/that/does/not/exist\"));\n  async.complete();\n});",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    sub.changeReplicationFactor(topic, ar -> {\n+    sub.changeReplicationFactor(topic).setHandler(ar -> {",
                "-      kafka.changeReplicationFactor(topic, ar -> {\n+      kafka.changeReplicationFactor(topic).setHandler(ar -> {"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  void createTopic(Topic newTopic, Handler<AsyncResult<Void>> handler);\n-  void deleteTopic(TopicName topicName, Handler<AsyncResult<Void>> handler);\n-  void updateTopicConfig(Topic topic, Handler<AsyncResult<Void>> handler);\n-  void increasePartitions(Topic topic, Handler<AsyncResult<Void>> handler);\n-  void changeReplicationFactor(Topic topic, Handler<AsyncResult<Void>> handler);\n-  void topicMetadata(TopicName topicName, Handler<AsyncResult<TopicMetadata>> handler);\n-  void listTopics(Handler<AsyncResult<Set<String>>> handler);\n+  Future<Void> createTopic(Topic newTopic);\n+  Future<Void> deleteTopic(TopicName topicName);\n+  Future<Void> updateTopicConfig(Topic topic);",
                    "+    return handler;",
                    "+  Future<Void> changeReplicationFactor(Topic topic);\n+  Future<TopicMetadata> topicMetadata(TopicName topicName);\n+  Future<Set<String>> listTopics();"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    sub.changeReplicationFactor(topic, ar -> {\n+    sub.changeReplicationFactor(topic).setHandler(ar -> {"
                ]
            }
        ]
    },
    {
        "id": 105,
        "Anal": "The method \"changeReplicationFactor\" no longer takes a second parameter \"handler\" of type `Handler<AsyncResult<Void>>`. Instead, it now returns a `Future<Void>`.",
        "Stmts": "sub.changeReplicationFactor(topic, ar -> {\n  context.assertTrue(ar.succeeded());\n  async.complete();\n});",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    sub.changeReplicationFactor(topic, ar -> {\n+    sub.changeReplicationFactor(topic).setHandler(ar -> {",
                "-      kafka.changeReplicationFactor(topic, ar -> {\n+      kafka.changeReplicationFactor(topic).setHandler(ar -> {"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  void createTopic(Topic newTopic, Handler<AsyncResult<Void>> handler);\n-  void deleteTopic(TopicName topicName, Handler<AsyncResult<Void>> handler);\n-  void updateTopicConfig(Topic topic, Handler<AsyncResult<Void>> handler);\n-  void increasePartitions(Topic topic, Handler<AsyncResult<Void>> handler);\n-  void changeReplicationFactor(Topic topic, Handler<AsyncResult<Void>> handler);\n-  void topicMetadata(TopicName topicName, Handler<AsyncResult<TopicMetadata>> handler);\n-  void listTopics(Handler<AsyncResult<Set<String>>> handler);\n+  Future<Void> createTopic(Topic newTopic);\n+  Future<Void> deleteTopic(TopicName topicName);\n+  Future<Void> updateTopicConfig(Topic topic);",
                    "+    return handler;",
                    "+  Future<Void> changeReplicationFactor(Topic topic);\n+  Future<TopicMetadata> topicMetadata(TopicName topicName);\n+  Future<Set<String>> listTopics();"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    sub.changeReplicationFactor(topic, ar -> {\n+    sub.changeReplicationFactor(topic).setHandler(ar -> {"
                ]
            }
        ]
    },
    {
        "id": 106,
        "Anal": "The method \"changeReplicationFactor\" no longer takes a second parameter \"handler\" of type `Handler<AsyncResult<Void>>`. Instead, it now returns a `Future<Void>`.",
        "Stmts": "sub.changeReplicationFactor(topic, ar -> {\n  context.assertFalse(ar.succeeded());\n  context.assertTrue(ar.cause().getMessage().contains(\"Failed to reassign partitions\"));\n  async.complete();\n});",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    sub.changeReplicationFactor(topic, ar -> {\n+    sub.changeReplicationFactor(topic).setHandler(ar -> {",
                "-      kafka.changeReplicationFactor(topic, ar -> {\n+      kafka.changeReplicationFactor(topic).setHandler(ar -> {"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  void createTopic(Topic newTopic, Handler<AsyncResult<Void>> handler);\n-  void deleteTopic(TopicName topicName, Handler<AsyncResult<Void>> handler);\n-  void updateTopicConfig(Topic topic, Handler<AsyncResult<Void>> handler);\n-  void increasePartitions(Topic topic, Handler<AsyncResult<Void>> handler);\n-  void changeReplicationFactor(Topic topic, Handler<AsyncResult<Void>> handler);\n-  void topicMetadata(TopicName topicName, Handler<AsyncResult<TopicMetadata>> handler);\n-  void listTopics(Handler<AsyncResult<Set<String>>> handler);\n+  Future<Void> createTopic(Topic newTopic);\n+  Future<Void> deleteTopic(TopicName topicName);\n+  Future<Void> updateTopicConfig(Topic topic);",
                    "+    return handler;",
                    "+  Future<Void> changeReplicationFactor(Topic topic);\n+  Future<TopicMetadata> topicMetadata(TopicName topicName);\n+  Future<Set<String>> listTopics();"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    sub.changeReplicationFactor(topic, ar -> {\n+    sub.changeReplicationFactor(topic).setHandler(ar -> {"
                ]
            }
        ]
    },
    {
        "id": 107,
        "Anal": "The method \"getCpu\" now throws a `PerfMonException`.",
        "Stmts": "double result = instance.getCpu();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-            cnxLost = true;\n+        try {\n+          switch (connectors[i].getMetricType()) {\n+          case AbstractPerformanceMonitoringGui.PERFMON_CPU:\n+            generateSample(100 * connectors[i].getCpu(), label + \", %\");",
                "     long value = (long)(100 * connector.getCpu());"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+    if (ret[0] < 0 || ret[1] < 0)\n+      throwNotSupportedMetricException(\"disks I/O\");",
                    "-    } else {\n-      ret = AGENT_ERROR;\n-    }\n+    if (ret <= 0)\n+      throwNotSupportedMetricException(\"memory\");",
                    "+    if (ret[0] < 0 || ret[1] < 0)\n+      throwNotSupportedMetricException(\"swap\");"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-  public void testGetMem() {\n+  public void testGetMem() throws PerfMonException {",
                    "-  public void testGetNetIO() {\n+  public void testGetNetIO() throws PerfMonException {",
                    "-  public void testGetSwap() {\n+  public void testGetSwap() throws PerfMonException {"
                ]
            }
        ]
    },
    {
        "id": 108,
        "Anal": "The method name \"getEnvMapForLog\" has been changed to \"getEnvMap\".",
        "Stmts": "LOGGER.debug(JsonUtil.format(SystemUtil.getEnvMapForLog()));",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public static Map<String, String> getPropertiesMapForLog() {\n-    Properties properties = System.getProperties();\n-    return new TreeMap<String, String>(ConvertUtil.toMap(properties));\n+  public static Map<String, String> getPropertiesMap() {\n+    return new TreeMap<String, String>(toMap(System.getProperties()));",
                    "-    setPropertiesFromMap(ConvertUtil.toMap(properties));\n+    setPropertiesFromMap(toMap(properties));"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-  public void testGetPropertiesMapForLog() {\n-    LOGGER.debug(JsonUtil.format(SystemUtil.getPropertiesMapForLog()));\n+  public void testGetPropertiesMap() {\n+    LOGGER.debug(JsonUtil.format(SystemUtil.getPropertiesMap()));"
                ]
            }
        ]
    },
    {
        "id": 109,
        "Anal": "The second parameter \"httpURLConnectionParam\" of the method \"getResponseBodyAsString\" changes from `HttpURLConnectionParam` to `ConnectionConfig`.",
        "Stmts": "HttpURLConnectionParam httpURLConnectionParam = new HttpURLConnectionParam();\nhttpURLConnectionParam.setContentCharset(CharsetType.GBK);\nString responseBodyAsString = URLConnectionUtil.getResponseBodyAsString(templateFile, httpURLConnectionParam);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public static String readLine(String urlString, HttpURLConnectionParam httpURLConnectionParam) {\n-    InputStream inputStream = getInputStream(urlString, httpURLConnectionParam);\n-    BufferedReader bufferedReader = InputStreamUtil.toBufferedReader(inputStream, httpURLConnectionParam.getContentCharset());\n+  public static String readLine(String urlString, ConnectionConfig connectionConfig) {\n+    InputStream inputStream = getInputStream(urlString, connectionConfig);\n+    BufferedReader bufferedReader = InputStreamUtil.toBufferedReader(inputStream, connectionConfig.getContentCharset());",
                    "-    Proxy proxy = getProxy(httpURLConnectionParam.getProxyAddress(), httpURLConnectionParam.getProxyPort());\n-    HttpURLConnection httpURLConnection = null;\n+    Proxy proxy = getProxy(connectionConfig.getProxyAddress(), connectionConfig.getProxyPort());",
                    "-  public static InputStream getInputStream(String urlString, HttpURLConnectionParam httpURLConnectionParam) {\n+  public static InputStream getInputStream(String urlString, ConnectionConfig connectionConfig) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 110,
        "Anal": "The method name \"joinValues\" has been changed to \"joinValuesOrderByIncludeKeys\".",
        "Stmts": "assertEquals(StringUtils.EMPTY, ParamUtil.joinValues(map, \"a\", \"b\"));\nassertEquals(value, ParamUtil.joinValues(map, \"service\"));\nassertEquals(value + value2, ParamUtil.joinValues(map, \"service\", \"paymentType\"));\nassertEquals(value2 + value, ParamUtil.joinValues(map, \"paymentType\", \"service\"));",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    return Validator.isNullOrEmpty(arrayValueMap) ? StringUtils.EMPTY : joinArrayValueMap(toSafeArrayValueMap(arrayValueMap, charsetType));\n+    return Validator.isNullOrEmpty(arrayValueMap) ? StringUtils.EMPTY : toQueryStringUseArrayValueMap(toSafeArrayValueMap(arrayValueMap, charsetType));",
                    "-    if (Validator.isNullOrEmpty(charsetType)) {\n-      return value;\n-    }\n-    return URIUtil.encode(URIUtil.decode(value, charsetType), charsetType);\n+    return Validator.isNullOrEmpty(charsetType) ? value : URIUtil.encode(URIUtil.decode(value, charsetType), charsetType);",
                    "+  }\n+  public static String toQueryStringUseSingleValueMap(Map<String, String> singleValueMap) {\n+    return Validator.isNullOrEmpty(singleValueMap) ? StringUtils.EMPTY : toQueryStringUseArrayValueMap(toArrayValueMap(singleValueMap));\n+  }\n+  public static String toQueryStringUseArrayValueMap(Map<String, String[]> arrayValueMap) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    LOGGER.info(ParamUtil.joinValues(map, \"service\", \"paymentType\"));\n+    LOGGER.info(ParamUtil.joinValuesOrderByIncludeKeys(map, \"service\", \"paymentType\"));",
                    "-  public void testJoinValues1() {\n+  public void testJoinValuesOrderByIncludeKeys() {",
                    "-    LOGGER.info(ParamUtil.joinSingleValueMap(map));\n+    LOGGER.info(ParamUtil.toQueryStringUseSingleValueMap(map));"
                ]
            }
        ]
    },
    {
        "id": 111,
        "Anal": "The order of parameters in the method \"toString\" has been swapped. The \"collection\" parameter is now the second parameter and \"toStringConfig\" is the first.",
        "Stmts": "assertEquals(\"2548\", ConvertUtil.toString(list, toStringConfig));",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    for (int i = 0, j = arrays.length; i < j; ++i) {\n-      T t = arrays[i];\n+    for (int i = 0, j = operateArray.length; i < j; ++i) {\n+      @SuppressWarnings(\"unchecked\") T t = (T)operateArray[i];",
                    "-    return (T)ConvertUtils.convert(value, targetType);\n+    return (T)org.apache.commons.beanutils.ConvertUtils.convert(value, targetType);",
                    "+  }\n+  private static <T> Object[] toObjects(T... arrays) {\n+    if (Validator.isNullOrEmpty(arrays)) {\n+      return ArrayUtils.EMPTY_STRING_ARRAY;\n+    }\n+    if (arrays.length > 1) {\n+      return arrays;\n+    }\n+    Object o = arrays[0];\n+    if (isPrimitiveArray(o)) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    LOGGER.debug(ConvertUtil.toString(list, toStringConfig));\n+    LOGGER.debug(ConvertUtil.toString(toStringConfig, list));",
                    "+    assertEquals(\"2\", ConvertUtil.toString(new ToStringConfig(\",\"), 2));\n+    assertEquals(\"2\", ConvertUtil.toString(new ToStringConfig(\",\"), new Integer(2)));",
                    "+  public void toList() {\n+    User user1 = new User();\n+    user1.setId(1L);\n+    User user2 = new User();\n+    user2.setId(2L);\n+    User[] users = {user1, user2};\n+    List<User> list = ConvertUtil.toList(users);\n+    LOGGER.info(JsonUtil.format(list));\n+  }\n+  @Test"
                ]
            }
        ]
    },
    {
        "id": 112,
        "Anal": "The order of parameters in the method \"toString\" has been swapped. The \"collection\" parameter is now the second parameter and \"toStringConfig\" is the first.",
        "Stmts": "LOGGER.debug(ConvertUtil.toString(list, toStringConfig));",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    for (int i = 0, j = arrays.length; i < j; ++i) {\n-      T t = arrays[i];\n+    for (int i = 0, j = operateArray.length; i < j; ++i) {\n+      @SuppressWarnings(\"unchecked\") T t = (T)operateArray[i];",
                    "-    return (T)ConvertUtils.convert(value, targetType);\n+    return (T)org.apache.commons.beanutils.ConvertUtils.convert(value, targetType);",
                    "+  }\n+  private static <T> Object[] toObjects(T... arrays) {\n+    if (Validator.isNullOrEmpty(arrays)) {\n+      return ArrayUtils.EMPTY_STRING_ARRAY;\n+    }\n+    if (arrays.length > 1) {\n+      return arrays;\n+    }\n+    Object o = arrays[0];\n+    if (isPrimitiveArray(o)) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    assertEquals(\"2548\", ConvertUtil.toString(list, toStringConfig));\n+    assertEquals(\"2548\", ConvertUtil.toString(toStringConfig, list));",
                    "+  public void toList() {\n+    User user1 = new User();\n+    user1.setId(1L);\n+    User user2 = new User();\n+    user2.setId(2L);\n+    User[] users = {user1, user2};\n+    List<User> list = ConvertUtil.toList(users);\n+    LOGGER.info(JsonUtil.format(list));\n+  }\n+  @Test",
                    "+    assertEquals(\"2\", ConvertUtil.toString(new ToStringConfig(\",\"), 2));\n+    assertEquals(\"2\", ConvertUtil.toString(new ToStringConfig(\",\"), new Integer(2)));"
                ]
            }
        ]
    },
    {
        "id": 113,
        "Anal": "The method \"getConcreteMembers\" has changed its parameters. The first change is the second parameter \"genericInherited\" which changes from `Element` to `TypeElement`. The second change is the third parameter \"members\" which changes from `Map<Element, TypeMirror>` to `Map<VariableElement, TypeMirror>`.",
        "Stmts": "Map<Element, TypeMirror> genericMembers = new HashMap<>();\nfor (Element element : genericElement.getEnclosedElements()) {\n  if (element instanceof VariableElement) {\n    genericMembers.put(element, element.asType());\n  }\n}\nLinkedHashMap<Element, TypeMirror> members = TypeUtils.getConcreteMembers(concreteType, types.asElement(genericType), genericMembers);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  private static List<? extends TypeMirror> getParameterizedTypes(@NotNull Element element) {\n+  private static List<? extends TypeMirror> getParameterizedTypes(@NotNull TypeElement element) {",
                    "-  public static boolean isEnum(@Nullable Element element) {\n-    TypeElement typeElement = (TypeElement)element;\n-    TypeMirror typeMirror = typeElement != null ? typeElement.getSuperclass() : null;\n+  public static boolean isEnum(@Nullable TypeElement element) {\n+    TypeMirror typeMirror = element != null ? element.getSuperclass() : null;",
                    "-  public static boolean isConcreteType(@NotNull Element element) {\n+  public static boolean isConcreteType(@NotNull TypeElement element) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    TypeMirror realConcreteType = types.getDeclaredType((TypeElement)Utils.getElementFromClass(DummyGenericClass.class), Utils.getTypeMirrorFromClass(String.class));\n+    TypeMirror realConcreteType = types.getDeclaredType(Utils.getElementFromClass(DummyGenericClass.class), Utils.getTypeMirrorFromClass(String.class));"
                ]
            }
        ]
    },
    {
        "id": 114,
        "Anal": "The method \"createClassifier\" changes its parameters from `name`, `language`, and `trainingData` to a single parameter `createClassifierOptions`.",
        "Stmts": "service.createClassifier(classifierId, \"en\", new File(\"src/test/resources/natural_language_classifier/weather_data_train.csv\")).execute();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public ServiceCall<Void> deleteClassifier(String classifierId) {\n-    Validator.isTrue((classifierId != null) && !classifierId.isEmpty(), \"classifierId cannot be null or empty\");\n-    final Request request = RequestBuilder.delete(String.format(PATH_CLASSIFIER, classifierId)).build();\n-    return createServiceCall(request, ResponseConverterUtils.getVoid());\n+  public ServiceCall<Void> deleteClassifier(DeleteClassifierOptions deleteClassifierOptions) {\n+    Validator.notNull(deleteClassifierOptions, \"deleteClassifierOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/classifiers/%s\", deleteClassifierOptions.classifierId()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());",
                    "-  public ServiceCall<Classifier> getClassifier(String classifierId) {\n-    Validator.isTrue((classifierId != null) && !classifierId.isEmpty(), \"classifierId cannot be null or empty\");\n-    final Request request = RequestBuilder.get(String.format(PATH_CLASSIFIER, classifierId)).build();\n-    return createServiceCall(request, ResponseConverterUtils.getObject(Classifier.class));\n+  public ServiceCall<Classifier> getClassifier(GetClassifierOptions getClassifierOptions) {\n+    Validator.notNull(getClassifierOptions, \"getClassifierOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/classifiers/%s\", getClassifierOptions.classifierId()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Classifier.class));",
                    "-  public ServiceCall<Classifiers> getClassifiers() {\n-    final Request request = RequestBuilder.get(PATH_CLASSIFIERS).build();\n-    return createServiceCall(request, ResponseConverterUtils.getObject(Classifiers.class));\n+  public ServiceCall<ClassifierList> listClassifiers(ListClassifiersOptions listClassifiersOptions) {\n+    RequestBuilder builder = RequestBuilder.get(\"/v1/classifiers\");\n+    if (listClassifiersOptions != null) {}\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(ClassifierList.class));\n+  }\n+  public ServiceCall<ClassifierList> listClassifiers() {\n+    return listClassifiers(null);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    final Classification result = service.classify(classifierId, classification.getText()).execute();\n+    ClassifyOptions classifyOptions = new ClassifyOptions.Builder().classifierId(classifierId).text(classification.getText()).build();\n+    final Classification result = service.classify(classifyOptions).execute();",
                    "-  @Test(expected = IllegalArgumentException.class)\n-  public void testNullTrainingDataFile() {\n-    service.createClassifier(null, null, new File(\"src/test/resources/notfound.txt\"));\n+  @Test(expected = FileNotFoundException.class)\n+  public void testNullTrainingDataFile() throws FileNotFoundException {\n+    server.enqueue(jsonResponse(classifier));\n+    File metadata = new File(RESOURCE + \"metadata.json\");\n+    File trainingData = new File(RESOURCE + \"notfound.txt\");\n+    CreateClassifierOptions createOptions = new CreateClassifierOptions.Builder().metadata(metadata).trainingData(trainingData).trainingDataFilename(\"notfound.txt\").build();\n+    service.createClassifier(createOptions).execute();",
                    "-    service.classify(classifierId, null);\n+    ClassifyOptions classifyOptions = new ClassifyOptions.Builder().classifierId(classifierId).build();\n+    service.classify(classifyOptions);"
                ]
            }
        ]
    },
    {
        "id": 115,
        "Anal": "The method \"createClassifier\" changes from accepting three parameters: \"name\", \"language\", and \"trainingData\" to accepting a single parameter of type \"CreateClassifierOptions\".",
        "Stmts": "service.createClassifier(null, null, new File(\"src/test/resources/notfound.txt\"));",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public ServiceCall<Void> deleteClassifier(String classifierId) {\n-    Validator.isTrue((classifierId != null) && !classifierId.isEmpty(), \"classifierId cannot be null or empty\");\n-    final Request request = RequestBuilder.delete(String.format(PATH_CLASSIFIER, classifierId)).build();\n-    return createServiceCall(request, ResponseConverterUtils.getVoid());\n+  public ServiceCall<Void> deleteClassifier(DeleteClassifierOptions deleteClassifierOptions) {\n+    Validator.notNull(deleteClassifierOptions, \"deleteClassifierOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/classifiers/%s\", deleteClassifierOptions.classifierId()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());",
                    "-  public ServiceCall<Classifier> getClassifier(String classifierId) {\n-    Validator.isTrue((classifierId != null) && !classifierId.isEmpty(), \"classifierId cannot be null or empty\");\n-    final Request request = RequestBuilder.get(String.format(PATH_CLASSIFIER, classifierId)).build();\n-    return createServiceCall(request, ResponseConverterUtils.getObject(Classifier.class));\n+  public ServiceCall<Classifier> getClassifier(GetClassifierOptions getClassifierOptions) {\n+    Validator.notNull(getClassifierOptions, \"getClassifierOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/classifiers/%s\", getClassifierOptions.classifierId()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Classifier.class));",
                    "-  public ServiceCall<Classifiers> getClassifiers() {\n-    final Request request = RequestBuilder.get(PATH_CLASSIFIERS).build();\n-    return createServiceCall(request, ResponseConverterUtils.getObject(Classifiers.class));\n+  public ServiceCall<ClassifierList> listClassifiers(ListClassifiersOptions listClassifiersOptions) {\n+    RequestBuilder builder = RequestBuilder.get(\"/v1/classifiers\");\n+    if (listClassifiersOptions != null) {}\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(ClassifierList.class));\n+  }\n+  public ServiceCall<ClassifierList> listClassifiers() {\n+    return listClassifiers(null);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-  public void testCreateClassifier() throws InterruptedException {\n+  public void testCreateClassifier() throws InterruptedException, FileNotFoundException {",
                    "-    final Classifier response = service.createClassifier(classifierId, \"en\", new File(\"src/test/resources/natural_language_classifier/weather_data_train.csv\")).execute();\n+    File metadata = new File(RESOURCE + \"metadata.json\");\n+    File trainingData = new File(RESOURCE + \"weather_data_train.csv\");\n+    CreateClassifierOptions createOptions = new CreateClassifierOptions.Builder().metadata(metadata).trainingData(trainingData).trainingDataFilename(\"weather_data_train.csv\").build();\n+    final Classifier response = service.createClassifier(createOptions).execute();",
                    "-    service.classify(classifierId, null);\n+    ClassifyOptions classifyOptions = new ClassifyOptions.Builder().classifierId(classifierId).build();\n+    service.classify(classifyOptions);"
                ]
            }
        ]
    },
    {
        "id": 116,
        "Anal": "The method \"classify\" changes from accepting two string parameters \"classifierId\" and \"text\" to accepting a single parameter of type \"ClassifyOptions\".",
        "Stmts": "service.classify(\"\", \"test\");",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public ServiceCall<Void> deleteClassifier(String classifierId) {\n-    Validator.isTrue((classifierId != null) && !classifierId.isEmpty(), \"classifierId cannot be null or empty\");\n-    final Request request = RequestBuilder.delete(String.format(PATH_CLASSIFIER, classifierId)).build();\n-    return createServiceCall(request, ResponseConverterUtils.getVoid());\n+  public ServiceCall<Void> deleteClassifier(DeleteClassifierOptions deleteClassifierOptions) {\n+    Validator.notNull(deleteClassifierOptions, \"deleteClassifierOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/classifiers/%s\", deleteClassifierOptions.classifierId()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());",
                    "-  public ServiceCall<Classifier> getClassifier(String classifierId) {\n-    Validator.isTrue((classifierId != null) && !classifierId.isEmpty(), \"classifierId cannot be null or empty\");\n-    final Request request = RequestBuilder.get(String.format(PATH_CLASSIFIER, classifierId)).build();\n-    return createServiceCall(request, ResponseConverterUtils.getObject(Classifier.class));\n+  public ServiceCall<Classifier> getClassifier(GetClassifierOptions getClassifierOptions) {\n+    Validator.notNull(getClassifierOptions, \"getClassifierOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/classifiers/%s\", getClassifierOptions.classifierId()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Classifier.class));",
                    "+  public ServiceCall<Classifier> createClassifier(CreateClassifierOptions createClassifierOptions) {\n+    Validator.notNull(createClassifierOptions, \"createClassifierOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.post(\"/v1/classifiers\");\n+    MultipartBody.Builder multipartBuilder = new MultipartBody.Builder();\n+    multipartBuilder.setType(MultipartBody.FORM);\n+    RequestBody trainingMetadataBody = RequestUtils.inputStreamBody(createClassifierOptions.metadata(), \"application/json\");\n+    multipartBuilder.addFormDataPart(\"training_metadata\", createClassifierOptions.metadataFilename(), trainingMetadataBody);\n+    RequestBody trainingDataBody = RequestUtils.inputStreamBody(createClassifierOptions.trainingData(), \"text/csv\");\n+    multipartBuilder.addFormDataPart(\"training_data\", createClassifierOptions.trainingDataFilename(), trainingDataBody);\n+    builder.body(multipartBuilder.build());"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    final Classifier response = service.createClassifier(classifierId, \"en\", new File(\"src/test/resources/natural_language_classifier/weather_data_train.csv\")).execute();\n+    File metadata = new File(RESOURCE + \"metadata.json\");\n+    File trainingData = new File(RESOURCE + \"weather_data_train.csv\");\n+    CreateClassifierOptions createOptions = new CreateClassifierOptions.Builder().metadata(metadata).trainingData(trainingData).trainingDataFilename(\"weather_data_train.csv\").build();\n+    final Classifier response = service.createClassifier(createOptions).execute();",
                    "-  @Test(expected = IllegalArgumentException.class)\n-  public void testNullTrainingDataFile() {\n-    service.createClassifier(null, null, new File(\"src/test/resources/notfound.txt\"));\n+  @Test(expected = FileNotFoundException.class)\n+  public void testNullTrainingDataFile() throws FileNotFoundException {\n+    server.enqueue(jsonResponse(classifier));\n+    File metadata = new File(RESOURCE + \"metadata.json\");\n+    File trainingData = new File(RESOURCE + \"notfound.txt\");\n+    CreateClassifierOptions createOptions = new CreateClassifierOptions.Builder().metadata(metadata).trainingData(trainingData).trainingDataFilename(\"notfound.txt\").build();\n+    service.createClassifier(createOptions).execute();",
                    "-    service.classify(classifierId, null);\n+    ClassifyOptions classifyOptions = new ClassifyOptions.Builder().classifierId(classifierId).build();\n+    service.classify(classifyOptions);"
                ]
            }
        ]
    },
    {
        "id": 117,
        "Anal": "The method \"classify\" no longer takes two parameters \"classifierId\" and \"text\". Instead, it now takes a single parameter of type \"ClassifyOptions\".",
        "Stmts": "service.classify(classifierId, null);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public ServiceCall<Void> deleteClassifier(String classifierId) {\n-    Validator.isTrue((classifierId != null) && !classifierId.isEmpty(), \"classifierId cannot be null or empty\");\n-    final Request request = RequestBuilder.delete(String.format(PATH_CLASSIFIER, classifierId)).build();\n-    return createServiceCall(request, ResponseConverterUtils.getVoid());\n+  public ServiceCall<Void> deleteClassifier(DeleteClassifierOptions deleteClassifierOptions) {\n+    Validator.notNull(deleteClassifierOptions, \"deleteClassifierOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/classifiers/%s\", deleteClassifierOptions.classifierId()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());",
                    "-  public ServiceCall<Classifier> getClassifier(String classifierId) {\n-    Validator.isTrue((classifierId != null) && !classifierId.isEmpty(), \"classifierId cannot be null or empty\");\n-    final Request request = RequestBuilder.get(String.format(PATH_CLASSIFIER, classifierId)).build();\n-    return createServiceCall(request, ResponseConverterUtils.getObject(Classifier.class));\n+  public ServiceCall<Classifier> getClassifier(GetClassifierOptions getClassifierOptions) {\n+    Validator.notNull(getClassifierOptions, \"getClassifierOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/classifiers/%s\", getClassifierOptions.classifierId()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Classifier.class));",
                    "+  public ServiceCall<Classifier> createClassifier(CreateClassifierOptions createClassifierOptions) {\n+    Validator.notNull(createClassifierOptions, \"createClassifierOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.post(\"/v1/classifiers\");\n+    MultipartBody.Builder multipartBuilder = new MultipartBody.Builder();\n+    multipartBuilder.setType(MultipartBody.FORM);\n+    RequestBody trainingMetadataBody = RequestUtils.inputStreamBody(createClassifierOptions.metadata(), \"application/json\");\n+    multipartBuilder.addFormDataPart(\"training_metadata\", createClassifierOptions.metadataFilename(), trainingMetadataBody);\n+    RequestBody trainingDataBody = RequestUtils.inputStreamBody(createClassifierOptions.trainingData(), \"text/csv\");\n+    multipartBuilder.addFormDataPart(\"training_data\", createClassifierOptions.trainingDataFilename(), trainingDataBody);\n+    builder.body(multipartBuilder.build());"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    final Classification result = service.classify(classifierId, classification.getText()).execute();\n+    ClassifyOptions classifyOptions = new ClassifyOptions.Builder().classifierId(classifierId).text(classification.getText()).build();\n+    final Classification result = service.classify(classifyOptions).execute();",
                    "-  @Test(expected = IllegalArgumentException.class)\n-  public void testNullTrainingDataFile() {\n-    service.createClassifier(null, null, new File(\"src/test/resources/notfound.txt\"));\n+  @Test(expected = FileNotFoundException.class)\n+  public void testNullTrainingDataFile() throws FileNotFoundException {\n+    server.enqueue(jsonResponse(classifier));\n+    File metadata = new File(RESOURCE + \"metadata.json\");\n+    File trainingData = new File(RESOURCE + \"notfound.txt\");\n+    CreateClassifierOptions createOptions = new CreateClassifierOptions.Builder().metadata(metadata).trainingData(trainingData).trainingDataFilename(\"notfound.txt\").build();\n+    service.createClassifier(createOptions).execute();",
                    "-    final Classifier response = service.createClassifier(classifierId, \"en\", new File(\"src/test/resources/natural_language_classifier/weather_data_train.csv\")).execute();\n+    File metadata = new File(RESOURCE + \"metadata.json\");\n+    File trainingData = new File(RESOURCE + \"weather_data_train.csv\");\n+    CreateClassifierOptions createOptions = new CreateClassifierOptions.Builder().metadata(metadata).trainingData(trainingData).trainingDataFilename(\"weather_data_train.csv\").build();\n+    final Classifier response = service.createClassifier(createOptions).execute();"
                ]
            }
        ]
    },
    {
        "id": 118,
        "Anal": "The parameter \"classifierId\" of the method \"deleteClassifier\" changes from `String` to `DeleteClassifierOptions`.",
        "Stmts": "service.deleteClassifier(\"\");",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public ServiceCall<Classifier> getClassifier(String classifierId) {\n-    Validator.isTrue((classifierId != null) && !classifierId.isEmpty(), \"classifierId cannot be null or empty\");\n-    final Request request = RequestBuilder.get(String.format(PATH_CLASSIFIER, classifierId)).build();\n-    return createServiceCall(request, ResponseConverterUtils.getObject(Classifier.class));\n+  public ServiceCall<Classifier> getClassifier(GetClassifierOptions getClassifierOptions) {\n+    Validator.notNull(getClassifierOptions, \"getClassifierOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/classifiers/%s\", getClassifierOptions.classifierId()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Classifier.class));",
                    "+  public ServiceCall<Classifier> createClassifier(CreateClassifierOptions createClassifierOptions) {\n+    Validator.notNull(createClassifierOptions, \"createClassifierOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.post(\"/v1/classifiers\");\n+    MultipartBody.Builder multipartBuilder = new MultipartBody.Builder();\n+    multipartBuilder.setType(MultipartBody.FORM);\n+    RequestBody trainingMetadataBody = RequestUtils.inputStreamBody(createClassifierOptions.metadata(), \"application/json\");\n+    multipartBuilder.addFormDataPart(\"training_metadata\", createClassifierOptions.metadataFilename(), trainingMetadataBody);\n+    RequestBody trainingDataBody = RequestUtils.inputStreamBody(createClassifierOptions.trainingData(), \"text/csv\");\n+    multipartBuilder.addFormDataPart(\"training_data\", createClassifierOptions.trainingDataFilename(), trainingDataBody);\n+    builder.body(multipartBuilder.build());",
                    "-  public ServiceCall<Classifiers> getClassifiers() {\n-    final Request request = RequestBuilder.get(PATH_CLASSIFIERS).build();\n-    return createServiceCall(request, ResponseConverterUtils.getObject(Classifiers.class));\n+  public ServiceCall<ClassifierList> listClassifiers(ListClassifiersOptions listClassifiersOptions) {\n+    RequestBuilder builder = RequestBuilder.get(\"/v1/classifiers\");\n+    if (listClassifiersOptions != null) {}\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(ClassifierList.class));\n+  }\n+  public ServiceCall<ClassifierList> listClassifiers() {\n+    return listClassifiers(null);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    service.deleteClassifier(classifierId);\n+    DeleteClassifierOptions deleteOptions = new DeleteClassifierOptions.Builder().classifierId(classifierId).build();\n+    service.deleteClassifier(deleteOptions);",
                    "-    final Classifiers response = service.getClassifiers().execute();\n+    final ClassifierList response = service.listClassifiers().execute();",
                    "-    service.classify(classifierId, null);\n+    ClassifyOptions classifyOptions = new ClassifyOptions.Builder().classifierId(classifierId).build();\n+    service.classify(classifyOptions);"
                ]
            }
        ]
    },
    {
        "id": 119,
        "Anal": "The return type of the method \"synthesize\" changes from `InputStream` to `ServiceCall<InputStream>`.",
        "Stmts": "final InputStream in = service.synthesize(text, Voice.EN_LISA, HttpMediaType.AUDIO_WAV);\nAssert.assertNotNull(in);\nwriteInputStreamToOutputStream(in, new FileOutputStream(\"target/output.wav\"));",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public InputStream synthesize(final String text, final Voice voice) {\n+  public ServiceCall<InputStream> synthesize(final String text, final Voice voice) {",
                    "-  public List<Voice> getVoices() {\n-    final Request request = RequestBuilder.get(\"/v1/voices\").build();\n-    final Response response = execute(request);\n-    final JsonObject jsonObject = ResponseUtil.getJsonObject(response);\n-    final List<Voice> voices = GsonSingleton.getGsonWithoutPrettyPrinting().fromJson(jsonObject.get(\"voices\"), listVoiceType);\n-    return voices;\n+  public ServiceCall<List<Voice>> getVoices() {\n+    final okhttp3.Request request = RequestBuilder.get(\"/v1/voices\").build3();\n+    return createServiceCall(createCall(request), ResponseUtil.getVoiceListConverter(listVoiceType));",
                    "-  public InputStream synthesize(final String text, final String format) {\n+  public ServiceCall<InputStream> synthesize(final String text, final String format) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    final List<Voice> result = service.getVoices();\n+    final List<Voice> result = service.getVoices().execute();",
                    "-    final InputStream is = service.synthesize(text, Voice.EN_LISA, HttpMediaType.AUDIO_WAV);\n+    final InputStream is = service.synthesize(text, Voice.EN_LISA, HttpMediaType.AUDIO_WAV).execute();"
                ]
            }
        ]
    },
    {
        "id": 120,
        "Anal": "The return type of the method \"getModel\" changes from `SpeechModel` to `ServiceCall<SpeechModel>`.",
        "Stmts": "SpeechModel model = service.getModel(\"not-a-real-Model\");\nmodel = service.getModel(speechModel.getName());",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    String path = PATH_RECOGNIZE;\n-    if (options != null && (options.getSessionId() != null && !options.getSessionId().isEmpty()))\n-      path = String.format(PATH_SESSION_RECOGNIZE, options.getSessionId());\n-    final RequestBuilder requestBuilder = RequestBuilder.post(path);\n-    buildRecognizeRequest(requestBuilder, options);\n-    requestBuilder.withBody(RequestBody.create(MediaType.parse(contentType), audio));\n+    requestBuilder.withBody(okhttp3.RequestBody.create(okhttp3.MediaType.parse(contentType), audio));",
                    "-  public SpeechResults recognize(File audio, String contentType, RecognizeOptions options) {\n+  public ServiceCall<SpeechResults> recognize(File audio, String contentType, RecognizeOptions options) {",
                    "-  public SpeechResults recognize(File audio, RecognizeOptions options) {\n+  public ServiceCall<SpeechResults> recognize(File audio, RecognizeOptions options) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    final List<SpeechModel> models = service.getModels();\n+    final List<SpeechModel> models = service.getModels().execute();",
                    "-    service.getModel(model);\n+    service.getModel(model).execute();",
                    "-      service.recognize(null);\n+      service.recognize(null).execute();"
                ]
            }
        ]
    },
    {
        "id": 121,
        "Anal": "The return type of the method \"recognize\" changes from `SpeechResults` to `ServiceCall<SpeechResults>`.",
        "Stmts": "service.recognize(null);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    String path = PATH_RECOGNIZE;\n-    if (options != null && (options.getSessionId() != null && !options.getSessionId().isEmpty()))\n-      path = String.format(PATH_SESSION_RECOGNIZE, options.getSessionId());\n-    final RequestBuilder requestBuilder = RequestBuilder.post(path);\n-    buildRecognizeRequest(requestBuilder, options);\n-    requestBuilder.withBody(RequestBody.create(MediaType.parse(contentType), audio));\n+    requestBuilder.withBody(okhttp3.RequestBody.create(okhttp3.MediaType.parse(contentType), audio));",
                    "-  public SpeechResults recognize(File audio, String contentType, RecognizeOptions options) {\n+  public ServiceCall<SpeechResults> recognize(File audio, String contentType, RecognizeOptions options) {",
                    "-  public SpeechResults recognize(File audio, RecognizeOptions options) {\n+  public ServiceCall<SpeechResults> recognize(File audio, RecognizeOptions options) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    final SpeechResults result = service.recognize(audio);\n+    final SpeechResults result = service.recognize(audio).execute();",
                    "-    service.deleteSession(null);\n+    service.deleteSession(null).execute();",
                    "-    SpeechModel model = service.getModel(\"not-a-real-Model\");\n+    SpeechModel model = service.getModel(\"not-a-real-Model\").execute();"
                ]
            }
        ]
    },
    {
        "id": 122,
        "Anal": "The return type of the method \"getVoices\" changes from `List<Voice>` to `ServiceCall<List<Voice>>`.",
        "Stmts": "final List<Voice> result = service.getVoices();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public InputStream synthesize(final String text, final Voice voice) {\n+  public ServiceCall<InputStream> synthesize(final String text, final Voice voice) {",
                    "-  public ServiceCall<InputStream> synthesize3(final String text, final Voice voice, final String outputFormat) {\n+  public ServiceCall<InputStream> synthesize(final String text, final Voice voice, final String outputFormat) {",
                    "-  public InputStream synthesize(final String text, final String format) {\n+  public ServiceCall<InputStream> synthesize(final String text, final String format) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    final InputStream is = service.synthesize(text, Voice.EN_LISA, HttpMediaType.AUDIO_WAV);\n+    final InputStream is = service.synthesize(text, Voice.EN_LISA, HttpMediaType.AUDIO_WAV).execute();",
                    "-      final InputStream in = service.synthesize(text, Voice.EN_LISA, HttpMediaType.AUDIO_WAV);\n+      final InputStream in = service.synthesize(text, Voice.EN_LISA, HttpMediaType.AUDIO_WAV).execute();"
                ]
            }
        ]
    },
    {
        "id": 123,
        "Anal": "The parameters of the method \"deleteCorpus\" have been changed from two strings \"customizationId\" and \"corpusName\" to a single `DeleteCorpusOptions` object.",
        "Stmts": "service.deleteCorpus(id, corpus).execute();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+      builder.query(\"allow_overwrite\", String.valueOf(addAudioOptions.allowOverwrite()));\n+    }\n+    builder.body(RequestBody.create(MediaType.parse(addAudioOptions.contentType()), addAudioOptions.audioResource()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<Void> deleteAudio(DeleteAudioOptions deleteAudioOptions) {\n+    Validator.notNull(deleteAudioOptions, \"deleteAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", deleteAudioOptions.customizationId(), deleteAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }",
                    "+    } else {\n+      builder.bodyContent(addWordsOptions.body(), addWordsOptions.contentType());\n+    }\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<Void> deleteWord(DeleteWordOptions deleteWordOptions) {\n+    Validator.notNull(deleteWordOptions, \"deleteWordOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/customizations/%s/words/%s\", deleteWordOptions.customizationId(), deleteWordOptions.wordName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }",
                    "+    Validator.notNull(getSessionStatusOptions, \"getSessionStatusOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/sessions/%s/recognize\", getSessionStatusOptions.sessionId()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(SessionStatus.class));\n+  }\n+  public ServiceCall<RecognitionJob> checkJob(CheckJobOptions checkJobOptions) {\n+    Validator.notNull(checkJobOptions, \"checkJobOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/recognitions/%s\", checkJobOptions.id()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(RecognitionJob.class));\n+  }\n+  public ServiceCall<RecognitionJobs> checkJobs(CheckJobsOptions checkJobsOptions) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    service.getCorpus(id, corpus).execute();\n+    GetCorpusOptions getOptions = new GetCorpusOptions.Builder().customizationId(id).corpusName(corpus).build();\n+    service.getCorpus(getOptions).execute();",
                    "-    List<Corpus> result = service.getCorpora(id).execute();\n+    ListCorporaOptions listOptions = new ListCorporaOptions.Builder().customizationId(id).build();\n+    Corpora result = service.listCorpora(listOptions).execute();",
                    "-    service.deleteWord(id, wordName).execute();\n+    DeleteWordOptions deleteOptions = new DeleteWordOptions.Builder().customizationId(id).wordName(wordName).build();\n+    service.deleteWord(deleteOptions).execute();"
                ]
            }
        ]
    },
    {
        "id": 124,
        "Anal": "The return type of the method \"getModels\" changes from `ServiceCall<List<SpeechModel>>` to `ServiceCall<SpeechModels>`.",
        "Stmts": "final List<SpeechModel> models = service.getModels().execute();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+    Validator.notNull(deleteWordOptions, \"deleteWordOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/customizations/%s/words/%s\", deleteWordOptions.customizationId(), deleteWordOptions.wordName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<Word> getWord(GetWordOptions getWordOptions) {\n+    Validator.notNull(getWordOptions, \"getWordOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/customizations/%s/words/%s\", getWordOptions.customizationId(), getWordOptions.wordName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Word.class));\n+  }\n+  public ServiceCall<Words> listWords(ListWordsOptions listWordsOptions) {",
                    "+    Validator.notNull(deleteAudioOptions, \"deleteAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", deleteAudioOptions.customizationId(), deleteAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<AudioListing> getAudio(GetAudioOptions getAudioOptions) {\n+    Validator.notNull(getAudioOptions, \"getAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", getAudioOptions.customizationId(), getAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(AudioListing.class));\n+  }\n+  public ServiceCall<AudioResources> listAudio(ListAudioOptions listAudioOptions) {",
                    "+    Validator.notNull(getSessionStatusOptions, \"getSessionStatusOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/sessions/%s/recognize\", getSessionStatusOptions.sessionId()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(SessionStatus.class));\n+  }\n+  public ServiceCall<RecognitionJob> checkJob(CheckJobOptions checkJobOptions) {\n+    Validator.notNull(checkJobOptions, \"checkJobOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/recognitions/%s\", checkJobOptions.id()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(RecognitionJob.class));\n+  }\n+  public ServiceCall<RecognitionJobs> checkJobs(CheckJobsOptions checkJobsOptions) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    SpeechModel model = service.getModel(\"not-a-real-Model\").execute();\n+    GetModelOptions getOptionsString = new GetModelOptions.Builder().modelId(\"not-a-real-Model\").build();\n+    SpeechModel model = service.getModel(getOptionsString).execute();",
                    "-    model = service.getModel(speechModel.getName()).execute();\n+    GetModelOptions getOptionsGetter = new GetModelOptions.Builder().modelId(speechModel.getName()).build();\n+    model = service.getModel(getOptionsGetter).execute();",
                    "+  }\n+  @Test\n+  public void testGetLanguageModel() throws InterruptedException, FileNotFoundException {\n+    String id = \"foo\";\n+    LanguageModel model = loadFixture(\"src/test/resources/speech_to_text/customization.json\", LanguageModel.class);\n+    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(model)));\n+    GetLanguageModelOptions getOptions = new GetLanguageModelOptions.Builder().customizationId(id).build();\n+    LanguageModel result = service.getLanguageModel(getOptions).execute();"
                ]
            }
        ]
    },
    {
        "id": 125,
        "Anal": "The method \"recognize\" has changed its parameter from `File` to `RecognizeOptions` and its return type from `SpeechResults` to `SpeechRecognitionResults`.",
        "Stmts": "final SpeechResults result = service.recognize(SAMPLE_WAV).execute();\nassertEquals(result, speechResults);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+    Validator.notNull(deleteWordOptions, \"deleteWordOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/customizations/%s/words/%s\", deleteWordOptions.customizationId(), deleteWordOptions.wordName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<Word> getWord(GetWordOptions getWordOptions) {\n+    Validator.notNull(getWordOptions, \"getWordOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/customizations/%s/words/%s\", getWordOptions.customizationId(), getWordOptions.wordName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Word.class));\n+  }\n+  public ServiceCall<Words> listWords(ListWordsOptions listWordsOptions) {",
                    "+    Validator.notNull(deleteAudioOptions, \"deleteAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", deleteAudioOptions.customizationId(), deleteAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<AudioListing> getAudio(GetAudioOptions getAudioOptions) {\n+    Validator.notNull(getAudioOptions, \"getAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", getAudioOptions.customizationId(), getAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(AudioListing.class));\n+  }\n+  public ServiceCall<AudioResources> listAudio(ListAudioOptions listAudioOptions) {",
                    "+    Validator.notNull(getSessionStatusOptions, \"getSessionStatusOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/sessions/%s/recognize\", getSessionStatusOptions.sessionId()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(SessionStatus.class));\n+  }\n+  public ServiceCall<RecognitionJob> checkJob(CheckJobOptions checkJobOptions) {\n+    Validator.notNull(checkJobOptions, \"checkJobOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/recognitions/%s\", checkJobOptions.id()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(RecognitionJob.class));\n+  }\n+  public ServiceCall<RecognitionJobs> checkJobs(CheckJobsOptions checkJobsOptions) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    RecognizeOptions options = new RecognizeOptions.Builder().customizationId(id).customizationWeight(0.5).build();\n-    SpeechResults result = service.recognize(SAMPLE_WAV, options).execute();\n+    RecognizeOptions recognizeOptions = new RecognizeOptions.Builder().audio(SAMPLE_WAV).contentType(RecognizeOptions.ContentType.AUDIO_WAV).customizationId(id).customizationWeight(0.5).build();\n+    SpeechRecognitionResults result = service.recognize(recognizeOptions).execute();",
                    "-    RecognizeOptions options = new RecognizeOptions.Builder().customizationId(id).build();\n-    SpeechResults result = service.recognize(SAMPLE_WAV, options).execute();\n+    RecognizeOptions recognizeOptions = new RecognizeOptions.Builder().audio(SAMPLE_WAV).contentType(RecognizeOptions.ContentType.AUDIO_WAV).customizationId(id).build();\n+    SpeechRecognitionResults result = service.recognize(recognizeOptions).execute();",
                    "-    final SpeechResults result = service.recognize(SAMPLE_WEBM).execute();\n+    RecognizeOptions recognizeOptions = new RecognizeOptions.Builder().audio(SAMPLE_WEBM).contentType(RecognizeOptions.ContentType.AUDIO_WEBM).build();\n+    final SpeechRecognitionResults result = service.recognize(recognizeOptions).execute();"
                ]
            }
        ]
    },
    {
        "id": 126,
        "Anal": "The \"recognize\" method has been changed to only accept a single parameter of type `RecognizeOptions`. The return type has also been changed from `SpeechResults` to `SpeechRecognitionResults`.",
        "Stmts": "RecognizeOptions options = new RecognizeOptions.Builder().customizationId(id).build();\nSpeechResults result = service.recognize(SAMPLE_WAV, options).execute();\nassertEquals(recognition, GSON.toJsonTree(result));",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+    Validator.notNull(deleteWordOptions, \"deleteWordOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/customizations/%s/words/%s\", deleteWordOptions.customizationId(), deleteWordOptions.wordName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<Word> getWord(GetWordOptions getWordOptions) {\n+    Validator.notNull(getWordOptions, \"getWordOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/customizations/%s/words/%s\", getWordOptions.customizationId(), getWordOptions.wordName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Word.class));\n+  }\n+  public ServiceCall<Words> listWords(ListWordsOptions listWordsOptions) {",
                    "+    Validator.notNull(deleteAudioOptions, \"deleteAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", deleteAudioOptions.customizationId(), deleteAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<AudioListing> getAudio(GetAudioOptions getAudioOptions) {\n+    Validator.notNull(getAudioOptions, \"getAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", getAudioOptions.customizationId(), getAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(AudioListing.class));\n+  }\n+  public ServiceCall<AudioResources> listAudio(ListAudioOptions listAudioOptions) {",
                    "+    Validator.notNull(getSessionStatusOptions, \"getSessionStatusOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/sessions/%s/recognize\", getSessionStatusOptions.sessionId()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(SessionStatus.class));\n+  }\n+  public ServiceCall<RecognitionJob> checkJob(CheckJobOptions checkJobOptions) {\n+    Validator.notNull(checkJobOptions, \"checkJobOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/recognitions/%s\", checkJobOptions.id()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(RecognitionJob.class));\n+  }\n+  public ServiceCall<RecognitionJobs> checkJobs(CheckJobsOptions checkJobsOptions) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    RecognizeOptions options = new RecognizeOptions.Builder().customizationId(id).customizationWeight(0.5).build();\n-    SpeechResults result = service.recognize(SAMPLE_WAV, options).execute();\n+    RecognizeOptions recognizeOptions = new RecognizeOptions.Builder().audio(SAMPLE_WAV).contentType(RecognizeOptions.ContentType.AUDIO_WAV).customizationId(id).customizationWeight(0.5).build();\n+    SpeechRecognitionResults result = service.recognize(recognizeOptions).execute();",
                    "-    RecognizeOptions options = new RecognizeOptions.Builder().speakerLabels(true).build();\n-    SpeechResults result = service.recognize(SAMPLE_WAV, options).execute();\n+    RecognizeOptions recognizeOptions = new RecognizeOptions.Builder().audio(SAMPLE_WAV).contentType(RecognizeOptions.ContentType.AUDIO_WAV).speakerLabels(true).build();\n+    SpeechRecognitionResults result = service.recognize(recognizeOptions).execute();",
                    "-    final SpeechResults result = service.recognize(SAMPLE_WAV).execute();\n+    RecognizeOptions recognizeOptions = new RecognizeOptions.Builder().audio(SAMPLE_WAV).contentType(RecognizeOptions.ContentType.AUDIO_WAV).build();\n+    final SpeechRecognitionResults result = service.recognize(recognizeOptions).execute();"
                ]
            }
        ]
    },
    {
        "id": 127,
        "Anal": "The method \"getCustomizations\" has been replaced with \"listLanguageModels\" which takes a different parameter type `ListLanguageModelsOptions` instead of a `String`.",
        "Stmts": "List<Customization> result = service.getCustomizations(\"en-us\").execute();\nassertEquals(PATH_CUSTOMIZATIONS + \"?language=en-us\", request.getPath());\nassertEquals(customizations.get(\"customizations\").getAsJsonArray().size(), result.size());\nassertEquals(customizations.get(\"customizations\"), GSON.toJsonTree(result));",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+  }\n+  public ServiceCall<Void> deleteWord(DeleteWordOptions deleteWordOptions) {\n+    Validator.notNull(deleteWordOptions, \"deleteWordOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/customizations/%s/words/%s\", deleteWordOptions.customizationId(), deleteWordOptions.wordName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<Word> getWord(GetWordOptions getWordOptions) {\n+    Validator.notNull(getWordOptions, \"getWordOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/customizations/%s/words/%s\", getWordOptions.customizationId(), getWordOptions.wordName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Word.class));",
                    "+  }\n+  public ServiceCall<Void> deleteAudio(DeleteAudioOptions deleteAudioOptions) {\n+    Validator.notNull(deleteAudioOptions, \"deleteAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", deleteAudioOptions.customizationId(), deleteAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<AudioListing> getAudio(GetAudioOptions getAudioOptions) {\n+    Validator.notNull(getAudioOptions, \"getAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", getAudioOptions.customizationId(), getAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(AudioListing.class));",
                    "+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<Corpus> getCorpus(GetCorpusOptions getCorpusOptions) {\n+    Validator.notNull(getCorpusOptions, \"getCorpusOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/customizations/%s/corpora/%s\", getCorpusOptions.customizationId(), getCorpusOptions.corpusName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Corpus.class));\n+  }\n+  public ServiceCall<Corpora> listCorpora(ListCorporaOptions listCorporaOptions) {\n+    Validator.notNull(listCorporaOptions, \"listCorporaOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/customizations/%s/corpora\", listCorporaOptions.customizationId()));"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    assertEquals(jobsAsJson.get(\"recognitions\"), GSON.toJsonTree(result));\n-  }\n-  @Test\n-  public void testGetCustomization() throws InterruptedException, FileNotFoundException {\n-    String id = \"foo\";\n-    Customization customization = loadFixture(\"src/test/resources/speech_to_text/customization.json\", Customization.class);\n-    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(customization)));\n-    Customization result = service.getCustomization(id).execute();\n+    assertEquals(jobsAsJson.get(\"recognitions\"), GSON.toJsonTree(result.getRecognitions()));\n+  }",
                    "-    assertEquals(result.toString(), customization.toString());\n-  }\n-  @Test\n-  public void testCreateCustomization() throws InterruptedException, FileNotFoundException {\n-    Customization customization = loadFixture(\"src/test/resources/speech_to_text/customization.json\", Customization.class);\n-    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(customization)));\n-    Customization result = service.createCustomization(customization.getName(), SpeechModel.EN_GB_BROADBANDMODEL, customization.getDescription()).execute();\n+    assertEquals(result.toString(), model.toString());\n+  }\n+  @Test",
                    "-    assertEquals(result.toString(), customization.toString());\n-  }\n-  @Test\n-  public void testDeleteCustomization() throws InterruptedException {\n-    String id = \"foo\";\n-    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(\"{}\"));\n-    service.deleteCustomization(id).execute();\n+    assertEquals(result.toString(), model.toString());\n+  }\n+  @Test"
                ]
            }
        ]
    },
    {
        "id": 128,
        "Anal": "The method \"getCustomization\" has been changed to \"getLanguageModel\" and the parameter type has changed from `String` to `GetLanguageModelOptions`.",
        "Stmts": "String id = \"foo\";\nCustomization result = service.getCustomization(id).execute();\nassertEquals(String.format(PATH_CUSTOMIZATION, id), request.getPath());\nassertEquals(result.toString(), customization.toString());",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+  }\n+  public ServiceCall<Void> deleteCorpus(DeleteCorpusOptions deleteCorpusOptions) {\n+    Validator.notNull(deleteCorpusOptions, \"deleteCorpusOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/customizations/%s/corpora/%s\", deleteCorpusOptions.customizationId(), deleteCorpusOptions.corpusName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<Corpus> getCorpus(GetCorpusOptions getCorpusOptions) {\n+    Validator.notNull(getCorpusOptions, \"getCorpusOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/customizations/%s/corpora/%s\", getCorpusOptions.customizationId(), getCorpusOptions.corpusName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Corpus.class));",
                    "+      builder.query(\"allow_overwrite\", String.valueOf(addAudioOptions.allowOverwrite()));\n+    }\n+    builder.body(RequestBody.create(MediaType.parse(addAudioOptions.contentType()), addAudioOptions.audioResource()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<Void> deleteAudio(DeleteAudioOptions deleteAudioOptions) {\n+    Validator.notNull(deleteAudioOptions, \"deleteAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", deleteAudioOptions.customizationId(), deleteAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }",
                    "+      builder.query(\"version\", recognizeOptions.version());\n+    }\n+    if (recognizeOptions.inactivityTimeout() != null) {\n+      builder.query(\"inactivity_timeout\", recognizeOptions.inactivityTimeout());\n+    }\n+    if (recognizeOptions.keywords() != null) {\n+      builder.query(\"keywords\", RequestUtils.join(recognizeOptions.keywords(), \",\"));\n+    }\n+    if (recognizeOptions.keywordsThreshold() != null) {\n+      builder.query(\"keywords_threshold\", recognizeOptions.keywordsThreshold());"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    assertEquals(result.toString(), customization.toString());\n-  }\n-  @Test\n-  public void testDeleteCustomization() throws InterruptedException {\n-    String id = \"foo\";\n-    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(\"{}\"));\n-    service.deleteCustomization(id).execute();\n+    assertEquals(result.toString(), model.toString());\n+  }\n+  @Test",
                    "-  public void testResetCustomization() throws InterruptedException, FileNotFoundException {\n-    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(\"{}\"));\n-    String id = \"foo\";\n-    service.resetCustomization(id).execute();\n+  public void testResetLanguageModel() throws InterruptedException, FileNotFoundException {\n+    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(\"{}\"));\n+    String id = \"foo\";\n+    ResetLanguageModelOptions resetOptions = new ResetLanguageModelOptions.Builder().customizationId(id).build();\n+    service.resetLanguageModel(resetOptions).execute();",
                    "-  public void testTrainCustomization() throws InterruptedException, FileNotFoundException {\n-    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(\"{}\"));\n-    String id = \"foo\";\n-    service.trainCustomization(id, WordTypeToAdd.ALL).execute();\n+  public void testTrainLanguageModel() throws InterruptedException, FileNotFoundException {\n+    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(\"{}\"));\n+    String id = \"foo\";\n+    TrainLanguageModelOptions trainOptions = new TrainLanguageModelOptions.Builder().customizationId(id).wordTypeToAdd(TrainLanguageModelOptions.WordTypeToAdd.ALL).build();\n+    service.trainLanguageModel(trainOptions).execute();"
                ]
            }
        ]
    },
    {
        "id": 129,
        "Anal": "The method \"createCustomization\" has been changed to \"createLanguageModel\" and the parameters have been replaced with a single parameter of type \"CreateLanguageModelOptions\".",
        "Stmts": "Customization result = service.createCustomization(customization.getName(), SpeechModel.EN_GB_BROADBANDMODEL, customization.getDescription()).execute();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+    Validator.notNull(deleteWordOptions, \"deleteWordOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/customizations/%s/words/%s\", deleteWordOptions.customizationId(), deleteWordOptions.wordName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<Word> getWord(GetWordOptions getWordOptions) {\n+    Validator.notNull(getWordOptions, \"getWordOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/customizations/%s/words/%s\", getWordOptions.customizationId(), getWordOptions.wordName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Word.class));\n+  }\n+  public ServiceCall<Words> listWords(ListWordsOptions listWordsOptions) {",
                    "+    Validator.notNull(deleteAudioOptions, \"deleteAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", deleteAudioOptions.customizationId(), deleteAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<AudioListing> getAudio(GetAudioOptions getAudioOptions) {\n+    Validator.notNull(getAudioOptions, \"getAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", getAudioOptions.customizationId(), getAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(AudioListing.class));\n+  }\n+  public ServiceCall<AudioResources> listAudio(ListAudioOptions listAudioOptions) {",
                    "+    }\n+    if (recognizeOptions.version() != null) {\n+      builder.query(\"version\", recognizeOptions.version());\n+    }\n+    if (recognizeOptions.inactivityTimeout() != null) {\n+      builder.query(\"inactivity_timeout\", recognizeOptions.inactivityTimeout());\n+    }\n+    if (recognizeOptions.keywords() != null) {\n+      builder.query(\"keywords\", RequestUtils.join(recognizeOptions.keywords(), \",\"));\n+    }"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    assertEquals(customizations.get(\"customizations\").getAsJsonArray().size(), result.size());\n-    assertEquals(customizations.get(\"customizations\"), GSON.toJsonTree(result));\n-  }\n-  @Test\n-  public void testGetCustomization() throws InterruptedException, FileNotFoundException {\n-    String id = \"foo\";\n-    Customization customization = loadFixture(\"src/test/resources/speech_to_text/customization.json\", Customization.class);\n-    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(customization)));\n-    Customization result = service.getCustomization(id).execute();\n+    assertEquals(customizations.get(\"customizations\").getAsJsonArray().size(), result.getCustomizations().size());",
                    "-    List<Customization> result = service.getCustomizations(\"en-us\").execute();\n+    ListLanguageModelsOptions listOptions = new ListLanguageModelsOptions.Builder().language(\"en-us\").build();\n+    LanguageModels result = service.listLanguageModels(listOptions).execute();",
                    "-    assertEquals(result.toString(), customization.toString());\n-  }\n-  @Test\n-  public void testDeleteCustomization() throws InterruptedException {\n-    String id = \"foo\";\n-    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(\"{}\"));\n-    service.deleteCustomization(id).execute();\n+    assertEquals(result.toString(), model.toString());\n+  }\n+  @Test"
                ]
            }
        ]
    },
    {
        "id": 130,
        "Anal": "The method \"deleteCustomization\" has been replaced by the method \"deleteLanguageModel\" which takes a different parameter type `DeleteLanguageModelOptions`.",
        "Stmts": "String id = \"foo\";\nservice.deleteCustomization(id).execute();\nassertEquals(String.format(PATH_CUSTOMIZATION, id), request.getPath());",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+  }\n+  public ServiceCall<Void> deleteCorpus(DeleteCorpusOptions deleteCorpusOptions) {\n+    Validator.notNull(deleteCorpusOptions, \"deleteCorpusOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/customizations/%s/corpora/%s\", deleteCorpusOptions.customizationId(), deleteCorpusOptions.corpusName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<Corpus> getCorpus(GetCorpusOptions getCorpusOptions) {\n+    Validator.notNull(getCorpusOptions, \"getCorpusOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/customizations/%s/corpora/%s\", getCorpusOptions.customizationId(), getCorpusOptions.corpusName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Corpus.class));",
                    "+      builder.query(\"allow_overwrite\", String.valueOf(addAudioOptions.allowOverwrite()));\n+    }\n+    builder.body(RequestBody.create(MediaType.parse(addAudioOptions.contentType()), addAudioOptions.audioResource()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<Void> deleteAudio(DeleteAudioOptions deleteAudioOptions) {\n+    Validator.notNull(deleteAudioOptions, \"deleteAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", deleteAudioOptions.customizationId(), deleteAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }",
                    "+      builder.query(\"version\", recognizeOptions.version());\n+    }\n+    if (recognizeOptions.inactivityTimeout() != null) {\n+      builder.query(\"inactivity_timeout\", recognizeOptions.inactivityTimeout());\n+    }\n+    if (recognizeOptions.keywords() != null) {\n+      builder.query(\"keywords\", RequestUtils.join(recognizeOptions.keywords(), \",\"));\n+    }\n+    if (recognizeOptions.keywordsThreshold() != null) {\n+      builder.query(\"keywords_threshold\", recognizeOptions.keywordsThreshold());"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    assertEquals(customizations.get(\"customizations\").getAsJsonArray().size(), result.size());\n-    assertEquals(customizations.get(\"customizations\"), GSON.toJsonTree(result));\n-  }\n-  @Test\n-  public void testGetCustomization() throws InterruptedException, FileNotFoundException {\n-    String id = \"foo\";\n-    Customization customization = loadFixture(\"src/test/resources/speech_to_text/customization.json\", Customization.class);\n-    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(customization)));\n-    Customization result = service.getCustomization(id).execute();\n+    assertEquals(customizations.get(\"customizations\").getAsJsonArray().size(), result.getCustomizations().size());",
                    "-    assertEquals(result.toString(), customization.toString());\n-  }\n-  @Test\n-  public void testTrainCustomization() throws InterruptedException, FileNotFoundException {\n-    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(\"{}\"));\n-    String id = \"foo\";\n-    service.trainCustomization(id, WordTypeToAdd.ALL).execute();\n+    assertEquals(result.toString(), model.toString());\n+  }\n+  @Test",
                    "-  public void testResetCustomization() throws InterruptedException, FileNotFoundException {\n-    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(\"{}\"));\n-    String id = \"foo\";\n-    service.resetCustomization(id).execute();\n+  public void testResetLanguageModel() throws InterruptedException, FileNotFoundException {\n+    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(\"{}\"));\n+    String id = \"foo\";\n+    ResetLanguageModelOptions resetOptions = new ResetLanguageModelOptions.Builder().customizationId(id).build();\n+    service.resetLanguageModel(resetOptions).execute();"
                ]
            }
        ]
    },
    {
        "id": 131,
        "Anal": "The method name changes from \"getCorpora\" to \"listCorpora\" and the parameter changes from a single string \"customizationId\" to a \"ListCorporaOptions\" object.",
        "Stmts": "List<Corpus> result = service.getCorpora(id).execute();\nassertEquals(String.format(PATH_CORPORA, id), request.getPath());",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+      builder.query(\"allow_overwrite\", String.valueOf(addAudioOptions.allowOverwrite()));\n+    }\n+    builder.body(RequestBody.create(MediaType.parse(addAudioOptions.contentType()), addAudioOptions.audioResource()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<Void> deleteAudio(DeleteAudioOptions deleteAudioOptions) {\n+    Validator.notNull(deleteAudioOptions, \"deleteAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", deleteAudioOptions.customizationId(), deleteAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }",
                    "+    } else {\n+      builder.bodyContent(addWordsOptions.body(), addWordsOptions.contentType());\n+    }\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<Void> deleteWord(DeleteWordOptions deleteWordOptions) {\n+    Validator.notNull(deleteWordOptions, \"deleteWordOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/customizations/%s/words/%s\", deleteWordOptions.customizationId(), deleteWordOptions.wordName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }",
                    "+    Validator.notNull(getSessionStatusOptions, \"getSessionStatusOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/sessions/%s/recognize\", getSessionStatusOptions.sessionId()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(SessionStatus.class));\n+  }\n+  public ServiceCall<RecognitionJob> checkJob(CheckJobOptions checkJobOptions) {\n+    Validator.notNull(checkJobOptions, \"checkJobOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/recognitions/%s\", checkJobOptions.id()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(RecognitionJob.class));\n+  }\n+  public ServiceCall<RecognitionJobs> checkJobs(CheckJobsOptions checkJobsOptions) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    service.getCorpus(id, corpus).execute();\n+    GetCorpusOptions getOptions = new GetCorpusOptions.Builder().customizationId(id).corpusName(corpus).build();\n+    service.getCorpus(getOptions).execute();",
                    "-    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(\"{}\"));\n-    service.addCorpus(id, corpusName, corpusFile, true).execute();\n+    String corpusFileText = new String(Files.readAllBytes(Paths.get(corpusFile.toURI())));\n+    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(\"{}\"));\n+    AddCorpusOptions addOptions = new AddCorpusOptions.Builder().customizationId(id).corpusName(corpusName).corpusFile(corpusFile).corpusFileContentType(HttpMediaType.TEXT_PLAIN).allowOverwrite(true).build();\n+    service.addCorpus(addOptions).execute();",
                    "-    assertEquals(customizations.get(\"customizations\").getAsJsonArray().size(), result.size());\n-    assertEquals(customizations.get(\"customizations\"), GSON.toJsonTree(result));\n-  }\n-  @Test\n-  public void testGetCustomization() throws InterruptedException, FileNotFoundException {\n-    String id = \"foo\";\n-    Customization customization = loadFixture(\"src/test/resources/speech_to_text/customization.json\", Customization.class);\n-    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(customization)));\n-    Customization result = service.getCustomization(id).execute();\n+    assertEquals(customizations.get(\"customizations\").getAsJsonArray().size(), result.getCustomizations().size());"
                ]
            }
        ]
    },
    {
        "id": 132,
        "Anal": "The method \"getWords\" has been changed to \"listWords\" and its parameters have also been changed from two parameters \"customizationId\" and \"Word.Type type\" to a single parameter \"ListWordsOptions listWordsOptions\".",
        "Stmts": "List<WordData> result = service.getWords(id, null).execute();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+    Validator.notNull(deleteAudioOptions, \"deleteAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", deleteAudioOptions.customizationId(), deleteAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<AudioListing> getAudio(GetAudioOptions getAudioOptions) {\n+    Validator.notNull(getAudioOptions, \"getAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", getAudioOptions.customizationId(), getAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(AudioListing.class));\n+  }\n+  public ServiceCall<AudioResources> listAudio(ListAudioOptions listAudioOptions) {",
                    "+    }\n+    if (recognizeOptions.version() != null) {\n+      builder.query(\"version\", recognizeOptions.version());\n+    }\n+    if (recognizeOptions.inactivityTimeout() != null) {\n+      builder.query(\"inactivity_timeout\", recognizeOptions.inactivityTimeout());\n+    }\n+    if (recognizeOptions.keywords() != null) {\n+      builder.query(\"keywords\", RequestUtils.join(recognizeOptions.keywords(), \",\"));\n+    }",
                    "+    Validator.notNull(getSessionStatusOptions, \"getSessionStatusOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/sessions/%s/recognize\", getSessionStatusOptions.sessionId()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(SessionStatus.class));\n+  }\n+  public ServiceCall<RecognitionJob> checkJob(CheckJobOptions checkJobOptions) {\n+    Validator.notNull(checkJobOptions, \"checkJobOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/recognitions/%s\", checkJobOptions.id()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(RecognitionJob.class));\n+  }\n+  public ServiceCall<RecognitionJobs> checkJobs(CheckJobsOptions checkJobsOptions) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    List<WordData> result = service.getWords(id, null, Sort.ALPHA).execute();\n+    ListWordsOptions listOptions = new ListWordsOptions.Builder().customizationId(id).sort(ListWordsOptions.Sort.ALPHABETICAL).build();\n+    Words result = service.listWords(listOptions).execute();",
                    "-    List<WordData> result = service.getWords(id, Type.ALL).execute();\n+    ListWordsOptions listOptions = new ListWordsOptions.Builder().customizationId(id).wordType(ListWordsOptions.WordType.ALL).build();\n+    Words result = service.listWords(listOptions).execute();",
                    "-    List<WordData> result = service.getWords(id, Type.ALL, Sort.ALPHA).execute();\n+    ListWordsOptions listOptions = new ListWordsOptions.Builder().customizationId(id).sort(ListWordsOptions.Sort.ALPHABETICAL).wordType(ListWordsOptions.WordType.ALL).build();\n+    Words result = service.listWords(listOptions).execute();"
                ]
            }
        ]
    },
    {
        "id": 133,
        "Anal": "The method \"getWords\" has been changed to \"listWords\" and the parameters have also been changed from two separate parameters \"customizationId\" and \"type\" to a single parameter \"listWordsOptions\".",
        "Stmts": "List<WordData> result = service.getWords(id, Type.ALL).execute();\nassertEquals(String.format(PATH_WORDS, id) + \"?word_type=all\", request.getPath());",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+    Validator.notNull(deleteAudioOptions, \"deleteAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", deleteAudioOptions.customizationId(), deleteAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<AudioListing> getAudio(GetAudioOptions getAudioOptions) {\n+    Validator.notNull(getAudioOptions, \"getAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", getAudioOptions.customizationId(), getAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(AudioListing.class));\n+  }\n+  public ServiceCall<AudioResources> listAudio(ListAudioOptions listAudioOptions) {",
                    "+    }\n+    if (recognizeOptions.version() != null) {\n+      builder.query(\"version\", recognizeOptions.version());\n+    }\n+    if (recognizeOptions.inactivityTimeout() != null) {\n+      builder.query(\"inactivity_timeout\", recognizeOptions.inactivityTimeout());\n+    }\n+    if (recognizeOptions.keywords() != null) {\n+      builder.query(\"keywords\", RequestUtils.join(recognizeOptions.keywords(), \",\"));\n+    }",
                    "+    Validator.notNull(getSessionStatusOptions, \"getSessionStatusOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/sessions/%s/recognize\", getSessionStatusOptions.sessionId()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(SessionStatus.class));\n+  }\n+  public ServiceCall<RecognitionJob> checkJob(CheckJobOptions checkJobOptions) {\n+    Validator.notNull(checkJobOptions, \"checkJobOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/recognitions/%s\", checkJobOptions.id()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(RecognitionJob.class));\n+  }\n+  public ServiceCall<RecognitionJobs> checkJobs(CheckJobsOptions checkJobsOptions) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    List<WordData> result = service.getWords(id, Type.ALL, Sort.ALPHA).execute();\n+    ListWordsOptions listOptions = new ListWordsOptions.Builder().customizationId(id).sort(ListWordsOptions.Sort.ALPHABETICAL).wordType(ListWordsOptions.WordType.ALL).build();\n+    Words result = service.listWords(listOptions).execute();",
                    "-    List<WordData> result = service.getWords(id, null).execute();\n+    ListWordsOptions listOptions = new ListWordsOptions.Builder().customizationId(id).build();\n+    Words result = service.listWords(listOptions).execute();",
                    "-    List<WordData> result = service.getWords(id, null, Sort.ALPHA).execute();\n+    ListWordsOptions listOptions = new ListWordsOptions.Builder().customizationId(id).sort(ListWordsOptions.Sort.ALPHABETICAL).build();\n+    Words result = service.listWords(listOptions).execute();"
                ]
            }
        ]
    },
    {
        "id": 134,
        "Anal": "The method \"getWords\" has been replaced by the method \"listWords\" which takes a different parameter `ListWordsOptions` instead of `String customizationId`, `Word.Type type`, and `Word.Sort sort`.",
        "Stmts": "List<WordData> result = service.getWords(id, null, Sort.ALPHA).execute();\nassertEquals(String.format(PATH_WORDS, id) + \"?sort=alphabetical\", request.getPath());",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+    Validator.notNull(deleteAudioOptions, \"deleteAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", deleteAudioOptions.customizationId(), deleteAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<AudioListing> getAudio(GetAudioOptions getAudioOptions) {\n+    Validator.notNull(getAudioOptions, \"getAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", getAudioOptions.customizationId(), getAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(AudioListing.class));\n+  }\n+  public ServiceCall<AudioResources> listAudio(ListAudioOptions listAudioOptions) {",
                    "+    Validator.notNull(getSessionStatusOptions, \"getSessionStatusOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/sessions/%s/recognize\", getSessionStatusOptions.sessionId()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(SessionStatus.class));\n+  }\n+  public ServiceCall<RecognitionJob> checkJob(CheckJobOptions checkJobOptions) {\n+    Validator.notNull(checkJobOptions, \"checkJobOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/recognitions/%s\", checkJobOptions.id()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(RecognitionJob.class));\n+  }\n+  public ServiceCall<RecognitionJobs> checkJobs(CheckJobsOptions checkJobsOptions) {",
                    "+    Validator.notNull(deleteWordOptions, \"deleteWordOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/customizations/%s/words/%s\", deleteWordOptions.customizationId(), deleteWordOptions.wordName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<Word> getWord(GetWordOptions getWordOptions) {\n+    Validator.notNull(getWordOptions, \"getWordOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/customizations/%s/words/%s\", getWordOptions.customizationId(), getWordOptions.wordName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Word.class));\n+  }\n+  public ServiceCall<AcousticModel> createAcousticModel(CreateAcousticModelOptions createAcousticModelOptions) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    List<WordData> result = service.getWords(id, null).execute();\n+    ListWordsOptions listOptions = new ListWordsOptions.Builder().customizationId(id).build();\n+    Words result = service.listWords(listOptions).execute();",
                    "-    List<WordData> result = service.getWords(id, Type.ALL, Sort.ALPHA).execute();\n+    ListWordsOptions listOptions = new ListWordsOptions.Builder().customizationId(id).sort(ListWordsOptions.Sort.ALPHABETICAL).wordType(ListWordsOptions.WordType.ALL).build();\n+    Words result = service.listWords(listOptions).execute();",
                    "-    List<WordData> result = service.getWords(id, Type.ALL).execute();\n+    ListWordsOptions listOptions = new ListWordsOptions.Builder().customizationId(id).wordType(ListWordsOptions.WordType.ALL).build();\n+    Words result = service.listWords(listOptions).execute();"
                ]
            }
        ]
    },
    {
        "id": 135,
        "Anal": "The method \"getWords\" has been replaced with \"listWords\" which takes a different parameter type `ListWordsOptions` instead of separate parameters for customizationId, type, and sort.",
        "Stmts": "List<WordData> result = service.getWords(id, Type.ALL, Sort.ALPHA).execute();\nassertEquals(String.format(PATH_WORDS, id) + \"?word_type=all&sort=alphabetical\", request.getPath());",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+    Validator.notNull(deleteAudioOptions, \"deleteAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", deleteAudioOptions.customizationId(), deleteAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<AudioListing> getAudio(GetAudioOptions getAudioOptions) {\n+    Validator.notNull(getAudioOptions, \"getAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", getAudioOptions.customizationId(), getAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(AudioListing.class));\n+  }\n+  public ServiceCall<AudioResources> listAudio(ListAudioOptions listAudioOptions) {",
                    "+    Validator.notNull(getSessionStatusOptions, \"getSessionStatusOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/sessions/%s/recognize\", getSessionStatusOptions.sessionId()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(SessionStatus.class));\n+  }\n+  public ServiceCall<RecognitionJob> checkJob(CheckJobOptions checkJobOptions) {\n+    Validator.notNull(checkJobOptions, \"checkJobOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/recognitions/%s\", checkJobOptions.id()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(RecognitionJob.class));\n+  }\n+  public ServiceCall<RecognitionJobs> checkJobs(CheckJobsOptions checkJobsOptions) {",
                    "+    Validator.notNull(deleteWordOptions, \"deleteWordOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/customizations/%s/words/%s\", deleteWordOptions.customizationId(), deleteWordOptions.wordName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<Word> getWord(GetWordOptions getWordOptions) {\n+    Validator.notNull(getWordOptions, \"getWordOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/customizations/%s/words/%s\", getWordOptions.customizationId(), getWordOptions.wordName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Word.class));\n+  }\n+  public ServiceCall<AcousticModel> createAcousticModel(CreateAcousticModelOptions createAcousticModelOptions) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    List<WordData> result = service.getWords(id, null, Sort.ALPHA).execute();\n+    ListWordsOptions listOptions = new ListWordsOptions.Builder().customizationId(id).sort(ListWordsOptions.Sort.ALPHABETICAL).build();\n+    Words result = service.listWords(listOptions).execute();",
                    "-    List<WordData> result = service.getWords(id, Type.ALL).execute();\n+    ListWordsOptions listOptions = new ListWordsOptions.Builder().customizationId(id).wordType(ListWordsOptions.WordType.ALL).build();\n+    Words result = service.listWords(listOptions).execute();",
                    "-    List<WordData> result = service.getWords(id, null).execute();\n+    ListWordsOptions listOptions = new ListWordsOptions.Builder().customizationId(id).build();\n+    Words result = service.listWords(listOptions).execute();"
                ]
            }
        ]
    }
]