[
    {
        "id": 0,
        "Anal": "The method \"getGroupFromGrpcClient\" now requires an additional parameter of type `AlluxioConfiguration`.",
        "Stmts": "Assert.assertEquals(\"\", SecurityUtils.getGroupFromGrpcClient());\nAssert.assertEquals(\"test_client_user\", SecurityUtils.getGroupFromGrpcClient());",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-      mOwner = SecurityUtils.getOwnerFromGrpcClient();\n-      mGroup = SecurityUtils.getGroupFromGrpcClient();\n+    if (SecurityUtils.isAuthenticationEnabled(ServerConfiguration.global())) {\n+      mOwner = SecurityUtils.getOwnerFromGrpcClient(ServerConfiguration.global());\n+      mGroup = SecurityUtils.getGroupFromGrpcClient(ServerConfiguration.global());"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class AlluxioConfiguration (optional references)",
                "contexts": [
                    "String get(PropertyKey key, ConfigurationValueOptions options);",
                    "void validate();",
                    "float getFloat(PropertyKey key);"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-      User user = AuthenticatedClientUser.get();\n+      User user = AuthenticatedClientUser.get(conf);",
                    "-      return LoginUser.get().getName();\n+      return LoginUser.get(conf).getName();",
                    "-      return CommonUtils.getPrimaryGroupName(LoginUser.get().getName());\n+      return CommonUtils.getPrimaryGroupName(LoginUser.get(conf).getName(), conf);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "+  private InstancedConfiguration mConfiguration;\n+  @Before\n+  public void before() {\n+    mConfiguration = ConfigurationTestUtils.defaults();\n+  }"
                ]
            }
        ]
    },
    {
        "id": 1,
        "Anal": "The method \"getTmpDir\" now requires a parameter of type `List<String>` named \"tmpDirs\".",
        "Stmts": "assertEquals(singleDir, CommonUtils.getTmpDir());\nresults.add(CommonUtils.getTmpDir());",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    mFile = new File(PathUtils.concatPath(CommonUtils.getTmpDir(), UUID.randomUUID()));\n+    mFile = new File(PathUtils.concatPath(CommonUtils.getTmpDir(mTmpDirs), UUID.randomUUID()));",
                "-  public S3AOutputStream(String bucketName, String key, TransferManager manager) throws IOException {\n+  public S3AOutputStream(String bucketName, String key, TransferManager manager, List<String> tmpDirs, boolean sseEnabled) throws IOException {\n-    mFile = new File(PathUtils.concatPath(CommonUtils.getTmpDir(), UUID.randomUUID()));\n+    mSseEnabled = sseEnabled;\n+    mFile = new File(PathUtils.concatPath(CommonUtils.getTmpDir(tmpDirs), UUID.randomUUID()));",
                "-  public OSSOutputStream(String bucketName, String key, OSSClient client) throws IOException {\n+  public OSSOutputStream(String bucketName, String key, OSSClient client, List<String> tmpDirs) throws IOException {\n-    mFile = new File(PathUtils.concatPath(CommonUtils.getTmpDir(), UUID.randomUUID()));\n+    mFile = new File(PathUtils.concatPath(CommonUtils.getTmpDir(tmpDirs), UUID.randomUUID()));"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public static boolean isLocalHost(WorkerNetAddress address) {\n-    return address.getHost().equals(NetworkAddressUtils.getClientHostName());\n-  }\n-  public static String convertMsToDate(long millis) {\n-    DateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT_PATTERN);\n+  public static boolean isLocalHost(WorkerNetAddress address, AlluxioConfiguration conf) {\n+    return address.getHost().equals(NetworkAddressUtils.getClientHostName(conf));\n+  }\n+  public static String convertMsToDate(long millis, String dateFormatPattern) {\n+    DateFormat dateFormat = new SimpleDateFormat(dateFormatPattern);",
                    "-  public static String getWorkerDataDirectory(String storageDir) {\n-    return PathUtils.concatPath(storageDir.trim(), Configuration.get(PropertyKey.WORKER_DATA_FOLDER));\n+  public static String getWorkerDataDirectory(String storageDir, AlluxioConfiguration conf) {\n+    return PathUtils.concatPath(storageDir.trim(), conf.get(PropertyKey.WORKER_DATA_FOLDER));",
                    "-  public static String getPrimaryGroupName(String userName) throws IOException {\n-    List<String> groups = getGroups(userName);\n+  public static String getPrimaryGroupName(String userName, AlluxioConfiguration conf) throws IOException {\n+    List<String> groups = getGroups(userName, conf);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 2,
        "Anal": "The method name \"formatPermission\" changes to \"formatMode\", and the first parameter \"permission\" changes to \"mode\".",
        "Stmts": "Assert.assertEquals(\"-rw-rw-rw-\", FormatUtils.formatPermission((short)0666, false));\nAssert.assertEquals(\"drw-rw-rw-\", FormatUtils.formatPermission((short)0666, true));\nAssert.assertEquals(\"-rwxrwxrwx\", FormatUtils.formatPermission((short)0777, false));\nAssert.assertEquals(\"drwxrwxrwx\", FormatUtils.formatPermission((short)0777, true));\nAssert.assertEquals(\"-r--r--r--\", FormatUtils.formatPermission((short)0444, false));\nAssert.assertEquals(\"dr--r--r--\", FormatUtils.formatPermission((short)0444, true));\nAssert.assertEquals(\"-r-xr-xr-x\", FormatUtils.formatPermission((short)0555, false));\nAssert.assertEquals(\"dr-xr-xr-x\", FormatUtils.formatPermission((short)0555, true));\nAssert.assertEquals(\"-rwxr-xr--\", FormatUtils.formatPermission((short)0754, false));\nAssert.assertEquals(\"drwxr-xr--\", FormatUtils.formatPermission((short)0754, true));",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    mPermission = FormatUtils.formatPermission(Mode.createNoAccess().toShort(), true);\n+    mPermission = FormatUtils.formatMode(Mode.createNoAccess().toShort(), true);",
                "-    mPermission = FormatUtils.formatPermission((short)status.getPermission(), status.isFolder());\n+    mPermission = FormatUtils.formatMode((short)status.getPermission(), status.isFolder());",
                "-      System.out.format(formatLsString(SecurityUtils.isSecurityEnabled(mConfiguration), status.isFolder(), FormatUtils.formatPermission((short)status.getPermission(), status.isFolder()), status.getUserName(), status.getGroupName(), status.getLength(), status.getCreationTimeMs(), 100 == status.getInMemoryPercentage(), status.getPath()));\n+      System.out.format(formatLsString(SecurityUtils.isSecurityEnabled(mConfiguration), status.isFolder(), FormatUtils.formatMode((short)status.getPermission(), status.isFolder()), status.getUserName(), status.getGroupName(), status.getLength(), status.getCreationTimeMs(), 100 == status.getInMemoryPercentage(), status.getPath()));"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": []
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 3,
        "Anal": "The method \"applyUMask\" no longer takes a \"Configuration\" object as a parameter.",
        "Stmts": "Configuration conf = new Configuration();\nconf.set(Constants.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());\nconf.set(Constants.SECURITY_AUTHORIZATION_PERMISSION_ENABLED, \"true\");\npermissionStatus = permissionStatus.applyUMask(umaskPermission, conf);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    return super.setPermissionStatus(permissionStatus.applyUMask(UMASK, MasterContext.getConf()));\n+    if (!SecurityUtils.isAuthorizationEnabled(MasterContext.getConf())) {\n+      return super.setPermissionStatus(permissionStatus);\n+    }\n+    return super.setPermissionStatus(permissionStatus.applyUMask(UMASK));"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    if (remote) {\n-      User user = AuthenticatedClientUser.get(conf);\n-      if (user == null) {\n-        throw new IOException(ExceptionMessage.AUTHORIZED_CLIENT_USER_IS_NULL.getMessage());\n-      }\n-      return new PermissionStatus(user.getName(), CommonUtils.getPrimaryGroupName(conf, user.getName()), FileSystemPermission.getDefault().applyUMask(conf));\n+    User user = AuthenticatedClientUser.get(conf);\n+    if (user == null) {\n+      throw new IOException(ExceptionMessage.AUTHORIZED_CLIENT_USER_IS_NULL.getMessage());\n+    }",
                    "+  }\n+  public static PermissionStatus getAsLoginUser(Configuration conf) throws IOException {\n+    if (!SecurityUtils.isAuthenticationEnabled(conf)) {\n+      return new PermissionStatus(\"\", \"\", FileSystemPermission.getFullFsPermission());",
                    "-  public static PermissionStatus get(Configuration conf, boolean remote) throws IOException {\n-    if (!SecurityUtils.isSecurityEnabled(conf)) {\n+  public static PermissionStatus getDefault(Configuration conf) throws IOException {\n+    if (!SecurityUtils.isAuthenticationEnabled(conf)) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 4,
        "Anal": "The third parameter \"options\" of the method \"mount\" changes from `MountOptions` to `MountPOptions`.",
        "Stmts": "MountOptions mountOptions = MountOptions.defaults();\nmFileSystem.mount(alluxioPath, ufsPath, mountOptions);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    mount(alluxioPath, ufsPath, MountOptions.defaults());\n-  }\n-  @Override\n-  public void mount(AlluxioURI alluxioPath, AlluxioURI ufsPath, MountOptions options) throws IOException, AlluxioException {\n+    mount(alluxioPath, ufsPath, MountPOptions.getDefaultInstance());",
                "-  public Response mount(@PathParam(\"path\") final String path, @QueryParam(\"src\") final String src, final MountOptions options) {\n+  public Response mount(@PathParam(\"path\") final String path, @QueryParam(\"src\") final String src, final MountPOptions options) {\n-          mFileSystem.mount(new AlluxioURI(path), new AlluxioURI(src), MountOptions.defaults());\n+          mFileSystem.mount(new AlluxioURI(path), new AlluxioURI(src), MountPOptions.getDefaultInstance());",
                "-  public Response mount(@PathParam(\"path\") final String path, @QueryParam(\"src\") final String src, final MountOptions options) {\n+  public Response mount(@PathParam(\"path\") final String path, @QueryParam(\"src\") final String src, final MountPOptions options) {\n-          mFileSystem.mount(new AlluxioURI(path), new AlluxioURI(src), MountOptions.defaults());\n+          mFileSystem.mount(new AlluxioURI(path), new AlluxioURI(src), MountPOptions.getDefaultInstance());\n           mFileSystem.mount(new AlluxioURI(path), new AlluxioURI(src), options);"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class MountPOptions (optional references)",
                "contexts": [
                    "public static alluxio.grpc.MountPOptions getDefaultInstance();",
                    "public alluxio.grpc.MountPOptions getDefaultInstanceForType();",
                    "public static alluxio.grpc.MountPOptions parseFrom( java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException;",
                    "public boolean hasCommonOptions();"
                ]
            },
            {
                "info": "Defined in class MountPOptions.PropertiesDefaultEntryHolder.Builder (optional references)",
                "contexts": [
                    "public Builder setCommonOptions(alluxio.grpc.FileSystemMasterCommonPOptions value);",
                    "public Builder setCommonOptions( alluxio.grpc.FileSystemMasterCommonPOptions.Builder builderForValue);"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    delete(path, DeleteOptions.defaults());\n-  }\n-  @Override\n-  public void delete(AlluxioURI path, DeleteOptions options)throws DirectoryNotEmptyException, FileDoesNotExistException, IOException, AlluxioException {\n+    delete(path, DeletePOptions.getDefaultInstance());\n+  }\n+  @Override\n+  public void delete(AlluxioURI path, DeletePOptions options)throws DirectoryNotEmptyException, FileDoesNotExistException, IOException, AlluxioException {",
                    "-    free(path, FreeOptions.defaults());\n-  }\n-  @Override\n-  public void free(AlluxioURI path, FreeOptions options) throws FileDoesNotExistException, IOException, AlluxioException {\n+    free(path, FreePOptions.getDefaultInstance());\n+  }\n+  @Override\n+  public void free(AlluxioURI path, FreePOptions options) throws FileDoesNotExistException, IOException, AlluxioException {",
                    "-  void delete(AlluxioURI path, DeleteOptions options)throws DirectoryNotEmptyException, FileDoesNotExistException, IOException, AlluxioException;\n+  void delete(AlluxioURI path, DeletePOptions options)throws DirectoryNotEmptyException, FileDoesNotExistException, IOException, AlluxioException;"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 5,
        "Anal": "The sixth parameter \"options\" of the method \"workerRegister\" changes from `RegisterWorkerTOptions` to `RegisterWorkerPOptions`.",
        "Stmts": "mBlockMaster.workerRegister(worker1, tiers, worker1TotalBytesOnTiers, worker1UsedBytesOnTiers, NO_BLOCKS_ON_TIERS, new RegisterWorkerTOptions());\nmBlockMaster.workerRegister(worker2, tiers, worker2TotalBytesOnTiers, worker2UsedBytesOnTiers, NO_BLOCKS_ON_TIERS, new RegisterWorkerTOptions());",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "+      currentBlocksOnTiersMap.put(blockEntry.getKey(), blockEntry.getValue().getTiersList());\n+    }\n+    RegisterWorkerPOptions options = request.getOptions();\n+    RpcUtils.call(LOG, (RpcUtils.RpcCallableThrowsIOException<RegisterWorkerPResponse>)() -> {\n+      mBlockMaster.workerRegister(workerId, storageTiers, totalBytesOnTiers, usedBytesOnTiers, currentBlocksOnTiersMap, options);"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class RegisterWorkerPOptions (optional references)",
                "contexts": [
                    "public static alluxio.grpc.RegisterWorkerPOptions getDefaultInstance();",
                    "public alluxio.grpc.RegisterWorkerPOptions getDefaultInstanceForType();",
                    "public static alluxio.grpc.RegisterWorkerPOptions parseFrom( byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException;",
                    "public static com.google.protobuf.Parser<RegisterWorkerPOptions> parser();"
                ]
            },
            {
                "info": "Defined in class RegisterWorkerPOptions.Builder (optional references)",
                "contexts": [
                    "public alluxio.grpc.RegisterWorkerPOptions build();",
                    "public alluxio.grpc.RegisterWorkerPOptions buildPartial();"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public Map<String, TProcessor> getServices() {\n-    Map<String, TProcessor> services = new HashMap<>();\n-    services.put(Constants.BLOCK_MASTER_CLIENT_SERVICE_NAME, new BlockMasterClientService.Processor<>(new BlockMasterClientServiceHandler(this)));\n-    services.put(Constants.BLOCK_MASTER_WORKER_SERVICE_NAME, new BlockMasterWorkerService.Processor<>(new BlockMasterWorkerServiceHandler(this)));\n+  public Map<ServiceType, GrpcService> getServices() {\n+    Map<ServiceType, GrpcService> services = new HashMap<>();\n+    services.put(ServiceType.BLOCK_MASTER_CLIENT_SERVICE, new GrpcService(new BlockMasterClientServiceHandler(this)));\n+    services.put(ServiceType.BLOCK_MASTER_WORKER_SERVICE, new GrpcService(new BlockMasterWorkerServiceHandler(this)));",
                    "-      return new Command(CommandType.Register, new ArrayList<Long>());\n+      return Command.newBuilder().setCommandType(CommandType.Register).build();",
                    "-        return new Command(CommandType.Nothing, new ArrayList<Long>());\n-      }\n-      return new Command(CommandType.Free, toRemoveBlocks);\n+        return Command.newBuilder().setCommandType(CommandType.Nothing).build();\n+      }\n+      return Command.newBuilder().setCommandType(CommandType.Free).addAllData(toRemoveBlocks).build();"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 6,
        "Anal": "The method \"setUserFromThriftClient\" no longer accepts a `Configuration` parameter.",
        "Stmts": "permission.setUserFromThriftClient(conf);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    mPermission = Permission.defaults().setUserFromThriftClient(MasterContext.getConf());\n+    mPermission = Permission.defaults().setUserFromThriftClient();"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    String loginUserName = LoginUser.get(conf).getName();\n+    String loginUserName = LoginUser.get().getName();",
                    "-    mGroupName = CommonUtils.getPrimaryGroupName(conf, loginUserName);\n+    mGroupName = CommonUtils.getPrimaryGroupName(loginUserName);",
                    "-  public Permission applyFileUMask(Configuration conf) {\n-    mMode = mMode.applyUMask(Mode.getUMask(conf)).applyUMask(FILE_UMASK);\n+  public Permission applyFileUMask() {\n+    mMode = mMode.applyUMask(Mode.getUMask()).applyUMask(FILE_UMASK);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 7,
        "Anal": "The method \"createBlockPath\" has an additional parameter \"workerDataFolderPermissions\".",
        "Stmts": "FileUtils.createBlockPath(tempFile.getAbsolutePath());",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    FileUtils.createBlockPath(blockPath);\n+    FileUtils.createBlockPath(blockPath, ServerConfiguration.get(PropertyKey.WORKER_DATA_FOLDER_PERMISSIONS));"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public static boolean createStorageDirPath(String path) throws IOException {\n+  public static boolean createStorageDirPath(String path, String workerDataFolderPermissions) throws IOException {",
                    "-    String perms = Configuration.get(PropertyKey.WORKER_DATA_FOLDER_PERMISSIONS);\n-    changeLocalFilePermission(absolutePath, perms);\n+    changeLocalFilePermission(absolutePath, workerDataFolderPermissions);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "+  private String mWorkerDataFolderPerms = ConfigurationUtils.defaults().get(PropertyKey.WORKER_DATA_FOLDER_PERMISSIONS);"
                ]
            }
        ]
    },
    {
        "id": 8,
        "Anal": "The method name \"toArray\" has been changed to \"finish\".",
        "Stmts": "assertEquals(CAP, il.toArray().length);\nassertEquals(il.size(), il.toArray().length);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    Item[] its = Arrays.copyOf(values, s);\n+    Item[] its = new Item[s];\n+    System.arraycopy(values, 0, its, 0, values.length);",
                    "-    values[next] = i;\n-    if (++next == values.length)\n+    values[size] = i;\n+    if (++size == values.length)",
                    "-  private int next = 0 << 0;\n+  private int size = 0 << 0;"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-  private static final int CAP = 1 << 8;\n+  private static final int CAP = 1 << 4;"
                ]
            }
        ]
    },
    {
        "id": 9,
        "Anal": "The parameter \"nodes\" of the method \"handleFailure\" changes from `Map` to `Set`.",
        "Stmts": "Map map = new HashMap<String, Boolean>();\nclient.handleFailure(map);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "+          }\n+        }\n+        log.debug(\"Failure already taken care of.\");\n+      } else {\n+        localManagementClient.handleFailure(pollReport.getFailingNodes()).get();",
                "+      } else if (!pollReport.getFailingNodes().isEmpty() && !latestLayout.getUnresponsiveServers().isEmpty()) {\n+        log.info(\"Failures detected. Failed nodes : {}\", pollReport.toString());\n+        for (String failedServer : pollReport.getFailingNodes()) {\n+          if (!latestLayout.getUnresponsiveServers().contains(failedServer)) {\n+            localManagementClient.handleFailure(pollReport.getFailingNodes()).get();",
                "+    try {\n+      if (!pollReport.getIsFailurePresent()) {\n+        if (!latestLayout.getUnresponsiveServers().isEmpty()) {\n+          log.info(\"Received response from unresponsive server\");\n+          localManagementClient.handleFailure(pollReport.getFailingNodes()).get();"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": []
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 10,
        "Anal": "The return type of the method \"getServerStatus\" changes from `HashMap<String, Boolean>` to `PollReport`.",
        "Stmts": "Map<String, Boolean> result = failureDetectorPolicy.getServerStatus();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "+    PollReport pollReport = failureDetectorPolicy.getServerStatus();\n+    analyzePollReportAndTriggerHandler(pollReport);\n+  }\n+  private void analyzePollReportAndTriggerHandler(PollReport pollReport) {\n+    if (!startFailureHandler) {"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class PollReport.PollReportBuilder (optional references)",
                "contexts": [
                    "public PollReportBuilder setFailingNodes(Set<String> failingNodes);"
                ]
            },
            {
                "info": "Defined in class PollReport (optional references)",
                "contexts": [
                    "@Data private final Set<String> failingNodes;",
                    "@Data private final Boolean isFailurePresent;"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  HashMap<String, Boolean> getServerStatus();\n+  PollReport getServerStatus();"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    Map<String, Boolean> actualResult = new HashMap<>();\n+    Set<String> actualResult = new HashSet<>();",
                    "-  private void pollAndMatchExpectedResult(Map<String, Boolean> expectedResult) throws InterruptedException {\n+  private void pollAndMatchExpectedResult(Set<String> expectedResult) throws InterruptedException {",
                    "-      Map<String, Boolean> tempMap = failureDetectorPolicy.getServerStatus();\n-      if (tempMap != null) {\n-        tempMap.forEach(actualResult::putIfAbsent);\n+      Set<String> tempResult = failureDetectorPolicy.getServerStatus().getFailingNodes();\n+      if (tempResult != null) {\n+        tempResult.forEach(actualResult::add);"
                ]
            }
        ]
    },
    {
        "id": 11,
        "Anal": "The return type of the method \"getServerStatus\" changes from `HashMap<String, Boolean>` to `PollReport`.",
        "Stmts": "Map<String, Boolean> expectedResult = new HashMap<>();\nexpectedResult.put(getEndpoint(SERVERS.PORT_0), false);\nexpectedResult.put(getEndpoint(SERVERS.PORT_1), false);\nexpectedResult.put(getEndpoint(SERVERS.PORT_2), false);\npollAndMatchExpectedResult(expectedResult);\nexpectedResult.remove(getEndpoint(SERVERS.PORT_0));\npollAndMatchExpectedResult(expectedResult);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "+    PollReport pollReport = failureDetectorPolicy.getServerStatus();\n+    analyzePollReportAndTriggerHandler(pollReport);\n+  }\n+  private void analyzePollReportAndTriggerHandler(PollReport pollReport) {\n+    if (!startFailureHandler) {"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class PollReport.PollReportBuilder (optional references)",
                "contexts": [
                    "public PollReport build();",
                    "public PollReportBuilder setIsStatusChangePresent();"
                ]
            },
            {
                "info": "Defined in class PollReport (optional references)",
                "contexts": [
                    "@Data private final ImmutableMap<String, Long> outOfPhaseEpochNodes;"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  HashMap<String, Boolean> getServerStatus();\n+  PollReport getServerStatus();"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    Map<String, Boolean> actualResult = new HashMap<>();\n+    Set<String> actualResult = new HashSet<>();",
                    "-  private void pollAndMatchExpectedResult(Map<String, Boolean> expectedResult) throws InterruptedException {\n+  private void pollAndMatchExpectedResult(Set<String> expectedResult) throws InterruptedException {",
                    "-      Map<String, Boolean> tempMap = failureDetectorPolicy.getServerStatus();\n-      if (tempMap != null) {\n-        tempMap.forEach(actualResult::putIfAbsent);\n+      Set<String> tempResult = failureDetectorPolicy.getServerStatus().getFailingNodes();\n+      if (tempResult != null) {\n+        tempResult.forEach(actualResult::add);"
                ]
            }
        ]
    },
    {
        "id": 12,
        "Anal": "The method name changes from `getItemId` to `getResourceId`.",
        "Stmts": "assertTrue(\"testGetItemId 0\", mv.getItemId() >= 0);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    row.setColumn(\"item_id\", itemId);\n+    row.setColumn(\"resource_id\", resourceId);\n+    row.setColumn(\"resource_type_id\", resourceTypeId);",
                    "-  private int itemId;\n+  private int resourceId;\n+  private int resourceTypeId;",
                    "-      itemId = row.getIntColumn(\"item_id\");\n+      resourceId = row.getIntColumn(\"resource_id\");\n+      resourceTypeId = row.getIntColumn(\"resource_type_id\");"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-      this.mv.setItemId(Item.create(context).getID());\n+      this.mv.setResourceId(Item.create(context).getID());\n+      this.mv.setResourceTypeId(Constants.ITEM);"
                ]
            }
        ]
    },
    {
        "id": 13,
        "Anal": "The method name \"setItemId\" changes to \"setResourceId\" and the parameter name \"itemId\" changes to \"resourceId\".",
        "Stmts": "int itemId = 55;\nmv.setItemId(itemId);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "+    for (int dcIdx = 0; dcIdx < getMetadata().size(); dcIdx++) {\n+      if (!storedDC[dcIdx]) {\n+        DCValue dcv = getMetadata().get(dcIdx);\n+        MetadataValue metadata = new MetadataValue();\n+        metadata.setResourceId(getID());"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    row.setColumn(\"item_id\", itemId);\n+    row.setColumn(\"resource_id\", resourceId);\n+    row.setColumn(\"resource_type_id\", resourceTypeId);",
                    "-  private int itemId;\n+  private int resourceId;\n+  private int resourceTypeId;",
                    "-      itemId = row.getIntColumn(\"item_id\");\n+      resourceId = row.getIntColumn(\"resource_id\");\n+      resourceTypeId = row.getIntColumn(\"resource_type_id\");"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-      this.mv.setItemId(Item.create(context).getID());\n+      this.mv.setResourceId(Item.create(context).getID());\n+      this.mv.setResourceTypeId(Constants.ITEM);"
                ]
            }
        ]
    },
    {
        "id": 14,
        "Anal": "The method \"getFormat\" now requires a parameter of type \"Context\".",
        "Stmts": "bs.getFormat();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-      for (Bitstream bs : bundle.getBitstreams()) {\n-        String fmt = bs.getFormat().getShortDescription();\n+      for (BundleBitstream bundleBitstream : bundle.getBitstreams()) {\n+        Bitstream bs = bundleBitstream.getBitstream();\n+        String fmt = bs.getFormat(Curator.curationContext()).getShortDescription();",
                "+      if (bi.size() > 0) {\n+        handle = bi.get(0).getHandle();\n-      String ext[] = bitstream.getFormat().getExtensions();\n-      bsName = \"bitstream_\" + sid + (ext.length > 0 ? ext[0] : \"\");\n+      List<String> ext = bitstream.getFormat(context).getExtensions();",
                "-      for (Bitstream bs : bitstreams) {\n+      for (BundleBitstream bundleBitstream : bitstreams) {\n+        Bitstream bs = bundleBitstream.getBitstream();\n-        arLink.setAttribute(\"type\", bs.getFormat().getMIMEType());\n+        arLink.setAttribute(\"type\", bs.getFormat(context).getMIMEType());"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class Context (optional references)",
                "contexts": [
                    "protected Context(EventService eventService, DBConnection dbConnection);",
                    "public Context();",
                    "public Context(short options);"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+  public void setDeleted(boolean deleted) {\n+    this.deleted = deleted;",
                    "+  @Column(name = \"size_bytes\") private long sizeBytes;\n+  @Column(name = \"deleted\") private boolean deleted = false;\n+  @Column(name = \"internal_id\", length = 256) private String internalId;\n+  @Column(name = \"store_number\") private int storeNumber;\n+  @ManyToOne(fetch = FetchType.EAGER) @JoinColumn(name = \"bitstream_format_id\") private BitstreamFormat bitstreamFormat;\n+  @OneToMany(mappedBy = \"bitstream\", fetch = FetchType.LAZY) @OrderBy(\"bitstreamOrder asc\") private List<BundleBitstream> bundles = new ArrayList<>();\n+  @OneToOne(fetch = FetchType.LAZY, mappedBy = \"logo\") private Community community;\n+  @OneToOne(fetch = FetchType.LAZY, mappedBy = \"logo\") private Collection collection;\n+  @Transient private BitstreamService bitstreamService;\n+  public Bitstream() {}",
                    "+  @Override"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-      this.bs = Bitstream.create(context, new FileInputStream(f));\n+      this.bs = bitstreamService.create(context, new FileInputStream(f));",
                    "+  protected BitstreamFormatService bitstreamFormatService = ContentServiceFactory.getInstance().getBitstreamFormatService();"
                ]
            }
        ]
    },
    {
        "id": 15,
        "Anal": "The method name changes from \"getValueId\" to \"getID\" and the return type changes from primitive type `int` to wrapper class `Integer`.",
        "Stmts": "mv.getValueId();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "+    log.info(LogManager.getHeader(context, \"update_metadatavalue\", \"metadata_value_id=\" + metadataValue.getID()));",
                "+    if (this.getID() != other.getID()) {",
                "+    hash = 47 * hash + this.getID();"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    hash = 47 * hash + this.valueId;\n-    hash = 47 * hash + this.getValueId();\n+    hash = 47 * hash + this.id;\n+    hash = 47 * hash + this.getID();",
                    "-    if (this.getValueId() != other.getValueId()) {\n+    if (this.getID() != other.getID()) {",
                    "+public interface ReloadableEntity<T extends Serializable> {\n+  T getID();\n+}"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 16,
        "Anal": "The parameter \"responseException\" of the method \"getErrorCode\" changes from `HttpResponseException` to `ResponseException`.",
        "Stmts": "Mockito.when(responseException.getContent()).thenReturn(\"{\\\"type\\\":\\\"other\\\",\\\"message\\\":\\\"some other object\\\"}\");\nErrorResponseUtil.getErrorCode(responseException);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": []
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-  @Mock HttpResponseException responseException;\n+  @Mock private ResponseException responseException;"
                ]
            }
        ]
    },
    {
        "id": 17,
        "Anal": "The parameter \"responseException\" of the method \"getErrorCode\" changes from `HttpResponseException` to `ResponseException`.",
        "Stmts": "Mockito.when(responseException.getContent()).thenReturn(\"{\\\"errors\\\":[{\\\"code\\\":\\\"MANIFEST_INVALID\\\",\\\"message\\\":\\\"manifest invalid\\\",\\\"detail\\\":{}}]}\");\nAssert.assertSame(ErrorCodes.MANIFEST_INVALID, ErrorResponseUtil.getErrorCode(responseException));",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": []
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-  @Mock HttpResponseException responseException;\n+  @Mock private ResponseException responseException;"
                ]
            }
        ]
    },
    {
        "id": 18,
        "Anal": "The method \"changeProtectionKey\" has two new parameters added: `Number160 versionKey`, `Number160 basedOnKey`, and `byte[] hash`. The position of the `int ttl` parameter has also been moved.",
        "Stmts": "FuturePut changeFuture1 = node.getDataManager().changeProtectionKey(locationKey, domainKey, contentKey, data1v2.getTimeToLive(), keypair1, keypair2);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    } catch (IOException | InvalidKeyException | SignatureException e) {\n+    } catch (IOException | InvalidKeyException | SignatureException | NoSuchAlgorithmException | NoSuchPaddingException | IllegalBlockSizeException | BadPaddingException e) {",
                    "-  boolean changeProtectionKey(String locationKey, String contentKey, int ttl, KeyPair oldKey, KeyPair newKey);\n+  boolean changeProtectionKey(String locationKey, String contentKey, Number160 versionKey, Number160 basedOnKey, int ttl, KeyPair oldKey, KeyPair newKey, byte[] hash);",
                    "-  public boolean changeProtectionKey(String locationKey, String contentKey, int ttl, KeyPair oldKey, KeyPair newKey) {\n+  public boolean changeProtectionKey(String locationKey, String contentKey, Number160 versionKey, Number160 basedOnKey, int ttl, KeyPair oldKey, KeyPair newKey, byte[] hash) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-  private static final int networkSize = 10;\n+  private static final int networkSize = 3;"
                ]
            }
        ]
    },
    {
        "id": 19,
        "Anal": "The exception thrown by the method \"onCreateOrUpdateCommand\" changes from `GenieException` to `GeniePreconditionException`.",
        "Stmts": "this.c.onCreateOrUpdateCommand();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  private void validate(final CommandStatus status, final String executable) throws GenieException {\n+  private void validate(final CommandStatus status, final String executable, final String error) throws GeniePreconditionException {",
                    "+    if (StringUtils.isNotBlank(error)) {\n+      builder.append(error);\n+    }",
                    "-  public void validate() throws GenieException {\n-    super.validate();\n-    this.validate(this.status, this.executable);\n+  public void validate() throws GeniePreconditionException {\n+    String error = null;\n+    try {\n+      super.validate();\n+    } catch (final GeniePreconditionException ge) {\n+      error = ge.getMessage();\n+    }"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 20,
        "Anal": "The method \"deriveSecret\" has an additional parameter \"hashAlgorithm\" added as the second parameter and the last parameter \"hashValue\" is replaced by \"toHash\".",
        "Stmts": "byte[] hashValue = ArrayConverter.hexStringToByteArray(\"52c04472bdfe929772c98b91cf425f78f47659be9d4a7d68b9e29d162935e9b9\");\nbyte[] result = HKDFunction.deriveSecret(macAlgorithm, prk, labelIn, hashValue);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "+    byte[] saltMasterSecret = HKDFunction.deriveSecret(macAlg.getJavaName(), digestAlgo.getJavaName(), tlsContext.getHandshakeSecret(), HKDFunction.DERIVED, ArrayConverter.hexStringToByteArray(\"\"));\n-    byte[] clientApplicationTrafficSecret = HKDFunction.deriveSecret(macAlg.getJavaName(), masterSecret, HKDFunction.CLIENT_APPLICATION_TRAFFIC_SECRET, tlsContext.getDigest().digest(tlsContext.getSelectedProtocolVersion(), tlsContext.getSelectedCipherSuite()));\n+    byte[] clientApplicationTrafficSecret = HKDFunction.deriveSecret(macAlg.getJavaName(), digestAlgo.getJavaName(), masterSecret, HKDFunction.CLIENT_APPLICATION_TRAFFIC_SECRET, tlsContext.getDigest().getRawBytes());\n-    byte[] serverApplicationTrafficSecret = HKDFunction.deriveSecret(macAlg.getJavaName(), masterSecret, HKDFunction.SERVER_APPLICATION_TRAFFIC_SECRET, tlsContext.getDigest().digest(tlsContext.getSelectedProtocolVersion(), tlsContext.getSelectedCipherSuite()));\n+    byte[] serverApplicationTrafficSecret = HKDFunction.deriveSecret(macAlg.getJavaName(), digestAlgo.getJavaName(), masterSecret, HKDFunction.SERVER_APPLICATION_TRAFFIC_SECRET, tlsContext.getDigest().getRawBytes());",
                "-    byte[] saltMasterSecret = HKDFunction.deriveSecret(macAlg.getJavaName(), tlsContext.getHandshakeSecret(), HKDFunction.DERIVED, ArrayConverter.hexStringToByteArray(\"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\"));\n+    DigestAlgorithm digestAlgo = AlgorithmResolver.getDigestAlgorithm(tlsContext.getSelectedProtocolVersion(), tlsContext.getSelectedCipherSuite());\n+    byte[] saltMasterSecret = HKDFunction.deriveSecret(macAlg.getJavaName(), digestAlgo.getJavaName(), tlsContext.getHandshakeSecret(), HKDFunction.DERIVED, ArrayConverter.hexStringToByteArray(\"\"));\n-    byte[] clientApplicationTrafficSecret = HKDFunction.deriveSecret(macAlg.getJavaName(), masterSecret, HKDFunction.CLIENT_APPLICATION_TRAFFIC_SECRET, tlsContext.getDigest().digest(tlsContext.getSelectedProtocolVersion(), tlsContext.getSelectedCipherSuite()));\n+    byte[] clientApplicationTrafficSecret = HKDFunction.deriveSecret(macAlg.getJavaName(), digestAlgo.getJavaName(), masterSecret, HKDFunction.CLIENT_APPLICATION_TRAFFIC_SECRET, tlsContext.getDigest().getRawBytes());",
                "-    byte[] clientHandshakeTrafficSecret = HKDFunction.deriveSecret(macAlg.getJavaName(), handshakeSecret, HKDFunction.CLIENT_HANDSHAKE_TRAFFIC_SECRET, context.getDigest().digest(context.getSelectedProtocolVersion(), context.getSelectedCipherSuite()));\n+    byte[] clientHandshakeTrafficSecret = HKDFunction.deriveSecret(macAlg.getJavaName(), digestAlgo.getJavaName(), handshakeSecret, HKDFunction.CLIENT_HANDSHAKE_TRAFFIC_SECRET, context.getDigest().getRawBytes());\n-    byte[] serverHandshakeTrafficSecret = HKDFunction.deriveSecret(macAlg.getJavaName(), handshakeSecret, HKDFunction.SERVER_HANDSHAKE_TRAFFIC_SECRET, context.getDigest().digest(context.getSelectedProtocolVersion(), context.getSelectedCipherSuite()));\n+    byte[] serverHandshakeTrafficSecret = HKDFunction.deriveSecret(macAlg.getJavaName(), digestAlgo.getJavaName(), handshakeSecret, HKDFunction.SERVER_HANDSHAKE_TRAFFIC_SECRET, context.getDigest().getRawBytes());"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-      byte[] out = mac.doFinal();\n-      return out;\n+      return mac.doFinal();",
                    "-    byte[] result = expand(macAlgorithm, prk, info, outLen);\n-    return result;\n+    return expand(macAlgorithm, prk, info, outLen);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 21,
        "Anal": "The return type of the method \"next\" changes from `DateTimeAdjuster` to `WithAdjuster`.",
        "Stmts": "DateTimeAdjuster next = DateTimeAdjusters.next(SUNDAY);\nassertTrue(next instanceof Serializable);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [
            {
                "info": "Defined in class WithAdjuster (optional references)",
                "contexts": [
                    "DateTime doAdjustment(DateTime dateTime);"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public static DateTimeAdjuster nextOrCurrent(DayOfWeek dow) {\n+  public static WithAdjuster nextOrCurrent(DayOfWeek dow) {",
                    "-  private static enum Impl implements DateTimeAdjuster {\n+  private static enum Impl implements WithAdjuster {",
                    "-  public static DateTimeAdjuster previousOrCurrent(DayOfWeek dow) {\n+  public static WithAdjuster previousOrCurrent(DayOfWeek dow) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 22,
        "Anal": "The return type of the method \"parseToEngine\" changes to \"DateTimeBuilder\" from \"CalendricalEngine\".",
        "Stmts": "CalendricalEngine result = test.parseToEngine(\"ONE30\");\nassertEquals(result.getInput().size(), 1);\nassertEquals(result.getInput().get(0), DAY_OF_MONTH.field(30L));",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "+      DateTimeBuilder builder = parseToBuilder(str).resolve();\n+      for (Class<?> type : types) {\n+        CalendricalObject cal = (CalendricalObject)builder.extract(type);\n-      throw new CalendricalException(\"Unable to convert parsed text to any specified rule: \" + Arrays.toString(rules));\n+      throw new CalendricalException(\"Unable to convert parsed text to any specified type: \" + Arrays.toString(types));",
                "+      DateTimeBuilder builder = parseToBuilder(str);\n+      T result = builder.resolve().extract(type);\n+      if (result == null) {\n+        throw new CalendricalException(\"Unable to convert parsed text to \" + type);\n+      }",
                "+        return formatter.parseToBuilder(source);\n-      return context != null ? context.toCalendricalEngine() : null;\n+      return context != null ? context.toBuilder() : null;"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class DateTimeBuilder (optional references)",
                "contexts": [
                    "public Map<Class<?>, CalendricalObject> getObjectMap();",
                    "public void addObject(CalendricalObject calendrical);",
                    "@SuppressWarnings(\"unchecked\") @Override public <T> T extract(Class<T> type);"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    DateTimes.checkNotNull(rules, \"CalendricalRule array must not be null\");\n-    if (rules.length < 2) {\n-      throw new IllegalArgumentException(\"At least two rules must be specified\");\n+    DateTimes.checkNotNull(types, \"Class array must not be null\");\n+    if (types.length < 2) {\n+      throw new IllegalArgumentException(\"At least two types must be specified\");",
                    "-      throw new CalendricalException(\"Unable to convert parsed text to any specified rule: \" + Arrays.toString(rules));\n+      throw new CalendricalException(\"Unable to convert parsed text to any specified type: \" + Arrays.toString(types));",
                    "-      if (obj instanceof Calendrical == false) {\n-        throw new IllegalArgumentException(\"Format target must implement Calendrical\");\n+      if (obj instanceof CalendricalObject == false) {\n+        throw new IllegalArgumentException(\"Format target must implement CalendricalObject\");"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 23,
        "Anal": "The return type of the method \"firstDayOfMonth\" changes from `DateTimeAdjuster` to `WithAdjuster`.",
        "Stmts": "DateTimeAdjuster firstDayOfMonth = DateTimeAdjusters.firstDayOfMonth();\nassertTrue(firstDayOfMonth instanceof Serializable);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [
            {
                "info": "Defined in class WithAdjuster (optional references)",
                "contexts": [
                    "DateTime doAdjustment(DateTime dateTime);"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public static DateTimeAdjuster nextOrCurrent(DayOfWeek dow) {\n+  public static WithAdjuster nextOrCurrent(DayOfWeek dow) {",
                    "-  private static enum Impl implements DateTimeAdjuster {\n+  private static enum Impl implements WithAdjuster {",
                    "-  public static DateTimeAdjuster previousOrCurrent(DayOfWeek dow) {\n+  public static WithAdjuster previousOrCurrent(DayOfWeek dow) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 24,
        "Anal": "The parameter \"dateTime\" of the method \"print\" changes from `DateTimeAccessor` to `TemporalAccessor`.",
        "Stmts": "test.print((DateTimeAccessor)null);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "     return new DateTimeFormatterBuilder().appendChronoText(style).toFormatter(locale).print(new DefaultInterfaceDateTimeAccessor() {",
                "     return new DateTimeFormatterBuilder().appendZoneText(style).toFormatter(locale).print(new DefaultInterfaceDateTimeAccessor() {"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class TemporalAccessor.Query (optional references)",
                "contexts": [
                    "R doQuery(TemporalAccessor dateTime);"
                ]
            },
            {
                "info": "Defined in class TemporalAccessor (optional references)",
                "contexts": [
                    "<R> R query(Query<R> query);",
                    "boolean isSupported(TemporalField field);"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-        formatter.printTo((DateTimeAccessor)obj, toAppendTo);\n+        formatter.printTo((TemporalAccessor)obj, toAppendTo);",
                    "-  public DateTimeAccessor parseBest(CharSequence text, Class<?>... types) {\n+  public TemporalAccessor parseBest(CharSequence text, Class<?>... types) {",
                    "-  public void printTo(DateTimeAccessor dateTime, Appendable appendable) {\n+  public void printTo(TemporalAccessor dateTime, Appendable appendable) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 25,
        "Anal": "The parameter \"dateTime\" of the method \"print\" changes from `DateTimeAccessor` to `TemporalAccessor`.",
        "Stmts": "String result = test.print(LocalDate.of(2008, 6, 30));",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "     return new DateTimeFormatterBuilder().appendChronoText(style).toFormatter(locale).print(new DefaultInterfaceDateTimeAccessor() {",
                "     return new DateTimeFormatterBuilder().appendZoneText(style).toFormatter(locale).print(new DefaultInterfaceDateTimeAccessor() {"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class TemporalAccessor.Query (optional references)",
                "contexts": [
                    "R doQuery(TemporalAccessor dateTime);"
                ]
            },
            {
                "info": "Defined in class TemporalAccessor (optional references)",
                "contexts": [
                    "<R> R query(Query<R> query);",
                    "boolean isSupported(TemporalField field);"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-        formatter.printTo((DateTimeAccessor)obj, toAppendTo);\n+        formatter.printTo((TemporalAccessor)obj, toAppendTo);",
                    "-  public DateTimeAccessor parseBest(CharSequence text, Class<?>... types) {\n+  public TemporalAccessor parseBest(CharSequence text, Class<?>... types) {",
                    "-  public void printTo(DateTimeAccessor dateTime, Appendable appendable) {\n+  public void printTo(TemporalAccessor dateTime, Appendable appendable) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 26,
        "Anal": "The return type of the method \"parseBest\" changes from `DateTimeAccessor` to `TemporalAccessor`.",
        "Stmts": "DateTimeAccessor result = test.parseBest(\"2011-06-30+03:00\", OffsetDate.class, LocalDate.class);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [
            {
                "info": "Defined in class TemporalAccessor (optional references)",
                "contexts": [
                    "int get(TemporalField field);",
                    "long getLong(TemporalField field);",
                    "ValueRange range(TemporalField field);"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-        formatter.printTo((DateTimeAccessor)obj, toAppendTo);\n+        formatter.printTo((TemporalAccessor)obj, toAppendTo);",
                    "-  public String print(DateTimeAccessor dateTime) {\n+  public String print(TemporalAccessor dateTime) {",
                    "-  public void printTo(DateTimeAccessor dateTime, Appendable appendable) {\n+  public void printTo(TemporalAccessor dateTime, Appendable appendable) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 27,
        "Anal": "The method name \"matchesCalendrical\" changes to \"matches\".",
        "Stmts": "assertEquals(DateTimeField.of(YEAR, 2008).matchesCalendrical(date), true);\nassertEquals(DateTimeField.of(YEAR, 2006).matchesCalendrical(date), false);\nassertEquals(DateTimeField.of(MONTH_OF_YEAR, 6).matchesCalendrical(date), true);\nassertEquals(DateTimeField.of(MONTH_OF_YEAR, 7).matchesCalendrical(date), false);\nassertEquals(DateTimeField.of(MONTH_OF_YEAR, -1).matchesCalendrical(date), false);\nassertEquals(DateTimeField.of(DAY_OF_MONTH, 30).matchesCalendrical(date), true);\nassertEquals(DateTimeField.of(DAY_OF_MONTH, 12).matchesCalendrical(date), false);\nassertEquals(DateTimeField.of(DAY_OF_WEEK, 1).matchesCalendrical(date), true);\nassertEquals(DateTimeField.of(DAY_OF_WEEK, 2).matchesCalendrical(date), false);\nassertEquals(DateTimeField.of(HOUR_OF_DAY, 2).matchesCalendrical(date), false);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": []
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 28,
        "Anal": "The method \"appendValueReduced\" has an additional parameter \"maxWidth\" added.",
        "Stmts": "builder.appendValueReduced(null, 2, 2000);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-        appendValueReduced(field, 2, 2000);\n+        appendValueReduced(field, 2, 2, 2000);"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    ReducedPrinterParser(TemporalField field, int width, int baseValue) {\n-      super(field, width, width, SignStyle.NOT_NEGATIVE);\n+    ReducedPrinterParser(TemporalField field, int width, int maxWidth, int baseValue) {\n+      super(field, width, maxWidth, SignStyle.NOT_NEGATIVE);",
                    "-        appendValueReduced(field, 2, 2000);\n+        appendValueReduced(field, 2, 2, 2000);",
                    "+    }\n+    return this;\n+  }\n+  public DateTimeFormatterBuilder appendValueReduced(TemporalField field, int width, int maxWidth, ChronoLocalDate baseDate) {\n+    Objects.requireNonNull(field, \"field\");\n+    Objects.requireNonNull(baseDate, \"baseDate\");\n+    ReducedPrinterParser pp = new ReducedPrinterParser(field, width, maxWidth, baseDate.get(ChronoField.YEAR));\n+    if (width == maxWidth) {\n+      appendFixedWidth(width, pp);\n+    } else {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 29,
        "Anal": "The method \"appendValueReduced\" has an additional parameter \"maxWidth\" added as the third parameter.",
        "Stmts": "builder.appendValueReduced(YEAR, 2, 2000);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-        appendValueReduced(field, 2, 2000);\n+        appendValueReduced(field, 2, 2, 2000);"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    ReducedPrinterParser(TemporalField field, int width, int baseValue) {\n-      super(field, width, width, SignStyle.NOT_NEGATIVE);\n+    ReducedPrinterParser(TemporalField field, int width, int maxWidth, int baseValue) {\n+      super(field, width, maxWidth, SignStyle.NOT_NEGATIVE);",
                    "-        appendValueReduced(field, 2, 2000);\n+        appendValueReduced(field, 2, 2, 2000);",
                    "+    }\n+    return this;\n+  }\n+  public DateTimeFormatterBuilder appendValueReduced(TemporalField field, int width, int maxWidth, ChronoLocalDate baseDate) {\n+    Objects.requireNonNull(field, \"field\");\n+    Objects.requireNonNull(baseDate, \"baseDate\");\n+    ReducedPrinterParser pp = new ReducedPrinterParser(field, width, maxWidth, baseDate.get(ChronoField.YEAR));\n+    if (width == maxWidth) {\n+      appendFixedWidth(width, pp);\n+    } else {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 30,
        "Anal": "The method name \"getAvailableGroupIds\" changes to \"getAvailableZoneIds\".",
        "Stmts": "Set<String> groups = ZoneRulesProvider.getAvailableGroupIds();\nSet<String> groups2 = ZoneRulesProvider.getAvailableGroupIds();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    Set<String> pre = ZoneRulesProvider.getAvailableGroupIds();\n-    assertEquals(pre.contains(\"TEMPMOCK.-_\"), false);\n+    Set<String> pre = ZoneRulesProvider.getAvailableZoneIds();",
                "-    assertEquals(post.contains(\"TEMPMOCK.-_\"), true);\n-    assertEquals(ZoneRulesProvider.getProvider(\"TEMPMOCK.-_\").getGroupId(), \"TEMPMOCK.-_\");\n-    assertEquals(ZoneRulesProvider.getProvider(\"TEMPMOCK.-_\").getRules(\"World%@~.-_\", \"1.-_\").isFixedOffset(), true);\n+    assertEquals(pre.contains(\"FooLocation\"), false);\n+    Set<String> post = ZoneRulesProvider.getAvailableZoneIds();",
                "-      position += matchedGroupLen;\n-      ZoneRulesProvider provider = ZoneRulesProvider.getProvider(matchedGroupId);\n-      Entry<Integer, SubstringTree> entry = preparedTree.get(matchedGroupId);\n-      Set<String> regionIds = provider.getAvailableRegionIds();\n+      Set<String> regionIds = ZoneRulesProvider.getAvailableZoneIds();"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-      registerProvider(provider);\n+      registerProvider0(provider);\n+    }\n+    PROVIDERS.addAll(loaded);\n+  }\n+  public static ZoneRules getRules(String zoneId) {\n+    Objects.requireNonNull(zoneId, \"zoneId\");\n+    return getProvider(zoneId).provideRules(zoneId);\n+  }\n+  public static NavigableMap<String, ZoneRules> getVersions(String zoneId) {",
                    "-    return group;\n+    return changed;",
                    "+  }\n+  public static void registerProvider(ZoneRulesProvider provider) {\n+    Objects.requireNonNull(provider, \"provider\");\n+    registerProvider0(provider);\n+    PROVIDERS.add(provider);\n+  }\n+  private static void registerProvider0(ZoneRulesProvider provider) {\n+    for (String zoneId : provider.provideZoneIds()) {\n+      Objects.requireNonNull(zoneId, \"zoneId\");\n+      ZoneRulesProvider old = ZONES.putIfAbsent(zoneId, provider.provideBind(zoneId));"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    public Set<String> getAvailableRegionIds() {\n-      return new HashSet<String>(Arrays.asList(\"World%@~.-_\"));\n+    protected ZoneRulesProvider provideBind(String zoneId) {\n+      return this;",
                    "-    public SortedSet<String> getAvailableVersionIds() {\n-      return new TreeSet<String>(Arrays.asList(\"1.-_\"));\n+    protected NavigableMap<String, ZoneRules> provideVersions(String zoneId) {\n+      NavigableMap<String, ZoneRules> result = new TreeMap<>();\n+      result.put(\"BarVersion\", rules);\n+      return result;",
                    "-    public MockTempProvider() {\n-      super(\"TEMPMOCK.-_\");\n+    final ZoneRules rules = ZoneOffset.of(\"+01:45\").getRules();\n+    @Override\n+    public Set<String> provideZoneIds() {\n+      return new HashSet<String>(Collections.singleton(\"FooLocation\"));"
                ]
            }
        ]
    },
    {
        "id": 31,
        "Anal": "The method name \"isSPNegoMessage\" has been changed to \"isSPNegTokenInitMessage\".",
        "Stmts": "Assert.assertFalse(header.isSPNegoMessage());\nAssert.assertFalse(header.isSPNegoMessage());\nAssert.assertTrue(header.isSPNegoMessage());",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    return this.isNtlmType1Message() || this.isSPNegoMessage();\n+    return this.isNtlmType1Message() || this.isSPNegTokenInitMessage();"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    return this.isNtlmType1Message() || this.isSPNegoMessage();\n+    return this.isNtlmType1Message() || this.isSPNegTokenInitMessage();"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 32,
        "Anal": "The second parameter \"stack\" of the method \"findByClusterStackAndVersion\" changes from `String` to `StackId`.",
        "Stmts": "Assert.assertEquals(3, hostVersionDAO.findByClusterStackAndVersion(\"test_cluster1\", \"HDP-2.2\", \"2.2.0.0-995\").size());\nAssert.assertEquals(3, hostVersionDAO.findByClusterStackAndVersion(\"test_cluster1\", \"HDP-2.2\", \"2.2.0.1-996\").size());\nAssert.assertEquals(3, hostVersionDAO.findByClusterStackAndVersion(\"test_cluster1\", \"HDP-2.2\", \"2.2.1.0-500\").size());",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [
            {
                "info": "Defined in class StackId (optional references)",
                "contexts": [
                    "public StackId();",
                    "public StackId(String stackId);",
                    "public StackId(StackEntity stackEntity);"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public HostVersionEntity findByClusterStackVersionAndHost(String clusterName, String stack, String version, String hostName) {\n+  public HostVersionEntity findByClusterStackVersionAndHost(String clusterName, StackId stackId, String version, String hostName) {",
                    "-    query.setParameter(\"stack\", stack);\n+    query.setParameter(\"stackName\", stackId.getStackName());\n+    query.setParameter(\"stackVersion\", stackId.getStackVersion());"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    ClusterVersionEntity clusterVersionEntity = new ClusterVersionEntity(clusterEntity, helper.getOrCreateRepositoryVersion(\"HDP-2.2\", \"2.2.0.0-995\"), RepositoryVersionState.CURRENT, System.currentTimeMillis(), System.currentTimeMillis(), \"admin\");\n+    ClusterVersionEntity clusterVersionEntity = new ClusterVersionEntity(clusterEntity, helper.getOrCreateRepositoryVersion(HDP_22_STACK, \"2.2.0.0-995\"), RepositoryVersionState.CURRENT, System.currentTimeMillis(), System.currentTimeMillis(), \"admin\");",
                    "-      HostVersionEntity hostVersionEntity = new HostVersionEntity(hostEntities[i].getHostName(), helper.getOrCreateRepositoryVersion(\"HDP-2.2\", \"2.2.1.0-500\"), desiredState);\n+      HostVersionEntity hostVersionEntity = new HostVersionEntity(hostEntities[i].getHostName(), helper.getOrCreateRepositoryVersion(HDP_22_STACK, \"2.2.1.0-500\"), desiredState);",
                    "-      HostVersionEntity hostVersionEntity = new HostVersionEntity(host.getHostName(), helper.getOrCreateRepositoryVersion(\"HDP-2.2\", \"2.2.0.1-996\"), RepositoryVersionState.INSTALLED);\n+      HostVersionEntity hostVersionEntity = new HostVersionEntity(host.getHostName(), helper.getOrCreateRepositoryVersion(HDP_22_STACK, \"2.2.0.1-996\"), RepositoryVersionState.INSTALLED);"
                ]
            }
        ]
    },
    {
        "id": 33,
        "Anal": "The parameter \"stack\" of the method \"findByStack\" changes from `String` to `StackId`.",
        "Stmts": "Assert.assertEquals(0, repositoryVersionDAO.findByStack(\"non existing\").size());\nAssert.assertEquals(1, repositoryVersionDAO.findByStack(\"stack\").size());",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    List<RepositoryVersionEntity> existingRepoVersions = repositoryVersionDAO.findByStack(requiredStack.getStackId());\n+    List<RepositoryVersionEntity> existingRepoVersions = repositoryVersionDAO.findByStack(requiredStack);",
                "-        requestedEntities.addAll(s_repositoryVersionDAO.findByStack(stackId.getStackId()));\n+        requestedEntities.addAll(s_repositoryVersionDAO.findByStack(stackId));",
                "-        requestedEntities.addAll(s_repositoryVersionDAO.findByStack(stackId.getStackId()));\n+        requestedEntities.addAll(s_repositoryVersionDAO.findByStack(stackId));\n-            requestedEntities.addAll(s_repositoryVersionDAO.findByStack(up.getTargetStack()));\n+            StackId targetStackId = new StackId(up.getTargetStack());\n+            requestedEntities.addAll(s_repositoryVersionDAO.findByStack(targetStackId));"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class StackId (optional references)",
                "contexts": [
                    "public StackId();",
                    "public StackId(String stackId);",
                    "public StackId(StackInfo stackInfo);",
                    "public void setStackId(String stackId);",
                    "public String getStackId();",
                    "public String getStackName();"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public RepositoryVersionEntity create(String stack, String version, String displayName, String upgradePack, String operatingSystems) throws AmbariException {\n-    if (stack == null || stack.isEmpty() || version == null || version.isEmpty() || displayName == null || displayName.isEmpty()) {\n+  public RepositoryVersionEntity create(StackEntity stackEntity, String version, String displayName, String upgradePack, String operatingSystems) throws AmbariException {\n+    if (stackEntity == null || version == null || version.isEmpty() || displayName == null || displayName.isEmpty()) {",
                    "-      throw new AmbariException(\"Repository version for stack \" + stack + \" and version \" + version + \" already exists\");\n+      throw new AmbariException(\"Repository version for stack \" + stackEntity + \" and version \" + version + \" already exists\");",
                    "-    RepositoryVersionEntity newEntity = new RepositoryVersionEntity(stack, version, displayName, upgradePack, operatingSystems);\n+    RepositoryVersionEntity newEntity = new RepositoryVersionEntity(stackEntity, version, displayName, upgradePack, operatingSystems);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "+    StackEntity stackEntity = stackDAO.find(HDP_206.getStackName(), HDP_206.getStackVersion());\n+    Assert.assertNotNull(stackEntity);",
                    "+    stackDAO = injector.getInstance(StackDAO.class);",
                    "+  private StackDAO stackDAO;"
                ]
            }
        ]
    },
    {
        "id": 34,
        "Anal": "The method name \"hexDigitToBoolArray\" has been changed to \"hexDigitToBinary\".",
        "Stmts": "assertBoolArrayEquals(new boolean[] {false, false, false, false}, Conversion.hexDigitToBoolArray('0'));\nConversion.hexDigitToBoolArray('G');",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public static char boolArrayBeMsb0ToHexDigit(boolean[] src) {\n-    return boolArrayBeMsb0ToHexDigit(src, 0);\n-  }\n-  public static char boolArrayBeMsb0ToHexDigit(boolean[] src, int srcPos) {\n+  public static char binaryBeMsb0ToHexDigit(boolean[] src) {\n+    return binaryBeMsb0ToHexDigit(src, 0);\n+  }\n+  public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) {",
                    "-  public static short boolArrayToShort(boolean[] src, int srcPos, short dstInit, int dstPos, int nBools) {\n+  public static short binaryToShort(boolean[] src, int srcPos, short dstInit, int dstPos, int nBools) {",
                    "-  public static byte boolArrayToByte(boolean[] src, int srcPos, byte dstInit, int dstPos, int nBools) {\n+  public static byte binaryToByte(boolean[] src, int srcPos, byte dstInit, int dstPos, int nBools) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-  static void assertBoolArrayEquals(boolean[] expected, boolean[] actual) {\n+  static void assertBinaryEquals(boolean[] expected, boolean[] actual) {"
                ]
            }
        ]
    },
    {
        "id": 35,
        "Anal": "The method \"createSSLEngineFactory\" has been renamed to \"createInternalServerSSLEngineFactory\" and the parameter \"clientMode\" has been removed.",
        "Stmts": "final SSLEngineFactory serverSSLEngineFactory = SSLUtils.createServerSSLEngineFactory(serverConfig);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    }\n-    return serverSSLContext;\n+  @Nullable\n+  public SSLEngineFactory createServerSSLEngineFactory() throws Exception {\n+    return getSSLEnabled() ? SSLUtils.createInternalServerSSLEngineFactory(config) : null;"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+    String keystoreFilePath = getAndCheckOption(config, SecurityOptions.SSL_INTERNAL_KEYSTORE, SecurityOptions.SSL_KEYSTORE);\n+    String keystorePassword = getAndCheckOption(config, SecurityOptions.SSL_INTERNAL_KEYSTORE_PASSWORD, SecurityOptions.SSL_KEYSTORE_PASSWORD);\n+    String certPassword = getAndCheckOption(config, SecurityOptions.SSL_INTERNAL_KEY_PASSWORD, SecurityOptions.SSL_KEY_PASSWORD);\n+    String trustStoreFilePath = getAndCheckOption(config, SecurityOptions.SSL_INTERNAL_TRUSTSTORE, SecurityOptions.SSL_TRUSTSTORE);\n+    String trustStorePassword = getAndCheckOption(config, SecurityOptions.SSL_INTERNAL_TRUSTSTORE_PASSWORD, SecurityOptions.SSL_TRUSTSTORE_PASSWORD);\n+    String sslProtocolVersion = config.getString(SecurityOptions.SSL_PROTOCOL);\n+    KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+    try (InputStream keyStoreFile = Files.newInputStream(new File(keystoreFilePath).toPath())) {\n+      keyStore.load(keyStoreFile, keystorePassword.toCharArray());\n+    }",
                    "-    return clientSSLContext;\n+    String keystoreFilePath = getAndCheckOption(config, SecurityOptions.SSL_REST_KEYSTORE, SecurityOptions.SSL_KEYSTORE);\n+    String keystorePassword = getAndCheckOption(config, SecurityOptions.SSL_REST_KEYSTORE_PASSWORD, SecurityOptions.SSL_KEYSTORE_PASSWORD);\n+    String certPassword = getAndCheckOption(config, SecurityOptions.SSL_REST_KEY_PASSWORD, SecurityOptions.SSL_KEY_PASSWORD);\n+    String sslProtocolVersion = config.getString(SecurityOptions.SSL_PROTOCOL);\n+    KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+    try (InputStream keyStoreFile = Files.newInputStream(new File(keystoreFilePath).toPath())) {\n+      keyStore.load(keyStoreFile, keystorePassword.toCharArray());\n+    }\n+    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());",
                    "+    sslContext.init(null, tmf.getTrustManagers(), null);\n+    return sslContext;\n+  }\n+  private static String getAndCheckOption(Configuration config, ConfigOption<String> primaryOption, ConfigOption<String> fallbackOption) {\n+    String value = config.getString(primaryOption, config.getString(fallbackOption));\n+    if (value != null) {\n+      return value;\n+    } else {\n+      throw new IllegalConfigurationException(\"The config option \" + primaryOption.key() + \" or \" + fallbackOption.key() + \" is missing.\");\n+    }"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-public class SSLUtilsTest {}\n+public class SSLUtilsTest {\n+  public static final String TRUST_STORE_PATH = SSLUtilsTest.class.getResource(\"/local127.truststore\").getFile();\n+  public static final String KEY_STORE_PATH = SSLUtilsTest.class.getResource(\"/local127.keystore\").getFile();\n+  public static final String UNTRUSTED_KEY_STORE_PATH = SSLUtilsTest.class.getResource(\"/local127.keystore\").getFile();\n+  public static final String TRUST_STORE_PASSWORD = \"password\";\n+  public static final String KEY_STORE_PASSWORD = \"password\";\n+  public static final String KEY_PASSWORD = \"password\";\n+  public static Configuration createRestSslConfigWithKeyStore() {\n+    final Configuration config = new Configuration();",
                    "+    config.setBoolean(SecurityOptions.SSL_REST_ENABLED, true);\n+    addRestKeyStoreConfig(config);\n+    addRestTrustStoreConfig(config);\n+    return config;\n+  }\n+  public static Configuration createInternalSslConfigWithKeyStore() {\n+    final Configuration config = new Configuration();\n+    config.setBoolean(SecurityOptions.SSL_INTERNAL_ENABLED, true);\n+    addInternalKeyStoreConfig(config);\n+    return config;",
                    "+  private static void addInternalKeyStoreConfig(Configuration config) {\n+    config.setString(SecurityOptions.SSL_INTERNAL_KEYSTORE, KEY_STORE_PATH);\n+    config.setString(SecurityOptions.SSL_INTERNAL_KEYSTORE_PASSWORD, KEY_STORE_PASSWORD);\n+    config.setString(SecurityOptions.SSL_INTERNAL_KEY_PASSWORD, KEY_PASSWORD);\n+  }\n+  private static void addInternalTrustStoreConfig(Configuration config) {\n+    config.setString(SecurityOptions.SSL_INTERNAL_TRUSTSTORE, TRUST_STORE_PATH);\n+    config.setString(SecurityOptions.SSL_INTERNAL_TRUSTSTORE_PASSWORD, TRUST_STORE_PASSWORD);\n+  }\n+}"
                ]
            }
        ]
    },
    {
        "id": 36,
        "Anal": "The return type of the method \"getSnapshottingSettings\" changes from `JobSnapshottingSettings` to `JobCheckpointingSettings`.",
        "Stmts": "JobSnapshottingSettings snapshottingSettings = new JobSnapshottingSettings(Collections.singletonList(new JobVertexID()), Collections.singletonList(new JobVertexID()), Collections.singletonList(new JobVertexID()), 181238123L, 19191992L, 191929L, 123, ExternalizedCheckpointSettings.none(), null, false);\nassertEquals(snapshottingSettings, tracker.getSnapshottingSettings());",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "       return checkpointStatsTracker.getSnapshottingSettings();"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class JobCheckpointingSettings (optional references)",
                "contexts": [
                    "@Nullable public StateBackend getDefaultStateBackend();",
                    "public JobCheckpointingSettings( List<JobVertexID> verticesToTrigger, List<JobVertexID> verticesToAcknowledge, List<JobVertexID> verticesToConfirm, long checkpointInterval, long checkpointTimeout, long minPauseBetweenCheckpoints, int maxConcurrentCheckpoints, ExternalizedCheckpointSettings externalizedCheckpointSettings, @Nullable StateBackend defaultStateBackend, boolean isExactlyOnce);",
                    "@Override public String toString();"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  private final JobSnapshottingSettings jobSnapshottingSettings;\n+  private final JobCheckpointingSettings jobCheckpointingSettings;",
                    "-  public CheckpointStatsTracker(int numRememberedCheckpoints, List<ExecutionJobVertex> jobVertices, JobSnapshottingSettings jobSnapshottingSettings, MetricGroup metricGroup) {\n+  public CheckpointStatsTracker(int numRememberedCheckpoints, List<ExecutionJobVertex> jobVertices, JobCheckpointingSettings jobCheckpointingSettings, MetricGroup metricGroup) {",
                    "-    this.jobSnapshottingSettings = checkNotNull(jobSnapshottingSettings);\n+    this.jobCheckpointingSettings = checkNotNull(jobCheckpointingSettings);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    return new CheckpointStatsTracker(0, Collections.singletonList(jobVertex), mock(JobSnapshottingSettings.class), new UnregisteredMetricsGroup());\n+    return new CheckpointStatsTracker(0, Collections.singletonList(jobVertex), mock(JobCheckpointingSettings.class), new UnregisteredMetricsGroup());"
                ]
            }
        ]
    },
    {
        "id": 37,
        "Anal": "The return type of the method \"getInputs\" changes from `List<Output>` to `List<Operator<?>.Output>`.",
        "Stmts": "final List<Operator.Output> result = fixture.getInputs();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "+      final List<Operator<?>.Output> operatorInputs = new ArrayList<Operator<?>.Output>(operator.getInputs());",
                "+      final Operator<?>.Output input = operator.getInputs().get(inputIndex);",
                "         for (int index = 0; index < operator.getInputs().size(); index++) {\n-          final Output input = operator.getInput(index);\n+          final Operator<?>.Output input = operator.getInput(index);\n-        final Source[] moduleInputs = module.getInputs();\n-        DependencyAwareGraphTraverser.INSTANCE.traverse(module.getAllOutputs(), OperatorNavigator.INSTANCE, new GraphTraverseListener<Operator>() {"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  private transient List<Operator<Self>.Output> inputs = new ArrayList<Operator<Self>.Output>();\n+  private transient List<Operator<?>.Output> inputs = new ArrayList<Operator<?>.Output>();",
                    "-      final Output other = (Output)obj;\n+      @SuppressWarnings(\"unchecked\") final Operator<Self>.Output other = (Operator<Self>.Output)obj;",
                    "-        final ListIterator<Output> e = Operator.this.inputs.listIterator();\n+        final ListIterator<Operator<?>.Output> e = Operator.this.inputs.listIterator();"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-  static class OpImpl extends Operator {\n+  static class OpImpl extends Operator<OpImpl> {"
                ]
            }
        ]
    },
    {
        "id": 38,
        "Anal": "The method \"clearAndPut\" now returns a List of Runnables and throws a MailboxStateException. It also changes the parameter name from \"shutdownAction\" to \"priorityLetter\".",
        "Stmts": "mailbox.clearAndPut(POISON_LETTER);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "+      List<Runnable> droppedRunnables = mailbox.clearAndPut(priorityLetter);\n+      FutureUtils.cancelRunnableFutures(droppedRunnables);\n+    } catch (MailboxStateException msex) {\n+      LOG.debug(\"Mailbox already closed in cancel().\", msex);\n+    }"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+    checkPutStateConditions();\n+    headIndex = decreaseIndexWithWrapAround(headIndex);\n+    this.ringBuffer[headIndex] = letter;\n+    ++count;\n+    notEmpty.signal();\n+  }\n+  private void putTailInternal(Runnable letter) throws MailboxStateException {\n+    assert lock.isHeldByCurrentThread();\n+    checkPutStateConditions();",
                    "-        putInternal(letter);\n+        putTailInternal(letter);",
                    "+  }"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "+    } catch (MailboxStateException ignore) {}\n+  }\n+  private void testAllPuttingUnblocksInternal(Consumer<Mailbox> unblockMethod) throws InterruptedException {\n+    testUnblocksInternal(() -> mailbox.putMail(() -> {}), unblockMethod, MailboxStateException.class);\n+    setUp();\n+    testUnblocksInternal(() -> mailbox.putFirst(() -> {}), unblockMethod, MailboxStateException.class);\n+    setUp();\n+    testUnblocksInternal(() -> mailbox.clearAndPut(() -> {}), unblockMethod, MailboxStateException.class);\n+  }\n+  private void testUnblocksInternal(RunnableWithException testMethod, Consumer<Mailbox> unblockMethod, Class<?> expectedExceptionClass) throws InterruptedException {",
                    "+    try {\n+      mailbox.tryPutFirst(() -> {});\n+      Assert.fail();\n+    } catch (MailboxStateException ignore) {}\n+    try {\n+      mailbox.putMail(() -> {});\n+      Assert.fail();\n+    } catch (MailboxStateException ignore) {}\n+    try {\n+      mailbox.putFirst(() -> {});",
                    "+    mailbox.open();\n+  }\n+  @After\n+  public void tearDown() {\n+    mailbox.close();\n+  }\n+  private void testLifecyclePuttingInternal() throws Exception {\n+    try {\n+      mailbox.tryPutMail(() -> {});\n+      Assert.fail();"
                ]
            }
        ]
    },
    {
        "id": 39,
        "Anal": "The parameter \"millis\" of the method \"sleep\" changes from `long` to `Duration`.",
        "Stmts": "long expectedSleepTimeMs = new Random().nextInt(100);\nSysUtils.sleep(expectedSleepTimeMs);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-      int port = socket.getLocalPort();\n-      return port;\n+      return socket.getLocalPort();"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 40,
        "Anal": "The method \"getContainers\" has been updated to include two new parameters: `Resource maxContainerResource` and `Resource padding`. These parameters have been added between the existing parameters `PackingPlan currentPackingPlan` and `Map<String, TreeSet<Integer>> componentIndexes`.",
        "Stmts": "Map<Integer, Container> containers = PackingPlanBuilder.getContainers(packingPlan, paddingPercentage, new HashMap<String, TreeSet<Integer>>(), new TreeSet<Integer>());",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-      Resource resource = new Resource(Math.round(containerCpu), containerRam, containerDiskInBytes);\n-      PackingPlan.ContainerPlan containerPlan = new PackingPlan.ContainerPlan(containerId, instancePlans, resource);\n+      Resource totalUsedResources = container.getTotalUsedResources();\n+      Resource resource = new Resource(Math.round(totalUsedResources.getCpu()), totalUsedResources.getRam(), totalUsedResources.getDisk());\n+      PackingPlan.ContainerPlan containerPlan = new PackingPlan.ContainerPlan(containerId, container.getInstances(), resource);",
                    "-          newContainerMap.put(containerId, new Container(containerId, this.maxContainerResource, this.requestedContainerPadding));\n+          this.containers.put(containerId, new Container(containerId, this.maxContainerResource, this.requestedContainerPadding));",
                    "-    Resource instanceResource = PackingUtils.getResourceRequirement(componentName, this.componentRamMap, this.defaultInstanceResource, this.maxContainerResource, this.requestedContainerPadding);\n+    Resource instanceResource = componentResourceMap.getOrDefault(componentName, defaultInstanceResource);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    testContainers.add(new Container(3, null, 5));\n-    testContainers.add(new Container(6, null, 20));\n-    testContainers.add(new Container(4, null, 20));\n+    testContainers.add(new Container(3, null, new Resource(5, ByteAmount.fromGigabytes(5), ByteAmount.fromGigabytes(5))));\n+    testContainers.add(new Container(6, null, new Resource(20, ByteAmount.fromGigabytes(20), ByteAmount.fromGigabytes(20))));\n+    testContainers.add(new Container(4, null, new Resource(20, ByteAmount.fromGigabytes(20), ByteAmount.fromGigabytes(20))));",
                    "-      return container.getPaddingPercentage();\n+      return container.getPadding().getCpu();"
                ]
            }
        ]
    },
    {
        "id": 41,
        "Anal": "The method \"assign\" has been updated to include a new parameter \"stellarContext\" of type `Context`.",
        "Stmts": "executor.assign(\"foo\", \"2\", message);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-      expressions.forEach((var, expr) -> executor.assign(var, expr, message));\n+      expressions.forEach((var, expr) -> executor.assign(var, expr, message, stellarContext));"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class Context (optional references)",
                "contexts": [
                    "public static Context EMPTY_CONTEXT();",
                    "public Optional<Object> getCapability(Enum<?> capability);"
                ]
            },
            {
                "info": "Defined in class Context.Capability.Builder (optional references)",
                "contexts": [
                    "public Builder with(String s, Capability capability);"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public <T> T execute(String expr, JSONObject message, Class<T> clazz) {\n-    Object resultObject = execute(expr, message);\n+  public <T> T execute(String expr, JSONObject message, Class<T> clazz, Context stellarContext) {\n+    Object resultObject = execute(expr, message, stellarContext);",
                    "-      return processor.parse(expr, resolver, StellarFunctions.FUNCTION_RESOLVER(), Context.EMPTY_CONTEXT());\n+      return processor.parse(expr, resolver, StellarFunctions.FUNCTION_RESOLVER(), stellarContext);",
                    "-  private Object execute(String expr, JSONObject msg) {\n+  private Object execute(String expr, JSONObject msg, Context stellarContext) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 42,
        "Anal": "The method \"execute\" has been updated to include a new parameter \"stellarContext\" of type `Context`.",
        "Stmts": "String actual = executor.execute(\"TO_UPPER('lowercase')\", message, String.class);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-      result = executor.execute(resultExpr, new JSONObject(), Object.class);\n+      result = executor.execute(resultExpr, new JSONObject(), Object.class, stellarContext);",
                "-    if (StringUtils.isBlank(onlyIf) || executor.execute(onlyIf, message, Boolean.class)) {\n+    if (StringUtils.isBlank(onlyIf) || executor.execute(onlyIf, message, Boolean.class, stellarContext)) {",
                "-    if (StringUtils.isBlank(onlyIf) || executor.execute(onlyIf, message, Boolean.class)) {\n+    if (StringUtils.isBlank(onlyIf) || executor.execute(onlyIf, message, Boolean.class, stellarContext)) {\n-      String entity = executor.execute(profile.getForeach(), message, String.class);\n+      String entity = executor.execute(profile.getForeach(), message, String.class, stellarContext);"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class Context (optional references)",
                "contexts": [
                    "public static Context EMPTY_CONTEXT();",
                    "public Optional<Object> getCapability(String capability);"
                ]
            },
            {
                "info": "Defined in class Context.Capability (optional references)",
                "contexts": [
                    "Object get();"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-      return processor.parse(expr, resolver, StellarFunctions.FUNCTION_RESOLVER(), Context.EMPTY_CONTEXT());\n+      return processor.parse(expr, resolver, StellarFunctions.FUNCTION_RESOLVER(), stellarContext);",
                    "-  private Object execute(String expr, JSONObject msg) {\n+  private Object execute(String expr, JSONObject msg, Context stellarContext) {",
                    "-  void assign(String variable, String expression, JSONObject message);\n-  <T> T execute(String expression, JSONObject message, Class<T> clazz);\n+  void assign(String variable, String expression, JSONObject message, Context stellarContext);\n+  <T> T execute(String expression, JSONObject message, Class<T> clazz, Context stellarContext);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 43,
        "Anal": "The method \"removePartition\" now throws a `MetadataServiceException`.",
        "Stmts": "pdms.removePartition(newHCatDependency, false);\npdms.removePartition(newHCatDependency);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "       removePartition(partition, true);"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-      _registerMessageReceiver(_getTopic(partition));\n+      _registerMessageReceiver(partition);",
                    "+      }\n+    }\n+    return result;",
                    "-  private void _registerMessageReceiver(String topic) throws Exception {\n-    MessageReceiver recvr = new MessageReceiver(new HCatMessageHandler());\n-    log.debug(\"Registering topic :\" + topic);\n-    recvr.registerTopic(topic);\n+  private void _registerMessageReceiver(PartitionWrapper partition) throws MetadataServiceException {\n+    String topic = _getTopic(partition);\n+    try {\n+      MessageReceiver recvr = Services.get().get(JMSAccessorService.class).getTopicReceiver(topic);\n+      if (recvr == null) {\n+        recvr = new MessageReceiver(new HCatMessageHandler());"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "+  protected static final String localActiveMQBroker = \"vm://localhost?broker.persistent=false\";\n+  protected static final String ActiveMQConnFactory = \"org.apache.activemq.jndi.ActiveMQInitialContextFactory\";",
                    "+  protected Services setupServicesForHCatalog() throws ServiceException {\n+    Services services = new Services();\n+    Configuration conf = services.getConf();\n+    conf.set(Services.CONF_SERVICE_EXT_CLASSES, \"org.apache.oozie.service.PartitionDependencyManagerService,\"\n+                                                    + \"org.apache.oozie.service.JMSAccessorService,\"\n+                                                    + \"org.apache.oozie.service.MetaDataAccessorService\");\n+    conf.set(JMSAccessorService.JMS_CONNECTIONS_PROPERTIES, \"default=java.naming.factory.initial#\" + ActiveMQConnFactory + \";\"\n+                                                                + \"java.naming.provider.url#\" + localActiveMQBroker);\n+    return services;\n+  }",
                    "-    Services services = new Services();\n-    addServiceToRun(services.getConf(), PartitionDependencyManagerService.class.getName());\n+    Services services = super.setupServicesForHCatalog();"
                ]
            }
        ]
    },
    {
        "id": 44,
        "Anal": "The parameter of the method \"parseServiceRequestPath\" changes from `String` to `HttpServletRequest`.",
        "Stmts": "ServiceRequestPathInfo info = GatewayServlet.parseServiceRequestPath(null);\ninfo = GatewayServlet.parseServiceRequestPath(\"/invalidpath\");\ninfo = GatewayServlet.parseServiceRequestPath(\"/invalid/path\");\ninfo = GatewayServlet.parseServiceRequestPath(\"/Org1/Service1/1.0\");\ninfo = GatewayServlet.parseServiceRequestPath(\"/MyOrg/Service-99/2.7\");\ninfo = GatewayServlet.parseServiceRequestPath(\"/MyOrg/Service-99/2.7/resource\");\ninfo = GatewayServlet.parseServiceRequestPath(\"/MyOrg/Service-99/2.7/path/to/resource\");\ninfo = GatewayServlet.parseServiceRequestPath(\"/MyOrg/Service-99/2.7/path/to/resource?query=1234\");",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    ServiceRequestPathInfo pathInfo = parseServiceRequestPath(request.getPathInfo());\n+    ServiceRequestPathInfo pathInfo = parseServiceRequestPath(request);"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    ServiceRequestPathInfo pathInfo = parseServiceRequestPath(request.getPathInfo());\n+    ServiceRequestPathInfo pathInfo = parseServiceRequestPath(request);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-public class GatewayServletTest {}\n+public class GatewayServletTest {\n+  private ServiceRequestPathInfo parseServiceRequestPath(String path) {\n+    return parseServiceRequestPath(path, null, null);\n+  }\n+  private ServiceRequestPathInfo parseServiceRequestPath(String path, String acceptHeader, String apiVersionHeader) {\n+    MockHttpServletRequest mockReq = new MockHttpServletRequest(path);\n+    if (acceptHeader != null) {\n+      mockReq.setHeader(\"Accept\", acceptHeader);\n+    }",
                    "+      mockReq.setHeader(\"X-API-Version\", apiVersionHeader);\n+    }\n+    return GatewayServlet.parseServiceRequestPath(mockReq);\n+  }\n+}"
                ]
            }
        ]
    },
    {
        "id": 45,
        "Anal": "The method \"visitLabels\" changes from accepting an `AcceptsLabelAttribute` parameter to returning a `Collection<DepEdge>`.",
        "Stmts": "VisitationRecorder recorder = new VisitationRecorder(\"srcs\");\nmapper.visitLabels(recorder);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": []
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    }\n+  protected static List<String> getLabelsForAttribute(AttributeMap attributeMap, String attributeName) throws InterruptedException {\n+    return attributeMap.visitLabels().stream().filter((d) -> d.getAttribute().getName().equals(attributeName)).map(AttributeMap.DepEdge::getLabel).map(Label::toString).collect(Collectors.toList());"
                ]
            }
        ]
    },
    {
        "id": 46,
        "Anal": "There is no change in the focal method as per the provided syntactic diff.",
        "Stmts": "",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": []
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 47,
        "Anal": "The parameters of the method \"divideInternally\" have been replaced by a single parameter of type `SubunitClustererParameters`.",
        "Stmts": "boolean divided = sc1.divideInternally(0.8, 3.0, 20);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-        clusters.get(c).divideInternally(params.getCoverageThreshold(), params.getRmsdThreshold(), params.getMinimumSequenceLength());\n+        clusters.get(c).divideInternally(params);"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class SubunitClustererParameters (optional references)",
                "contexts": [
                    "public SubunitClustererParameters();",
                    "public SubunitClustererParameters(boolean iUseGlobalMetrics);",
                    "public void setMinimumSequenceLength(int minimumSequenceLength);",
                    "public int getMinimumSequenceLength();",
                    "public void setMinimumSequenceLengthFraction( double minimumSequenceLengthFraction);",
                    "public void setSequenceCoverageThreshold(double sequenceCoverageThreshold);",
                    "public void setStructureCoverageThreshold(double structureCoverageThreshold);",
                    "public double getStructureCoverageThreshold();",
                    "public void setRMSDThreshold(double rmsdThreshold);",
                    "public double getRMSDThreshold();",
                    "public void setUseRMSD(boolean useRMSD);"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+      double gaps2 = aligner.getPair().getAlignedSequence(2).getNumGapPositions();\n+      double lengthAlignment = aligner.getPair().getLength();\n+      double lengthThis = aligner.getQuery().getLength();\n+      double lengthOther = aligner.getTarget().getLength();\n+      sequenceCoverage = (lengthAlignment - gaps1 - gaps2) / Math.max(lengthThis, lengthOther);\n+      if (sequenceCoverage < params.getSequenceCoverageThreshold())\n+        return false;\n+    }",
                    "+    double sequenceIdentity;\n+    if (params.isUseGlobalMetrics()) {\n+      sequenceIdentity = aligner.getPair().getPercentageOfIdentity(true);\n+    } else {\n+      sequenceIdentity = aligner.getPair().getPercentageOfIdentity(false);\n+    }\n+    if (sequenceIdentity < params.getSequenceIdentityThreshold())\n+      return false;\n+    double sequenceCoverage = 0;\n+    if (params.isUseSequenceCoverage()) {",
                    "+    } catch (NoSuchMethodException e) {}\n+    if (setOptimizeAlignment != null) {\n+      try {\n+        setOptimizeAlignment.invoke(aligner_params, params.isOptimizeAlignment());\n+      } catch (IllegalAccessException | InvocationTargetException e) {\n+        logger.warn(\"Could not set alignment optimisation switch\");\n+      }\n+    }"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 48,
        "Anal": "The method \"mergeStructure\" changes its parameters from `(SubunitCluster other, double maxRmsd, double minCoverage)` to `(SubunitCluster other, SubunitClustererParameters params)`.",
        "Stmts": "boolean merged13 = sc1.mergeStructure(sc3, 3.0, 0.9);\nboolean merged24 = sc2.mergeStructure(sc4, 3.0, 0.9);\nboolean merged = sc1.mergeStructure(sc2, 3.0, 0.9);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-        if (c1.get(i).mergeStructure(c2.get(j), cParams.getRmsdThreshold(), cParams.getCoverageThreshold(), aParams.getAligner()))\n+        if (c1.get(i).mergeStructure(c2.get(j), cParams)) {",
                "-          if (clusters.get(c1).mergeStructure(clusters.get(c2), params.getRmsdThreshold(), params.getCoverageThreshold()))\n+          if (clusters.get(c1).mergeStructure(clusters.get(c2), params)) {",
                "-          if (clusters.get(c1).mergeStructure(clusters.get(c2), params.getRmsdThreshold(), params.getCoverageThreshold()))\n+          if (clusters.get(c1).mergeStructure(clusters.get(c2), params))"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class SubunitClustererParameters (optional references)",
                "contexts": [
                    "public SubunitClustererParameters();",
                    "public SubunitClustererParameters(boolean iUseGlobalMetrics);",
                    "public void setUseStructureCoverage(boolean useStructureCoverage);",
                    "public boolean isUseStructureCoverage();",
                    "public void setUseSequenceCoverage(boolean useSequenceCoverage);",
                    "public void setUseRMSD(boolean useRMSD);",
                    "public boolean isUseRMSD();",
                    "public void setRMSDThreshold(double rmsdThreshold);"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+      double gaps2 = aligner.getPair().getAlignedSequence(2).getNumGapPositions();\n+      double lengthAlignment = aligner.getPair().getLength();\n+      double lengthThis = aligner.getQuery().getLength();\n+      double lengthOther = aligner.getTarget().getLength();\n+      sequenceCoverage = (lengthAlignment - gaps1 - gaps2) / Math.max(lengthThis, lengthOther);\n+      if (sequenceCoverage < params.getSequenceCoverageThreshold())\n+        return false;\n+    }",
                    "+    double sequenceIdentity;\n+    if (params.isUseGlobalMetrics()) {\n+      sequenceIdentity = aligner.getPair().getPercentageOfIdentity(true);\n+    } else {\n+      sequenceIdentity = aligner.getPair().getPercentageOfIdentity(false);\n+    }\n+    if (sequenceIdentity < params.getSequenceIdentityThreshold())\n+      return false;\n+    double sequenceCoverage = 0;\n+    if (params.isUseSequenceCoverage()) {",
                    "+  public boolean mergeSequence(SubunitCluster other, SubunitClustererParameters params) throws CompoundNotFoundException {\n+    PairwiseSequenceAlignerType alignerType = PairwiseSequenceAlignerType.LOCAL;\n+    if (params.isUseGlobalMetrics()) {\n+      alignerType = PairwiseSequenceAlignerType.GLOBAL;\n+    }\n+    return mergeSequence(other, params, alignerType, new SimpleGapPenalty(), SubstitutionMatrixHelper.getBlosum62());\n+  }\n+  public boolean mergeSequence(SubunitCluster other, SubunitClustererParameters params, PairwiseSequenceAlignerType alignerType, GapPenalty gapPenalty, SubstitutionMatrix<AminoAcidCompound> subsMatrix) throws CompoundNotFoundException {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 49,
        "Anal": "The method \"getPercentageOfIdentity\" now requires a boolean parameter \"countGaps\".",
        "Stmts": "assertEquals(global.getPercentageOfIdentity(), 1.0, 0.01);\nassertEquals(local.getPercentageOfIdentity(), 1.0, 0.01);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "+    double sequenceIdentity;\n+    if (params.isUseGlobalMetrics()) {\n+      sequenceIdentity = aligner.getPair().getPercentageOfIdentity(true);\n+    } else {\n+      sequenceIdentity = aligner.getPair().getPercentageOfIdentity(false);",
                "-    if (seqid < minSeqid)\n-      return false;\n+    double sequenceIdentity;\n+    if (params.isUseGlobalMetrics()) {\n+      sequenceIdentity = aligner.getPair().getPercentageOfIdentity(true);"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": []
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 50,
        "Anal": "The parameter \"filename\" of the method \"deploy\" changes from `String` to `Class<? extends Application>`.",
        "Stmts": "HttpResponse response = deploy(\"WordCount.jar\");",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-      Assert.assertEquals(200, GatewayFastTestsSuite.POST(\"/v2/apps/WordCountApp/flows/WordCountFlow/start\", null).getStatusLine().getStatusCode());\n-      Assert.assertEquals(200, GatewayFastTestsSuite.POST(\"/v2/apps/WordCountApp/flows/WordCountFlow/stop\", null).getStatusLine().getStatusCode());\n-      Assert.assertEquals(200, GatewayFastTestsSuite.POST(\"/v2/apps/WordCountApp/flows/WordCountFlow/start\", null).getStatusLine().getStatusCode());\n-      Assert.assertEquals(200, GatewayFastTestsSuite.POST(\"/v2/apps/WordCountApp/flows/WordCountFlow/stop\", null).getStatusLine().getStatusCode());\n-      Assert.assertEquals(200, GatewayFastTestsSuite.DELETE(\"/v2/apps/WordCountApp\").getStatusLine().getStatusCode());\n-      response = GatewayFastTestsSuite.GET(\"/v2/apps/WordCountApp/flows/WordCountFlow/history\");\n+      Assert.assertEquals(200, GatewayFastTestsSuite.POST(\"/v2/apps/WordCount/flows/WordCounter/start\", null).getStatusLine().getStatusCode());\n+      Assert.assertEquals(200, GatewayFastTestsSuite.POST(\"/v2/apps/WordCount/flows/WordCounter/stop\", null).getStatusLine().getStatusCode());\n+      Assert.assertEquals(200, GatewayFastTestsSuite.POST(\"/v2/apps/WordCount/flows/WordCounter/start\", null).getStatusLine().getStatusCode());\n+      Assert.assertEquals(200, GatewayFastTestsSuite.POST(\"/v2/apps/WordCount/flows/WordCounter/stop\", null).getStatusLine().getStatusCode());",
                    "-      Assert.assertEquals(200, GatewayFastTestsSuite.POST(\"/v2/apps/WordCountApp/flows/WordCountFlow/stop\", null).getStatusLine().getStatusCode());\n-      Assert.assertEquals(\"STOPPED\", getRunnableStatus(\"flows\", \"WordCountApp\", \"WordCountFlow\"));\n-      Assert.assertEquals(200, GatewayFastTestsSuite.DELETE(\"/v2/apps/WordCountApp\").getStatusLine().getStatusCode());\n-      Assert.assertEquals(404, GatewayFastTestsSuite.DELETE(\"/v2/apps/WordCountApp\").getStatusLine().getStatusCode());\n+      Assert.assertEquals(200, GatewayFastTestsSuite.POST(\"/v2/apps/WordCount/flows/WordCounter/stop\", null).getStatusLine().getStatusCode());\n+      Assert.assertEquals(\"STOPPED\", getRunnableStatus(\"flows\", \"WordCount\", \"WordCounter\"));\n+      Assert.assertEquals(200, GatewayFastTestsSuite.DELETE(\"/v2/apps/WordCount\").getStatusLine().getStatusCode());\n+      Assert.assertEquals(404, GatewayFastTestsSuite.DELETE(\"/v2/apps/WordCount\").getStatusLine().getStatusCode());",
                    "-    Assert.assertEquals(200, GatewayFastTestsSuite.DELETE(\"/v2/apps/WordCountApp\").getStatusLine().getStatusCode());\n+    Assert.assertEquals(200, GatewayFastTestsSuite.DELETE(\"/v2/apps/WordCount\").getStatusLine().getStatusCode());"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-  private HttpResponse deploy(String filename) throws Exception {\n-    File archive = FileUtils.toFile(getClass().getResource(\"/\" + filename));\n+  private HttpResponse deploy(Class<? extends Application> application) throws Exception {\n+    Manifest manifest = new Manifest();\n+    manifest.getMainAttributes().put(ManifestFields.MANIFEST_VERSION, \"1.0\");\n+    manifest.getMainAttributes().put(ManifestFields.MAIN_CLASS, application.getName());",
                    "-    put.setHeader(\"X-Archive-Name\", filename);\n+    put.setHeader(\"X-Archive-Name\", application.getSimpleName() + \".jar\");",
                    "-      bos.close();\n+      jarOut.close();"
                ]
            }
        ]
    },
    {
        "id": 51,
        "Anal": "The method name \"HypergeometricCdf\" has been changed to \"hypergeometricCdf\".",
        "Stmts": "double result = DiscreteDistributions.HypergeometricCdf(k, n, Kp, Np);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    double BT = Math.exp(ContinuousDistributions.LogGamma(S) - ContinuousDistributions.LogGamma(B) - ContinuousDistributions.LogGamma(A) + A * Math.log(Z) + B * Math.log(1 - Z));\n+    double BT = Math.exp(ContinuousDistributions.logGamma(S) - ContinuousDistributions.logGamma(B) - ContinuousDistributions.logGamma(A) + A * Math.log(Z) + B * Math.log(1 - Z));",
                    "-  public static double UniformCdf(int k, int n) {\n+  public static double uniformCdf(int k, int n) {",
                    "-  public static double Poisson(int k, double lamda) {\n+  public static double poisson(int k, double lamda) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 52,
        "Anal": "The method \"getColumns\" has been renamed to \"getXDataTypes\" and the return type has changed from `Map<Object, ColumnType>` to `Map<Object, TypeInference.DataType>`.",
        "Stmts": "Map<Object, Dataset.ColumnType> expResult = new LinkedHashMap<>();\nMap<Object, Dataset.ColumnType> result = instance.getColumns();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "   protected static void extractDummies(Dataset data, Map<Object, Object> referenceLevels) {\n-    Map<Object, Dataset.ColumnType> columnTypes = data.getColumns();\n+    Map<Object, TypeInference.DataType> columnTypes = data.getXDataTypes();",
                "+      minColumnValues.put(Dataset.yColumnName, min);\n+      maxColumnValues.put(Dataset.yColumnName, max);\n-    Dataset.ColumnType columnType = Dataset.value2ColumnType(data.get(data.iterator().next()).getY());\n-    if (columnType == Dataset.ColumnType.NUMERICAL) {\n+    if (data.getYDataType() == TypeInference.DataType.NUMERICAL) {",
                "   private static DataTable2D bivariateMatrix(Dataset dataSet, BivariateType type) {\n-    Map<Object, Dataset.ColumnType> variable2Type = dataSet.getColumns();\n-    Object[] allVariables = variable2Type.keySet().toArray();\n+    Map<Object, TypeInference.DataType> columnTypes = dataSet.getXDataTypes();\n+    Object[] allVariables = columnTypes.keySet().toArray();"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  private final Map<Object, ColumnType> columns;\n+  private TypeInference.DataType yDataType;\n+  private final Map<Object, TypeInference.DataType> xDataTypes;",
                    "-  public int size() {\n+  public int getVariableNumber() {\n+    return xDataTypes.size();\n+  }\n+  public int getRecordNumber() {",
                    "-    columns.clear();\n+    yDataType = null;\n+    xDataTypes.clear();"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 53,
        "Anal": "The method name \"allStoredEventsSince\" changes to \"findStoredEventsSince\".",
        "Stmts": "List<StoredEvent> result = instance.allStoredEventsSince(occurredFrom);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public List<StoredEvent> allStoredEventsBetween(Date occurredFrom, Date occurredTo) {\n+  public List<StoredEvent> findStoredEventsBetween(Date occurredFrom, Date occurredTo) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 54,
        "Anal": "The parameter \"m\" of the method \"putAll\" changes from `Map<? extends K, ? extends Object>` to `Map<? extends String, ? extends Object>`.",
        "Stmts": "MultiMap<String> input = new MultiMap<String>();\ninput.put(\"food\", \"apple\");\ninput.put(\"color\", \"red\");\ninput.put(\"amount\", \"bushel\");\nmm.putAll(input);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public Set<Entry<K, Object>> entrySet() {\n+  @Override\n+  public Set<Entry<String, Object>> entrySet() {",
                    "-  public Object put(K name, Object value) {\n+  @Override\n+  public Object put(String name, Object value) {",
                    "+  @Override"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-  private void assertValues(MultiMap<String> mm, String key, Object... expectedValues) {\n-    List<Object> values = mm.getValues(key);\n+  private void assertValues(MultiMap mm, String key, Object... expectedValues) {\n+    List<String> values = mm.getValues(key);",
                    "-  private void assertMapSize(MultiMap<String> mm, int expectedSize) {\n+  private void assertMapSize(MultiMap mm, int expectedSize) {",
                    "-  private void assertEmptyValues(MultiMap<String> mm, String key) {\n-    List<Object> values = mm.getValues(key);\n+  private void assertEmptyValues(MultiMap mm, String key) {\n+    List<String> values = mm.getValues(key);"
                ]
            }
        ]
    },
    {
        "id": 55,
        "Anal": "The visibility of the method \"transact\" has been changed from public to package-private.",
        "Stmts": "",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public <R> R transact(Work<R> work) {\n+  <R> R transact(Work<R> work) {",
                    "-  public <R> R transactNewReadOnly(Work<R> work) {\n+  <R> R transactNewReadOnly(Work<R> work) {",
                    "-  public <R> R transactNew(Work<R> work) {\n+  <R> R transactNew(Work<R> work) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    assertThat(ofy().transactNewReadOnly(new Work<Integer>() {\n+    assertThat(tm().transactNewReadOnly(new Work<Integer>() {"
                ]
            }
        ]
    },
    {
        "id": 56,
        "Anal": "The method name \"promote\" has been changed to \"setPrimary\".",
        "Stmts": "Keyset keyset = KeysetManager.withKeysetHandle(handle).promote(newPrimaryKeyId).getKeysetHandle().getKeyset();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-        return this;\n-      }\n-    }\n-    throw new GeneralSecurityException(\"key not found: \" + keyId);\n+    return setPrimary(keyId);"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+        if (key.getStatus() != KeyStatusType.ENABLED && key.getStatus() != KeyStatusType.DISABLED && key.getStatus() != KeyStatusType.DESTROYED) {\n+          throw new GeneralSecurityException(\"cannot destroy key with id \" + keyId + \" and status \" + key.getStatus());\n+        }",
                    "+        if (key.getStatus() != KeyStatusType.ENABLED && key.getStatus() != KeyStatusType.DISABLED) {\n+          throw new GeneralSecurityException(\"cannot disable key with id \" + keyId + \" and status \" + key.getStatus());\n+        }",
                    "+        if (key.getStatus() != KeyStatusType.ENABLED && key.getStatus() != KeyStatusType.DISABLED) {\n+          throw new GeneralSecurityException(\"cannot enable key with id \" + keyId + \" and status \" + key.getStatus());\n+        }"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-      manager.enable(keyId).promote(keyId);\n+      manager.enable(keyId).setPrimary(keyId);",
                    "-  private void enablePromoteKey(KeysetManager manager, int keyId) {\n+  private void enableSetPrimaryKey(KeysetManager manager, int keyId) {",
                    "-  private void disableEnablePromoteKey(KeysetManager manager, int keyId) {\n+  private void disableEnableSetPrimaryKey(KeysetManager manager, int keyId) {"
                ]
            }
        ]
    },
    {
        "id": 57,
        "Anal": "The return type of the method \"currentlyPreparedTxs\" changes from `Map<GridCacheVersion, WALPointer>` to `Set<GridCacheVersion>`.",
        "Stmts": "Map<GridCacheVersion, WALPointer> currentlyPreparedTxs = tracker.currentlyPreparedTxs();\nassertEquals(2, currentlyPreparedTxs.size());\nassertTrue(currentlyPreparedTxs.containsKey(nearXidVersion(1)));\nassertTrue(currentlyPreparedTxs.containsKey(nearXidVersion(3)));\n\nMap<GridCacheVersion, WALPointer> currentlyPreparedTxs = tracker.currentlyPreparedTxs();\nassertEquals(1, currentlyPreparedTxs.size());\nassertTrue(currentlyPreparedTxs.containsKey(nearXidVersion(1)));",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-      notCommittedInTimeoutTxs.putAll(currentlyPreparedTxs);\n-      Set<GridCacheVersion> pendingTxs = new HashSet<>(notCommittedInTimeoutTxs.keySet());\n+      notCommittedInTimeoutTxs.addAll(preparedCommittedTxsCounters.keySet());\n+      Set<GridCacheVersion> pendingTxs = new HashSet<>(notCommittedInTimeoutTxs);",
                    "-  private final ConcurrentHashMap<GridCacheVersion, WALPointer> currentlyPreparedTxs = new ConcurrentHashMap<>();\n-  private final ConcurrentHashMap<GridCacheVersion, AtomicInteger> preparedCommittedTxsCounters = new ConcurrentHashMap<>();\n-  private volatile ConcurrentHashMap<GridCacheVersion, WALPointer> trackedPreparedTxs = new ConcurrentHashMap<>();\n-  private volatile ConcurrentHashMap<GridCacheVersion, WALPointer> trackedCommittedTxs = new ConcurrentHashMap<>();\n+  private final ConcurrentHashMap<GridCacheVersion, Integer> preparedCommittedTxsCounters = new ConcurrentHashMap<>();\n+  private volatile GridConcurrentHashSet<GridCacheVersion> trackedPreparedTxs = new GridConcurrentHashSet<>();\n+  private volatile GridConcurrentHashSet<GridCacheVersion> trackedCommittedTxs = new GridConcurrentHashSet<>();",
                    "-          trackedCommittedTxs.put(nearXidVer, preparedPtr);\n+          trackedCommittedTxs.add(nearXidVer);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-  private Map<GridCacheVersion, WALPointer> awaitFinishOfPreparedTxs(long preparedTxsTimeout, long committingTxsTimeout) throws IgniteCheckedException {\n-    IgniteInternalFuture<Map<GridCacheVersion, WALPointer>> fut;\n+  private Set<GridCacheVersion> awaitFinishOfPreparedTxs(long preparedTxsTimeout, long committingTxsTimeout) throws IgniteCheckedException {\n+    IgniteInternalFuture<Set<GridCacheVersion>> fut;",
                    "-    tracker.onTxPrepared(nearXidVersion(txId), new FileWALPointer(0, txId * 10, 1));\n+    tracker.onTxPrepared(nearXidVersion(txId));"
                ]
            }
        ]
    },
    {
        "id": 58,
        "Anal": "The return type of the method \"solve\" changes from a 2D array of doubles (`double[][]`) to `DenseMatrix`.",
        "Stmts": "double[][] x = Math.solve(A, B2);\nassertEquals(X2.length, x.length);\nassertEquals(X2[0].length, x[0].length);\nfor (int i = 0; i < X2.length; i++) {\n    for (int j = 0; j < X2[i].length; j++) {\n      assertEquals(X2[i][j], x[i][j], 1E-7);\n    }\n}",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [
            {
                "info": "Defined in class DenseMatrix (optional references)",
                "contexts": [
                    "public double[][] array();",
                    "default public double[] diag();",
                    "public double det();",
                    "public double trace();",
                    "public double get(int i, int j);",
                    "default public double apply(int i, int j);",
                    "public abstract DenseMatrix set(int i, int j, double x);"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-      qr.solve(inv);\n-    }\n-    return inv;\n+      return qr.inverse();\n+    }",
                    "-    return EigenValueDecomposition.decompose(A);\n-  }\n-  public static EigenValueDecomposition eigen(double[][] A, boolean symmetric) {\n-    return EigenValueDecomposition.decompose(A, symmetric);\n-  }\n-  public static EigenValueDecomposition eigen(double[][] A, boolean symmetric, boolean onlyValues) {\n-    return EigenValueDecomposition.decompose(A, symmetric, onlyValues);\n+    return new EigenValueDecomposition(A);\n+  }\n+  public static EigenValueDecomposition eigen(double[][] A, boolean onlyValues) {",
                    "-    return SingularValueDecomposition.decompose(x).norm();\n+    return new SingularValueDecomposition(x).norm();"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 59,
        "Anal": "The method name \"colSum\" has been changed to \"colSums\".",
        "Stmts": "double[] result = Math.colSum(A);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public static double[] colSd(double[][] data) {\n+  public static double[] colSds(double[][] data) {",
                    "-  public static double[] rowSd(double[][] data) {\n+  public static double[] rowSds(double[][] data) {",
                    "+  public static double[][] transpose(double[][] A) {\n+    int m = A.length;\n+    int n = A[0].length;\n+    double[][] matrix = new double[n][m];\n+    for (int i = 0; i < m; i++) {\n+      for (int j = 0; j < n; j++) {\n+        matrix[j][i] = A[i][j];\n+      }\n+    }\n+    return matrix;"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 60,
        "Anal": "The return type of the method \"addAllAsync\" changes from `ICompletableFuture<Long>` to `CompletionStage<Long>`.",
        "Stmts": "long result = ringbuffer.addAllAsync(items, OVERWRITE).get();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public ICompletableFuture<ReadResultSet<E>> readManyAsync(long startSequence, int minCount, int maxCount, @Nullable IFunction<E, Boolean> filter) {\n+  public CompletionStage<ReadResultSet<E>> readManyAsync(long startSequence, int minCount, int maxCount, @Nullable IFunction<E, Boolean> filter) {",
                    "-  protected final <E> InternalCompletableFuture<E> invokeOnPartition(Operation operation) {\n+  protected final <E> InvocationFuture<E> invokeOnPartition(Operation operation) {",
                    "-    InternalCompletableFuture<Long> f = invokeOnPartition(op);\n-    return f.join();\n+    InvocationFuture<Long> f = invokeOnPartition(op);\n+    return f.joinInternal();"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-      long sequence = ringbuffer.addAsync(item, OVERWRITE).get();\n+      long sequence = ringbuffer.addAsync(item, OVERWRITE).toCompletableFuture().get();",
                    "-    List<String> items = new ArrayList<String>(size);\n+    List<String> items = new ArrayList<>(size);"
                ]
            }
        ]
    },
    {
        "id": 61,
        "Anal": "The method \"getUntaggedName\" in the \"VersioningService\" class has been changed from a non-static method to a static method.",
        "Stmts": "VersioningService instance = new VersioningService();\nString result = instance.getUntaggedName(expression);\nresult = instance.getUntaggedName(expression);\nresult = instance.getUntaggedName(expression);\ntry {\n    result = instance.getUntaggedName(expression);\n} catch (VersioningSyntaxException e) {}",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+      if (!name.equals(untagged)) {\n+        throw new VersioningException(LOCALSTRINGS.getLocalString(\"application.noversion\", \"Application {0} has no version registered\", untagged));\n+      }",
                    "-  public final List<String> matchExpression(List<String> listVersion, String appName) throws VersioningException {\n+  public static final List<String> matchExpression(List<String> listVersion, String appName) throws VersioningException {",
                    "-  public List<String> getVersions(String untaggedName, List<ApplicationRef> allApplicationRefs) {\n+  public static final List<String> getVersions(String untaggedName, List<ApplicationRef> allApplicationRefs) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 62,
        "Anal": "The method name \"modifyVApp\" has been changed to \"editVApp\".",
        "Stmts": "Task modifyVApp = vAppApi.modifyVApp(vApp.getHref(), newVApp);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  Task modifyProductSections(URI vAppURI, ProductSectionList sectionList);\n+  Task editProductSections(URI vAppURI, ProductSectionList sectionList);",
                    "-  Task modifyNetworkConfigSection(URI vAppURI, NetworkConfigSection section);\n+  Task editNetworkConfigSection(URI vAppURI, NetworkConfigSection section);",
                    "-  Task deleteVApp(URI vAppURI);\n-  ControlAccessParams modifyControlAccess(URI vAppURI, ControlAccessParams params);\n+  Task removeVApp(URI vAppURI);\n+  ControlAccessParams editControlAccess(URI vAppURI, ControlAccessParams params);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-      Task task = vappTemplateApi.deleteVappTemplate(vAppTemplate.getHref());\n+      Task task = vappTemplateApi.removeVappTemplate(vAppTemplate.getHref());",
                    "-      Task task = vAppApi.deleteVApp(vAppURI);\n+      Task task = vAppApi.removeVApp(vAppURI);",
                    "-      Link orgLink = find(links, and(relEquals(\"up\"), typeEquals(VCloudDirectorMediaType.ORG)));\n-      userUrn = adminContext.getApi().getUserApi().createUserInOrg(randomTestUser(\"VAppAccessTest\"), toAdminUri(orgLink)).getId();\n+      userUrn = adminContext.getApi().getUserApi().addUserToOrg(randomTestUser(\"VAppAccessTest\"), org.getId()).getId();"
                ]
            }
        ]
    },
    {
        "id": 63,
        "Anal": "The return type of the method \"listFlavorsInDetail\" changes from `Set<? extends Flavor>` to `PagedIterable<? extends Flavor>`.",
        "Stmts": "Set<? extends Flavor> response = api.listFlavorsInDetail();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "+  @GET @SelectJson(\"flavor\") @Consumes(MediaType.APPLICATION_JSON) @Path(\"/flavors/{id}\") @ExceptionParser(ReturnNullOnNotFoundOr404.class) ListenableFuture<? extends Flavor> get(@PathParam(\"id\") String id);"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class PagedIterable (optional references)",
                "contexts": [
                    "public FluentIterable<E> concat();"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  Set<? extends Resource> listFlavors();\n-  Flavor getFlavor(String id);\n+  PagedIterable<? extends Resource> list();\n+  PaginatedCollection<? extends Resource> list(PaginationOptions options);\n+  PaginatedCollection<? extends Flavor> listInDetail(PaginationOptions options);\n+  Flavor get(String id);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    return DEFAULT_FLAVOR_ORDERING.min(flavorApi.listFlavorsInDetail()).getId();\n+    return DEFAULT_FLAVOR_ORDERING.min(flavorApi.listInDetail().concat()).getId();",
                    "-    ServerCreated server = serverApi.createServer(\"test\", imageIdForZone(zoneId), flavorRefForZone(zoneId));\n+    ServerCreated server = serverApi.create(\"test\", imageIdForZone(zoneId), flavorRefForZone(zoneId));",
                    "-    for (currentDetails = api.getServer(serverId); currentDetails.getStatus() != status || (currentDetails.getExtendedStatus().isPresent() && currentDetails.getExtendedStatus().get().getTaskState() != null); currentDetails = api.getServer(serverId)) {\n+    for (currentDetails = api.get(serverId); currentDetails.getStatus() != status || (currentDetails.getExtendedStatus().isPresent() && currentDetails.getExtendedStatus().get().getTaskState() != null); currentDetails = api.get(serverId)) {"
                ]
            }
        ]
    },
    {
        "id": 64,
        "Anal": "The method \"listFlavors\" has been renamed to \"list\" and its return type has changed from `Set<? extends Resource>` to `PagedIterable<? extends Resource>`.",
        "Stmts": "",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "+  @GET @SelectJson(\"flavor\") @Consumes(MediaType.APPLICATION_JSON) @Path(\"/flavors/{id}\") @ExceptionParser(ReturnNullOnNotFoundOr404.class) ListenableFuture<? extends Flavor> get(@PathParam(\"id\") String id);"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class PagedIterable (optional references)",
                "contexts": [
                    "public FluentIterable<E> concat();"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  Set<? extends Flavor> listFlavorsInDetail();\n-  Flavor getFlavor(String id);\n+  PaginatedCollection<? extends Resource> list(PaginationOptions options);\n+  PagedIterable<? extends Flavor> listInDetail();\n+  PaginatedCollection<? extends Flavor> listInDetail(PaginationOptions options);\n+  Flavor get(String id);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    return DEFAULT_FLAVOR_ORDERING.min(flavorApi.listFlavorsInDetail()).getId();\n+    return DEFAULT_FLAVOR_ORDERING.min(flavorApi.listInDetail().concat()).getId();",
                    "-    ServerCreated server = serverApi.createServer(\"test\", imageIdForZone(zoneId), flavorRefForZone(zoneId));\n+    ServerCreated server = serverApi.create(\"test\", imageIdForZone(zoneId), flavorRefForZone(zoneId));",
                    "-    for (currentDetails = api.getServer(serverId); currentDetails.getStatus() != status || (currentDetails.getExtendedStatus().isPresent() && currentDetails.getExtendedStatus().get().getTaskState() != null); currentDetails = api.getServer(serverId)) {\n+    for (currentDetails = api.get(serverId); currentDetails.getStatus() != status || (currentDetails.getExtendedStatus().isPresent() && currentDetails.getExtendedStatus().get().getTaskState() != null); currentDetails = api.get(serverId)) {"
                ]
            }
        ]
    },
    {
        "id": 65,
        "Anal": "The exception thrown by the method \"getChecksum\" changes from `FileNotFoundException` to `IOException`.",
        "Stmts": "} catch (FileNotFoundException ex) {\n    exceptionThrown = true;\n}",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "     byte[] b = getChecksum(\"MD5\", file);",
                "     byte[] b = getChecksum(\"SHA1\", file);"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public static String getMD5Checksum(File file) throws FileNotFoundException, NoSuchAlgorithmException {\n+  public static String getMD5Checksum(File file) throws IOException, NoSuchAlgorithmException {",
                    "-  public static String getSHA1Checksum(File file) throws FileNotFoundException, NoSuchAlgorithmException {\n+  public static String getSHA1Checksum(File file) throws IOException, NoSuchAlgorithmException {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 66,
        "Anal": "The method \"analyze\" now requires an additional parameter of type `Engine`.",
        "Stmts": "instance.analyze(result);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-                aa.analyze(d, this);\n-              } else {\n-                a.analyze(d);\n-              }\n+              a.analyze(d, this);"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class Engine (optional references)",
                "contexts": [
                    "public Engine();",
                    "public Engine(boolean autoUpdate);",
                    "public List<Analyzer> getAnalyzers();"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  void analyze(Dependency dependency) throws AnalysisException;\n+  void analyze(Dependency dependency, Engine engine) throws AnalysisException;"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 67,
        "Anal": "The method \"removeProperty\" changes from a static method to a non-static method.",
        "Stmts": "Settings.removeProperty(key);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  private Settings(String propertiesFilePath) {\n+  public Settings() {\n+    initialize(PROPERTIES_FILE);\n+  }\n+  public Settings(String propertiesFilePath) {\n+    initialize(propertiesFilePath);\n+  }\n+  private final void initialize(String propertiesFilePath) {",
                    "-  public static String getString(String key) {\n-    return System.getProperty(key, LOCAL_SETTINGS.get().props.getProperty(key));\n-  }\n-  public static String[] getArray(final String key) {\n+  public String getString(String key) {\n+    return System.getProperty(key, props.getProperty(key));\n+  }\n+  public String[] getArray(final String key) {",
                    "-  public static void initialize() {\n-    LOCAL_SETTINGS.set(new Settings(PROPERTIES_FILE));\n-  }\n-  public static void initialize(String propertiesFilePath) {\n-    LOCAL_SETTINGS.set(new Settings(propertiesFilePath));\n-  }\n-  public static void cleanup() {\n+  public void cleanup() {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-  @AfterClass\n-  public static void tearDownClass() throws Exception {\n-    Settings.cleanup(true);\n+  @After\n+  public void tearDown() {\n+    settings.cleanup(true);\n+  }\n+  protected Settings getSettings() {\n+    return settings;",
                    "-  @BeforeClass\n-  public static void setUpClass() throws Exception {\n-    Settings.initialize();\n+  private Settings settings;\n+  @Before\n+  public void setUp() {\n+    settings = new Settings();"
                ]
            }
        ]
    },
    {
        "id": 68,
        "Anal": "The method name \"inAbbrevJournalNames\" has been changed to \"tokenPositionsAbbrevJournalNames\".",
        "Stmts": "List<OffsetPosition> journalsPositions = target.inAbbrevJournalNames(input);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-      abbrevJournalsPositions = lexicon.inAbbrevJournalNames(allString);\n-      conferencesPositions = lexicon.inConferenceNames(allString);\n-      publishersPositions = lexicon.inPublisherNames(allString);\n+      journalsPositions = lexicon.tokenPositionsJournalNames(allString);\n+      abbrevJournalsPositions = lexicon.tokenPositionsAbbrevJournalNames(allString);",
                "-        abbrevJournalPositions = lexicon.inAbbrevJournalNames(text);\n-        conferencePositions = lexicon.inConferenceNames(text);\n-        publisherPositions = lexicon.inPublisherNames(text);\n+        journalPositions = lexicon.tokenPositionsJournalNames(text);\n+        abbrevJournalPositions = lexicon.tokenPositionsAbbrevJournalNames(text);"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public List<OffsetPosition> inJournalNames(String s) {\n+  public List<OffsetPosition> tokenPositionsJournalNames(String s) {",
                    "-    List<OffsetPosition> results = personTitlePattern.matcher(s);\n-    return results;\n-  }\n-  public List<OffsetPosition> inPersonTitleLayoutToken(List<LayoutToken> s) {\n+    List<OffsetPosition> results = personTitlePattern.matchLayoutToken(s);\n+    return results;\n+  }\n+  public List<OffsetPosition> tokenPositionsPersonSuffix(List<LayoutToken> s) {\n+    if (personSuffixPattern == null) {\n+      initPersonSuffix();",
                    "-    result = inDOIPatternLayoutToken(tokens, text);\n-    List<OffsetPosition> positions = inArXivPatternLayoutToken(tokens, text);\n+    result = tokenPositionsDOIPattern(tokens, text);\n+    List<OffsetPosition> positions = tokenPositionsArXivPattern(tokens, text);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 69,
        "Anal": "The parameter \"tokens\" of the method \"matcher\" changes from `List<String>` to `List<LayoutToken>`.",
        "Stmts": "final List<OffsetPosition> offsetPositions = target.matcher(Arrays.asList(\"I\", \"m\", \"walking\", \"in\", \"The\", \"Bronx\"));",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    if (cityPattern == null) {\n-      initCities();\n-    }\n-    List<OffsetPosition> results = cityPattern.matcherLayoutToken(s);\n+    List<OffsetPosition> results = cityPattern.matchLayoutToken(s);",
                "-    List<OffsetPosition> results = organisationPattern.matcher(s);\n-    return results;\n-  }\n-  public List<OffsetPosition> inOrganisationNamesLayoutToken(List<LayoutToken> s) {\n+    List<OffsetPosition> results = organisationPattern.matchLayoutToken(s);",
                "-    if (publisherPattern == null) {\n-      initPublishers();\n-    }\n-    List<OffsetPosition> results = publisherPattern.matcherLayoutToken(s);\n+    List<OffsetPosition> results = publisherPattern.matchLayoutToken(s);"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class LayoutToken (optional references)",
                "contexts": [
                    "public LayoutToken();",
                    "public LayoutToken(String text);",
                    "public LayoutToken(LayoutToken token);",
                    "public void setX(double d);",
                    "public double getX();",
                    "public void setOffset(int offset);"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-        continue;\n-      }\n-      token = token.toLowerCase();\n+    for (LayoutToken token : tokens) {\n+      if (token.getText().equals(\" \")) {\n+        currentPos++;\n+        continue;\n+      }\n+      if (delimiters.indexOf(token.getText()) != -1) {\n+        currentPos++;",
                    "+      }\n+      String tokenString = token.getText().toLowerCase();",
                    "-  public List<OffsetPosition> match(String text) {\n+  public List<OffsetPosition> matchCharacter(String text) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 70,
        "Anal": "The method name \"match\" changes to \"matchCharacter\".",
        "Stmts": "final List<OffsetPosition> positions = target.match(input);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    List<OffsetPosition> results = orgFormPattern.matcher(s);\n-    return results;\n-  }\n-  public List<OffsetPosition> inOrgFormNames(List<String> s) {\n+    List<OffsetPosition> results = orgFormPattern.matchCharacter(s);",
                "-    List<OffsetPosition> results = organisationPattern.matcherLayoutToken(s);\n-    return results;\n-  }\n+    List<OffsetPosition> results = organisationPattern.matchCharacter(s);",
                "-    List<OffsetPosition> results = locationPattern.matcher(s);\n-    return results;\n-  }\n-  public List<OffsetPosition> inLocationNames(List<String> s) {\n+    List<OffsetPosition> results = locationPattern.matchCharacter(s);"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-        continue;\n-      }\n-      token = token.toLowerCase();\n+    for (LayoutToken token : tokens) {\n+      if (token.getText().equals(\" \")) {\n+        currentPos++;\n+        continue;\n+      }\n+      if (delimiters.indexOf(token.getText()) != -1) {\n+        currentPos++;",
                    "+      }\n+      String tokenString = token.getText().toLowerCase();",
                    "-  public List<OffsetPosition> match(List<String> tokens) {\n+  public List<OffsetPosition> matchCharacterLayoutToken(List<LayoutToken> tokens) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 71,
        "Anal": "The parameter \"tokens\" of the method \"match\" changes from `List<String>` to `List<LayoutToken>`.",
        "Stmts": "final List<OffsetPosition> offsetPositions = target.match(Arrays.asList(input.split(\" \")));",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-    }\n-    List<OffsetPosition> results = locationPattern.matcherLayoutToken(s);\n-    return results;\n-  }\n+    List<OffsetPosition> results = locationPattern.matchCharacterLayoutToken(s);",
                "-    }\n-    List<OffsetPosition> results = orgFormPattern.match(s);\n-    return results;\n-  }\n+    List<OffsetPosition> results = orgFormPattern.matchCharacterLayoutToken(s);",
                "+  public List<OffsetPosition> charPositionsOrganisationNames(List<LayoutToken> s) {\n+    if (organisationPattern == null) {\n+      initOrganisations();\n+    }\n+    List<OffsetPosition> results = organisationPattern.matchCharacterLayoutToken(s);"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class LayoutToken (optional references)",
                "contexts": [
                    "public LayoutToken();",
                    "public LayoutToken(String text);",
                    "public LayoutToken(LayoutToken token);",
                    "public void setX(double d);",
                    "public double getX();",
                    "public void setOffset(int offset);"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public List<OffsetPosition> match(String text) {\n+  public List<OffsetPosition> matchCharacter(String text) {",
                    "+  }\n+  public int loadTerm(String term) {\n+    return loadTerm(term, true);",
                    "-  public List<OffsetPosition> matcher(String text) {\n+  public List<OffsetPosition> matchToken(String text) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 72,
        "Anal": "The method \"downloadFileFromServer\" has an additional parameter \"targetFileDir\" of type String.",
        "Stmts": "String valueString = fetcherMgr.downloadFileFromServer(requestUrl, RestfulMgrMock.defaultFileName);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  String downloadFileFromServer(String url, String fileName) throws Exception;\n+  String downloadFileFromServer(String url, String fileName, String copy2TargetDirPath) throws Exception;"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 73,
        "Anal": "The parameter \"image\" of the method \"setImage\" changes from `ImageFloat32` to `GrayF32`.",
        "Stmts": "ImageFloat32 image = new ImageFloat32(640, 480);\nalg.setImage(image);\nss.initialize(image);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  ImageGradient<ImageFloat32, ImageFloat32> gradient = FactoryDerivative.three_F32();\n+  ImageGradient<GrayF32, GrayF32> gradient = FactoryDerivative.three_F32();",
                    "-    public ImageFloat32 derivX = new ImageFloat32(1, 1);\n-    public ImageFloat32 derivY = new ImageFloat32(1, 1);\n+    public GrayF32 derivX = new GrayF32(1, 1);\n+    public GrayF32 derivY = new GrayF32(1, 1);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 74,
        "Anal": "The method name \"fit\" has been changed to \"prune\".",
        "Stmts": "alg.fit(contours, corners, output);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+    if (indexA == indexB) {\n+      return 100000.0;\n+    }",
                    "-    int length = circularDistance(indexA, indexB);\n-    for (int k = 1; k < length; k++) {\n-      Point2D_I32 c = getContour(indexA + k);\n+    int length = circularDistance(indexA, indexB) - 1;\n+    int numSamples = Math.min(length, maxPointSamples);\n+    if (length > 1) {\n+      for (int k = 0; k < numSamples; k++) {\n+        int offset = k * (numSamples - 1) / (length - 1);\n+        Point2D_I32 c = getContour(indexA + 1 + offset);\n+        point.set(c.x, c.y);",
                    "+  int maxPointSamples = 20;"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "+        foundMatch = true;\n+        break;\n+      }\n+    }\n+    assertTrue(foundMatch);\n+  }",
                    "+  private void checkMatched(GrowQueue_I32 corners, GrowQueue_I32 output) {\n+    boolean foundMatch = false;\n+    for (int offset = 0; offset < 4; offset++) {\n+      boolean matched = true;\n+      for (int i = 0; i < 4; i++) {\n+        if (corners.get(i) != output.get((offset + i) % 4)) {\n+          matched = false;\n+          break;\n+        }\n+      }"
                ]
            }
        ]
    },
    {
        "id": 75,
        "Anal": "The method \"computeCostInnerD\" has an additional parameter \"workCostLr\" of type short array.",
        "Stmts": "alg.computeCostInnerD(costXD, idxCost, idxWork, rangeD);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+      this.x0 = x0;\n+      this.y0 = y0;\n+      this.dx = dx;\n+      this.dy = dy;\n+    }\n+  }",
                    "-    saveWorkToAggregated(x0, y0, dx, dy, lengthPath);\n-  }\n-  void saveWorkToAggregated(int x0, int y0, int dx, int dy, int length) {\n+    saveWorkToAggregated(x0, y0, dx, dy, lengthPath, workCostLr);\n+  }\n+  void saveWorkToAggregated(int x0, int y0, int dx, int dy, int length, short[] workCostLr) {",
                    "+      for (int i = minInclusive; i < maxExclusive; i++) {\n+        Trajectory t = trajectories.get(i);\n+        scorePath(t.x0, t.y0, t.dx, t.dy, workspace.workCostLr);\n+      }\n+    }\n+  }\n+  void scorePath(int x0, int y0, int dx, int dy, short[] workCostLr) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    return alg.workCostLr[alg.lengthD * pathIdx + d] & 0xFFFF;\n+    short[] workCostLr = alg.workspace.get(0).workCostLr;\n+    return workCostLr[alg.lengthD * pathIdx + d] & 0xFFFF;",
                    "-    void scorePath(int x0, int y0, int dx, int dy) {\n+    void scorePath(int x0, int y0, int dx, int dy, short[] work) {"
                ]
            }
        ]
    },
    {
        "id": 76,
        "Anal": "The method \"gaussian\" has an additional parameter \"sigma\" of type double added between \"orderY\" and \"radius\".",
        "Stmts": "SteerableKernel<Kernel2D_F32> alg = FactorySteerable.gaussian(Kernel2D_F32.class, orderX, orderY, 10);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": []
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 77,
        "Anal": "The method \"fullView\" has been renamed to \"transform_F32\" and a new parameter \"type\" of type `AdjustmentType` has been added as the first parameter.",
        "Stmts": "PointTransform_F32 adjToDist = LensDistortionOps.fullView(param, null, true);\nPointTransform_F32 distToAdj = LensDistortionOps.fullView(param, null, false);\nadjToDist = LensDistortionOps.fullView(param, null, true);\ndistToAdj = LensDistortionOps.fullView(param, null, false);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-      undistToDist = fullView(param, paramAdj, true);\n+      undistToDist = transform_F32(type, param, paramAdj, true);",
                    "-  }\n-  private static PointTransform_F32 adjustmentTransform(IntrinsicParameters param, IntrinsicParameters paramAdj, boolean adjToDistorted, PointTransform_F32 remove_p_to_p, DenseMatrix64F A) {\n+  private static PointTransform_F32 adjustmentTransform_F32(IntrinsicParameters param, IntrinsicParameters paramAdj, boolean adjToDistorted, PointTransform_F32 remove_p_to_p, DenseMatrix64F A) {",
                    "+    }\n+  }\n+  private static PointTransform_F64 adjustmentTransform_F64(IntrinsicParameters param, IntrinsicParameters paramAdj, boolean adjToDistorted, PointTransform_F64 remove_p_to_p, DenseMatrix64F A) {\n+    DenseMatrix64F A_inv = null;\n+    if (!adjToDistorted || paramAdj != null) {\n+      A_inv = new DenseMatrix64F(3, 3);\n+      if (!CommonOps.invert(A, A_inv)) {\n+        throw new RuntimeException(\"Failed to invert adjustment matrix.  Probably bad.\");\n+      }\n+    }"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 78,
        "Anal": "The method \"allInside\" has been renamed to \"transform_F32\" and a new parameter \"type\" of type `AdjustmentType` has been added as the first parameter.",
        "Stmts": "PointTransform_F32 adjToDist = LensDistortionOps.allInside(param, null, true);\nPointTransform_F32 distToAdj = LensDistortionOps.allInside(param, null, false);\nadjToDist = LensDistortionOps.allInside(param, null, true);\ndistToAdj = LensDistortionOps.allInside(param, null, false);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-      undistToDist = fullView(param, paramAdj, true);\n+      undistToDist = transform_F32(type, param, paramAdj, true);",
                    "+    }\n+  }\n+  private static PointTransform_F64 adjustmentTransform_F64(IntrinsicParameters param, IntrinsicParameters paramAdj, boolean adjToDistorted, PointTransform_F64 remove_p_to_p, DenseMatrix64F A) {\n+    DenseMatrix64F A_inv = null;\n+    if (!adjToDistorted || paramAdj != null) {\n+      A_inv = new DenseMatrix64F(3, 3);\n+      if (!CommonOps.invert(A, A_inv)) {\n+        throw new RuntimeException(\"Failed to invert adjustment matrix.  Probably bad.\");\n+      }\n+    }",
                    "-    case ALL_INSIDE:\n-      undistToDist = allInside(param, paramAdj, true);\n-      break;\n+    case SHRINK:"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 79,
        "Anal": "The parameters \"integral\" and \"intensity\" of the method \"hessian\" change from `ImageFloat32` to `GrayF32`.",
        "Stmts": "ImageFloat32 integral = new ImageFloat32(width, height);\nImageFloat32 found = new ImageFloat32(width, height);\nImageFloat32 expected = new ImageFloat32(width, height);\nIntegralImageFeatureIntensity.hessian(integral, skip, size, found);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public static void hessian(ImageSInt32 integral, int skip, int size, ImageFloat32 intensity) {\n+  public static void hessian(GrayS32 integral, int skip, int size, GrayF32 intensity) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 80,
        "Anal": "The method name \"findErrorLocatorBM\" has been changed to \"findErrorLocatorPolynomialBM\".",
        "Stmts": "alg.findErrorLocatorBM(syndromes, nsyn, errorLocator);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+  }",
                    "-    findErrorLocatorBM(syndromes.data, syndromes.size, errorLocatorPoly);\n+    findErrorLocatorPolynomialBM(syndromes.data, syndromes.size, errorLocatorPoly);",
                    "-  public void correctErrors(GrowQueue_I8 message, int syndromes[], GrowQueue_I32 locations) {}\n+  public void correctErrors(GrowQueue_I8 message, GrowQueue_I8 ecc, GrowQueue_I8 errorLocator, GrowQueue_I32 errorLocations) {\n+    GrowQueue_I32 coefLocations = new GrowQueue_I32(errorLocations.size);\n+    for (int i = 0; i < errorLocations.size; i++) {\n+      coefLocations.data[message.size - i - 1] = errorLocations.get(i);\n+    }\n+  }\n+  void findErrorEvaluator(int syndromes[], int syndromeLength, GrowQueue_I8 errorLocator) {}"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    alg.findErrorLocatorBM(syndromes, nsyn, errorLocator);\n+    alg.findErrorLocatorPolynomialBM(syndromes, nsyn, errorLocator);",
                    "+      GrowQueue_I8 hack = new GrowQueue_I8();\n+      alg.findErrorLocatorPolynomial(N, locations, hack);\n+      System.out.println();"
                ]
            }
        ]
    },
    {
        "id": 81,
        "Anal": "The generic type parameter \"T\" of the method \"scaleSpace\" changes from `ImageSingleBand` to `ImageGray`.",
        "Stmts": "PyramidFloat<ImageFloat32> pyramid = FactoryPyramid.scaleSpacePyramid(ss, ImageFloat32.class);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public static <T extends ImageSingleBand> PyramidDiscrete<T> discreteGaussian(int[] scaleFactors, double sigma, int radius, boolean saveOriginalReference, Class<T> imageType) {\n+  public static <T extends ImageGray> PyramidDiscrete<T> discreteGaussian(int[] scaleFactors, double sigma, int radius, boolean saveOriginalReference, Class<T> imageType) {",
                    "-  public static <T extends ImageSingleBand> PyramidFloat<T> scaleSpacePyramid(double scaleSpace[], Class<T> imageType) {\n+  public static <T extends ImageGray> PyramidFloat<T> scaleSpacePyramid(double scaleSpace[], Class<T> imageType) {",
                    "-  public static <T extends ImageSingleBand> PyramidFloat<T> floatGaussian(double scaleFactors[], double[] sigmas, Class<T> imageType) {\n+  public static <T extends ImageGray> PyramidFloat<T> floatGaussian(double scaleFactors[], double[] sigmas, Class<T> imageType) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 82,
        "Anal": "The exception thrown by the method \"copy\" changes from `IOException, StoreException` to a more general `Exception`.",
        "Stmts": "storeCopier.copy(new StoreFindTokenFactory(STORE_KEY_FACTORY).getNewFindToken());",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    Message transform(Message message);\n+    Message transform(Message message) throws Exception;"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 83,
        "Anal": "The method \"replenishConnections\" has an additional parameter \"maxNewConnectionsPerHost\" of type int.",
        "Stmts": "connectionTracker.replenishConnections(this::mockNewConnection);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": []
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 84,
        "Anal": "The method name \"getMuleHomeFile\" has been changed to \"getMuleHome\".",
        "Stmts": "File muleHome = MuleContainerBootstrapUtils.getMuleHomeFile();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-      File domainDir = new File(MuleContainerBootstrapUtils.getMuleHomeFile(), \"lib/shared/\" + domain);\n+      File domainDir = new File(MuleContainerBootstrapUtils.getMuleHome(), \"lib/shared/\" + domain);",
                "-  public static File getMuleAppsFile() {\n-    return isStandalone() ? new File(getMuleHomeFile(), MULE_APPS_FILENAME) : null;\n+  public static File getMuleAppsDir() {\n+    return isStandalone() ? new File(getMuleHome(), MULE_APPS_FILENAME) : null;"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public static File getMuleAppsFile() {\n-    return isStandalone() ? new File(getMuleHomeFile(), MULE_APPS_FILENAME) : null;\n+  public static File getMuleAppsDir() {\n+    return isStandalone() ? new File(getMuleHome(), MULE_APPS_FILENAME) : null;"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 85,
        "Anal": "The method \"saveOrUpdateUserDetail\" has been renamed to \"saveUser\" and the fourth parameter \"followersStr\" has been removed.",
        "Stmts": "userController.saveOrUpdateUserDetail(currUser, model, currUser, null);\nuserController.saveOrUpdateUserDetail(admin, model, temp, null);\nuserController.saveOrUpdateUserDetail(admin, model, temp, null);\nuserController.saveOrUpdateUserDetail(currUser, model, currUser, \"temp1, temp2\");",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+  }\n+  private User saveUser(User user) {\n+    if (StringUtils.isBlank(user.getPassword())) {\n+      return userService.saveUserWithoutPasswordEncoding(user);\n+    } else {\n+      return userService.saveUser(user);\n+    }",
                    "-  public String getUserList(ModelMap model, @RequestParam(required = false) String roleName, @PageableDefaults(pageNumber = 0, value = 10) Pageable pageable, @RequestParam(required = false) String keywords) {\n+  public String getUsers(ModelMap model, @RequestParam(required = false) Role role, @PageableDefaults(pageNumber = 0, value = 10) Pageable pageable, @RequestParam(required = false) String keywords) {",
                    "-  @RequestMapping(value = \"/api/\", method = RequestMethod.POST)\n+  @RequestMapping(value = {\"/api/\", \"/api\"}, method = RequestMethod.POST)"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    userController.saveOrUpdateUserDetail(getAdminUser(), model, newUser, null);\n+    userController.saveUser(getAdminUser(), model, newUser);"
                ]
            }
        ]
    },
    {
        "id": 86,
        "Anal": "The method name \"put\" changes to \"putBoolean\".",
        "Stmts": "buffer.put(true);\nbuffer.put(false);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-      buffer.put(true);\n-      buffer.putSVar(exceptionId);\n+      buffer.putBoolean(true);",
                "-      buffer.put(true);\n-      buffer.putSVar(span.getExceptionId());\n+      buffer.putBoolean(true);",
                "-      buffer.put(true);\n-      buffer.putSVar(spanEventBo.getExceptionId());\n+      buffer.putBoolean(true);"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-      put((byte)0);\n+      putByte((byte)0);",
                    "-      put((short)bytes.length);\n-      put(bytes);\n+      putShort((short)bytes.length);\n+      putBytes(bytes);",
                    "-      putSVar(NULL);\n-    } else {\n-      putSVar(bytes.length);\n-      put(bytes);\n+      putSVInt(NULL);\n+    } else {\n+      putSVInt(bytes.length);\n+      putBytes(bytes);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    buffer.put(expected);\n+    buffer.putInt(expected);",
                    "-    buffer.put((byte)value);\n+    buffer.putByte((byte)value);",
                    "-    buffer.putVar(v);\n+    buffer.putVInt(v);"
                ]
            }
        ]
    },
    {
        "id": 87,
        "Anal": "The method \"cloneForDiscontinuing\" now throws `IllegalAccessException` and `InstantiationException`.",
        "Stmts": "Order orderThatCanDiscontinueTheOrder = anOrder.cloneForDiscontinuing();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "     Order newOrder = orderToDiscontinue.cloneForDiscontinuing();",
                "-  public Order cloneForDiscontinuing() {\n-    Order newOrder = new Order();\n+  public Order cloneForDiscontinuing() throws IllegalAccessException, InstantiationException {",
                "-  public Order cloneForDiscontinuing() {\n-    Order newOrder = new Order();\n+  public Order cloneForDiscontinuing() throws IllegalAccessException, InstantiationException {\n+    Order newOrder = this.getClass().newInstance();"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": []
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 88,
        "Anal": "An additional parameter \"pluginConfig\" of type `YangPluginConfig` has been added to the method \"getConstructor\".",
        "Stmts": "String method = getConstructor(CLASS_NAME, testAttr, GENERATE_SERVICE_AND_MANAGER);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "+import org.onosproject.yangutils.translator.tojava.utils.YangPluginConfig;\n import static org.onosproject.yangutils.translator.tojava.utils.MethodsGenerator.getConstructor;",
                "-  private void addConstructor(JavaAttributeInfo attr) throws IOException {\n-    appendToFile(getConstructorImplTempFileHandle(), getConstructor(getGeneratedJavaClassName(), attr, getGeneratedJavaFiles()));\n+  private void addConstructor(JavaAttributeInfo attr, YangPluginConfig pluginConfig) throws IOException {\n+    appendToFile(getConstructorImplTempFileHandle(), getConstructor(getGeneratedJavaClassName(), attr, getGeneratedJavaFiles(), pluginConfig));"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class YangPluginConfig (optional references)",
                "contexts": [
                    "public YangPluginConfig();",
                    "public void setCodeGenDir(String codeGenDir);",
                    "public YangToJavaNamingConflictUtil getConflictResolver();"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    if (!outputName.equals(VOID)) {\n-      outputName = getCapitalCase(outputName);\n-    }\n-    String method = getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + outputName + SPACE + rpcName + OPEN_PARENTHESIS + inputName + SPACE + RPC_INPUT_VAR_NAME + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + YANG_UTILS_TODO + NEW_LINE;\n+  public static String getRpcServiceMethod(String rpcName, String inputName, String outputName, YangPluginConfig pluginConfig) {\n+    rpcName = getCamelCase(rpcName, pluginConfig.getConflictResolver());\n+    if (!inputName.equals(EMPTY_STRING)) {\n+      inputName = inputName + SPACE + RPC_INPUT_VAR_NAME;\n+    }\n+    return FOUR_SPACE_INDENTATION + outputName + SPACE + rpcName + OPEN_PARENTHESIS + inputName + CLOSE_PARENTHESIS + SEMI_COLAN;",
                    "-      method += EIGHT_SPACE_INDENTATION + RETURN + SPACE + NULL + SEMI_COLAN + NEW_LINE;\n+      method += EIGHT_SPACE_INDENTATION + RETURN + SPACE + parseTypeForReturnValue(outputName) + SEMI_COLAN + NEW_LINE;",
                    "-    return getJavaDoc(type, attributeName, attr.isListAttr()) + getSetterForInterface(attributeName, attrType, className, attr.isListAttr(), generatedJavaFiles);\n-  }\n-  public static String getConstructorString(String name) {\n-    return getJavaDoc(CONSTRUCTOR, name, false);\n-  }\n-  public static String getDefaultConstructorString(String name, String modifierType) {\n-    return getJavaDoc(DEFAULT_CONSTRUCTOR, name, false) + getDefaultConstructor(name, modifierType) + NEW_LINE;\n+    return getJavaDoc(type, attributeName, attr.isListAttr(), pluginConfig) + getSetterForInterface(attributeName, attrType, className, attr.isListAttr(), generatedJavaFiles);\n+  }\n+  public static String getConstructorString(String name, YangPluginConfig pluginConfig) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 89,
        "Anal": "The return type of the method \"getTunnelInfos\" changes from `Map<TunnelId, PceccTunnelInfo>` to `Map<TunnelId, ResourceConsumer>`.",
        "Stmts": "Map<TunnelId, PceccTunnelInfo> tunnelInfoMap = distrPceStore.getTunnelInfos();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [
            {
                "info": "Defined in class ResourceConsumer (optional references)",
                "contexts": [
                    "ResourceConsumerId consumerId();"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    globalNodeLabelMap = storageService.<DeviceId, LabelResourceId>consistentMapBuilder().withName(\"onos-pce-globalnodelabelmap\").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(LabelResourceId.class).build())).build();\n-    adjLabelMap = storageService.<Link, LabelResourceId>consistentMapBuilder().withName(\"onos-pce-adjlabelmap\").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(Link.class, LabelResource.class, LabelResourceId.class).build())).build();\n-    tunnelInfoMap = storageService.<TunnelId, PceccTunnelInfo>consistentMapBuilder().withName(\"onos-pce-tunnelinfomap\").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(TunnelId.class, PceccTunnelInfo.class, DefaultLspLocalLabelInfo.class, TunnelConsumerId.class, LabelResourceId.class).build())).build();\n+    tunnelInfoMap = storageService.<TunnelId, ResourceConsumer>consistentMapBuilder().withName(\"onos-pce-tunnelinfomap\").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(TunnelId.class, TunnelConsumerId.class).build())).build();",
                    "-  LabelResourceId getGlobalNodeLabel(DeviceId id);\n-  LabelResourceId getAdjLabel(Link link);\n-  PceccTunnelInfo getTunnelInfo(TunnelId tunnelId);\n-  void addGlobalNodeLabel(DeviceId deviceId, LabelResourceId labelId);\n-  void addAdjLabel(Link link, LabelResourceId labelId);\n-  void addTunnelInfo(TunnelId tunnelId, PceccTunnelInfo pceccTunnelInfo);\n+  ResourceConsumer getTunnelInfo(TunnelId tunnelId);\n+  void addTunnelInfo(TunnelId tunnelId, ResourceConsumer tunnelConsumerId);",
                    "-  Map<DeviceId, LabelResourceId> getGlobalNodeLabels();\n-  Map<Link, LabelResourceId> getAdjLabels();\n-  Map<TunnelId, PceccTunnelInfo> getTunnelInfos();\n+  Map<TunnelId, ResourceConsumer> getTunnelInfos();"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "+  private ConnectPoint dstConnectionPoint4 = new ConnectPoint(deviceId4, portNumber4);",
                    "-  private PceccTunnelInfo pceccTunnelInfo1;\n-  private PceccTunnelInfo pceccTunnelInfo2;\n+  private ResourceConsumer tunnelConsumerId1 = TunnelConsumerId.valueOf(10);\n+  private ResourceConsumer tunnelConsumerId2 = TunnelConsumerId.valueOf(20);",
                    "-  private ConnectPoint srcConnectionPoint1 = new ConnectPoint((ElementId)deviceId1, portNumber1);\n-  private ConnectPoint dstConnectionPoint2 = new ConnectPoint((ElementId)deviceId2, portNumber2);\n-  private ConnectPoint srcConnectionPoint3 = new ConnectPoint((ElementId)deviceId3, portNumber3);\n-  private ConnectPoint dstConnectionPoint4 = new ConnectPoint((ElementId)deviceId4, portNumber4);\n-  private LabelResource labelResource1 = new DefaultLabelResource(deviceId1, labelId1);\n-  private LabelResource labelResource2 = new DefaultLabelResource(deviceId2, labelId2);\n-  private LabelResource labelResource3 = new DefaultLabelResource(deviceId3, labelId3);\n-  private LabelResource labelResource4 = new DefaultLabelResource(deviceId4, labelId4);\n+  private ConnectPoint srcConnectionPoint1 = new ConnectPoint(deviceId1, portNumber1);\n+  private ConnectPoint dstConnectionPoint2 = new ConnectPoint(deviceId2, portNumber2);"
                ]
            }
        ]
    },
    {
        "id": 90,
        "Anal": "The return type of the method \"getTunnelInfo\" changes from `PceccTunnelInfo` to `ResourceConsumer`.",
        "Stmts": "assertThat(distrPceStore.getTunnelInfo(tunnelId1), is(pceccTunnelInfo1));\nassertThat(distrPceStore.getTunnelInfo(tunnelId2), is(pceccTunnelInfo2));",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "+    resourceService.release(pceStore.getTunnelInfo(oldTunnel.tunnelId()));\n-    PceccTunnelInfo tunnelInfo = pceStore.getTunnelInfo(newTunnel.tunnelId());\n-    if (tunnelInfo == null || tunnelInfo.tunnelConsumerId() == null) {\n+    ResourceConsumer consumer = pceStore.getTunnelInfo(newTunnel.tunnelId());\n+    if (consumer == null) {",
                "+    ResourceConsumer consumer = pceStore.getTunnelInfo(newTunnel.tunnelId());\n+    if (consumer == null) {\n-    ResourceConsumer consumer = tunnelInfo.tunnelConsumerId();",
                "+    ResourceConsumer tunnelConsumerId = pceStore.getTunnelInfo(tunnel.tunnelId());\n+    if (tunnelConsumerId == null) {\n+      log.debug(\"Bandwidth not allocated (0 bandwidth) for old LSP.\");\n+      return;\n+    }"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class ResourceConsumer (optional references)",
                "contexts": [
                    "ResourceConsumerId consumerId();"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    globalNodeLabelMap = storageService.<DeviceId, LabelResourceId>consistentMapBuilder().withName(\"onos-pce-globalnodelabelmap\").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(LabelResourceId.class).build())).build();\n-    adjLabelMap = storageService.<Link, LabelResourceId>consistentMapBuilder().withName(\"onos-pce-adjlabelmap\").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(Link.class, LabelResource.class, LabelResourceId.class).build())).build();\n-    tunnelInfoMap = storageService.<TunnelId, PceccTunnelInfo>consistentMapBuilder().withName(\"onos-pce-tunnelinfomap\").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(TunnelId.class, PceccTunnelInfo.class, DefaultLspLocalLabelInfo.class, TunnelConsumerId.class, LabelResourceId.class).build())).build();\n+    tunnelInfoMap = storageService.<TunnelId, ResourceConsumer>consistentMapBuilder().withName(\"onos-pce-tunnelinfomap\").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(TunnelId.class, TunnelConsumerId.class).build())).build();",
                    "-  LabelResourceId getGlobalNodeLabel(DeviceId id);\n-  LabelResourceId getAdjLabel(Link link);\n-  PceccTunnelInfo getTunnelInfo(TunnelId tunnelId);\n-  void addGlobalNodeLabel(DeviceId deviceId, LabelResourceId labelId);\n-  void addAdjLabel(Link link, LabelResourceId labelId);\n-  void addTunnelInfo(TunnelId tunnelId, PceccTunnelInfo pceccTunnelInfo);\n+  ResourceConsumer getTunnelInfo(TunnelId tunnelId);\n+  void addTunnelInfo(TunnelId tunnelId, ResourceConsumer tunnelConsumerId);",
                    "-  Map<DeviceId, LabelResourceId> getGlobalNodeLabels();\n-  Map<Link, LabelResourceId> getAdjLabels();\n-  Map<TunnelId, PceccTunnelInfo> getTunnelInfos();\n+  Map<TunnelId, ResourceConsumer> getTunnelInfos();"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "+  private ConnectPoint dstConnectionPoint4 = new ConnectPoint(deviceId4, portNumber4);",
                    "-  private PceccTunnelInfo pceccTunnelInfo1;\n-  private PceccTunnelInfo pceccTunnelInfo2;\n+  private ResourceConsumer tunnelConsumerId1 = TunnelConsumerId.valueOf(10);\n+  private ResourceConsumer tunnelConsumerId2 = TunnelConsumerId.valueOf(20);",
                    "-  private ConnectPoint srcConnectionPoint1 = new ConnectPoint((ElementId)deviceId1, portNumber1);\n-  private ConnectPoint dstConnectionPoint2 = new ConnectPoint((ElementId)deviceId2, portNumber2);\n-  private ConnectPoint srcConnectionPoint3 = new ConnectPoint((ElementId)deviceId3, portNumber3);\n-  private ConnectPoint dstConnectionPoint4 = new ConnectPoint((ElementId)deviceId4, portNumber4);\n-  private LabelResource labelResource1 = new DefaultLabelResource(deviceId1, labelId1);\n-  private LabelResource labelResource2 = new DefaultLabelResource(deviceId2, labelId2);\n-  private LabelResource labelResource3 = new DefaultLabelResource(deviceId3, labelId3);\n-  private LabelResource labelResource4 = new DefaultLabelResource(deviceId4, labelId4);\n+  private ConnectPoint srcConnectionPoint1 = new ConnectPoint(deviceId1, portNumber1);\n+  private ConnectPoint dstConnectionPoint2 = new ConnectPoint(deviceId2, portNumber2);"
                ]
            }
        ]
    },
    {
        "id": 91,
        "Anal": "The second parameter \"pceccTunnelInfo\" of the method \"addTunnelInfo\" changes from `PceccTunnelInfo` to `ResourceConsumer`.",
        "Stmts": "distrPceStore.addTunnelInfo(tunnelId1, pceccTunnelInfo1);\ndistrPceStore.addTunnelInfo(tunnelId2, pceccTunnelInfo2);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-      PceccTunnelInfo pceccTunnelInfo = new PceccTunnelInfo(null, consumerId);\n-      pceStore.addTunnelInfo(tunnelId, pceccTunnelInfo);\n+      pceStore.addTunnelInfo(tunnelId, consumerId);",
                "-          reserveBandwidth(tunnel.path(), bwConstraintValue, null);\n+          TunnelConsumerId consumerId = reserveBandwidth(tunnel.path(), bwConstraintValue, null);\n+          if (consumerId != null) {\n+            pceStore.addTunnelInfo(tunnel.tunnelId(), consumerId);",
                "-      Tunnel tunnelForlabelDownload = new DefaultTunnel(null, tunnel.src(), tunnel.dst(), MPLS, INIT, null, updatedTunnelId, tunnel.tunnelName(), computedPath, labelStack, annotationBuilder.build());\n-      if (!crHandler.allocateLabel(tunnelForlabelDownload)) {\n-        log.error(\"Unable to allocate labels for the tunnel {}.\", tunnel.toString());\n-      }\n+      pceStore.addTunnelInfo(updatedTunnelId, consumerId);"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class ResourceConsumer (optional references)",
                "contexts": [
                    "ResourceConsumerId consumerId();"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    globalNodeLabelMap = storageService.<DeviceId, LabelResourceId>consistentMapBuilder().withName(\"onos-pce-globalnodelabelmap\").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(LabelResourceId.class).build())).build();\n-    adjLabelMap = storageService.<Link, LabelResourceId>consistentMapBuilder().withName(\"onos-pce-adjlabelmap\").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(Link.class, LabelResource.class, LabelResourceId.class).build())).build();\n-    tunnelInfoMap = storageService.<TunnelId, PceccTunnelInfo>consistentMapBuilder().withName(\"onos-pce-tunnelinfomap\").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(TunnelId.class, PceccTunnelInfo.class, DefaultLspLocalLabelInfo.class, TunnelConsumerId.class, LabelResourceId.class).build())).build();\n+    tunnelInfoMap = storageService.<TunnelId, ResourceConsumer>consistentMapBuilder().withName(\"onos-pce-tunnelinfomap\").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(TunnelId.class, TunnelConsumerId.class).build())).build();",
                    "-  LabelResourceId getGlobalNodeLabel(DeviceId id);\n-  LabelResourceId getAdjLabel(Link link);\n-  PceccTunnelInfo getTunnelInfo(TunnelId tunnelId);\n-  void addGlobalNodeLabel(DeviceId deviceId, LabelResourceId labelId);\n-  void addAdjLabel(Link link, LabelResourceId labelId);\n-  void addTunnelInfo(TunnelId tunnelId, PceccTunnelInfo pceccTunnelInfo);\n+  ResourceConsumer getTunnelInfo(TunnelId tunnelId);\n+  void addTunnelInfo(TunnelId tunnelId, ResourceConsumer tunnelConsumerId);",
                    "-  Map<DeviceId, LabelResourceId> getGlobalNodeLabels();\n-  Map<Link, LabelResourceId> getAdjLabels();\n-  Map<TunnelId, PceccTunnelInfo> getTunnelInfos();\n+  Map<TunnelId, ResourceConsumer> getTunnelInfos();"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "+  private ConnectPoint dstConnectionPoint4 = new ConnectPoint(deviceId4, portNumber4);",
                    "-  private PceccTunnelInfo pceccTunnelInfo1;\n-  private PceccTunnelInfo pceccTunnelInfo2;\n+  private ResourceConsumer tunnelConsumerId1 = TunnelConsumerId.valueOf(10);\n+  private ResourceConsumer tunnelConsumerId2 = TunnelConsumerId.valueOf(20);",
                    "-  private ConnectPoint srcConnectionPoint1 = new ConnectPoint((ElementId)deviceId1, portNumber1);\n-  private ConnectPoint dstConnectionPoint2 = new ConnectPoint((ElementId)deviceId2, portNumber2);\n-  private ConnectPoint srcConnectionPoint3 = new ConnectPoint((ElementId)deviceId3, portNumber3);\n-  private ConnectPoint dstConnectionPoint4 = new ConnectPoint((ElementId)deviceId4, portNumber4);\n-  private LabelResource labelResource1 = new DefaultLabelResource(deviceId1, labelId1);\n-  private LabelResource labelResource2 = new DefaultLabelResource(deviceId2, labelId2);\n-  private LabelResource labelResource3 = new DefaultLabelResource(deviceId3, labelId3);\n-  private LabelResource labelResource4 = new DefaultLabelResource(deviceId4, labelId4);\n+  private ConnectPoint srcConnectionPoint1 = new ConnectPoint(deviceId1, portNumber1);\n+  private ConnectPoint dstConnectionPoint2 = new ConnectPoint(deviceId2, portNumber2);"
                ]
            }
        ]
    },
    {
        "id": 92,
        "Anal": "The parameters of the method \"buildNdpSolicit\" have changed from byte arrays to `Ip6Address` for targetIp, sourceIp, destinationIp and `MacAddress` for sourceMac, destinationMac.",
        "Stmts": "Ethernet ethPacket = NeighborSolicitation.buildNdpSolicit(TARGET_IP.toOctets(), SRC_IP.toOctets(), DST_IP.toOctets(), SRC_MAC.toBytes(), DST_MAC.toBytes(), VLAN_ID);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [
            {
                "info": "Defined in class Ip6Address (optional references)",
                "contexts": [
                    "public static final Ip6Address ZERO = Ip6Address.valueOf(\"::\");",
                    "public static Ip6Address valueOf(byte[] value);",
                    "public static Ip6Address valueOf(byte[] value, int offset);",
                    "public static Ip6Address valueOf(InetAddress inetAddress);",
                    "public static Ip6Address valueOf(String value);",
                    "public static Ip6Address makeMaskPrefix(int prefixLength);",
                    "public static Ip6Address makeMaskedAddress(final Ip6Address address, int prefixLength);",
                    "protected IpAddress();",
                    "protected IpAddress(Version version, byte[] value);",
                    "public Version version();",
                    "public boolean isIp6();",
                    "public static final int BIT_LENGTH = IpAddress.INET6_BIT_LENGTH;",
                    "public static IpAddress valueOf(String value);"
                ]
            },
            {
                "info": "Defined in class MacAddress (optional references)",
                "contexts": [
                    "public static final MacAddress ONOS = valueOf(\"a4:23:05:00:00:00\");",
                    "public MacAddress(final byte[] address);",
                    "public static final MacAddress ONOS_LLDP = valueOf(\"a5:23:05:00:00:01\");",
                    "public static MacAddress valueOf(final byte[] address);",
                    "public static final MacAddress NONE = ONOS;",
                    "public static final MacAddress IPV4_MULTICAST = valueOf(\"01:00:5e:00:00:00\");",
                    "public static final Set<MacAddress> LLDP = ImmutableSet.of( MacAddress.valueOf(\"01:80:c2:00:00:00\"), MacAddress.valueOf(\"01:80:c2:00:00:03\"), MacAddress.valueOf(\"01:80:c2:00:00:0e\"));",
                    "public static final int MAC_ADDRESS_LENGTH = 6;",
                    "public byte[] oui();",
                    "public boolean isOnos();",
                    "@Deprecated public boolean isLinkLocal();"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+  @Deprecated\n+  public static Ethernet buildNdpSolicit(byte[] targetIp, byte[] sourceIp, byte[] destinationIp, byte[] sourceMac, byte[] destinationMac, VlanId vlan) {\n+    if (targetIp.length != Ip6Address.BYTE_LENGTH || sourceIp.length != Ip6Address.BYTE_LENGTH || destinationIp.length != Ip6Address.BYTE_LENGTH || sourceMac.length != MacAddress.MAC_ADDRESS_LENGTH || destinationMac.length != MacAddress.MAC_ADDRESS_LENGTH) {\n+      return null;\n+    }\n+    Ethernet ethernet = new Ethernet();\n+    ethernet.setEtherType(Ethernet.TYPE_IPV6).setDestinationMACAddress(destinationMac).setSourceMACAddress(sourceMac);\n+    ethernet.setVlanID(vlan.id());\n+    IPv6 ipv6 = new IPv6();\n+    ipv6.setSourceAddress(sourceIp);",
                    "+  protected static final byte NDP_HOP_LIMIT = (byte)0x255;\n+  protected static final byte RESERVED_CODE = (byte)0x0;",
                    "+    ipv6.setHopLimit((byte)255);\n+    ICMP6 icmp6 = new ICMP6();\n+    icmp6.setIcmpType(ICMP6.NEIGHBOR_SOLICITATION);\n+    icmp6.setIcmpCode((byte)0);\n+    NeighborSolicitation ns = new NeighborSolicitation();\n+    ns.setTargetAddress(targetIp);\n+    if (!Arrays.equals(sourceIp, Ip6Address.ZERO.toOctets())) {\n+      ns.addOption(NeighborDiscoveryOptions.TYPE_SOURCE_LL_ADDRESS, sourceMac);\n+    }\n+    icmp6.setPayload(ns);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 93,
        "Anal": "The parameters of the method \"buildNdpSolicit\" have changed from byte arrays to specific types: `Ip6Address` for targetIp, sourceIp, and destinationIp, and `MacAddress` for sourceMac and destinationMac.",
        "Stmts": "Ethernet ethPacket = NeighborSolicitation.buildNdpSolicit(TARGET_IP.toOctets(), Ip6Address.ZERO.toOctets(), DST_IP.toOctets(), SRC_MAC.toBytes(), DST_MAC.toBytes(), VLAN_ID);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [
            {
                "info": "Defined in class Ip6Address (optional references)",
                "contexts": [
                    "public static final Ip6Address ZERO = Ip6Address.valueOf(\"::\");",
                    "public static Ip6Address valueOf(byte[] value);",
                    "public static Ip6Address valueOf(byte[] value, int offset);",
                    "public static Ip6Address valueOf(InetAddress inetAddress);",
                    "public static Ip6Address valueOf(String value);",
                    "public static Ip6Address makeMaskPrefix(int prefixLength);",
                    "public static Ip6Address makeMaskedAddress(final Ip6Address address, int prefixLength);",
                    "public static final IpAddress.Version VERSION = IpAddress.Version.INET6;",
                    "public static final int BYTE_LENGTH = IpAddress.INET6_BYTE_LENGTH;",
                    "public static final int BIT_LENGTH = IpAddress.INET6_BIT_LENGTH;"
                ]
            },
            {
                "info": "Defined in class MacAddress (optional references)",
                "contexts": [
                    "public MacAddress(final byte[] address);",
                    "public static MacAddress valueOf(final byte[] address);",
                    "public static final MacAddress NONE = ONOS;",
                    "public static final MacAddress ONOS = valueOf(\"a4:23:05:00:00:00\");",
                    "public static final MacAddress ONOS_LLDP = valueOf(\"a5:23:05:00:00:01\");",
                    "public static final MacAddress IPV4_MULTICAST = valueOf(\"01:00:5e:00:00:00\");",
                    "public static final Set<MacAddress> LLDP = ImmutableSet.of( MacAddress.valueOf(\"01:80:c2:00:00:00\"), MacAddress.valueOf(\"01:80:c2:00:00:03\"), MacAddress.valueOf(\"01:80:c2:00:00:0e\"));",
                    "public static final int MAC_ADDRESS_LENGTH = 6;",
                    "public byte[] oui();",
                    "public boolean isOnos();",
                    "@Deprecated public boolean isLinkLocal();"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+  @Deprecated\n+  public static Ethernet buildNdpSolicit(byte[] targetIp, byte[] sourceIp, byte[] destinationIp, byte[] sourceMac, byte[] destinationMac, VlanId vlan) {\n+    if (targetIp.length != Ip6Address.BYTE_LENGTH || sourceIp.length != Ip6Address.BYTE_LENGTH || destinationIp.length != Ip6Address.BYTE_LENGTH || sourceMac.length != MacAddress.MAC_ADDRESS_LENGTH || destinationMac.length != MacAddress.MAC_ADDRESS_LENGTH) {\n+      return null;\n+    }\n+    Ethernet ethernet = new Ethernet();\n+    ethernet.setEtherType(Ethernet.TYPE_IPV6).setDestinationMACAddress(destinationMac).setSourceMACAddress(sourceMac);\n+    ethernet.setVlanID(vlan.id());\n+    IPv6 ipv6 = new IPv6();\n+    ipv6.setSourceAddress(sourceIp);",
                    "+  protected static final byte NDP_HOP_LIMIT = (byte)0x255;\n+  protected static final byte RESERVED_CODE = (byte)0x0;",
                    "+    ipv6.setHopLimit((byte)255);\n+    ICMP6 icmp6 = new ICMP6();\n+    icmp6.setIcmpType(ICMP6.NEIGHBOR_SOLICITATION);\n+    icmp6.setIcmpCode((byte)0);\n+    NeighborSolicitation ns = new NeighborSolicitation();\n+    ns.setTargetAddress(targetIp);\n+    if (!Arrays.equals(sourceIp, Ip6Address.ZERO.toOctets())) {\n+      ns.addOption(NeighborDiscoveryOptions.TYPE_SOURCE_LL_ADDRESS, sourceMac);\n+    }\n+    icmp6.setPayload(ns);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 94,
        "Anal": "The third parameter \"revision\" of the method \"getRootPackage\" changes from `String` to `Date`.",
        "Stmts": "String rootPackage = getRootPackage((byte)1, CHILD_PACKAGE, DATE1, conflictResolver);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+    return rev;",
                    "-      return rev;\n-    } else {\n-      throw new TranslatorException(\"Date in revision is not proper: \" + date);\n+      rev = rev + val;",
                    "-    if (Integer.parseInt(revisionArr[INDEX_ONE]) <= MAX_MONTHS && Integer.parseInt(revisionArr[INDEX_TWO]) <= MAX_DAYS) {\n-      for (int i = INDEX_ONE; i < revisionArr.length; i++) {\n-        Integer val = Integer.parseInt(revisionArr[i]);\n-        if (val < VALUE_CHECK) {\n-          rev = rev + ZERO;\n-        }\n-        rev = rev + val;\n+    for (int i = INDEX_ONE; i < revisionArr.length; i++) {\n+      Integer val = Integer.parseInt(revisionArr[i]);\n+      if (val < VALUE_CHECK) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "+  private static final String DATE_FORMAT = \"yyyy-MM-dd\";\n+  private static SimpleDateFormat simpleDateFormat = new SimpleDateFormat(DATE_FORMAT);"
                ]
            }
        ]
    },
    {
        "id": 95,
        "Anal": "The third parameter \"revision\" of the method \"getRootPackage\" changes from `String` to `Date`.",
        "Stmts": "String rootPkgWithRev = getRootPackage((byte)1, CHILD_PACKAGE, DATE2, null);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+    return rev;",
                    "-      return rev;\n-    } else {\n-      throw new TranslatorException(\"Date in revision is not proper: \" + date);\n+      rev = rev + val;",
                    "-    if (Integer.parseInt(revisionArr[INDEX_ONE]) <= MAX_MONTHS && Integer.parseInt(revisionArr[INDEX_TWO]) <= MAX_DAYS) {\n-      for (int i = INDEX_ONE; i < revisionArr.length; i++) {\n-        Integer val = Integer.parseInt(revisionArr[i]);\n-        if (val < VALUE_CHECK) {\n-          rev = rev + ZERO;\n-        }\n-        rev = rev + val;\n+    for (int i = INDEX_ONE; i < revisionArr.length; i++) {\n+      Integer val = Integer.parseInt(revisionArr[i]);\n+      if (val < VALUE_CHECK) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "+  private static final String DATE_FORMAT = \"yyyy-MM-dd\";\n+  private static SimpleDateFormat simpleDateFormat = new SimpleDateFormat(DATE_FORMAT);"
                ]
            }
        ]
    },
    {
        "id": 96,
        "Anal": "An additional parameter \"pluginConfig\" of type `YangPluginConfig` has been added to the method \"addPackageInfo\".",
        "Stmts": "addPackageInfo(dirPath, CHECK1, CREATE_PATH, false);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-          addPackageInfo(pack, pkgInfo, getJavaPackageFromPackagePath(pkg), true);\n+          addPackageInfo(pack, pkgInfo, getJavaPackageFromPackagePath(pkg), true, ((JavaFileInfoContainer)parent).getJavaFileInfo().getPluginConfig());",
                "-          addPackageInfo(pack, pkgInfo, getJavaPackageFromPackagePath(pkg), true);\n+          addPackageInfo(pack, pkgInfo, getJavaPackageFromPackagePath(pkg), true, ((JavaFileInfoContainer)parent).getJavaFileInfo().getPluginConfig());\n-          addPackageInfo(pack, pkgInfo, getJavaPackageFromPackagePath(pkg), false);\n+          addPackageInfo(pack, pkgInfo, getJavaPackageFromPackagePath(pkg), false, ((JavaFileInfoContainer)yangNode).getJavaFileInfo().getPluginConfig());"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class YangPluginConfig (optional references)",
                "contexts": [
                    "public YangPluginConfig();",
                    "public void setConflictResolver(YangToJavaNamingConflictUtil conflictResolver);",
                    "public void setCodeGenDir(String codeGenDir);"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+    for (String str : strArray) {\n+      tempBuilder.append(str + string);\n+      if (tempBuilder.length() > lineSize) {\n+        String tempString = stringBuilder.toString();\n+        stringBuilder.delete(ZERO, stringBuilder.length());\n+        tempString = trimAtLast(tempString, string);\n+        stringBuilder.append(tempString);\n+        if (string.equals(PERIOD)) {\n+          stringBuilder.append(NEW_LINE + TWELVE_SPACE_INDENTATION + PERIOD + str + string);\n+        } else {",
                    "+    if (line.length() > lineSize) {\n+      String[] strArray = line.split(SPACE);\n+      stringBuilder = updateString(strArray, stringBuilder, SPACE, lineSize);\n+    } else {\n+      stringBuilder.append(line + NEW_LINE);\n+    }\n+    String[] strArray = stringBuilder.toString().split(NEW_LINE);\n+    StringBuilder tempBuilder = new StringBuilder();\n+    for (String str : strArray) {\n+      if (str.length() > SUB_LINE_SIZE) {",
                    "+      stringBuilder = updateString(strArray, stringBuilder, PERIOD, lineSize);\n+    } else {\n+      stringBuilder.append(line + NEW_LINE);\n+    }\n+    String[] strArray = stringBuilder.toString().split(NEW_LINE);\n+    StringBuilder tempBuilder = new StringBuilder();\n+    for (String str : strArray) {\n+      if (str.length() > SUB_LINE_SIZE) {\n+        if (line.contains(PERIOD) && !line.contains(PERIOD + HASH + OPEN_PARENTHESIS)) {\n+          String[] strArr = str.split(Pattern.quote(PERIOD));"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "+  private YangPluginConfig getStubPluginConfig() {\n+    YangPluginConfig pluginConfig = new YangPluginConfig();\n+    pluginConfig.setConflictResolver(null);\n+    return pluginConfig;\n+  }"
                ]
            }
        ]
    },
    {
        "id": 97,
        "Anal": "An additional boolean parameter \"isChildNode\" has been added to the method \"addPackageInfo\".",
        "Stmts": "addPackageInfo(dirPath, \"check1\", CREATE_PATH);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "+        File pack = createDirectories(pkg);\n+        YangNode parent = getParentNodeInGenCode(yangNode);\n+        if (parent != null) {\n+          pkgInfo = ((JavaFileInfoContainer)parent).getJavaFileInfo().getJavaName();\n+          addPackageInfo(pack, pkgInfo, getJavaPackageFromPackagePath(pkg), true);",
                "+          pkgInfo = ((JavaFileInfoContainer)parent).getJavaFileInfo().getJavaName();\n+          addPackageInfo(pack, pkgInfo, getJavaPackageFromPackagePath(pkg), true);\n+        } else {\n+          pkgInfo = ((JavaFileInfoContainer)yangNode).getJavaFileInfo().getJavaName();\n+          addPackageInfo(pack, pkgInfo, getJavaPackageFromPackagePath(pkg), false);",
                "-import static org.onosproject.yangutils.utils.UtilConstants.PACKAGE_INFO_JAVADOC_OF_CHILD;\n import static org.onosproject.yangutils.utils.io.impl.YangIoUtils.addPackageInfo;"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+    }\n+  }\n+  public static void searchAndDeleteTempDir(String root) throws IOException {\n+    List<File> store = new LinkedList<>();\n+    Stack<String> stack = new Stack<>();\n+    stack.push(root);\n+    while (!stack.empty()) {\n+      root = stack.pop();\n+      File file = new File(root);\n+      File[] filelist = file.listFiles();",
                    "+    for (File dir : store) {\n+      dir.delete();",
                    "+        continue;\n+      }\n+      for (File current : filelist) {\n+        if (current.isDirectory()) {\n+          stack.push(current.toString());\n+          if (current.getName().endsWith(\"-Temp\")) {\n+            store.add(current);\n+          }\n+        }\n+      }"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "+  private static final String CHECK1 = \"check1\";\n+  private static final String PKG_INFO = \"package-info.java\";\n+  private static final String PATH = \"src/main/yangmodel/\";\n+  private static final String MSG = \"Exception occured while creating package info file.\";"
                ]
            }
        ]
    },
    {
        "id": 98,
        "Anal": "The method \"setExcludePorts\" has been replaced by the method \"setSuppressHost\", with the parameter type changing from `Set<String>` to `Set<ConnectPoint>`.",
        "Stmts": "config.setExcludePorts(builder.build());\nSet<String> excludePorts = config.excludePorts();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [
            {
                "info": "Defined in class ConnectPoint (optional references)",
                "contexts": [
                    "public ConnectPoint(ElementId elementId, PortNumber portNumber);",
                    "public static ConnectPoint deviceConnectPoint(String string);",
                    "public static ConnectPoint hostConnectPoint(String string);",
                    "public PortNumber port();",
                    "public HostId hostId();",
                    "public IpElementId ipElementId();"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    return toStringHelper(this).add(\"vRouterMacs\", vRouterMacs()).add(\"excludePorts\", excludePorts()).toString();\n+    return toStringHelper(this).add(\"vRouterMacs\", vRouterMacs()).add(\"vRouterId\", vRouterId()).add(\"suppressSubnet\", suppressSubnet()).add(\"suppressHost\", suppressHost()).toString();",
                    "-  private static final String EXCLUDE_PORTS = \"excludePorts\";\n+  private static final String SUPPRESS_SUBNET = \"suppressSubnet\";\n+  private static final String SUPPRESS_HOST = \"suppressHost\";",
                    "-    return hasOnlyFields(VROUTER_MACS, VROUTER_ID, EXCLUDE_PORTS) && vRouterMacs() != null && vRouterId() != null && excludePorts() != null;\n+    return hasOnlyFields(VROUTER_MACS, VROUTER_ID, SUPPRESS_SUBNET, SUPPRESS_HOST) && vRouterMacs() != null && vRouterId() != null && suppressSubnet() != null && suppressHost() != null;"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-                                            + \"\\\"excludePorts\\\" : [\"\n-                                            + \"    \\\"port1\\\",\"\n-                                            + \"    \\\"port2\\\"\"\n+                                            + \"\\\"suppressSubnet\\\" : [\"\n+                                            + \"    \\\"of:1/1\\\",\"\n+                                            + \"    \\\"of:1/2\\\"\"\n+                                            + \"],\"\n+                                            + \"\\\"suppressHost\\\" : [\"\n+                                            + \"    \\\"of:1/1\\\",\"\n+                                            + \"    \\\"of:1/2\\\"\"",
                    "-  private static final String PORT_NAME_1 = \"port1\";\n-  private static final String PORT_NAME_2 = \"port2\";\n-  private static final String PORT_NAME_3 = \"port3\";\n+  private static final ConnectPoint PORT_1 = ConnectPoint.deviceConnectPoint(\"of:1/1\");\n+  private static final ConnectPoint PORT_2 = ConnectPoint.deviceConnectPoint(\"of:1/2\");\n+  private static final ConnectPoint PORT_3 = ConnectPoint.deviceConnectPoint(\"of:1/3\");",
                    "-                                                    + \"\\\"excludePorts\\\" : [\"\n-                                                    + \"    \\\"port1\\\",\"\n-                                                    + \"    \\\"port2\\\"\"\n+                                                    + \"\\\"suppressSubnet\\\" : [\"\n+                                                    + \"    \\\"of:1/1\\\",\"\n+                                                    + \"    \\\"wrongport\\\"\""
                ]
            }
        ]
    },
    {
        "id": 99,
        "Anal": "The parameter \"selected\" of the method \"setSelectedDatabaseConnection\" changes from `String` to `DatabaseItem`.",
        "Stmts": "String database = \"testing\";\ncontroller.setSelectedDatabaseConnection(database);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-      updateSelectedDatabase(NO_DATABASE, false);\n-    }\n+      if (connect != null) {\n+        config.copyConnectionInfoToAdvanced();\n+        setSelectedDatabaseConnection(USE_ADVANCED_OPTIONS);",
                "+      if (connect != null) {\n+        config.copyConnectionInfoToAdvanced();\n+        setSelectedDatabaseConnection(USE_ADVANCED_OPTIONS);\n+      } else {\n+        setSelectedDatabaseConnection(NO_DATABASE);",
                "+      }\n+    } finally {\n+      suppressEventHandling = false;\n+    }\n+    setSelectedDatabaseConnection(createDatabaseItem(getConfig().getDatabase()));"
            ]
        },
        "ClassCtx": [
            {
                "info": "Defined in class DatabaseItem (optional references)",
                "contexts": [
                    "public DatabaseItem(String name);",
                    "public DatabaseItem(String name, String displayName);",
                    "public String getName();",
                    "public String getDisplayName();",
                    "@Override public int hashCode();"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+  public void init() throws XulException, InvocationTargetException {\n+    NO_DATABASE = new DatabaseItem(\"@@none@@\", BaseMessages.getString(AbstractSqoopJobEntry.class, \"DatabaseName.ChooseAvailable\"));\n+    USE_ADVANCED_OPTIONS = new DatabaseItem(\"@@advanced@@\", BaseMessages.getString(AbstractSqoopJobEntry.class, \"DatabaseName.UseAdvancedOptions\"));\n+    bindings = new ArrayList<Binding>();\n+    suppressEventHandling = true;\n+    try {\n+      populateDatabases();\n+      setModeToggleLabel(BaseMessages.getString(AbstractSqoopJobEntry.class, MODE_I18N_STRINGS[0]));\n+      customizeModeToggleLabel(getModeToggleLabelElementId());\n+      createBindings(config, container, bindingFactory, bindings);",
                    "+    bindingFactory.createBinding(config, \"username\", this, \"usernameChanged\");\n+    bindingFactory.createBinding(config, \"password\", this, \"passwordChanged\");",
                    "+    } else {\n+      if (databaseConnections.contains(NO_DATABASE)) {\n+        databaseConnections.remove(NO_DATABASE);\n+      }\n+    }\n+    if (getConfig().getConnectFromAdvanced() != null || getConfig().getUsernameFromAdvanced() != null || getConfig().getPasswordFromAdvanced() != null) {\n+      if (!databaseConnections.contains(USE_ADVANCED_OPTIONS)) {\n+        databaseConnections.add(0, USE_ADVANCED_OPTIONS);\n+      }\n+    } else {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 100,
        "Anal": "The third parameter \"sourceHandle\" of the method \"concat\" changes from `SegmentHandle` to `String`.",
        "Stmts": "val sourceWriteHandle = s.openWrite(sourceSegment).join();\ns.concat(firstSegmentHandle, firstSegmentLength.get(), sourceWriteHandle, TIMEOUT).join();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "+    public CompletableFuture<Void> seal(SegmentHandle handle, Duration timeout) {\n-    public CompletableFuture<Void> concat(SegmentHandle targetHandle, long offset, SegmentHandle sourceHandle, Duration timeout) {\n+    public CompletableFuture<Void> concat(SegmentHandle targetHandle, long offset, String sourceSegment, Duration timeout) {\n-      return this.baseStorage.concat(targetHandle, offset, sourceHandle, timeout);\n+      return this.baseStorage.concat(targetHandle, offset, sourceSegment, timeout);"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  CompletableFuture<SegmentProperties> seal(SegmentHandle handle, Duration timeout);\n+  CompletableFuture<Void> seal(SegmentHandle handle, Duration timeout);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-  protected abstract SegmentHandle createHandle(String segmentName, boolean readOnly);\n+  protected abstract SegmentHandle createHandle(String segmentName, boolean readOnly, long epoch);",
                    "+  protected static final long DEFAULT_EPOCH = 1;"
                ]
            }
        ]
    },
    {
        "id": 101,
        "Anal": "The return type of the method \"removeFinishedWrites\" changes from `boolean` to `EnumSet<CleanupStatus>`.",
        "Stmts": "boolean result1 = q.removeFinishedWrites();\nAssert.assertTrue(\"Unexpected value from removeFinishedWrites when there were writes left in the queue.\", result1);\nboolean result2 = q.removeFinishedWrites();\nAssert.assertEquals(\"Unexpected result from removeFinishedWrites.\", !writes.isEmpty(), result2);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  synchronized List<Write> clear() {\n+  synchronized List<Write> close() {",
                    "-    long firstLedgerId = this.writes.peekFirst().getLedgerMetadata().getLedgerId();\n+    long firstLedgerId = this.writes.peekFirst().getWriteLedger().metadata.getLedgerId();",
                    "+    Exceptions.checkNotClosed(this.closed, this);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 102,
        "Anal": "The return type of the method \"createUser\" changes from `IdResponse` to `IdResult`.",
        "Stmts": "IdResponse response = accountWebServiceClient.createUser(userDTO);\nassertEquals(WSResponse.PARAMETER_ERROR, response.getCode());\nresponse = accountWebServiceClient.createUser(userDTO);\nassertEquals(WSResponse.PARAMETER_ERROR, response.getCode());",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [
            {
                "info": "Defined in class IdResult (optional references)",
                "contexts": [
                    "public String getCode();",
                    "public IdResult();",
                    "public IdResult(Long id);"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    response.setDefaultError();\n-    return response;\n+    result.setDefaultError();\n+    return result;",
                    "-  public SearchUserResponse searchUser(String loginName, String name) {\n-    SearchUserResponse response = new SearchUserResponse();\n+  public SearchUserResult searchUser(String loginName, String name) {\n+    SearchUserResult result = new SearchUserResult();",
                    "-      response.setUser(dto);\n-      return response;\n+      result.setUser(dto);\n+      return result;"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 103,
        "Anal": "The return type of the method \"getUser\" changes from `GetUserResponse` to `GetUserResult`.",
        "Stmts": "GetUserResponse response = accountWebServiceClient.getUser(1L);\nassertEquals(\"admin\", response.getUser().getLoginName());",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [
            {
                "info": "Defined in class GetUserResult (optional references)",
                "contexts": [
                    "public UserDTO getUser();",
                    "public void setUser(UserDTO user);"
                ]
            }
        ],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    response.setDefaultError();\n-    return response;\n+    result.setDefaultError();\n+    return result;",
                    "-  public SearchUserResponse searchUser(String loginName, String name) {\n-    SearchUserResponse response = new SearchUserResponse();\n+  public SearchUserResult searchUser(String loginName, String name) {\n+    SearchUserResult result = new SearchUserResult();",
                    "-      response.setUserList(dtoList);\n-      return response;\n+      result.setUserList(dtoList);\n+      return result;"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 104,
        "Anal": "The method \"changeReplicationFactor\" no longer takes a second parameter \"handler\" of type `Handler<AsyncResult<Void>>`. Instead, it now returns a `Future<Void>`.",
        "Stmts": "sub.changeReplicationFactor(topic, ar -> {\n  context.assertFalse(ar.succeeded());\n  final String message = ar.cause().getMessage();\n  context.assertTrue(message.contains(\"lacks an executable arg[0]\") && message.contains(\"/some/executable/that/does/not/exist\"));\n  async.complete();\n});",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-      kafka.changeReplicationFactor(topic, ar -> {\n+      kafka.changeReplicationFactor(topic).setHandler(ar -> {"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  void createTopic(Topic newTopic, Handler<AsyncResult<Void>> handler);\n-  void deleteTopic(TopicName topicName, Handler<AsyncResult<Void>> handler);\n-  void updateTopicConfig(Topic topic, Handler<AsyncResult<Void>> handler);\n-  void increasePartitions(Topic topic, Handler<AsyncResult<Void>> handler);\n-  void changeReplicationFactor(Topic topic, Handler<AsyncResult<Void>> handler);\n-  void topicMetadata(TopicName topicName, Handler<AsyncResult<TopicMetadata>> handler);\n-  void listTopics(Handler<AsyncResult<Set<String>>> handler);\n+  Future<Void> createTopic(Topic newTopic);\n+  Future<Void> deleteTopic(TopicName topicName);\n+  Future<Void> updateTopicConfig(Topic topic);",
                    "+    return handler;",
                    "+  Future<Void> changeReplicationFactor(Topic topic);\n+  Future<TopicMetadata> topicMetadata(TopicName topicName);\n+  Future<Set<String>> listTopics();"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 105,
        "Anal": "The method \"changeReplicationFactor\" no longer takes a second parameter \"handler\" of type `Handler<AsyncResult<Void>>`. Instead, it now returns a `Future<Void>`.",
        "Stmts": "sub.changeReplicationFactor(topic, ar -> {\n  context.assertTrue(ar.succeeded());\n  async.complete();\n});",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-      kafka.changeReplicationFactor(topic, ar -> {\n+      kafka.changeReplicationFactor(topic).setHandler(ar -> {"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  void createTopic(Topic newTopic, Handler<AsyncResult<Void>> handler);\n-  void deleteTopic(TopicName topicName, Handler<AsyncResult<Void>> handler);\n-  void updateTopicConfig(Topic topic, Handler<AsyncResult<Void>> handler);\n-  void increasePartitions(Topic topic, Handler<AsyncResult<Void>> handler);\n-  void changeReplicationFactor(Topic topic, Handler<AsyncResult<Void>> handler);\n-  void topicMetadata(TopicName topicName, Handler<AsyncResult<TopicMetadata>> handler);\n-  void listTopics(Handler<AsyncResult<Set<String>>> handler);\n+  Future<Void> createTopic(Topic newTopic);\n+  Future<Void> deleteTopic(TopicName topicName);\n+  Future<Void> updateTopicConfig(Topic topic);",
                    "+    return handler;",
                    "+  Future<Void> changeReplicationFactor(Topic topic);\n+  Future<TopicMetadata> topicMetadata(TopicName topicName);\n+  Future<Set<String>> listTopics();"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 106,
        "Anal": "The method \"changeReplicationFactor\" no longer takes a second parameter \"handler\" of type `Handler<AsyncResult<Void>>`. Instead, it now returns a `Future<Void>`.",
        "Stmts": "sub.changeReplicationFactor(topic, ar -> {\n  context.assertFalse(ar.succeeded());\n  context.assertTrue(ar.cause().getMessage().contains(\"Failed to reassign partitions\"));\n  async.complete();\n});",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "-      kafka.changeReplicationFactor(topic, ar -> {\n+      kafka.changeReplicationFactor(topic).setHandler(ar -> {"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  void createTopic(Topic newTopic, Handler<AsyncResult<Void>> handler);\n-  void deleteTopic(TopicName topicName, Handler<AsyncResult<Void>> handler);\n-  void updateTopicConfig(Topic topic, Handler<AsyncResult<Void>> handler);\n-  void increasePartitions(Topic topic, Handler<AsyncResult<Void>> handler);\n-  void changeReplicationFactor(Topic topic, Handler<AsyncResult<Void>> handler);\n-  void topicMetadata(TopicName topicName, Handler<AsyncResult<TopicMetadata>> handler);\n-  void listTopics(Handler<AsyncResult<Set<String>>> handler);\n+  Future<Void> createTopic(Topic newTopic);\n+  Future<Void> deleteTopic(TopicName topicName);\n+  Future<Void> updateTopicConfig(Topic topic);",
                    "+    return handler;",
                    "+  Future<Void> changeReplicationFactor(Topic topic);\n+  Future<TopicMetadata> topicMetadata(TopicName topicName);\n+  Future<Set<String>> listTopics();"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 107,
        "Anal": "The method \"getCpu\" now throws a `PerfMonException`.",
        "Stmts": "double result = instance.getCpu();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": [
                "     long value = (long)(100 * connector.getCpu());",
                "-            cnxLost = true;\n+        try {\n+          switch (connectors[i].getMetricType()) {\n+          case AbstractPerformanceMonitoringGui.PERFMON_CPU:\n+            generateSample(100 * connectors[i].getCpu(), label + \", %\");"
            ]
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+    if (ret[0] < 0 || ret[1] < 0)\n+      throwNotSupportedMetricException(\"disks I/O\");",
                    "-    } else {\n-      ret = AGENT_ERROR;\n-    }\n+    if (ret <= 0)\n+      throwNotSupportedMetricException(\"memory\");",
                    "+    if (ret[0] < 0 || ret[1] < 0)\n+      throwNotSupportedMetricException(\"swap\");"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "+    } catch (PerfMonException ex) {\n+      Logger.getLogger(AgentConnectorTest.class.getName()).log(Level.SEVERE, null, ex);"
                ]
            }
        ]
    },
    {
        "id": 108,
        "Anal": "The method name \"getEnvMapForLog\" has been changed to \"getEnvMap\".",
        "Stmts": "LOGGER.debug(JsonUtil.format(SystemUtil.getEnvMapForLog()));",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public static Map<String, String> getPropertiesMapForLog() {\n-    Properties properties = System.getProperties();\n-    return new TreeMap<String, String>(ConvertUtil.toMap(properties));\n+  public static Map<String, String> getPropertiesMap() {\n+    return new TreeMap<String, String>(toMap(System.getProperties()));",
                    "-    setPropertiesFromMap(ConvertUtil.toMap(properties));\n+    setPropertiesFromMap(toMap(properties));"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 109,
        "Anal": "The second parameter \"httpURLConnectionParam\" of the method \"getResponseBodyAsString\" changes from `HttpURLConnectionParam` to `ConnectionConfig`.",
        "Stmts": "HttpURLConnectionParam httpURLConnectionParam = new HttpURLConnectionParam();\nhttpURLConnectionParam.setContentCharset(CharsetType.GBK);\nString responseBodyAsString = URLConnectionUtil.getResponseBodyAsString(templateFile, httpURLConnectionParam);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public static String readLine(String urlString, HttpURLConnectionParam httpURLConnectionParam) {\n-    InputStream inputStream = getInputStream(urlString, httpURLConnectionParam);\n-    BufferedReader bufferedReader = InputStreamUtil.toBufferedReader(inputStream, httpURLConnectionParam.getContentCharset());\n+  public static String readLine(String urlString, ConnectionConfig connectionConfig) {\n+    InputStream inputStream = getInputStream(urlString, connectionConfig);\n+    BufferedReader bufferedReader = InputStreamUtil.toBufferedReader(inputStream, connectionConfig.getContentCharset());",
                    "-    Proxy proxy = getProxy(httpURLConnectionParam.getProxyAddress(), httpURLConnectionParam.getProxyPort());\n-    HttpURLConnection httpURLConnection = null;\n+    Proxy proxy = getProxy(connectionConfig.getProxyAddress(), connectionConfig.getProxyPort());",
                    "-  public static InputStream getInputStream(String urlString, HttpURLConnectionParam httpURLConnectionParam) {\n+  public static InputStream getInputStream(String urlString, ConnectionConfig connectionConfig) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 110,
        "Anal": "The method name \"joinValues\" has been changed to \"joinValuesOrderByIncludeKeys\".",
        "Stmts": "assertEquals(StringUtils.EMPTY, ParamUtil.joinValues(map, \"a\", \"b\"));\nassertEquals(value, ParamUtil.joinValues(map, \"service\"));\nassertEquals(value + value2, ParamUtil.joinValues(map, \"service\", \"paymentType\"));\nassertEquals(value2 + value, ParamUtil.joinValues(map, \"paymentType\", \"service\"));",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    return Validator.isNullOrEmpty(arrayValueMap) ? StringUtils.EMPTY : joinArrayValueMap(toSafeArrayValueMap(arrayValueMap, charsetType));\n+    return Validator.isNullOrEmpty(arrayValueMap) ? StringUtils.EMPTY : toQueryStringUseArrayValueMap(toSafeArrayValueMap(arrayValueMap, charsetType));",
                    "+  }\n+  public static String toQueryStringUseSingleValueMap(Map<String, String> singleValueMap) {\n+    return Validator.isNullOrEmpty(singleValueMap) ? StringUtils.EMPTY : toQueryStringUseArrayValueMap(toArrayValueMap(singleValueMap));\n+  }\n+  public static String toQueryStringUseArrayValueMap(Map<String, String[]> arrayValueMap) {",
                    "-    if (Validator.isNullOrEmpty(charsetType)) {\n-      return value;\n-    }\n-    return URIUtil.encode(URIUtil.decode(value, charsetType), charsetType);\n+    return Validator.isNullOrEmpty(charsetType) ? value : URIUtil.encode(URIUtil.decode(value, charsetType), charsetType);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 111,
        "Anal": "The order of parameters in the method \"toString\" has been swapped. The \"collection\" parameter is now the second parameter and \"toStringConfig\" is the first.",
        "Stmts": "assertEquals(\"2548\", ConvertUtil.toString(list, toStringConfig));",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    for (int i = 0, j = arrays.length; i < j; ++i) {\n-      T t = arrays[i];\n+    for (int i = 0, j = operateArray.length; i < j; ++i) {\n+      @SuppressWarnings(\"unchecked\") T t = (T)operateArray[i];",
                    "-    return (T)ConvertUtils.convert(value, targetType);\n+    return (T)org.apache.commons.beanutils.ConvertUtils.convert(value, targetType);",
                    "+  }\n+  private static <T> Object[] toObjects(T... arrays) {\n+    if (Validator.isNullOrEmpty(arrays)) {\n+      return ArrayUtils.EMPTY_STRING_ARRAY;\n+    }\n+    if (arrays.length > 1) {\n+      return arrays;\n+    }\n+    Object o = arrays[0];\n+    if (isPrimitiveArray(o)) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 112,
        "Anal": "The order of parameters in the method \"toString\" has been swapped. The \"collection\" parameter is now the second parameter and \"toStringConfig\" is the first.",
        "Stmts": "LOGGER.debug(ConvertUtil.toString(list, toStringConfig));",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    for (int i = 0, j = arrays.length; i < j; ++i) {\n-      T t = arrays[i];\n+    for (int i = 0, j = operateArray.length; i < j; ++i) {\n+      @SuppressWarnings(\"unchecked\") T t = (T)operateArray[i];",
                    "-    return (T)ConvertUtils.convert(value, targetType);\n+    return (T)org.apache.commons.beanutils.ConvertUtils.convert(value, targetType);",
                    "+  }\n+  private static <T> Object[] toObjects(T... arrays) {\n+    if (Validator.isNullOrEmpty(arrays)) {\n+      return ArrayUtils.EMPTY_STRING_ARRAY;\n+    }\n+    if (arrays.length > 1) {\n+      return arrays;\n+    }\n+    Object o = arrays[0];\n+    if (isPrimitiveArray(o)) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 113,
        "Anal": "The method \"getConcreteMembers\" has changed its parameters. The first change is the second parameter \"genericInherited\" which changes from `Element` to `TypeElement`. The second change is the third parameter \"members\" which changes from `Map<Element, TypeMirror>` to `Map<VariableElement, TypeMirror>`.",
        "Stmts": "Map<Element, TypeMirror> genericMembers = new HashMap<>();\nfor (Element element : genericElement.getEnclosedElements()) {\n  if (element instanceof VariableElement) {\n    genericMembers.put(element, element.asType());\n  }\n}\nLinkedHashMap<Element, TypeMirror> members = TypeUtils.getConcreteMembers(concreteType, types.asElement(genericType), genericMembers);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  private static List<? extends TypeMirror> getParameterizedTypes(@NotNull Element element) {\n+  private static List<? extends TypeMirror> getParameterizedTypes(@NotNull TypeElement element) {",
                    "-  public static boolean isEnum(@Nullable Element element) {\n-    TypeElement typeElement = (TypeElement)element;\n-    TypeMirror typeMirror = typeElement != null ? typeElement.getSuperclass() : null;\n+  public static boolean isEnum(@Nullable TypeElement element) {\n+    TypeMirror typeMirror = element != null ? element.getSuperclass() : null;",
                    "-  public static boolean isConcreteType(@NotNull Element element) {\n+  public static boolean isConcreteType(@NotNull TypeElement element) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 114,
        "Anal": "The method \"createClassifier\" changes its parameters from `name`, `language`, and `trainingData` to a single parameter `createClassifierOptions`.",
        "Stmts": "service.createClassifier(classifierId, \"en\", new File(\"src/test/resources/natural_language_classifier/weather_data_train.csv\")).execute();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public ServiceCall<Void> deleteClassifier(String classifierId) {\n-    Validator.isTrue((classifierId != null) && !classifierId.isEmpty(), \"classifierId cannot be null or empty\");\n-    final Request request = RequestBuilder.delete(String.format(PATH_CLASSIFIER, classifierId)).build();\n-    return createServiceCall(request, ResponseConverterUtils.getVoid());\n+  public ServiceCall<Void> deleteClassifier(DeleteClassifierOptions deleteClassifierOptions) {\n+    Validator.notNull(deleteClassifierOptions, \"deleteClassifierOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/classifiers/%s\", deleteClassifierOptions.classifierId()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());",
                    "-  public ServiceCall<Classifier> getClassifier(String classifierId) {\n-    Validator.isTrue((classifierId != null) && !classifierId.isEmpty(), \"classifierId cannot be null or empty\");\n-    final Request request = RequestBuilder.get(String.format(PATH_CLASSIFIER, classifierId)).build();\n-    return createServiceCall(request, ResponseConverterUtils.getObject(Classifier.class));\n+  public ServiceCall<Classifier> getClassifier(GetClassifierOptions getClassifierOptions) {\n+    Validator.notNull(getClassifierOptions, \"getClassifierOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/classifiers/%s\", getClassifierOptions.classifierId()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Classifier.class));",
                    "-  public ServiceCall<Classifiers> getClassifiers() {\n-    final Request request = RequestBuilder.get(PATH_CLASSIFIERS).build();\n-    return createServiceCall(request, ResponseConverterUtils.getObject(Classifiers.class));\n+  public ServiceCall<ClassifierList> listClassifiers(ListClassifiersOptions listClassifiersOptions) {\n+    RequestBuilder builder = RequestBuilder.get(\"/v1/classifiers\");\n+    if (listClassifiersOptions != null) {}\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(ClassifierList.class));\n+  }\n+  public ServiceCall<ClassifierList> listClassifiers() {\n+    return listClassifiers(null);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    classifiers = loadFixture(RESOURCE + \"classifiers.json\", Classifiers.class);\n+    classifiers = loadFixture(RESOURCE + \"classifiers.json\", ClassifierList.class);",
                    "-  private Classifiers classifiers;\n+  private ClassifierList classifiers;"
                ]
            }
        ]
    },
    {
        "id": 115,
        "Anal": "The method \"createClassifier\" changes from accepting three parameters: \"name\", \"language\", and \"trainingData\" to accepting a single parameter of type \"CreateClassifierOptions\".",
        "Stmts": "service.createClassifier(null, null, new File(\"src/test/resources/notfound.txt\"));",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public ServiceCall<Void> deleteClassifier(String classifierId) {\n-    Validator.isTrue((classifierId != null) && !classifierId.isEmpty(), \"classifierId cannot be null or empty\");\n-    final Request request = RequestBuilder.delete(String.format(PATH_CLASSIFIER, classifierId)).build();\n-    return createServiceCall(request, ResponseConverterUtils.getVoid());\n+  public ServiceCall<Void> deleteClassifier(DeleteClassifierOptions deleteClassifierOptions) {\n+    Validator.notNull(deleteClassifierOptions, \"deleteClassifierOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/classifiers/%s\", deleteClassifierOptions.classifierId()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());",
                    "-  public ServiceCall<Classifier> getClassifier(String classifierId) {\n-    Validator.isTrue((classifierId != null) && !classifierId.isEmpty(), \"classifierId cannot be null or empty\");\n-    final Request request = RequestBuilder.get(String.format(PATH_CLASSIFIER, classifierId)).build();\n-    return createServiceCall(request, ResponseConverterUtils.getObject(Classifier.class));\n+  public ServiceCall<Classifier> getClassifier(GetClassifierOptions getClassifierOptions) {\n+    Validator.notNull(getClassifierOptions, \"getClassifierOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/classifiers/%s\", getClassifierOptions.classifierId()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Classifier.class));",
                    "-  public ServiceCall<Classifiers> getClassifiers() {\n-    final Request request = RequestBuilder.get(PATH_CLASSIFIERS).build();\n-    return createServiceCall(request, ResponseConverterUtils.getObject(Classifiers.class));\n+  public ServiceCall<ClassifierList> listClassifiers(ListClassifiersOptions listClassifiersOptions) {\n+    RequestBuilder builder = RequestBuilder.get(\"/v1/classifiers\");\n+    if (listClassifiersOptions != null) {}\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(ClassifierList.class));\n+  }\n+  public ServiceCall<ClassifierList> listClassifiers() {\n+    return listClassifiers(null);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-  private Classifiers classifiers;\n+  private ClassifierList classifiers;",
                    "-    classifiers = loadFixture(RESOURCE + \"classifiers.json\", Classifiers.class);\n+    classifiers = loadFixture(RESOURCE + \"classifiers.json\", ClassifierList.class);"
                ]
            }
        ]
    },
    {
        "id": 116,
        "Anal": "The method \"classify\" changes from accepting two string parameters \"classifierId\" and \"text\" to accepting a single parameter of type \"ClassifyOptions\".",
        "Stmts": "service.classify(\"\", \"test\");",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public ServiceCall<Void> deleteClassifier(String classifierId) {\n-    Validator.isTrue((classifierId != null) && !classifierId.isEmpty(), \"classifierId cannot be null or empty\");\n-    final Request request = RequestBuilder.delete(String.format(PATH_CLASSIFIER, classifierId)).build();\n-    return createServiceCall(request, ResponseConverterUtils.getVoid());\n+  public ServiceCall<Void> deleteClassifier(DeleteClassifierOptions deleteClassifierOptions) {\n+    Validator.notNull(deleteClassifierOptions, \"deleteClassifierOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/classifiers/%s\", deleteClassifierOptions.classifierId()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());",
                    "-  public ServiceCall<Classifier> getClassifier(String classifierId) {\n-    Validator.isTrue((classifierId != null) && !classifierId.isEmpty(), \"classifierId cannot be null or empty\");\n-    final Request request = RequestBuilder.get(String.format(PATH_CLASSIFIER, classifierId)).build();\n-    return createServiceCall(request, ResponseConverterUtils.getObject(Classifier.class));\n+  public ServiceCall<Classifier> getClassifier(GetClassifierOptions getClassifierOptions) {\n+    Validator.notNull(getClassifierOptions, \"getClassifierOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/classifiers/%s\", getClassifierOptions.classifierId()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Classifier.class));",
                    "+  public ServiceCall<Classifier> createClassifier(CreateClassifierOptions createClassifierOptions) {\n+    Validator.notNull(createClassifierOptions, \"createClassifierOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.post(\"/v1/classifiers\");\n+    MultipartBody.Builder multipartBuilder = new MultipartBody.Builder();\n+    multipartBuilder.setType(MultipartBody.FORM);\n+    RequestBody trainingMetadataBody = RequestUtils.inputStreamBody(createClassifierOptions.metadata(), \"application/json\");\n+    multipartBuilder.addFormDataPart(\"training_metadata\", createClassifierOptions.metadataFilename(), trainingMetadataBody);\n+    RequestBody trainingDataBody = RequestUtils.inputStreamBody(createClassifierOptions.trainingData(), \"text/csv\");\n+    multipartBuilder.addFormDataPart(\"training_data\", createClassifierOptions.trainingDataFilename(), trainingDataBody);\n+    builder.body(multipartBuilder.build());"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-  private Classifiers classifiers;\n+  private ClassifierList classifiers;",
                    "-    classifiers = loadFixture(RESOURCE + \"classifiers.json\", Classifiers.class);\n+    classifiers = loadFixture(RESOURCE + \"classifiers.json\", ClassifierList.class);"
                ]
            }
        ]
    },
    {
        "id": 117,
        "Anal": "The method \"classify\" no longer takes two parameters \"classifierId\" and \"text\". Instead, it now takes a single parameter of type \"ClassifyOptions\".",
        "Stmts": "service.classify(classifierId, null);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public ServiceCall<Void> deleteClassifier(String classifierId) {\n-    Validator.isTrue((classifierId != null) && !classifierId.isEmpty(), \"classifierId cannot be null or empty\");\n-    final Request request = RequestBuilder.delete(String.format(PATH_CLASSIFIER, classifierId)).build();\n-    return createServiceCall(request, ResponseConverterUtils.getVoid());\n+  public ServiceCall<Void> deleteClassifier(DeleteClassifierOptions deleteClassifierOptions) {\n+    Validator.notNull(deleteClassifierOptions, \"deleteClassifierOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/classifiers/%s\", deleteClassifierOptions.classifierId()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());",
                    "-  public ServiceCall<Classifier> getClassifier(String classifierId) {\n-    Validator.isTrue((classifierId != null) && !classifierId.isEmpty(), \"classifierId cannot be null or empty\");\n-    final Request request = RequestBuilder.get(String.format(PATH_CLASSIFIER, classifierId)).build();\n-    return createServiceCall(request, ResponseConverterUtils.getObject(Classifier.class));\n+  public ServiceCall<Classifier> getClassifier(GetClassifierOptions getClassifierOptions) {\n+    Validator.notNull(getClassifierOptions, \"getClassifierOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/classifiers/%s\", getClassifierOptions.classifierId()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Classifier.class));",
                    "+  public ServiceCall<Classifier> createClassifier(CreateClassifierOptions createClassifierOptions) {\n+    Validator.notNull(createClassifierOptions, \"createClassifierOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.post(\"/v1/classifiers\");\n+    MultipartBody.Builder multipartBuilder = new MultipartBody.Builder();\n+    multipartBuilder.setType(MultipartBody.FORM);\n+    RequestBody trainingMetadataBody = RequestUtils.inputStreamBody(createClassifierOptions.metadata(), \"application/json\");\n+    multipartBuilder.addFormDataPart(\"training_metadata\", createClassifierOptions.metadataFilename(), trainingMetadataBody);\n+    RequestBody trainingDataBody = RequestUtils.inputStreamBody(createClassifierOptions.trainingData(), \"text/csv\");\n+    multipartBuilder.addFormDataPart(\"training_data\", createClassifierOptions.trainingDataFilename(), trainingDataBody);\n+    builder.body(multipartBuilder.build());"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    classifiers = loadFixture(RESOURCE + \"classifiers.json\", Classifiers.class);\n+    classifiers = loadFixture(RESOURCE + \"classifiers.json\", ClassifierList.class);",
                    "-  private Classifiers classifiers;\n+  private ClassifierList classifiers;"
                ]
            }
        ]
    },
    {
        "id": 118,
        "Anal": "The parameter \"classifierId\" of the method \"deleteClassifier\" changes from `String` to `DeleteClassifierOptions`.",
        "Stmts": "service.deleteClassifier(\"\");",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public ServiceCall<Classifier> getClassifier(String classifierId) {\n-    Validator.isTrue((classifierId != null) && !classifierId.isEmpty(), \"classifierId cannot be null or empty\");\n-    final Request request = RequestBuilder.get(String.format(PATH_CLASSIFIER, classifierId)).build();\n-    return createServiceCall(request, ResponseConverterUtils.getObject(Classifier.class));\n+  public ServiceCall<Classifier> getClassifier(GetClassifierOptions getClassifierOptions) {\n+    Validator.notNull(getClassifierOptions, \"getClassifierOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/classifiers/%s\", getClassifierOptions.classifierId()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Classifier.class));",
                    "+  public ServiceCall<Classifier> createClassifier(CreateClassifierOptions createClassifierOptions) {\n+    Validator.notNull(createClassifierOptions, \"createClassifierOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.post(\"/v1/classifiers\");\n+    MultipartBody.Builder multipartBuilder = new MultipartBody.Builder();\n+    multipartBuilder.setType(MultipartBody.FORM);\n+    RequestBody trainingMetadataBody = RequestUtils.inputStreamBody(createClassifierOptions.metadata(), \"application/json\");\n+    multipartBuilder.addFormDataPart(\"training_metadata\", createClassifierOptions.metadataFilename(), trainingMetadataBody);\n+    RequestBody trainingDataBody = RequestUtils.inputStreamBody(createClassifierOptions.trainingData(), \"text/csv\");\n+    multipartBuilder.addFormDataPart(\"training_data\", createClassifierOptions.trainingDataFilename(), trainingDataBody);\n+    builder.body(multipartBuilder.build());",
                    "-  public ServiceCall<Classifiers> getClassifiers() {\n-    final Request request = RequestBuilder.get(PATH_CLASSIFIERS).build();\n-    return createServiceCall(request, ResponseConverterUtils.getObject(Classifiers.class));\n+  public ServiceCall<ClassifierList> listClassifiers(ListClassifiersOptions listClassifiersOptions) {\n+    RequestBuilder builder = RequestBuilder.get(\"/v1/classifiers\");\n+    if (listClassifiersOptions != null) {}\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(ClassifierList.class));\n+  }\n+  public ServiceCall<ClassifierList> listClassifiers() {\n+    return listClassifiers(null);"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    classifiers = loadFixture(RESOURCE + \"classifiers.json\", Classifiers.class);\n+    classifiers = loadFixture(RESOURCE + \"classifiers.json\", ClassifierList.class);",
                    "-  private Classifiers classifiers;\n+  private ClassifierList classifiers;"
                ]
            }
        ]
    },
    {
        "id": 119,
        "Anal": "The return type of the method \"synthesize\" changes from `InputStream` to `ServiceCall<InputStream>`.",
        "Stmts": "final InputStream in = service.synthesize(text, Voice.EN_LISA, HttpMediaType.AUDIO_WAV);\nAssert.assertNotNull(in);\nwriteInputStreamToOutputStream(in, new FileOutputStream(\"target/output.wav\"));",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public InputStream synthesize(final String text, final Voice voice) {\n+  public ServiceCall<InputStream> synthesize(final String text, final Voice voice) {",
                    "-  public List<Voice> getVoices() {\n-    final Request request = RequestBuilder.get(\"/v1/voices\").build();\n-    final Response response = execute(request);\n-    final JsonObject jsonObject = ResponseUtil.getJsonObject(response);\n-    final List<Voice> voices = GsonSingleton.getGsonWithoutPrettyPrinting().fromJson(jsonObject.get(\"voices\"), listVoiceType);\n-    return voices;\n+  public ServiceCall<List<Voice>> getVoices() {\n+    final okhttp3.Request request = RequestBuilder.get(\"/v1/voices\").build3();\n+    return createServiceCall(createCall(request), ResponseUtil.getVoiceListConverter(listVoiceType));",
                    "-  public InputStream synthesize(final String text, final String format) {\n+  public ServiceCall<InputStream> synthesize(final String text, final String format) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    final InputStream is = service.synthesize(text, Voice.EN_LISA, HttpMediaType.AUDIO_WAV);\n+    final InputStream is = service.synthesize(text, Voice.EN_LISA, HttpMediaType.AUDIO_WAV).execute();"
                ]
            }
        ]
    },
    {
        "id": 120,
        "Anal": "The return type of the method \"getModel\" changes from `SpeechModel` to `ServiceCall<SpeechModel>`.",
        "Stmts": "SpeechModel model = service.getModel(\"not-a-real-Model\");\nmodel = service.getModel(speechModel.getName());",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    String path = PATH_RECOGNIZE;\n-    if (options != null && (options.getSessionId() != null && !options.getSessionId().isEmpty()))\n-      path = String.format(PATH_SESSION_RECOGNIZE, options.getSessionId());\n-    final RequestBuilder requestBuilder = RequestBuilder.post(path);\n-    buildRecognizeRequest(requestBuilder, options);\n-    requestBuilder.withBody(RequestBody.create(MediaType.parse(contentType), audio));\n+    requestBuilder.withBody(okhttp3.RequestBody.create(okhttp3.MediaType.parse(contentType), audio));",
                    "-  public SpeechResults recognize(File audio, String contentType, RecognizeOptions options) {\n+  public ServiceCall<SpeechResults> recognize(File audio, String contentType, RecognizeOptions options) {",
                    "-  public SpeechResults recognize(File audio, RecognizeOptions options) {\n+  public ServiceCall<SpeechResults> recognize(File audio, RecognizeOptions options) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 121,
        "Anal": "The return type of the method \"recognize\" changes from `SpeechResults` to `ServiceCall<SpeechResults>`.",
        "Stmts": "service.recognize(null);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-    String path = PATH_RECOGNIZE;\n-    if (options != null && (options.getSessionId() != null && !options.getSessionId().isEmpty()))\n-      path = String.format(PATH_SESSION_RECOGNIZE, options.getSessionId());\n-    final RequestBuilder requestBuilder = RequestBuilder.post(path);\n-    buildRecognizeRequest(requestBuilder, options);\n-    requestBuilder.withBody(RequestBody.create(MediaType.parse(contentType), audio));\n+    requestBuilder.withBody(okhttp3.RequestBody.create(okhttp3.MediaType.parse(contentType), audio));",
                    "-  public SpeechResults recognize(File audio, String contentType, RecognizeOptions options) {\n+  public ServiceCall<SpeechResults> recognize(File audio, String contentType, RecognizeOptions options) {",
                    "-  public SpeechResults recognize(File audio, RecognizeOptions options) {\n+  public ServiceCall<SpeechResults> recognize(File audio, RecognizeOptions options) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": []
            }
        ]
    },
    {
        "id": 122,
        "Anal": "The return type of the method \"getVoices\" changes from `List<Voice>` to `ServiceCall<List<Voice>>`.",
        "Stmts": "final List<Voice> result = service.getVoices();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "-  public InputStream synthesize(final String text, final Voice voice) {\n+  public ServiceCall<InputStream> synthesize(final String text, final Voice voice) {",
                    "-  public InputStream synthesize(final String text, final String format) {\n+  public ServiceCall<InputStream> synthesize(final String text, final String format) {",
                    "-  public ServiceCall<InputStream> synthesize3(final String text, final Voice voice, final String outputFormat) {\n+  public ServiceCall<InputStream> synthesize(final String text, final Voice voice, final String outputFormat) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    final InputStream is = service.synthesize(text, Voice.EN_LISA, HttpMediaType.AUDIO_WAV);\n+    final InputStream is = service.synthesize(text, Voice.EN_LISA, HttpMediaType.AUDIO_WAV).execute();"
                ]
            }
        ]
    },
    {
        "id": 123,
        "Anal": "The parameters of the method \"deleteCorpus\" have been changed from two strings \"customizationId\" and \"corpusName\" to a single `DeleteCorpusOptions` object.",
        "Stmts": "service.deleteCorpus(id, corpus).execute();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+      builder.query(\"allow_overwrite\", String.valueOf(addAudioOptions.allowOverwrite()));\n+    }\n+    builder.body(RequestBody.create(MediaType.parse(addAudioOptions.contentType()), addAudioOptions.audioResource()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<Void> deleteAudio(DeleteAudioOptions deleteAudioOptions) {\n+    Validator.notNull(deleteAudioOptions, \"deleteAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", deleteAudioOptions.customizationId(), deleteAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }",
                    "+    } else {\n+      builder.bodyContent(addWordsOptions.body(), addWordsOptions.contentType());\n+    }\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<Void> deleteWord(DeleteWordOptions deleteWordOptions) {\n+    Validator.notNull(deleteWordOptions, \"deleteWordOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/customizations/%s/words/%s\", deleteWordOptions.customizationId(), deleteWordOptions.wordName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }",
                    "+    Validator.notNull(getSessionStatusOptions, \"getSessionStatusOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/sessions/%s/recognize\", getSessionStatusOptions.sessionId()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(SessionStatus.class));\n+  }\n+  public ServiceCall<RecognitionJob> checkJob(CheckJobOptions checkJobOptions) {\n+    Validator.notNull(checkJobOptions, \"checkJobOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/recognitions/%s\", checkJobOptions.id()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(RecognitionJob.class));\n+  }\n+  public ServiceCall<RecognitionJobs> checkJobs(CheckJobsOptions checkJobsOptions) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    public void onTranscription(SpeechResults speechResults) {\n+    public void onTranscription(SpeechRecognitionResults speechResults) {",
                    "-    private final BlockingQueue<SpeechResults> speechResults = new LinkedBlockingQueue<>();\n+    private final BlockingQueue<SpeechRecognitionResults> speechResults = new LinkedBlockingQueue<>();"
                ]
            }
        ]
    },
    {
        "id": 124,
        "Anal": "The return type of the method \"getModels\" changes from `ServiceCall<List<SpeechModel>>` to `ServiceCall<SpeechModels>`.",
        "Stmts": "final List<SpeechModel> models = service.getModels().execute();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+    Validator.notNull(deleteWordOptions, \"deleteWordOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/customizations/%s/words/%s\", deleteWordOptions.customizationId(), deleteWordOptions.wordName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<Word> getWord(GetWordOptions getWordOptions) {\n+    Validator.notNull(getWordOptions, \"getWordOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/customizations/%s/words/%s\", getWordOptions.customizationId(), getWordOptions.wordName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Word.class));\n+  }\n+  public ServiceCall<Words> listWords(ListWordsOptions listWordsOptions) {",
                    "+    Validator.notNull(deleteAudioOptions, \"deleteAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", deleteAudioOptions.customizationId(), deleteAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<AudioListing> getAudio(GetAudioOptions getAudioOptions) {\n+    Validator.notNull(getAudioOptions, \"getAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", getAudioOptions.customizationId(), getAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(AudioListing.class));\n+  }\n+  public ServiceCall<AudioResources> listAudio(ListAudioOptions listAudioOptions) {",
                    "+    Validator.notNull(getSessionStatusOptions, \"getSessionStatusOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/sessions/%s/recognize\", getSessionStatusOptions.sessionId()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(SessionStatus.class));\n+  }\n+  public ServiceCall<RecognitionJob> checkJob(CheckJobOptions checkJobOptions) {\n+    Validator.notNull(checkJobOptions, \"checkJobOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/recognitions/%s\", checkJobOptions.id()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(RecognitionJob.class));\n+  }\n+  public ServiceCall<RecognitionJobs> checkJobs(CheckJobsOptions checkJobsOptions) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    public void onTranscription(SpeechResults speechResults) {\n+    public void onTranscription(SpeechRecognitionResults speechResults) {",
                    "-    private final BlockingQueue<SpeechResults> speechResults = new LinkedBlockingQueue<>();\n+    private final BlockingQueue<SpeechRecognitionResults> speechResults = new LinkedBlockingQueue<>();"
                ]
            }
        ]
    },
    {
        "id": 125,
        "Anal": "The method \"recognize\" has changed its parameter from `File` to `RecognizeOptions` and its return type from `SpeechResults` to `SpeechRecognitionResults`.",
        "Stmts": "final SpeechResults result = service.recognize(SAMPLE_WAV).execute();\nassertEquals(result, speechResults);",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+    Validator.notNull(deleteWordOptions, \"deleteWordOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/customizations/%s/words/%s\", deleteWordOptions.customizationId(), deleteWordOptions.wordName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<Word> getWord(GetWordOptions getWordOptions) {\n+    Validator.notNull(getWordOptions, \"getWordOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/customizations/%s/words/%s\", getWordOptions.customizationId(), getWordOptions.wordName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Word.class));\n+  }\n+  public ServiceCall<Words> listWords(ListWordsOptions listWordsOptions) {",
                    "+    Validator.notNull(deleteAudioOptions, \"deleteAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", deleteAudioOptions.customizationId(), deleteAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<AudioListing> getAudio(GetAudioOptions getAudioOptions) {\n+    Validator.notNull(getAudioOptions, \"getAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", getAudioOptions.customizationId(), getAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(AudioListing.class));\n+  }\n+  public ServiceCall<AudioResources> listAudio(ListAudioOptions listAudioOptions) {",
                    "+    Validator.notNull(getSessionStatusOptions, \"getSessionStatusOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/sessions/%s/recognize\", getSessionStatusOptions.sessionId()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(SessionStatus.class));\n+  }\n+  public ServiceCall<RecognitionJob> checkJob(CheckJobOptions checkJobOptions) {\n+    Validator.notNull(checkJobOptions, \"checkJobOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/recognitions/%s\", checkJobOptions.id()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(RecognitionJob.class));\n+  }\n+  public ServiceCall<RecognitionJobs> checkJobs(CheckJobsOptions checkJobsOptions) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    public void onTranscription(SpeechResults speechResults) {\n+    public void onTranscription(SpeechRecognitionResults speechResults) {",
                    "-    private final BlockingQueue<SpeechResults> speechResults = new LinkedBlockingQueue<>();\n+    private final BlockingQueue<SpeechRecognitionResults> speechResults = new LinkedBlockingQueue<>();"
                ]
            }
        ]
    },
    {
        "id": 126,
        "Anal": "The \"recognize\" method has been changed to only accept a single parameter of type `RecognizeOptions`. The return type has also been changed from `SpeechResults` to `SpeechRecognitionResults`.",
        "Stmts": "RecognizeOptions options = new RecognizeOptions.Builder().customizationId(id).build();\nSpeechResults result = service.recognize(SAMPLE_WAV, options).execute();\nassertEquals(recognition, GSON.toJsonTree(result));",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+    Validator.notNull(deleteWordOptions, \"deleteWordOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/customizations/%s/words/%s\", deleteWordOptions.customizationId(), deleteWordOptions.wordName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<Word> getWord(GetWordOptions getWordOptions) {\n+    Validator.notNull(getWordOptions, \"getWordOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/customizations/%s/words/%s\", getWordOptions.customizationId(), getWordOptions.wordName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Word.class));\n+  }\n+  public ServiceCall<Words> listWords(ListWordsOptions listWordsOptions) {",
                    "+    Validator.notNull(deleteAudioOptions, \"deleteAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", deleteAudioOptions.customizationId(), deleteAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<AudioListing> getAudio(GetAudioOptions getAudioOptions) {\n+    Validator.notNull(getAudioOptions, \"getAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", getAudioOptions.customizationId(), getAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(AudioListing.class));\n+  }\n+  public ServiceCall<AudioResources> listAudio(ListAudioOptions listAudioOptions) {",
                    "+    Validator.notNull(getSessionStatusOptions, \"getSessionStatusOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/sessions/%s/recognize\", getSessionStatusOptions.sessionId()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(SessionStatus.class));\n+  }\n+  public ServiceCall<RecognitionJob> checkJob(CheckJobOptions checkJobOptions) {\n+    Validator.notNull(checkJobOptions, \"checkJobOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/recognitions/%s\", checkJobOptions.id()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(RecognitionJob.class));\n+  }\n+  public ServiceCall<RecognitionJobs> checkJobs(CheckJobsOptions checkJobsOptions) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    public void onTranscription(SpeechResults speechResults) {\n+    public void onTranscription(SpeechRecognitionResults speechResults) {",
                    "-    private final BlockingQueue<SpeechResults> speechResults = new LinkedBlockingQueue<>();\n+    private final BlockingQueue<SpeechRecognitionResults> speechResults = new LinkedBlockingQueue<>();"
                ]
            }
        ]
    },
    {
        "id": 127,
        "Anal": "The method \"getCustomizations\" has been replaced with \"listLanguageModels\" which takes a different parameter type `ListLanguageModelsOptions` instead of a `String`.",
        "Stmts": "List<Customization> result = service.getCustomizations(\"en-us\").execute();\nassertEquals(PATH_CUSTOMIZATIONS + \"?language=en-us\", request.getPath());\nassertEquals(customizations.get(\"customizations\").getAsJsonArray().size(), result.size());\nassertEquals(customizations.get(\"customizations\"), GSON.toJsonTree(result));",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+  }\n+  public ServiceCall<Void> deleteWord(DeleteWordOptions deleteWordOptions) {\n+    Validator.notNull(deleteWordOptions, \"deleteWordOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/customizations/%s/words/%s\", deleteWordOptions.customizationId(), deleteWordOptions.wordName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<Word> getWord(GetWordOptions getWordOptions) {\n+    Validator.notNull(getWordOptions, \"getWordOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/customizations/%s/words/%s\", getWordOptions.customizationId(), getWordOptions.wordName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Word.class));",
                    "+  }\n+  public ServiceCall<Void> deleteAudio(DeleteAudioOptions deleteAudioOptions) {\n+    Validator.notNull(deleteAudioOptions, \"deleteAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", deleteAudioOptions.customizationId(), deleteAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<AudioListing> getAudio(GetAudioOptions getAudioOptions) {\n+    Validator.notNull(getAudioOptions, \"getAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", getAudioOptions.customizationId(), getAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(AudioListing.class));",
                    "+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<Corpus> getCorpus(GetCorpusOptions getCorpusOptions) {\n+    Validator.notNull(getCorpusOptions, \"getCorpusOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/customizations/%s/corpora/%s\", getCorpusOptions.customizationId(), getCorpusOptions.corpusName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Corpus.class));\n+  }\n+  public ServiceCall<Corpora> listCorpora(ListCorporaOptions listCorporaOptions) {\n+    Validator.notNull(listCorporaOptions, \"listCorporaOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/customizations/%s/corpora\", listCorporaOptions.customizationId()));"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    public void onTranscription(SpeechResults speechResults) {\n+    public void onTranscription(SpeechRecognitionResults speechResults) {",
                    "-    private final BlockingQueue<SpeechResults> speechResults = new LinkedBlockingQueue<>();\n+    private final BlockingQueue<SpeechRecognitionResults> speechResults = new LinkedBlockingQueue<>();"
                ]
            }
        ]
    },
    {
        "id": 128,
        "Anal": "The method \"getCustomization\" has been changed to \"getLanguageModel\" and the parameter type has changed from `String` to `GetLanguageModelOptions`.",
        "Stmts": "String id = \"foo\";\nCustomization result = service.getCustomization(id).execute();\nassertEquals(String.format(PATH_CUSTOMIZATION, id), request.getPath());\nassertEquals(result.toString(), customization.toString());",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+  }\n+  public ServiceCall<Void> deleteCorpus(DeleteCorpusOptions deleteCorpusOptions) {\n+    Validator.notNull(deleteCorpusOptions, \"deleteCorpusOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/customizations/%s/corpora/%s\", deleteCorpusOptions.customizationId(), deleteCorpusOptions.corpusName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<Corpus> getCorpus(GetCorpusOptions getCorpusOptions) {\n+    Validator.notNull(getCorpusOptions, \"getCorpusOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/customizations/%s/corpora/%s\", getCorpusOptions.customizationId(), getCorpusOptions.corpusName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Corpus.class));",
                    "+      builder.query(\"allow_overwrite\", String.valueOf(addAudioOptions.allowOverwrite()));\n+    }\n+    builder.body(RequestBody.create(MediaType.parse(addAudioOptions.contentType()), addAudioOptions.audioResource()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<Void> deleteAudio(DeleteAudioOptions deleteAudioOptions) {\n+    Validator.notNull(deleteAudioOptions, \"deleteAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", deleteAudioOptions.customizationId(), deleteAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }",
                    "+      builder.query(\"version\", recognizeOptions.version());\n+    }\n+    if (recognizeOptions.inactivityTimeout() != null) {\n+      builder.query(\"inactivity_timeout\", recognizeOptions.inactivityTimeout());\n+    }\n+    if (recognizeOptions.keywords() != null) {\n+      builder.query(\"keywords\", RequestUtils.join(recognizeOptions.keywords(), \",\"));\n+    }\n+    if (recognizeOptions.keywordsThreshold() != null) {\n+      builder.query(\"keywords_threshold\", recognizeOptions.keywordsThreshold());"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    public void onTranscription(SpeechResults speechResults) {\n+    public void onTranscription(SpeechRecognitionResults speechResults) {",
                    "-    private final BlockingQueue<SpeechResults> speechResults = new LinkedBlockingQueue<>();\n+    private final BlockingQueue<SpeechRecognitionResults> speechResults = new LinkedBlockingQueue<>();"
                ]
            }
        ]
    },
    {
        "id": 129,
        "Anal": "The method \"createCustomization\" has been changed to \"createLanguageModel\" and the parameters have been replaced with a single parameter of type \"CreateLanguageModelOptions\".",
        "Stmts": "Customization result = service.createCustomization(customization.getName(), SpeechModel.EN_GB_BROADBANDMODEL, customization.getDescription()).execute();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+    Validator.notNull(deleteWordOptions, \"deleteWordOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/customizations/%s/words/%s\", deleteWordOptions.customizationId(), deleteWordOptions.wordName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<Word> getWord(GetWordOptions getWordOptions) {\n+    Validator.notNull(getWordOptions, \"getWordOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/customizations/%s/words/%s\", getWordOptions.customizationId(), getWordOptions.wordName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Word.class));\n+  }\n+  public ServiceCall<Words> listWords(ListWordsOptions listWordsOptions) {",
                    "+    Validator.notNull(deleteAudioOptions, \"deleteAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", deleteAudioOptions.customizationId(), deleteAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<AudioListing> getAudio(GetAudioOptions getAudioOptions) {\n+    Validator.notNull(getAudioOptions, \"getAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", getAudioOptions.customizationId(), getAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(AudioListing.class));\n+  }\n+  public ServiceCall<AudioResources> listAudio(ListAudioOptions listAudioOptions) {",
                    "+    }\n+    if (recognizeOptions.version() != null) {\n+      builder.query(\"version\", recognizeOptions.version());\n+    }\n+    if (recognizeOptions.inactivityTimeout() != null) {\n+      builder.query(\"inactivity_timeout\", recognizeOptions.inactivityTimeout());\n+    }\n+    if (recognizeOptions.keywords() != null) {\n+      builder.query(\"keywords\", RequestUtils.join(recognizeOptions.keywords(), \",\"));\n+    }"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    public void onTranscription(SpeechResults speechResults) {\n+    public void onTranscription(SpeechRecognitionResults speechResults) {",
                    "-    private final BlockingQueue<SpeechResults> speechResults = new LinkedBlockingQueue<>();\n+    private final BlockingQueue<SpeechRecognitionResults> speechResults = new LinkedBlockingQueue<>();"
                ]
            }
        ]
    },
    {
        "id": 130,
        "Anal": "The method \"deleteCustomization\" has been replaced by the method \"deleteLanguageModel\" which takes a different parameter type `DeleteLanguageModelOptions`.",
        "Stmts": "String id = \"foo\";\nservice.deleteCustomization(id).execute();\nassertEquals(String.format(PATH_CUSTOMIZATION, id), request.getPath());",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+  }\n+  public ServiceCall<Void> deleteCorpus(DeleteCorpusOptions deleteCorpusOptions) {\n+    Validator.notNull(deleteCorpusOptions, \"deleteCorpusOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/customizations/%s/corpora/%s\", deleteCorpusOptions.customizationId(), deleteCorpusOptions.corpusName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<Corpus> getCorpus(GetCorpusOptions getCorpusOptions) {\n+    Validator.notNull(getCorpusOptions, \"getCorpusOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/customizations/%s/corpora/%s\", getCorpusOptions.customizationId(), getCorpusOptions.corpusName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Corpus.class));",
                    "+      builder.query(\"allow_overwrite\", String.valueOf(addAudioOptions.allowOverwrite()));\n+    }\n+    builder.body(RequestBody.create(MediaType.parse(addAudioOptions.contentType()), addAudioOptions.audioResource()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<Void> deleteAudio(DeleteAudioOptions deleteAudioOptions) {\n+    Validator.notNull(deleteAudioOptions, \"deleteAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", deleteAudioOptions.customizationId(), deleteAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }",
                    "+      builder.query(\"version\", recognizeOptions.version());\n+    }\n+    if (recognizeOptions.inactivityTimeout() != null) {\n+      builder.query(\"inactivity_timeout\", recognizeOptions.inactivityTimeout());\n+    }\n+    if (recognizeOptions.keywords() != null) {\n+      builder.query(\"keywords\", RequestUtils.join(recognizeOptions.keywords(), \",\"));\n+    }\n+    if (recognizeOptions.keywordsThreshold() != null) {\n+      builder.query(\"keywords_threshold\", recognizeOptions.keywordsThreshold());"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    public void onTranscription(SpeechResults speechResults) {\n+    public void onTranscription(SpeechRecognitionResults speechResults) {",
                    "-    private final BlockingQueue<SpeechResults> speechResults = new LinkedBlockingQueue<>();\n+    private final BlockingQueue<SpeechRecognitionResults> speechResults = new LinkedBlockingQueue<>();"
                ]
            }
        ]
    },
    {
        "id": 131,
        "Anal": "The method name changes from \"getCorpora\" to \"listCorpora\" and the parameter changes from a single string \"customizationId\" to a \"ListCorporaOptions\" object.",
        "Stmts": "List<Corpus> result = service.getCorpora(id).execute();\nassertEquals(String.format(PATH_CORPORA, id), request.getPath());",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+      builder.query(\"allow_overwrite\", String.valueOf(addAudioOptions.allowOverwrite()));\n+    }\n+    builder.body(RequestBody.create(MediaType.parse(addAudioOptions.contentType()), addAudioOptions.audioResource()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<Void> deleteAudio(DeleteAudioOptions deleteAudioOptions) {\n+    Validator.notNull(deleteAudioOptions, \"deleteAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", deleteAudioOptions.customizationId(), deleteAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }",
                    "+    } else {\n+      builder.bodyContent(addWordsOptions.body(), addWordsOptions.contentType());\n+    }\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<Void> deleteWord(DeleteWordOptions deleteWordOptions) {\n+    Validator.notNull(deleteWordOptions, \"deleteWordOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/customizations/%s/words/%s\", deleteWordOptions.customizationId(), deleteWordOptions.wordName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }",
                    "+    Validator.notNull(getSessionStatusOptions, \"getSessionStatusOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/sessions/%s/recognize\", getSessionStatusOptions.sessionId()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(SessionStatus.class));\n+  }\n+  public ServiceCall<RecognitionJob> checkJob(CheckJobOptions checkJobOptions) {\n+    Validator.notNull(checkJobOptions, \"checkJobOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/recognitions/%s\", checkJobOptions.id()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(RecognitionJob.class));\n+  }\n+  public ServiceCall<RecognitionJobs> checkJobs(CheckJobsOptions checkJobsOptions) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    private final BlockingQueue<SpeechResults> speechResults = new LinkedBlockingQueue<>();\n+    private final BlockingQueue<SpeechRecognitionResults> speechResults = new LinkedBlockingQueue<>();",
                    "-    public void onTranscription(SpeechResults speechResults) {\n+    public void onTranscription(SpeechRecognitionResults speechResults) {"
                ]
            }
        ]
    },
    {
        "id": 132,
        "Anal": "The method \"getWords\" has been changed to \"listWords\" and its parameters have also been changed from two parameters \"customizationId\" and \"Word.Type type\" to a single parameter \"ListWordsOptions listWordsOptions\".",
        "Stmts": "List<WordData> result = service.getWords(id, null).execute();",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+    Validator.notNull(deleteAudioOptions, \"deleteAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", deleteAudioOptions.customizationId(), deleteAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<AudioListing> getAudio(GetAudioOptions getAudioOptions) {\n+    Validator.notNull(getAudioOptions, \"getAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", getAudioOptions.customizationId(), getAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(AudioListing.class));\n+  }\n+  public ServiceCall<AudioResources> listAudio(ListAudioOptions listAudioOptions) {",
                    "+    }\n+    if (recognizeOptions.version() != null) {\n+      builder.query(\"version\", recognizeOptions.version());\n+    }\n+    if (recognizeOptions.inactivityTimeout() != null) {\n+      builder.query(\"inactivity_timeout\", recognizeOptions.inactivityTimeout());\n+    }\n+    if (recognizeOptions.keywords() != null) {\n+      builder.query(\"keywords\", RequestUtils.join(recognizeOptions.keywords(), \",\"));\n+    }",
                    "+    Validator.notNull(getSessionStatusOptions, \"getSessionStatusOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/sessions/%s/recognize\", getSessionStatusOptions.sessionId()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(SessionStatus.class));\n+  }\n+  public ServiceCall<RecognitionJob> checkJob(CheckJobOptions checkJobOptions) {\n+    Validator.notNull(checkJobOptions, \"checkJobOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/recognitions/%s\", checkJobOptions.id()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(RecognitionJob.class));\n+  }\n+  public ServiceCall<RecognitionJobs> checkJobs(CheckJobsOptions checkJobsOptions) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    private final BlockingQueue<SpeechResults> speechResults = new LinkedBlockingQueue<>();\n+    private final BlockingQueue<SpeechRecognitionResults> speechResults = new LinkedBlockingQueue<>();",
                    "-    public void onTranscription(SpeechResults speechResults) {\n+    public void onTranscription(SpeechRecognitionResults speechResults) {"
                ]
            }
        ]
    },
    {
        "id": 133,
        "Anal": "The method \"getWords\" has been changed to \"listWords\" and the parameters have also been changed from two separate parameters \"customizationId\" and \"type\" to a single parameter \"listWordsOptions\".",
        "Stmts": "List<WordData> result = service.getWords(id, Type.ALL).execute();\nassertEquals(String.format(PATH_WORDS, id) + \"?word_type=all\", request.getPath());",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+    Validator.notNull(deleteAudioOptions, \"deleteAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", deleteAudioOptions.customizationId(), deleteAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<AudioListing> getAudio(GetAudioOptions getAudioOptions) {\n+    Validator.notNull(getAudioOptions, \"getAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", getAudioOptions.customizationId(), getAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(AudioListing.class));\n+  }\n+  public ServiceCall<AudioResources> listAudio(ListAudioOptions listAudioOptions) {",
                    "+    }\n+    if (recognizeOptions.version() != null) {\n+      builder.query(\"version\", recognizeOptions.version());\n+    }\n+    if (recognizeOptions.inactivityTimeout() != null) {\n+      builder.query(\"inactivity_timeout\", recognizeOptions.inactivityTimeout());\n+    }\n+    if (recognizeOptions.keywords() != null) {\n+      builder.query(\"keywords\", RequestUtils.join(recognizeOptions.keywords(), \",\"));\n+    }",
                    "+    Validator.notNull(getSessionStatusOptions, \"getSessionStatusOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/sessions/%s/recognize\", getSessionStatusOptions.sessionId()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(SessionStatus.class));\n+  }\n+  public ServiceCall<RecognitionJob> checkJob(CheckJobOptions checkJobOptions) {\n+    Validator.notNull(checkJobOptions, \"checkJobOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/recognitions/%s\", checkJobOptions.id()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(RecognitionJob.class));\n+  }\n+  public ServiceCall<RecognitionJobs> checkJobs(CheckJobsOptions checkJobsOptions) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    private final BlockingQueue<SpeechResults> speechResults = new LinkedBlockingQueue<>();\n+    private final BlockingQueue<SpeechRecognitionResults> speechResults = new LinkedBlockingQueue<>();",
                    "-    public void onTranscription(SpeechResults speechResults) {\n+    public void onTranscription(SpeechRecognitionResults speechResults) {"
                ]
            }
        ]
    },
    {
        "id": 134,
        "Anal": "The method \"getWords\" has been replaced by the method \"listWords\" which takes a different parameter `ListWordsOptions` instead of `String customizationId`, `Word.Type type`, and `Word.Sort sort`.",
        "Stmts": "List<WordData> result = service.getWords(id, null, Sort.ALPHA).execute();\nassertEquals(String.format(PATH_WORDS, id) + \"?sort=alphabetical\", request.getPath());",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+    Validator.notNull(deleteAudioOptions, \"deleteAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", deleteAudioOptions.customizationId(), deleteAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<AudioListing> getAudio(GetAudioOptions getAudioOptions) {\n+    Validator.notNull(getAudioOptions, \"getAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", getAudioOptions.customizationId(), getAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(AudioListing.class));\n+  }\n+  public ServiceCall<AudioResources> listAudio(ListAudioOptions listAudioOptions) {",
                    "+    Validator.notNull(getSessionStatusOptions, \"getSessionStatusOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/sessions/%s/recognize\", getSessionStatusOptions.sessionId()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(SessionStatus.class));\n+  }\n+  public ServiceCall<RecognitionJob> checkJob(CheckJobOptions checkJobOptions) {\n+    Validator.notNull(checkJobOptions, \"checkJobOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/recognitions/%s\", checkJobOptions.id()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(RecognitionJob.class));\n+  }\n+  public ServiceCall<RecognitionJobs> checkJobs(CheckJobsOptions checkJobsOptions) {",
                    "+    Validator.notNull(deleteWordOptions, \"deleteWordOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/customizations/%s/words/%s\", deleteWordOptions.customizationId(), deleteWordOptions.wordName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<Word> getWord(GetWordOptions getWordOptions) {\n+    Validator.notNull(getWordOptions, \"getWordOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/customizations/%s/words/%s\", getWordOptions.customizationId(), getWordOptions.wordName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Word.class));\n+  }\n+  public ServiceCall<AcousticModel> createAcousticModel(CreateAcousticModelOptions createAcousticModelOptions) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    private final BlockingQueue<SpeechResults> speechResults = new LinkedBlockingQueue<>();\n+    private final BlockingQueue<SpeechRecognitionResults> speechResults = new LinkedBlockingQueue<>();",
                    "-    public void onTranscription(SpeechResults speechResults) {\n+    public void onTranscription(SpeechRecognitionResults speechResults) {"
                ]
            }
        ]
    },
    {
        "id": 135,
        "Anal": "The method \"getWords\" has been replaced with \"listWords\" which takes a different parameter type `ListWordsOptions` instead of separate parameters for customizationId, type, and sort.",
        "Stmts": "List<WordData> result = service.getWords(id, Type.ALL, Sort.ALPHA).execute();\nassertEquals(String.format(PATH_WORDS, id) + \"?word_type=all&sort=alphabetical\", request.getPath());",
        "UsagesCtx": {
            "info": "Usages diff texts of the focal method (examples of changes to use the updated focal method)",
            "contexts": []
        },
        "ClassCtx": [],
        "EnvCtx": [
            {
                "info": "Diff texts in the scope of the focal method (optional references)",
                "contexts": [
                    "+    Validator.notNull(deleteAudioOptions, \"deleteAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", deleteAudioOptions.customizationId(), deleteAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<AudioListing> getAudio(GetAudioOptions getAudioOptions) {\n+    Validator.notNull(getAudioOptions, \"getAudioOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/acoustic_customizations/%s/audio/%s\", getAudioOptions.customizationId(), getAudioOptions.audioName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(AudioListing.class));\n+  }\n+  public ServiceCall<AudioResources> listAudio(ListAudioOptions listAudioOptions) {",
                    "+    Validator.notNull(getSessionStatusOptions, \"getSessionStatusOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/sessions/%s/recognize\", getSessionStatusOptions.sessionId()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(SessionStatus.class));\n+  }\n+  public ServiceCall<RecognitionJob> checkJob(CheckJobOptions checkJobOptions) {\n+    Validator.notNull(checkJobOptions, \"checkJobOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/recognitions/%s\", checkJobOptions.id()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(RecognitionJob.class));\n+  }\n+  public ServiceCall<RecognitionJobs> checkJobs(CheckJobsOptions checkJobsOptions) {",
                    "+    Validator.notNull(deleteWordOptions, \"deleteWordOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.delete(String.format(\"/v1/customizations/%s/words/%s\", deleteWordOptions.customizationId(), deleteWordOptions.wordName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getVoid());\n+  }\n+  public ServiceCall<Word> getWord(GetWordOptions getWordOptions) {\n+    Validator.notNull(getWordOptions, \"getWordOptions cannot be null\");\n+    RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/customizations/%s/words/%s\", getWordOptions.customizationId(), getWordOptions.wordName()));\n+    return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Word.class));\n+  }\n+  public ServiceCall<AcousticModel> createAcousticModel(CreateAcousticModelOptions createAcousticModelOptions) {"
                ]
            },
            {
                "info": "Diff texts in the scope of the test method (new identifiers defined can be directly used in the new test)",
                "contexts": [
                    "-    private final BlockingQueue<SpeechResults> speechResults = new LinkedBlockingQueue<>();\n+    private final BlockingQueue<SpeechRecognitionResults> speechResults = new LinkedBlockingQueue<>();",
                    "-    public void onTranscription(SpeechResults speechResults) {\n+    public void onTranscription(SpeechRecognitionResults speechResults) {"
                ]
            }
        ]
    }
]