[
    {
        "id": 0,
        "original": "@Test\npublic void getGroupFromGrpcClient() throws Exception {\n  Configuration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.NOSASL.getAuthName());\n  Assert.assertEquals(\"\", SecurityUtils.getGroupFromGrpcClient());\n  Configuration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());\n  Configuration.set(PropertyKey.SECURITY_GROUP_MAPPING_CLASS, IdentityUserGroupsMapping.class.getName());\n  AuthenticatedClientUser.set(\"test_client_user\");\n  Assert.assertEquals(\"test_client_user\", SecurityUtils.getGroupFromGrpcClient());\n}",
        "prediction": "@Test\npublic void getGroupFromGrpcClient() throws Exception {\n  AlluxioConfiguration conf = ConfigurationTestUtils.defaults();\n  Configuration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.NOSASL.getAuthName());\n  Assert.assertEquals(\"\", SecurityUtils.getGroupFromGrpcClient(conf));\n  Configuration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());\n  Configuration.set(PropertyKey.SECURITY_GROUP_MAPPING_CLASS, IdentityUserGroupsMapping.class.getName());\n  AuthenticatedClientUser.set(\"test_client_user\");\n  Assert.assertEquals(\"test_client_user\", SecurityUtils.getGroupFromGrpcClient(conf));\n}",
        "reference": "@Test\npublic void getGroupFromGrpcClient() throws Exception {\n  mConfiguration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.NOSASL.getAuthName());\n  Assert.assertEquals(\"\", SecurityUtils.getGroupFromGrpcClient(mConfiguration));\n  mConfiguration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());\n  mConfiguration.set(PropertyKey.SECURITY_GROUP_MAPPING_CLASS, IdentityUserGroupsMapping.class.getName());\n  AuthenticatedClientUser.set(\"test_client_user\");\n  Assert.assertEquals(\"test_client_user\", SecurityUtils.getGroupFromGrpcClient(mConfiguration));\n}"
    },
    {
        "id": 1,
        "original": "@Test\npublic void getTmpDir() {\n  String singleDir = \"/tmp\";\n  Whitebox.setInternalState(CommonUtils.class, \"TMP_DIRS\", Collections.singletonList(singleDir));\n  assertEquals(singleDir, CommonUtils.getTmpDir());\n  List<String> multiDirs = Arrays.asList(\"/tmp1\", \"/tmp2\", \"/tmp3\");\n  Whitebox.setInternalState(CommonUtils.class, \"TMP_DIRS\", multiDirs);\n  Set<String> results = new HashSet<>();\n  for (int i = 0; i < 100 || results.size() != multiDirs.size(); i++) {\n    results.add(CommonUtils.getTmpDir());\n  }\n  assertEquals(new HashSet<>(multiDirs), results);\n  Whitebox.setInternalState(CommonUtils.class, \"TMP_DIRS\", Configuration.getList(PropertyKey.TMP_DIRS, \",\"));\n}",
        "prediction": "@Test\npublic void getTmpDir() {\n  String singleDir = \"/tmp\";\n  assertEquals(singleDir, CommonUtils.getTmpDir(Collections.singletonList(singleDir)));\n  List<String> multiDirs = Arrays.asList(\"/tmp1\", \"/tmp2\", \"/tmp3\");\n  Set<String> results = new HashSet<>();\n  for (int i = 0; i < 100 || results.size() != multiDirs.size(); i++) {\n    results.add(CommonUtils.getTmpDir(multiDirs));\n  }\n  assertEquals(new HashSet<>(multiDirs), results);\n}",
        "reference": "@Test\npublic void getTmpDir() {\n  String singleDir = \"/tmp\";\n  List<String> singleDirList = Arrays.asList(\"/tmp\");\n  assertEquals(singleDir, CommonUtils.getTmpDir(singleDirList));\n  List<String> multiDirs = Arrays.asList(\"/tmp1\", \"/tmp2\", \"/tmp3\");\n  Set<String> results = new HashSet<>();\n  for (int i = 0; i < 100 || results.size() != multiDirs.size(); i++) {\n    results.add(CommonUtils.getTmpDir(multiDirs));\n  }\n  assertEquals(new HashSet<>(multiDirs), results);\n}"
    },
    {
        "id": 2,
        "original": "@Test\npublic void formatPermissionTest() {\n  Assert.assertEquals(\"-rw-rw-rw-\", FormatUtils.formatPermission((short)0666, false));\n  Assert.assertEquals(\"drw-rw-rw-\", FormatUtils.formatPermission((short)0666, true));\n  Assert.assertEquals(\"-rwxrwxrwx\", FormatUtils.formatPermission((short)0777, false));\n  Assert.assertEquals(\"drwxrwxrwx\", FormatUtils.formatPermission((short)0777, true));\n  Assert.assertEquals(\"-r--r--r--\", FormatUtils.formatPermission((short)0444, false));\n  Assert.assertEquals(\"dr--r--r--\", FormatUtils.formatPermission((short)0444, true));\n  Assert.assertEquals(\"-r-xr-xr-x\", FormatUtils.formatPermission((short)0555, false));\n  Assert.assertEquals(\"dr-xr-xr-x\", FormatUtils.formatPermission((short)0555, true));\n  Assert.assertEquals(\"-rwxr-xr--\", FormatUtils.formatPermission((short)0754, false));\n  Assert.assertEquals(\"drwxr-xr--\", FormatUtils.formatPermission((short)0754, true));\n}",
        "prediction": "@Test\npublic void formatModeTest() {\n  Assert.assertEquals(\"-rw-rw-rw-\", FormatUtils.formatMode((short)0666, false));\n  Assert.assertEquals(\"drw-rw-rw-\", FormatUtils.formatMode((short)0666, true));\n  Assert.assertEquals(\"-rwxrwxrwx\", FormatUtils.formatMode((short)0777, false));\n  Assert.assertEquals(\"drwxrwxrwx\", FormatUtils.formatMode((short)0777, true));\n  Assert.assertEquals(\"-r--r--r--\", FormatUtils.formatMode((short)0444, false));\n  Assert.assertEquals(\"dr--r--r--\", FormatUtils.formatMode((short)0444, true));\n  Assert.assertEquals(\"-r-xr-xr-x\", FormatUtils.formatMode((short)0555, false));\n  Assert.assertEquals(\"dr-xr-xr-x\", FormatUtils.formatMode((short)0555, true));\n  Assert.assertEquals(\"-rwxr-xr--\", FormatUtils.formatMode((short)0754, false));\n  Assert.assertEquals(\"drwxr-xr--\", FormatUtils.formatMode((short)0754, true));\n}",
        "reference": "@Test\npublic void formatPermissionTest() {\n  Assert.assertEquals(\"-rw-rw-rw-\", FormatUtils.formatMode((short)0666, false));\n  Assert.assertEquals(\"drw-rw-rw-\", FormatUtils.formatMode((short)0666, true));\n  Assert.assertEquals(\"-rwxrwxrwx\", FormatUtils.formatMode((short)0777, false));\n  Assert.assertEquals(\"drwxrwxrwx\", FormatUtils.formatMode((short)0777, true));\n  Assert.assertEquals(\"-r--r--r--\", FormatUtils.formatMode((short)0444, false));\n  Assert.assertEquals(\"dr--r--r--\", FormatUtils.formatMode((short)0444, true));\n  Assert.assertEquals(\"-r-xr-xr-x\", FormatUtils.formatMode((short)0555, false));\n  Assert.assertEquals(\"dr-xr-xr-x\", FormatUtils.formatMode((short)0555, true));\n  Assert.assertEquals(\"-rwxr-xr--\", FormatUtils.formatMode((short)0754, false));\n  Assert.assertEquals(\"drwxr-xr--\", FormatUtils.formatMode((short)0754, true));\n}"
    },
    {
        "id": 3,
        "original": "@Test\npublic void applyUMaskTest() {\n  FileSystemPermission umaskPermission = new FileSystemPermission((short)0022);\n  PermissionStatus permissionStatus = new PermissionStatus(\"user1\", \"group1\", FileSystemPermission.getDefault());\n  Configuration conf = new Configuration();\n  conf.set(Constants.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());\n  conf.set(Constants.SECURITY_AUTHORIZATION_PERMISSION_ENABLED, \"true\");\n  permissionStatus = permissionStatus.applyUMask(umaskPermission, conf);\n  Assert.assertEquals(FileSystemAction.ALL, permissionStatus.getPermission().getUserAction());\n  Assert.assertEquals(FileSystemAction.READ_EXECUTE, permissionStatus.getPermission().getGroupAction());\n  Assert.assertEquals(FileSystemAction.READ_EXECUTE, permissionStatus.getPermission().getOtherAction());\n  Assert.assertEquals(0755, permissionStatus.getPermission().toShort());\n}",
        "prediction": "@Test\npublic void applyUMaskTest() {\n  FileSystemPermission umaskPermission = new FileSystemPermission((short)0022);\n  PermissionStatus permissionStatus = new PermissionStatus(\"user1\", \"group1\", FileSystemPermission.getDefault());\n  permissionStatus = permissionStatus.applyUMask(umaskPermission);\n  Assert.assertEquals(FileSystemAction.ALL, permissionStatus.getPermission().getUserAction());\n  Assert.assertEquals(FileSystemAction.READ_EXECUTE, permissionStatus.getPermission().getGroupAction());\n  Assert.assertEquals(FileSystemAction.READ_EXECUTE, permissionStatus.getPermission().getOtherAction());\n  Assert.assertEquals(0755, permissionStatus.getPermission().toShort());\n}",
        "reference": "@Test\npublic void applyUMaskTest() {\n  FileSystemPermission umaskPermission = new FileSystemPermission((short)0022);\n  PermissionStatus permissionStatus = new PermissionStatus(\"user1\", \"group1\", FileSystemPermission.getDefault());\n  permissionStatus = permissionStatus.applyUMask(umaskPermission);\n  Assert.assertEquals(FileSystemAction.ALL, permissionStatus.getPermission().getUserAction());\n  Assert.assertEquals(FileSystemAction.READ_EXECUTE, permissionStatus.getPermission().getGroupAction());\n  Assert.assertEquals(FileSystemAction.READ_EXECUTE, permissionStatus.getPermission().getOtherAction());\n  Assert.assertEquals(0755, permissionStatus.getPermission().toShort());\n}"
    },
    {
        "id": 4,
        "original": "@Test\npublic void mount() throws Exception {\n  AlluxioURI alluxioPath = new AlluxioURI(\"/t\");\n  AlluxioURI ufsPath = new AlluxioURI(\"/u\");\n  MountOptions mountOptions = MountOptions.defaults();\n  doNothing().when(mFileSystemMasterClient).mount(alluxioPath, ufsPath, mountOptions);\n  mFileSystem.mount(alluxioPath, ufsPath, mountOptions);\n  verify(mFileSystemMasterClient).mount(alluxioPath, ufsPath, mountOptions);\n  verifyFilesystemContextAcquiredAndReleased();\n}",
        "prediction": "@Test\npublic void mount() throws Exception {\n  AlluxioURI alluxioPath = new AlluxioURI(\"/t\");\n  AlluxioURI ufsPath = new AlluxioURI(\"/u\");\n  MountPOptions mountOptions = MountPOptions.newBuilder().build();\n  doNothing().when(mFileSystemMasterClient).mount(alluxioPath, ufsPath, mountOptions);\n  mFileSystem.mount(alluxioPath, ufsPath, mountOptions);\n  verify(mFileSystemMasterClient).mount(alluxioPath, ufsPath, mountOptions);\n  verifyFilesystemContextAcquiredAndReleased();\n}",
        "reference": "@Test\npublic void mount() throws Exception {\n  AlluxioURI alluxioPath = new AlluxioURI(\"/t\");\n  AlluxioURI ufsPath = new AlluxioURI(\"/u\");\n  MountPOptions mountOptions = MountPOptions.getDefaultInstance();\n  doNothing().when(mFileSystemMasterClient).mount(alluxioPath, ufsPath, mountOptions);\n  mFileSystem.mount(alluxioPath, ufsPath, mountOptions);\n  verify(mFileSystemMasterClient).mount(alluxioPath, ufsPath, mountOptions);\n  verifyFilesystemContextAcquiredAndReleased();\n}"
    },
    {
        "id": 5,
        "original": "@Test\npublic void countBytes() throws Exception {\n  long worker1 = mBlockMaster.getWorkerId(NET_ADDRESS_1);\n  long worker2 = mBlockMaster.getWorkerId(NET_ADDRESS_2);\n  List<String> tiers = Arrays.asList(\"MEM\", \"SSD\");\n  Map<String, Long> worker1TotalBytesOnTiers = ImmutableMap.of(\"MEM\", 10L, \"SSD\", 20L);\n  Map<String, Long> worker2TotalBytesOnTiers = ImmutableMap.of(\"MEM\", 1000L, \"SSD\", 2000L);\n  Map<String, Long> worker1UsedBytesOnTiers = ImmutableMap.of(\"MEM\", 1L, \"SSD\", 2L);\n  Map<String, Long> worker2UsedBytesOnTiers = ImmutableMap.of(\"MEM\", 100L, \"SSD\", 200L);\n  mBlockMaster.workerRegister(worker1, tiers, worker1TotalBytesOnTiers, worker1UsedBytesOnTiers, NO_BLOCKS_ON_TIERS, new RegisterWorkerTOptions());\n  mBlockMaster.workerRegister(worker2, tiers, worker2TotalBytesOnTiers, worker2UsedBytesOnTiers, NO_BLOCKS_ON_TIERS, new RegisterWorkerTOptions());\n  assertEquals(3030, mBlockMaster.getCapacityBytes());\n  assertEquals(303L, mBlockMaster.getUsedBytes());\n  assertEquals(ImmutableMap.of(\"MEM\", 1010L, \"SSD\", 2020L), mBlockMaster.getTotalBytesOnTiers());\n  assertEquals(ImmutableMap.of(\"MEM\", 101L, \"SSD\", 202L), mBlockMaster.getUsedBytesOnTiers());\n}",
        "prediction": "@Test\npublic void countBytes() throws Exception {\n  long worker1 = mBlockMaster.getWorkerId(NET_ADDRESS_1);\n  long worker2 = mBlockMaster.getWorkerId(NET_ADDRESS_2);\n  List<String> tiers = Arrays.asList(\"MEM\", \"SSD\");\n  Map<String, Long> worker1TotalBytesOnTiers = ImmutableMap.of(\"MEM\", 10L, \"SSD\", 20L);\n  Map<String, Long> worker2TotalBytesOnTiers = ImmutableMap.of(\"MEM\", 1000L, \"SSD\", 2000L);\n  Map<String, Long> worker1UsedBytesOnTiers = ImmutableMap.of(\"MEM\", 1L, \"SSD\", 2L);\n  Map<String, Long> worker2UsedBytesOnTiers = ImmutableMap.of(\"MEM\", 100L, \"SSD\", 200L);\n  mBlockMaster.workerRegister(worker1, tiers, worker1TotalBytesOnTiers, worker1UsedBytesOnTiers, NO_BLOCKS_ON_TIERS, RegisterWorkerPOptions.newBuilder().build());\n  mBlockMaster.workerRegister(worker2, tiers, worker2TotalBytesOnTiers, worker2UsedBytesOnTiers, NO_BLOCKS_ON_TIERS, RegisterWorkerPOptions.newBuilder().build());\n  assertEquals(3030, mBlockMaster.getCapacityBytes());\n  assertEquals(303L, mBlockMaster.getUsedBytes());\n  assertEquals(ImmutableMap.of(\"MEM\", 1010L, \"SSD\", 2020L), mBlockMaster.getTotalBytesOnTiers());\n  assertEquals(ImmutableMap.of(\"MEM\", 101L, \"SSD\", 202L), mBlockMaster.getUsedBytesOnTiers());\n}",
        "reference": "@Test\npublic void countBytes() throws Exception {\n  long worker1 = mBlockMaster.getWorkerId(NET_ADDRESS_1);\n  long worker2 = mBlockMaster.getWorkerId(NET_ADDRESS_2);\n  List<String> tiers = Arrays.asList(\"MEM\", \"SSD\");\n  Map<String, Long> worker1TotalBytesOnTiers = ImmutableMap.of(\"MEM\", 10L, \"SSD\", 20L);\n  Map<String, Long> worker2TotalBytesOnTiers = ImmutableMap.of(\"MEM\", 1000L, \"SSD\", 2000L);\n  Map<String, Long> worker1UsedBytesOnTiers = ImmutableMap.of(\"MEM\", 1L, \"SSD\", 2L);\n  Map<String, Long> worker2UsedBytesOnTiers = ImmutableMap.of(\"MEM\", 100L, \"SSD\", 200L);\n  mBlockMaster.workerRegister(worker1, tiers, worker1TotalBytesOnTiers, worker1UsedBytesOnTiers, NO_BLOCKS_ON_TIERS, RegisterWorkerPOptions.getDefaultInstance());\n  mBlockMaster.workerRegister(worker2, tiers, worker2TotalBytesOnTiers, worker2UsedBytesOnTiers, NO_BLOCKS_ON_TIERS, RegisterWorkerPOptions.getDefaultInstance());\n  assertEquals(3030, mBlockMaster.getCapacityBytes());\n  assertEquals(303L, mBlockMaster.getUsedBytes());\n  assertEquals(ImmutableMap.of(\"MEM\", 1010L, \"SSD\", 2020L), mBlockMaster.getTotalBytesOnTiers());\n  assertEquals(ImmutableMap.of(\"MEM\", 101L, \"SSD\", 202L), mBlockMaster.getUsedBytesOnTiers());\n}"
    },
    {
        "id": 6,
        "original": "@Test\npublic void setUserFromLoginModuleTest() throws Exception {\n  Configuration conf = new Configuration();\n  Permission permission = Permission.defaults();\n  conf.set(Constants.SECURITY_AUTHENTICATION_TYPE, AuthType.NOSASL.getAuthName());\n  permission.setUserFromThriftClient(conf);\n  verifyPermission(\"\", \"\", (short)0777, permission);\n  conf.set(Constants.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());\n  conf.set(Constants.SECURITY_LOGIN_USERNAME, \"test_login_user\");\n  conf.set(Constants.SECURITY_GROUP_MAPPING, IdentityUserGroupsMapping.class.getName());\n  Whitebox.setInternalState(LoginUser.class, \"sLoginUser\", (String)null);\n  permission.setUserFromLoginModule(conf);\n  verifyPermission(\"test_login_user\", \"test_login_user\", (short)0777, permission);\n}",
        "prediction": "@Test\npublic void setUserFromLoginModuleTest() throws Exception {\n  Configuration conf = new Configuration();\n  Permission permission = Permission.defaults();\n  conf.set(Constants.SECURITY_AUTHENTICATION_TYPE, AuthType.NOSASL.getAuthName());\n  permission.setUserFromThriftClient();\n  verifyPermission(\"\", \"\", (short)0777, permission);\n  conf.set(Constants.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());\n  conf.set(Constants.SECURITY_LOGIN_USERNAME, \"test_login_user\");\n  conf.set(Constants.SECURITY_GROUP_MAPPING, IdentityUserGroupsMapping.class.getName());\n  Whitebox.setInternalState(LoginUser.class, \"sLoginUser\", (String)null);\n  permission.setUserFromLoginModule(conf);\n  verifyPermission(\"test_login_user\", \"test_login_user\", (short)0777, permission);\n}",
        "reference": "@Test\npublic void setUserFromLoginModuleTest() throws Exception {\n  Configuration.defaultInit();\n  Permission permission = Permission.defaults();\n  Configuration.set(Constants.SECURITY_AUTHENTICATION_TYPE, AuthType.NOSASL.getAuthName());\n  permission.setUserFromThriftClient();\n  verifyPermission(\"\", \"\", (short)0777, permission);\n  Configuration.set(Constants.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());\n  Configuration.set(Constants.SECURITY_LOGIN_USERNAME, \"test_login_user\");\n  Configuration.set(Constants.SECURITY_GROUP_MAPPING, IdentityUserGroupsMapping.class.getName());\n  Whitebox.setInternalState(LoginUser.class, \"sLoginUser\", (String)null);\n  permission.setUserFromLoginModule();\n  verifyPermission(\"test_login_user\", \"test_login_user\", (short)0777, permission);\n}"
    },
    {
        "id": 7,
        "original": "@Test\npublic void createBlockPath() throws IOException {\n  String absolutePath = PathUtils.concatPath(mTestFolder.getRoot(), \"tmp\", \"bar\");\n  File tempFile = new File(absolutePath);\n  FileUtils.createBlockPath(tempFile.getAbsolutePath());\n  assertTrue(FileUtils.exists(tempFile.getParent()));\n}",
        "prediction": "@Test\npublic void createBlockPath() throws IOException {\n  String absolutePath = PathUtils.concatPath(mTestFolder.getRoot(), \"tmp\", \"bar\");\n  File tempFile = new File(absolutePath);\n  String workerDataFolderPermissions = \"755\";\n  FileUtils.createBlockPath(tempFile.getAbsolutePath(), workerDataFolderPermissions);\n  assertTrue(FileUtils.exists(tempFile.getParent()));\n}",
        "reference": "@Test\npublic void createBlockPath() throws IOException {\n  String absolutePath = PathUtils.concatPath(mTestFolder.getRoot(), \"tmp\", \"bar\");\n  File tempFile = new File(absolutePath);\n  FileUtils.createBlockPath(tempFile.getAbsolutePath(), mWorkerDataFolderPerms);\n  assertTrue(FileUtils.exists(tempFile.getParent()));\n}"
    },
    {
        "id": 8,
        "original": "@Test\npublic final void testToArray() {\n  ItemList il = new ItemList(Itr.ZERO);\n  for (int i = 0; i < CAP - 1; i++) {\n    il.add(Itr.ZERO);\n  }\n  assertEquals(CAP, il.toArray().length);\n  assertEquals(il.size(), il.toArray().length);\n}",
        "prediction": "@Test\npublic final void testToArray() {\n  ItemList il = new ItemList(Itr.ZERO);\n  for (int i = 0; i < CAP - 1; i++) {\n    il.add(Itr.ZERO);\n  }\n  assertEquals(CAP, il.finish().length);\n  assertEquals(0, il.size());\n}",
        "reference": "@Test\npublic final void testToArray() {\n  ItemList il = new ItemList(Itr.ZERO);\n  for (int i = 0; i < CAP - 1; i++) {\n    il.add(Itr.ZERO);\n  }\n  assertEquals(CAP, il.finish().length);\n}"
    },
    {
        "id": 9,
        "original": "@Test\npublic void handleFailure() throws Exception {\n  Map map = new HashMap<String, Boolean>();\n  map.put(\"Key\", true);\n  assertThat(client.handleFailure(map).get()).isEqualTo(true);\n}",
        "prediction": "@Test\npublic void handleFailure() throws Exception {\n  Set set = new HashSet<String>();\n  set.add(\"Key\");\n  assertThat(client.handleFailure(set).get()).isEqualTo(true);\n}",
        "reference": "@Test\npublic void handleFailure() throws Exception {\n  Set<String> set = new HashSet<>();\n  set.add(\"Key\");\n  assertThat(client.handleFailure(set).get()).isEqualTo(true);\n}"
    },
    {
        "id": 10,
        "original": "@Test\npublic void successfulPolling() throws InterruptedException {\n  for (int i = 0; i < PARAMETERS.CONCURRENCY_SOME; i++) {\n    failureDetectorPolicy.executePolicy(layout, corfuRuntime);\n    Thread.sleep(PARAMETERS.TIMEOUT_VERY_SHORT.toMillis());\n  }\n  Thread.sleep(PARAMETERS.TIMEOUT_SHORT.toMillis());\n  Map<String, Boolean> result = failureDetectorPolicy.getServerStatus();\n  assertThat(result).isNull();\n}",
        "prediction": "@Test\npublic void successfulPolling() throws InterruptedException {\n  for (int i = 0; i < PARAMETERS.CONCURRENCY_SOME; i++) {\n    failureDetectorPolicy.executePolicy(layout, corfuRuntime);\n    Thread.sleep(PARAMETERS.TIMEOUT_VERY_SHORT.toMillis());\n  }\n  Thread.sleep(PARAMETERS.TIMEOUT_SHORT.toMillis());\n  PollReport result = failureDetectorPolicy.getServerStatus();\n  assertThat(result.getFailingNodes()).isEmpty();\n  assertThat(result.getOutOfPhaseEpochNodes()).isEmpty();\n}",
        "reference": "@Test\npublic void successfulPolling() throws InterruptedException {\n  for (int i = 0; i < PARAMETERS.CONCURRENCY_SOME; i++) {\n    failureDetectorPolicy.executePolicy(layout, corfuRuntime);\n    Thread.sleep(PARAMETERS.TIMEOUT_VERY_SHORT.toMillis());\n  }\n  Thread.sleep(PARAMETERS.TIMEOUT_SHORT.toMillis());\n  PollReport result = failureDetectorPolicy.getServerStatus();\n  assertThat(result.getIsFailurePresent()).isFalse();\n}"
    },
    {
        "id": 11,
        "original": "@Test\npublic void failedPolling() throws InterruptedException {\n  addServerRule(SERVERS.PORT_0, new TestRule().always().drop());\n  addServerRule(SERVERS.PORT_1, new TestRule().always().drop());\n  addServerRule(SERVERS.PORT_2, new TestRule().always().drop());\n  Map<String, Boolean> expectedResult = new HashMap<>();\n  expectedResult.put(getEndpoint(SERVERS.PORT_0), false);\n  expectedResult.put(getEndpoint(SERVERS.PORT_1), false);\n  expectedResult.put(getEndpoint(SERVERS.PORT_2), false);\n  pollAndMatchExpectedResult(expectedResult);\n  clearServerRules(SERVERS.PORT_0);\n  expectedResult.remove(getEndpoint(SERVERS.PORT_0));\n  pollAndMatchExpectedResult(expectedResult);\n}",
        "prediction": "@Test\npublic void failedPolling() throws InterruptedException {\n  addServerRule(SERVERS.PORT_0, new TestRule().always().drop());\n  addServerRule(SERVERS.PORT_1, new TestRule().always().drop());\n  addServerRule(SERVERS.PORT_2, new TestRule().always().drop());\n  Set<String> expectedResult = new HashSet<>();\n  expectedResult.add(getEndpoint(SERVERS.PORT_0));\n  expectedResult.add(getEndpoint(SERVERS.PORT_1));\n  expectedResult.add(getEndpoint(SERVERS.PORT_2));\n  pollAndMatchExpectedResult(expectedResult);\n  clearServerRules(SERVERS.PORT_0);\n  expectedResult.remove(getEndpoint(SERVERS.PORT_0));\n  pollAndMatchExpectedResult(expectedResult);\n}",
        "reference": "@Test\npublic void failedPolling() throws InterruptedException {\n  addServerRule(SERVERS.PORT_0, new TestRule().always().drop());\n  addServerRule(SERVERS.PORT_1, new TestRule().always().drop());\n  addServerRule(SERVERS.PORT_2, new TestRule().always().drop());\n  Set<String> expectedResult = new HashSet<>();\n  expectedResult.add(getEndpoint(SERVERS.PORT_0));\n  expectedResult.add(getEndpoint(SERVERS.PORT_1));\n  expectedResult.add(getEndpoint(SERVERS.PORT_2));\n  pollAndMatchExpectedResult(expectedResult);\n  clearServerRules(SERVERS.PORT_0);\n  expectedResult.remove(getEndpoint(SERVERS.PORT_0));\n  pollAndMatchExpectedResult(expectedResult);\n}"
    },
    {
        "id": 12,
        "original": "@Test\npublic void testGetItemId() {\n  assertTrue(\"testGetItemId 0\", mv.getItemId() >= 0);\n}",
        "prediction": "@Test\npublic void testGetResourceId() {\n  assertTrue(\"testGetResourceId 0\", mv.getResourceId() >= 0);\n}",
        "reference": "@Test\npublic void testGetItemId() {\n  assertTrue(\"testGetItemId 0\", mv.getResourceId() >= 0);\n}"
    },
    {
        "id": 13,
        "original": "@Test\npublic void testSetItemId() {\n  int itemId = 55;\n  mv.setItemId(itemId);\n  assertThat(\"testSetItemId 0\", mv.getItemId(), equalTo(itemId));\n}",
        "prediction": "@Test\npublic void testSetResourceId() {\n  int resourceId = 55;\n  mv.setResourceId(resourceId);\n  assertThat(\"testSetResourceId 0\", mv.getResourceId(), equalTo(resourceId));\n}",
        "reference": "@Test\npublic void testSetItemId() {\n  int itemId = 55;\n  mv.setResourceId(itemId);\n  mv.setResourceTypeId(Constants.ITEM);\n  assertThat(\"testSetItemId 0\", mv.getResourceId(), equalTo(itemId));\n}"
    },
    {
        "id": 14,
        "original": "@Test\npublic void testGetFormat() throws SQLException {\n  assertThat(\"testGetFormat 0\", bs.getFormat(), notNullValue());\n  assertThat(\"testGetFormat 1\", bs.getFormat(), equalTo(BitstreamFormat.findUnknown(context)));\n}",
        "prediction": "@Test\npublic void testGetFormat() throws SQLException {\n  assertThat(\"testGetFormat 0\", bs.getFormat(context), notNullValue());\n  assertThat(\"testGetFormat 1\", bs.getFormat(context), equalTo(BitstreamFormat.findUnknown(context)));\n}",
        "reference": "@Test\npublic void testGetFormat() throws SQLException {\n  assertThat(\"testGetFormat 0\", bs.getFormat(context), notNullValue());\n  assertThat(\"testGetFormat 1\", bs.getFormat(context), equalTo(bitstreamFormatService.findUnknown(context)));\n}"
    },
    {
        "id": 15,
        "original": "@Test\npublic void testGetValueId() {\n  assertThat(\"testGetValueId 0\", mv.getValueId(), notNullValue());\n}",
        "prediction": "@Test\npublic void testGetID() {\n  assertThat(\"testGetID 0\", mv.getID(), notNullValue());\n}",
        "reference": "@Test\npublic void testGetValueId() {\n  assertThat(\"testGetValueId 0\", mv.getID(), notNullValue());\n}"
    },
    {
        "id": 16,
        "original": "@Test\npublic void testGetErrorCode_invalidErrorObject() {\n  Mockito.when(responseException.getContent()).thenReturn(\"{\\\"type\\\":\\\"other\\\",\\\"message\\\":\\\"some other object\\\"}\");\n  try {\n    ErrorResponseUtil.getErrorCode(responseException);\n    Assert.fail();\n  } catch (HttpResponseException ex) {\n    Assert.assertSame(responseException, ex);\n  }\n}",
        "prediction": "@Test\npublic void testGetErrorCode_invalidErrorObject() {\n  Mockito.when(responseException.getContent()).thenReturn(\"{\\\"type\\\":\\\"other\\\",\\\"message\\\":\\\"some other object\\\"}\");\n  try {\n    ErrorResponseUtil.getErrorCode(responseException);\n    Assert.fail();\n  } catch (ResponseException ex) {\n    Assert.assertSame(responseException, ex);\n  }\n}",
        "reference": "@Test\npublic void testGetErrorCode_invalidErrorObject() {\n  Mockito.when(responseException.getContent()).thenReturn(\"{\\\"type\\\":\\\"other\\\",\\\"message\\\":\\\"some other object\\\"}\");\n  try {\n    ErrorResponseUtil.getErrorCode(responseException);\n    Assert.fail();\n  } catch (ResponseException ex) {\n    Assert.assertSame(responseException, ex);\n  }\n}"
    },
    {
        "id": 17,
        "original": "@Test\npublic void testGetErrorCode_knownErrorCode() throws HttpResponseException {\n  Mockito.when(responseException.getContent()).thenReturn(\"{\\\"errors\\\":[{\\\"code\\\":\\\"MANIFEST_INVALID\\\",\\\"message\\\":\\\"manifest invalid\\\",\\\"detail\\\":{}}]}\");\n  Assert.assertSame(ErrorCodes.MANIFEST_INVALID, ErrorResponseUtil.getErrorCode(responseException));\n}",
        "prediction": "@Test\npublic void testGetErrorCode_knownErrorCode() throws ResponseException {\n  Mockito.when(responseException.getContent()).thenReturn(\"{\\\"errors\\\":[{\\\"code\\\":\\\"MANIFEST_INVALID\\\",\\\"message\\\":\\\"manifest invalid\\\",\\\"detail\\\":{}}]}\");\n  Assert.assertSame(ErrorCodes.MANIFEST_INVALID, ErrorResponseUtil.getErrorCode(responseException));\n}",
        "reference": "@Test\npublic void testGetErrorCode_knownErrorCode() throws ResponseException {\n  Mockito.when(responseException.getContent()).thenReturn(\"{\\\"errors\\\":[{\\\"code\\\":\\\"MANIFEST_INVALID\\\",\\\"message\\\":\\\"manifest invalid\\\",\\\"detail\\\":{}}]}\");\n  Assert.assertSame(ErrorCodes.MANIFEST_INVALID, ErrorResponseUtil.getErrorCode(responseException));\n}"
    },
    {
        "id": 18,
        "original": "@Test\npublic void testChangeProtectionKey() throws NoPeerConnectionException, IOException {\n  KeyPair keypair1 = EncryptionUtil.generateRSAKeyPair();\n  KeyPair keypair2 = EncryptionUtil.generateRSAKeyPair();\n  Number160 locationKey = Number160.createHash(NetworkTestUtil.randomString());\n  Number160 domainKey = H2HConstants.TOMP2P_DEFAULT_KEY;\n  Number160 contentKey = Number160.createHash(NetworkTestUtil.randomString());\n  NetworkManager node = network.get(random.nextInt(networkSize));\n  H2HTestData data1v0 = new H2HTestData(NetworkTestUtil.randomString());\n  data1v0.generateVersionKey();\n  data1v0.setBasedOnKey(Number160.ZERO);\n  FuturePut putFuture1 = node.getDataManager().put(locationKey, domainKey, contentKey, data1v0, keypair1);\n  putFuture1.awaitUninterruptibly();\n  Assert.assertTrue(putFuture1.isSuccess());\n  H2HTestData data1v1 = new H2HTestData(NetworkTestUtil.randomString());\n  data1v1.generateVersionKey();\n  data1v1.setBasedOnKey(data1v0.getVersionKey());\n  FuturePut putFuture2 = node.getDataManager().put(locationKey, domainKey, contentKey, data1v1, keypair1);\n  putFuture2.awaitUninterruptibly();\n  Assert.assertTrue(putFuture2.isSuccess());\n  H2HTestData data1v2 = new H2HTestData(NetworkTestUtil.randomString());\n  data1v2.generateVersionKey();\n  data1v2.setBasedOnKey(data1v1.getVersionKey());\n  FuturePut changeFuture1 = node.getDataManager().changeProtectionKey(locationKey, domainKey, contentKey, data1v2.getTimeToLive(), keypair1, keypair2);\n  changeFuture1.awaitUninterruptibly();\n  Assert.assertTrue(changeFuture1.isSuccess());\n  H2HTestData data1v3 = new H2HTestData(NetworkTestUtil.randomString());\n  data1v3.generateVersionKey();\n  data1v3.setBasedOnKey(data1v2.getVersionKey());\n  FuturePut changeFuture2 = node.getDataManager().put(locationKey, domainKey, contentKey, data1v3, keypair1);\n  changeFuture2.awaitUninterruptibly();\n  Assert.assertFalse(changeFuture2.isSuccess());\n}",
        "prediction": "@Test\npublic void testChangeProtectionKey() throws NoPeerConnectionException, IOException, NoSuchAlgorithmException {\n  KeyPair keypair1 = EncryptionUtil.generateRSAKeyPair();\n  KeyPair keypair2 = EncryptionUtil.generateRSAKeyPair();\n  Number160 locationKey = Number160.createHash(NetworkTestUtil.randomString());\n  Number160 domainKey = H2HConstants.TOMP2P_DEFAULT_KEY;\n  Number160 contentKey = Number160.createHash(NetworkTestUtil.randomString());\n  NetworkManager node = network.get(random.nextInt(networkSize));\n  H2HTestData data1v0 = new H2HTestData(NetworkTestUtil.randomString());\n  data1v0.generateVersionKey();\n  data1v0.setBasedOnKey(Number160.ZERO);\n  FuturePut putFuture1 = node.getDataManager().put(locationKey, domainKey, contentKey, data1v0, keypair1);\n  putFuture1.awaitUninterruptibly();\n  Assert.assertTrue(putFuture1.isSuccess());\n  H2HTestData data1v1 = new H2HTestData(NetworkTestUtil.randomString());\n  data1v1.generateVersionKey();\n  data1v1.setBasedOnKey(data1v0.getVersionKey());\n  FuturePut putFuture2 = node.getDataManager().put(locationKey, domainKey, contentKey, data1v1, keypair1);\n  putFuture2.awaitUninterruptibly();\n  Assert.assertTrue(putFuture2.isSuccess());\n  H2HTestData data1v2 = new H2HTestData(NetworkTestUtil.randomString());\n  data1v2.generateVersionKey();\n  data1v2.setBasedOnKey(data1v1.getVersionKey());\n  MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n  byte[] hash = md.digest(data1v2.toString().getBytes(StandardCharsets.UTF_8));\n  FuturePut changeFuture1 = node.getDataManager().changeProtectionKey(locationKey, domainKey, contentKey, data1v2.getVersionKey(), data1v2.getBasedOnKey(), data1v2.getTimeToLive(), keypair1, keypair2, hash);\n  changeFuture1.awaitUninterruptibly();\n  Assert.assertTrue(changeFuture1.isSuccess());\n  H2HTestData data1v3 = new H2HTestData(NetworkTestUtil.randomString());\n  data1v3.generateVersionKey();\n  data1v3.setBasedOnKey(data1v2.getVersionKey());\n  FuturePut changeFuture2 = node.getDataManager().put(locationKey, domainKey, contentKey, data1v3, keypair1);\n  changeFuture2.awaitUninterruptibly();\n  Assert.assertFalse(changeFuture2.isSuccess());\n}",
        "reference": "@Test\npublic void testChangeProtectionKey() throws NoPeerConnectionException, IOException, InvalidKeyException, SignatureException {\n  KeyPair keypairOld = EncryptionUtil.generateRSAKeyPair();\n  KeyPair keypairNew = EncryptionUtil.generateRSAKeyPair();\n  Number160 locationKey = Number160.createHash(NetworkTestUtil.randomString());\n  Number160 domainKey = H2HConstants.TOMP2P_DEFAULT_KEY;\n  Number160 contentKey = Number160.createHash(NetworkTestUtil.randomString());\n  NetworkManager node = network.get(random.nextInt(networkSize));\n  H2HSharableTestData data = new H2HSharableTestData(NetworkTestUtil.randomString());\n  data.generateVersionKey();\n  data.setBasedOnKey(Number160.ZERO);\n  FuturePut putFuture1 = node.getDataManager().put(locationKey, domainKey, contentKey, data, keypairOld);\n  putFuture1.awaitUninterruptibly();\n  Assert.assertTrue(putFuture1.isSuccess());\n  FuturePut changeFuture = node.getDataManager().changeProtectionKey(locationKey, domainKey, contentKey, data.getVersionKey(), data.getBasedOnKey(), data.getTimeToLive(), keypairOld, keypairNew, data.getHash());\n  changeFuture.awaitUninterruptibly();\n  Assert.assertTrue(changeFuture.isSuccess());\n  Data resData = node.getDataManager().get(locationKey, domainKey, contentKey, data.getVersionKey()).awaitUninterruptibly().getData();\n  Assert.assertTrue(resData.verify(keypairNew.getPublic(), new H2HSignatureFactory()));\n}"
    },
    {
        "id": 19,
        "original": "@Test\npublic void testOnCreateOrUpdateCommand() throws GenieException {\n  this.c = new Command(NAME, USER, CommandStatus.ACTIVE, EXECUTABLE, VERSION);\n  this.c.onCreateOrUpdateCommand();\n}",
        "prediction": "@Test\npublic void testOnCreateOrUpdateCommand() throws GeniePreconditionException {\n  this.c = new Command(NAME, USER, CommandStatus.ACTIVE, EXECUTABLE, VERSION);\n  this.c.onCreateOrUpdateCommand();\n}",
        "reference": "@Test\npublic void testOnCreateOrUpdateCommand() throws GeniePreconditionException {\n  this.c = new Command(NAME, USER, CommandStatus.ACTIVE, EXECUTABLE, VERSION);\n  this.c.onCreateOrUpdateCommand();\n}"
    },
    {
        "id": 20,
        "original": "@Test\npublic void testDeriveSecret() {\n  String macAlgorithm = HKDFAlgorithm.TLS_HKDF_SHA256.getMacAlgorithm().getJavaName();\n  byte[] prk = ArrayConverter.hexStringToByteArray(\"31168cad69862a80c6f6bfd42897d0fe23c406a12e652a8d3ae4217694f49844\");\n  byte[] hashValue = ArrayConverter.hexStringToByteArray(\"52c04472bdfe929772c98b91cf425f78f47659be9d4a7d68b9e29d162935e9b9\");\n  String labelIn = \"client handshake traffic secret\";\n  byte[] result = HKDFunction.deriveSecret(macAlgorithm, prk, labelIn, hashValue);\n  byte[] resultCorrect = ArrayConverter.hexStringToByteArray(\"6c6f274b1eae09b8bbd2039b7eb56147201a5e19288a3fd504fa52b1178a6e93\");\n  assertArrayEquals(result, resultCorrect);\n}",
        "prediction": "@Test\npublic void testDeriveSecret() {\n  String macAlgorithm = HKDFAlgorithm.TLS_HKDF_SHA256.getMacAlgorithm().getJavaName();\n  String hashAlgorithm = \"SHA-256\";\n  byte[] prk = ArrayConverter.hexStringToByteArray(\"31168cad69862a80c6f6bfd42897d0fe23c406a12e652a8d3ae4217694f49844\");\n  String labelIn = \"client handshake traffic secret\";\n  byte[] toHash = ArrayConverter.hexStringToByteArray(\"52c04472bdfe929772c98b91cf425f78f47659be9d4a7d68b9e29d162935e9b9\");\n  byte[] result = HKDFunction.deriveSecret(macAlgorithm, hashAlgorithm, prk, labelIn, toHash);\n  byte[] resultCorrect = ArrayConverter.hexStringToByteArray(\"6c6f274b1eae09b8bbd2039b7eb56147201a5e19288a3fd504fa52b1178a6e93\");\n  assertArrayEquals(result, resultCorrect);\n}",
        "reference": "@Test\npublic void testDeriveSecret() {\n  String macAlgorithm = HKDFAlgorithm.TLS_HKDF_SHA256.getMacAlgorithm().getJavaName();\n  String hashAlgorithm = DigestAlgorithm.SHA256.getJavaName();\n  byte[] prk = ArrayConverter.hexStringToByteArray(\"33AD0A1C607EC03B09E6CD9893680CE210ADF300AA1F2660E1B22E10F170F92A\");\n  byte[] toHash = ArrayConverter.hexStringToByteArray(\"\");\n  String labelIn = HKDFunction.DERIVED;\n  byte[] result = HKDFunction.deriveSecret(macAlgorithm, hashAlgorithm, prk, labelIn, toHash);\n  byte[] resultCorrect = ArrayConverter.hexStringToByteArray(\"6F2615A108C702C5678F54FC9DBAB69716C076189C48250CEBEAC3576C3611BA\");\n  assertArrayEquals(result, resultCorrect);\n}"
    },
    {
        "id": 21,
        "original": "@Test(groups = {\"tck\"})\npublic void test_next_serialization() throws IOException, ClassNotFoundException {\n  DateTimeAdjuster next = DateTimeAdjusters.next(SUNDAY);\n  assertTrue(next instanceof Serializable);\n  ByteArrayOutputStream baos = new ByteArrayOutputStream();\n  ObjectOutputStream oos = new ObjectOutputStream(baos);\n  oos.writeObject(next);\n  oos.close();\n  ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()));\n  assertEquals(ois.readObject(), next);\n}",
        "prediction": "@Test(groups = {\"tck\"})\npublic void test_next_serialization() throws IOException, ClassNotFoundException {\n  WithAdjuster next = DateTimeAdjusters.next(SUNDAY);\n  assertTrue(next instanceof Serializable);\n  ByteArrayOutputStream baos = new ByteArrayOutputStream();\n  ObjectOutputStream oos = new ObjectOutputStream(baos);\n  oos.writeObject(next);\n  oos.close();\n  ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()));\n  assertEquals(ois.readObject(), next);\n}",
        "reference": "@Test(groups = {\"tck\"})\npublic void test_next_serialization() throws IOException, ClassNotFoundException {\n  WithAdjuster next = DateTimeAdjusters.next(SUNDAY);\n  assertTrue(next instanceof Serializable);\n  ByteArrayOutputStream baos = new ByteArrayOutputStream();\n  ObjectOutputStream oos = new ObjectOutputStream(baos);\n  oos.writeObject(next);\n  oos.close();\n  ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()));\n  assertEquals(ois.readObject(), next);\n}"
    },
    {
        "id": 22,
        "original": "@Test(groups = {\"tck\"})\npublic void test_parseToEngine_String() throws Exception {\n  DateTimeFormatter test = new DateTimeFormatter(Locale.ENGLISH, DateTimeFormatSymbols.STANDARD, compPP);\n  CalendricalEngine result = test.parseToEngine(\"ONE30\");\n  assertEquals(result.getInput().size(), 1);\n  assertEquals(result.getInput().get(0), DAY_OF_MONTH.field(30L));\n}",
        "prediction": "@Test(groups = {\"tck\"})\npublic void test_parseToBuilder_String() throws Exception {\n  DateTimeFormatter test = new DateTimeFormatter(Locale.ENGLISH, DateTimeFormatSymbols.STANDARD, compPP);\n  DateTimeBuilder result = test.parseToBuilder(\"ONE30\");\n  assertEquals(result.getInput().size(), 1);\n  assertEquals(result.getInput().get(0), DAY_OF_MONTH.field(30L));\n}",
        "reference": "@Test(groups = {\"tck\"})\npublic void test_parseToEngine_String() throws Exception {\n  DateTimeFormatter test = new DateTimeFormatter(Locale.ENGLISH, DateTimeFormatSymbols.STANDARD, compPP);\n  CalendricalEngine result = test.parseToBuilder(\"ONE30\");\n  assertEquals(result.getInput().size(), 1);\n  assertEquals(result.getInput().get(0), DAY_OF_MONTH.field(30L));\n}"
    },
    {
        "id": 23,
        "original": "@Test(groups = {\"tck\"})\npublic void test_firstDayOfMonth_serialization() throws IOException, ClassNotFoundException {\n  DateTimeAdjuster firstDayOfMonth = DateTimeAdjusters.firstDayOfMonth();\n  assertTrue(firstDayOfMonth instanceof Serializable);\n  ByteArrayOutputStream baos = new ByteArrayOutputStream();\n  ObjectOutputStream oos = new ObjectOutputStream(baos);\n  oos.writeObject(firstDayOfMonth);\n  oos.close();\n  ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()));\n  assertSame(ois.readObject(), firstDayOfMonth);\n}",
        "prediction": "@Test(groups = {\"tck\"})\npublic void test_firstDayOfMonth_serialization() throws IOException, ClassNotFoundException {\n  WithAdjuster firstDayOfMonth = DateTimeAdjusters.firstDayOfMonth();\n  assertTrue(firstDayOfMonth instanceof Serializable);\n  ByteArrayOutputStream baos = new ByteArrayOutputStream();\n  ObjectOutputStream oos = new ObjectOutputStream(baos);\n  oos.writeObject(firstDayOfMonth);\n  oos.close();\n  ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()));\n  assertSame(ois.readObject(), firstDayOfMonth);\n}",
        "reference": "@Test(groups = {\"tck\"})\npublic void test_firstDayOfMonth_serialization() throws IOException, ClassNotFoundException {\n  WithAdjuster firstDayOfMonth = DateTimeAdjusters.firstDayOfMonth();\n  assertTrue(firstDayOfMonth instanceof Serializable);\n  ByteArrayOutputStream baos = new ByteArrayOutputStream();\n  ObjectOutputStream oos = new ObjectOutputStream(baos);\n  oos.writeObject(firstDayOfMonth);\n  oos.close();\n  ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()));\n  assertSame(ois.readObject(), firstDayOfMonth);\n}"
    },
    {
        "id": 24,
        "original": "@Test(expectedExceptions = NullPointerException.class, groups = {\"tck\"})\npublic void test_print_Calendrical_null() throws Exception {\n  DateTimeFormatter test = fmt.withLocale(Locale.ENGLISH).withSymbols(DateTimeFormatSymbols.STANDARD);\n  test.print((DateTimeAccessor)null);\n}",
        "prediction": "@Test(expectedExceptions = NullPointerException.class, groups = {\"tck\"})\npublic void test_print_Calendrical_null() throws Exception {\n  DateTimeFormatter test = fmt.withLocale(Locale.ENGLISH).withSymbols(DateTimeFormatSymbols.STANDARD);\n  test.print((TemporalAccessor)null);\n}",
        "reference": "@Test(expectedExceptions = NullPointerException.class, groups = {\"tck\"})\npublic void test_print_Calendrical_null() throws Exception {\n  DateTimeFormatter test = fmt.withLocale(Locale.ENGLISH).withSymbols(DateTimeFormatSymbols.STANDARD);\n  test.print((TemporalAccessor)null);\n}"
    },
    {
        "id": 25,
        "original": "@Test(groups = {\"tck\"})\npublic void test_print_Calendrical() throws Exception {\n  DateTimeFormatter test = fmt.withLocale(Locale.ENGLISH).withSymbols(DateTimeFormatSymbols.STANDARD);\n  String result = test.print(LocalDate.of(2008, 6, 30));\n  assertEquals(result, \"ONE30\");\n}",
        "prediction": "@Test(groups = {\"tck\"})\npublic void test_print_Calendrical() throws Exception {\n  DateTimeFormatter test = fmt.withLocale(Locale.ENGLISH).withSymbols(DateTimeFormatSymbols.STANDARD);\n  String result = test.print(LocalDate.of(2008, 6, 30));\n  assertEquals(result, \"ONE30\");\n}",
        "reference": "@Test(groups = {\"tck\"})\npublic void test_print_Calendrical() throws Exception {\n  DateTimeFormatter test = fmt.withLocale(Locale.ENGLISH).withSymbols(DateTimeFormatSymbols.STANDARD);\n  String result = test.print(LocalDate.of(2008, 6, 30));\n  assertEquals(result, \"ONE30\");\n}"
    },
    {
        "id": 26,
        "original": "@Test(groups = {\"tck\"})\npublic void test_parseBest_firstOption() throws Exception {\n  DateTimeFormatter test = DateTimeFormatters.pattern(\"yyyy-MM-dd[ZZZ]\");\n  DateTimeAccessor result = test.parseBest(\"2011-06-30+03:00\", OffsetDate.class, LocalDate.class);\n  assertEquals(result, OffsetDate.of(2011, 6, 30, ZoneOffset.ofHours(3)));\n}",
        "prediction": "@Test(groups = {\"tck\"})\npublic void test_parseBest_firstOption() throws Exception {\n  DateTimeFormatter test = DateTimeFormatters.pattern(\"yyyy-MM-dd[ZZZ]\");\n  TemporalAccessor result = test.parseBest(\"2011-06-30+03:00\", OffsetDate.class, LocalDate.class);\n  assertEquals(result, OffsetDate.of(2011, 6, 30, ZoneOffset.ofHours(3)));\n}",
        "reference": "@Test(groups = {\"tck\"})\npublic void test_parseBest_firstOption() throws Exception {\n  DateTimeFormatter test = DateTimeFormatters.pattern(\"yyyy-MM-dd[ZZZ]\");\n  TemporalAccessor result = test.parseBest(\"2011-06-30+03:00\", OffsetDate.class, LocalDate.class);\n  assertEquals(result, OffsetDate.of(2011, 6, 30, ZoneOffset.ofHours(3)));\n}"
    },
    {
        "id": 27,
        "original": "@Test(groups = {\"tck\"})\npublic void test_matchesCalendrical_ymd_date() {\n  LocalDate date = LocalDate.of(2008, 6, 30);\n  assertEquals(DateTimeField.of(YEAR, 2008).matchesCalendrical(date), true);\n  assertEquals(DateTimeField.of(YEAR, 2006).matchesCalendrical(date), false);\n  assertEquals(DateTimeField.of(MONTH_OF_YEAR, 6).matchesCalendrical(date), true);\n  assertEquals(DateTimeField.of(MONTH_OF_YEAR, 7).matchesCalendrical(date), false);\n  assertEquals(DateTimeField.of(MONTH_OF_YEAR, -1).matchesCalendrical(date), false);\n  assertEquals(DateTimeField.of(DAY_OF_MONTH, 30).matchesCalendrical(date), true);\n  assertEquals(DateTimeField.of(DAY_OF_MONTH, 12).matchesCalendrical(date), false);\n  assertEquals(DateTimeField.of(DAY_OF_WEEK, 1).matchesCalendrical(date), true);\n  assertEquals(DateTimeField.of(DAY_OF_WEEK, 2).matchesCalendrical(date), false);\n  assertEquals(DateTimeField.of(HOUR_OF_DAY, 2).matchesCalendrical(date), false);\n}",
        "prediction": "@Test(groups = {\"tck\"})\npublic void test_matchesCalendrical_ymd_date() {\n  LocalDate date = LocalDate.of(2008, 6, 30);\n  assertEquals(DateTimeField.of(YEAR, 2008).matches(date), true);\n  assertEquals(DateTimeField.of(YEAR, 2006).matches(date), false);\n  assertEquals(DateTimeField.of(MONTH_OF_YEAR, 6).matches(date), true);\n  assertEquals(DateTimeField.of(MONTH_OF_YEAR, 7).matches(date), false);\n  assertEquals(DateTimeField.of(MONTH_OF_YEAR, -1).matches(date), false);\n  assertEquals(DateTimeField.of(DAY_OF_MONTH, 30).matches(date), true);\n  assertEquals(DateTimeField.of(DAY_OF_MONTH, 12).matches(date), false);\n  assertEquals(DateTimeField.of(DAY_OF_WEEK, 1).matches(date), true);\n  assertEquals(DateTimeField.of(DAY_OF_WEEK, 2).matches(date), false);\n  assertEquals(DateTimeField.of(HOUR_OF_DAY, 2).matches(date), false);\n}",
        "reference": "@Test(groups = {\"tck\"})\npublic void test_matches() {\n  LocalDate date = LocalDate.of(2008, 6, 30);\n  assertEquals(DateTimeField.of(YEAR, 2008).matches(DateTimeField.of(YEAR, 2008)), true);\n  assertEquals(DateTimeField.of(YEAR, 2008).matches(DateTimeField.of(YEAR, 2012)), false);\n  assertEquals(DateTimeField.of(YEAR, 2008).matches(DateTimeField.of(MONTH_OF_YEAR, 2008)), false);\n  assertEquals(DateTimeField.of(YEAR, 2008).matches(date), true);\n  assertEquals(DateTimeField.of(YEAR, 2012).matches(date), false);\n  assertEquals(DateTimeField.of(MONTH_OF_YEAR, 6).matches(date), true);\n  assertEquals(DateTimeField.of(MONTH_OF_YEAR, 7).matches(date), false);\n  assertEquals(DateTimeField.of(MONTH_OF_YEAR, -1).matches(date), false);\n  assertEquals(DateTimeField.of(DAY_OF_MONTH, 30).matches(date), true);\n  assertEquals(DateTimeField.of(DAY_OF_MONTH, 12).matches(date), false);\n  assertEquals(DateTimeField.of(DAY_OF_WEEK, 1).matches(date), true);\n  assertEquals(DateTimeField.of(DAY_OF_WEEK, 2).matches(date), false);\n  assertEquals(DateTimeField.of(HOUR_OF_DAY, 2).matches(date), false);\n}"
    },
    {
        "id": 28,
        "original": "@Test(expectedExceptions = NullPointerException.class)\npublic void test_appendValueReduced_null() throws Exception {\n  builder.appendValueReduced(null, 2, 2000);\n}",
        "prediction": "@Test(expectedExceptions = NullPointerException.class)\npublic void test_appendValueReduced_null() throws Exception {\n  builder.appendValueReduced(null, 2, 2, 2000);\n}",
        "reference": "@Test(expectedExceptions = NullPointerException.class)\npublic void test_appendValueReduced_null() throws Exception {\n  builder.appendValueReduced(null, 2, 2, 2000);\n}"
    },
    {
        "id": 29,
        "original": "@Test\npublic void test_appendValueReduced() throws Exception {\n  builder.appendValueReduced(YEAR, 2, 2000);\n  DateTimeFormatter f = builder.toFormatter();\n  assertEquals(f.toString(), \"ReducedValue(Year,2,2000)\");\n  TemporalAccessor cal = f.parseUnresolved(\"12\", new ParsePosition(0));\n  assertEquals(cal.get(YEAR), 2012);\n}",
        "prediction": "@Test\npublic void test_appendValueReduced() throws Exception {\n  builder.appendValueReduced(YEAR, 2, 2, 2000);\n  DateTimeFormatter f = builder.toFormatter();\n  assertEquals(f.toString(), \"ReducedValue(Year,2,2,2000)\");\n  TemporalAccessor cal = f.parseUnresolved(\"12\", new ParsePosition(0));\n  assertEquals(cal.get(YEAR), 2012);\n}",
        "reference": "@Test\npublic void test_appendValueReduced() throws Exception {\n  builder.appendValueReduced(YEAR, 2, 2, 2000);\n  DateTimeFormatter f = builder.toFormatter();\n  assertEquals(f.toString(), \"ReducedValue(Year,2,2000)\");\n  TemporalAccessor cal = f.parseUnresolved(\"12\", new ParsePosition(0));\n  assertEquals(cal.get(YEAR), 2012);\n}"
    },
    {
        "id": 30,
        "original": "@Test(groups = {\"tck\"})\npublic void test_getAvailableGroupIds() {\n  Set<String> groups = ZoneRulesProvider.getAvailableGroupIds();\n  assertEquals(groups.contains(\"TZDB\"), true);\n  groups.clear();\n  assertEquals(groups.size(), 0);\n  Set<String> groups2 = ZoneRulesProvider.getAvailableGroupIds();\n  assertEquals(groups2.contains(\"TZDB\"), true);\n}",
        "prediction": "@Test(groups = {\"tck\"})\npublic void test_getAvailableZoneIds() {\n  Set<String> zones = ZoneRulesProvider.getAvailableZoneIds();\n  assertEquals(zones.contains(\"TZDB\"), true);\n  zones.clear();\n  assertEquals(zones.size(), 0);\n  Set<String> zones2 = ZoneRulesProvider.getAvailableZoneIds();\n  assertEquals(zones2.contains(\"TZDB\"), true);\n}",
        "reference": "@Test(groups = {\"tck\"})\npublic void test_getAvailableGroupIds() {\n  Set<String> zoneIds = ZoneRulesProvider.getAvailableZoneIds();\n  assertEquals(zoneIds.contains(\"Europe/London\"), true);\n  zoneIds.clear();\n  assertEquals(zoneIds.size(), 0);\n  Set<String> zoneIds2 = ZoneRulesProvider.getAvailableZoneIds();\n  assertEquals(zoneIds2.contains(\"Europe/London\"), true);\n}"
    },
    {
        "id": 31,
        "original": "@Test\npublic void testIsSPNegoMessage() {\n  final SimpleHttpRequest request = new SimpleHttpRequest();\n  final AuthorizationHeader header = new AuthorizationHeader(request);\n  Assert.assertFalse(header.isSPNegoMessage());\n  request.addHeader(\"Authorization\", \"\");\n  Assert.assertFalse(header.isSPNegoMessage());\n  request.addHeader(\"Authorization\", \"Negotiate YHYGBisGAQUFAqBsMGqgMDAuBgorBgEEAYI3AgIKBgkqhkiC9xIBAgIGCSqGSIb3EgECAgYKKwYBBAGCNwICHqI2BDROVExNU1NQAAEAAACXsgjiAwADADEAAAAJAAkAKAAAAAYBsR0AAAAPR0xZQ0VSSU5FU0FE\");\n  Assert.assertTrue(header.isSPNegoMessage());\n}",
        "prediction": "@Test\npublic void testIsSPNegTokenInitMessage() {\n  final SimpleHttpRequest request = new SimpleHttpRequest();\n  final AuthorizationHeader header = new AuthorizationHeader(request);\n  Assert.assertFalse(header.isSPNegTokenInitMessage());\n  request.addHeader(\"Authorization\", \"\");\n  Assert.assertFalse(header.isSPNegTokenInitMessage());\n  request.addHeader(\"Authorization\", \"Negotiate YHYGBisGAQUFAqBsMGqgMDAuBgorBgEEAYI3AgIKBgkqhkiC9xIBAgIGCSqGSIb3EgECAgYKKwYBBAGCNwICHqI2BDROVExNU1NQAAEAAACXsgjiAwADADEAAAAJAAkAKAAAAAYBsR0AAAAPR0xZQ0VSSU5FU0FE\");\n  Assert.assertTrue(header.isSPNegTokenInitMessage());\n}",
        "reference": "@Test\npublic void testIsSPNegTokenInitMessage() {\n  final SimpleHttpRequest request = new SimpleHttpRequest();\n  final AuthorizationHeader header = new AuthorizationHeader(request);\n  Assert.assertFalse(header.isSPNegTokenInitMessage());\n  request.addHeader(\"Authorization\", \"\");\n  Assert.assertFalse(header.isSPNegTokenInitMessage());\n  request.addHeader(\"Authorization\", \"Negotiate YHYGBisGAQUFAqBsMGqgMDAuBgorBgEEAYI3AgIKBgkqhkiC9xIBAgIGCSqGSIb3EgECAgYKKwYBBAGCNwICHqI2BDROVExNU1NQAAEAAACXsgjiAwADADEAAAAJAAkAKAAAAAYBsR0AAAAPR0xZQ0VSSU5FU0FE\");\n  Assert.assertTrue(header.isSPNegTokenInitMessage());\n}"
    },
    {
        "id": 32,
        "original": "@Test\npublic void testFindByClusterStackAndVersion() {\n  Assert.assertEquals(3, hostVersionDAO.findByClusterStackAndVersion(\"test_cluster1\", \"HDP-2.2\", \"2.2.0.0-995\").size());\n  Assert.assertEquals(3, hostVersionDAO.findAll().size());\n  addMoreVersions();\n  Assert.assertEquals(3, hostVersionDAO.findByClusterStackAndVersion(\"test_cluster1\", \"HDP-2.2\", \"2.2.0.1-996\").size());\n  Assert.assertEquals(3, hostVersionDAO.findByClusterStackAndVersion(\"test_cluster1\", \"HDP-2.2\", \"2.2.1.0-500\").size());\n  Assert.assertEquals(9, hostVersionDAO.findAll().size());\n}",
        "prediction": "@Test\npublic void testFindByClusterStackAndVersion() {\n  StackId stackId1 = new StackId(\"HDP-2.2\");\n  Assert.assertEquals(3, hostVersionDAO.findByClusterStackAndVersion(\"test_cluster1\", stackId1, \"2.2.0.0-995\").size());\n  Assert.assertEquals(3, hostVersionDAO.findAll().size());\n  addMoreVersions();\n  StackId stackId2 = new StackId(\"HDP-2.2\");\n  Assert.assertEquals(3, hostVersionDAO.findByClusterStackAndVersion(\"test_cluster1\", stackId2, \"2.2.0.1-996\").size());\n  StackId stackId3 = new StackId(\"HDP-2.2\");\n  Assert.assertEquals(3, hostVersionDAO.findByClusterStackAndVersion(\"test_cluster1\", stackId3, \"2.2.1.0-500\").size());\n  Assert.assertEquals(9, hostVersionDAO.findAll().size());\n}",
        "reference": "@Test\npublic void testFindByClusterStackAndVersion() {\n  Assert.assertEquals(3, hostVersionDAO.findByClusterStackAndVersion(\"test_cluster1\", HDP_22_STACK, \"2.2.0.0-995\").size());\n  Assert.assertEquals(3, hostVersionDAO.findAll().size());\n  addMoreVersions();\n  Assert.assertEquals(3, hostVersionDAO.findByClusterStackAndVersion(\"test_cluster1\", HDP_22_STACK, \"2.2.0.1-996\").size());\n  Assert.assertEquals(3, hostVersionDAO.findByClusterStackAndVersion(\"test_cluster1\", HDP_22_STACK, \"2.2.1.0-500\").size());\n  Assert.assertEquals(9, hostVersionDAO.findAll().size());\n}"
    },
    {
        "id": 33,
        "original": "@Test\npublic void testFindByStack() {\n  createSingleRecord();\n  Assert.assertEquals(0, repositoryVersionDAO.findByStack(\"non existing\").size());\n  Assert.assertEquals(1, repositoryVersionDAO.findByStack(\"stack\").size());\n}",
        "prediction": "@Test\npublic void testFindByStack() {\n  createSingleRecord();\n  StackId nonExistingStackId = new StackId(\"non existing\", \"1.0\");\n  StackId existingStackId = new StackId(\"stack\", \"1.0\");\n  Assert.assertEquals(0, repositoryVersionDAO.findByStack(nonExistingStackId).size());\n  Assert.assertEquals(1, repositoryVersionDAO.findByStack(existingStackId).size());\n}",
        "reference": "@Test\npublic void testFindByStack() {\n  createSingleRecord();\n  Assert.assertEquals(0, repositoryVersionDAO.findByStack(BAD_STACK).size());\n  Assert.assertEquals(1, repositoryVersionDAO.findByStack(HDP_206).size());\n}"
    },
    {
        "id": 34,
        "original": "@Test\npublic void testHexDigitToBoolArray() {\n  assertBoolArrayEquals(new boolean[] {false, false, false, false}, Conversion.hexDigitToBoolArray('0'));\n  assertBoolArrayEquals(new boolean[] {true, false, false, false}, Conversion.hexDigitToBoolArray('1'));\n  assertBoolArrayEquals(new boolean[] {false, true, false, false}, Conversion.hexDigitToBoolArray('2'));\n  assertBoolArrayEquals(new boolean[] {true, true, false, false}, Conversion.hexDigitToBoolArray('3'));\n  assertBoolArrayEquals(new boolean[] {false, false, true, false}, Conversion.hexDigitToBoolArray('4'));\n  assertBoolArrayEquals(new boolean[] {true, false, true, false}, Conversion.hexDigitToBoolArray('5'));\n  assertBoolArrayEquals(new boolean[] {false, true, true, false}, Conversion.hexDigitToBoolArray('6'));\n  assertBoolArrayEquals(new boolean[] {true, true, true, false}, Conversion.hexDigitToBoolArray('7'));\n  assertBoolArrayEquals(new boolean[] {false, false, false, true}, Conversion.hexDigitToBoolArray('8'));\n  assertBoolArrayEquals(new boolean[] {true, false, false, true}, Conversion.hexDigitToBoolArray('9'));\n  assertBoolArrayEquals(new boolean[] {false, true, false, true}, Conversion.hexDigitToBoolArray('A'));\n  assertBoolArrayEquals(new boolean[] {false, true, false, true}, Conversion.hexDigitToBoolArray('a'));\n  assertBoolArrayEquals(new boolean[] {true, true, false, true}, Conversion.hexDigitToBoolArray('B'));\n  assertBoolArrayEquals(new boolean[] {true, true, false, true}, Conversion.hexDigitToBoolArray('b'));\n  assertBoolArrayEquals(new boolean[] {false, false, true, true}, Conversion.hexDigitToBoolArray('C'));\n  assertBoolArrayEquals(new boolean[] {false, false, true, true}, Conversion.hexDigitToBoolArray('c'));\n  assertBoolArrayEquals(new boolean[] {true, false, true, true}, Conversion.hexDigitToBoolArray('D'));\n  assertBoolArrayEquals(new boolean[] {true, false, true, true}, Conversion.hexDigitToBoolArray('d'));\n  assertBoolArrayEquals(new boolean[] {false, true, true, true}, Conversion.hexDigitToBoolArray('E'));\n  assertBoolArrayEquals(new boolean[] {false, true, true, true}, Conversion.hexDigitToBoolArray('e'));\n  assertBoolArrayEquals(new boolean[] {true, true, true, true}, Conversion.hexDigitToBoolArray('F'));\n  assertBoolArrayEquals(new boolean[] {true, true, true, true}, Conversion.hexDigitToBoolArray('f'));\n  try {\n    Conversion.hexDigitToBoolArray('G');\n    fail(\"Thrown \" + IllegalArgumentException.class.getName() + \" expected\");\n  } catch (final IllegalArgumentException e) {}\n}",
        "prediction": "@Test\npublic void testHexDigitToBinary() {\n  assertBoolArrayEquals(new boolean[] {false, false, false, false}, Conversion.hexDigitToBinary('0'));\n  assertBoolArrayEquals(new boolean[] {true, false, false, false}, Conversion.hexDigitToBinary('1'));\n  assertBoolArrayEquals(new boolean[] {false, true, false, false}, Conversion.hexDigitToBinary('2'));\n  assertBoolArrayEquals(new boolean[] {true, true, false, false}, Conversion.hexDigitToBinary('3'));\n  assertBoolArrayEquals(new boolean[] {false, false, true, false}, Conversion.hexDigitToBinary('4'));\n  assertBoolArrayEquals(new boolean[] {true, false, true, false}, Conversion.hexDigitToBinary('5'));\n  assertBoolArrayEquals(new boolean[] {false, true, true, false}, Conversion.hexDigitToBinary('6'));\n  assertBoolArrayEquals(new boolean[] {true, true, true, false}, Conversion.hexDigitToBinary('7'));\n  assertBoolArrayEquals(new boolean[] {false, false, false, true}, Conversion.hexDigitToBinary('8'));\n  assertBoolArrayEquals(new boolean[] {true, false, false, true}, Conversion.hexDigitToBinary('9'));\n  assertBoolArrayEquals(new boolean[] {false, true, false, true}, Conversion.hexDigitToBinary('A'));\n  assertBoolArrayEquals(new boolean[] {false, true, false, true}, Conversion.hexDigitToBinary('a'));\n  assertBoolArrayEquals(new boolean[] {true, true, false, true}, Conversion.hexDigitToBinary('B'));\n  assertBoolArrayEquals(new boolean[] {true, true, false, true}, Conversion.hexDigitToBinary('b'));\n  assertBoolArrayEquals(new boolean[] {false, false, true, true}, Conversion.hexDigitToBinary('C'));\n  assertBoolArrayEquals(new boolean[] {false, false, true, true}, Conversion.hexDigitToBinary('c'));\n  assertBoolArrayEquals(new boolean[] {true, false, true, true}, Conversion.hexDigitToBinary('D'));\n  assertBoolArrayEquals(new boolean[] {true, false, true, true}, Conversion.hexDigitToBinary('d'));\n  assertBoolArrayEquals(new boolean[] {false, true, true, true}, Conversion.hexDigitToBinary('E'));\n  assertBoolArrayEquals(new boolean[] {false, true, true, true}, Conversion.hexDigitToBinary('e'));\n  assertBoolArrayEquals(new boolean[] {true, true, true, true}, Conversion.hexDigitToBinary('F'));\n  assertBoolArrayEquals(new boolean[] {true, true, true, true}, Conversion.hexDigitToBinary('f'));\n  try {\n    Conversion.hexDigitToBinary('G');\n    fail(\"Thrown \" + IllegalArgumentException.class.getName() + \" expected\");\n  } catch (final IllegalArgumentException e) {}\n}",
        "reference": "@Test\npublic void testHexDigitToBinary() {\n  assertBinaryEquals(new boolean[] {false, false, false, false}, Conversion.hexDigitToBinary('0'));\n  assertBinaryEquals(new boolean[] {true, false, false, false}, Conversion.hexDigitToBinary('1'));\n  assertBinaryEquals(new boolean[] {false, true, false, false}, Conversion.hexDigitToBinary('2'));\n  assertBinaryEquals(new boolean[] {true, true, false, false}, Conversion.hexDigitToBinary('3'));\n  assertBinaryEquals(new boolean[] {false, false, true, false}, Conversion.hexDigitToBinary('4'));\n  assertBinaryEquals(new boolean[] {true, false, true, false}, Conversion.hexDigitToBinary('5'));\n  assertBinaryEquals(new boolean[] {false, true, true, false}, Conversion.hexDigitToBinary('6'));\n  assertBinaryEquals(new boolean[] {true, true, true, false}, Conversion.hexDigitToBinary('7'));\n  assertBinaryEquals(new boolean[] {false, false, false, true}, Conversion.hexDigitToBinary('8'));\n  assertBinaryEquals(new boolean[] {true, false, false, true}, Conversion.hexDigitToBinary('9'));\n  assertBinaryEquals(new boolean[] {false, true, false, true}, Conversion.hexDigitToBinary('A'));\n  assertBinaryEquals(new boolean[] {false, true, false, true}, Conversion.hexDigitToBinary('a'));\n  assertBinaryEquals(new boolean[] {true, true, false, true}, Conversion.hexDigitToBinary('B'));\n  assertBinaryEquals(new boolean[] {true, true, false, true}, Conversion.hexDigitToBinary('b'));\n  assertBinaryEquals(new boolean[] {false, false, true, true}, Conversion.hexDigitToBinary('C'));\n  assertBinaryEquals(new boolean[] {false, false, true, true}, Conversion.hexDigitToBinary('c'));\n  assertBinaryEquals(new boolean[] {true, false, true, true}, Conversion.hexDigitToBinary('D'));\n  assertBinaryEquals(new boolean[] {true, false, true, true}, Conversion.hexDigitToBinary('d'));\n  assertBinaryEquals(new boolean[] {false, true, true, true}, Conversion.hexDigitToBinary('E'));\n  assertBinaryEquals(new boolean[] {false, true, true, true}, Conversion.hexDigitToBinary('e'));\n  assertBinaryEquals(new boolean[] {true, true, true, true}, Conversion.hexDigitToBinary('F'));\n  assertBinaryEquals(new boolean[] {true, true, true, true}, Conversion.hexDigitToBinary('f'));\n  try {\n    Conversion.hexDigitToBinary('G');\n    fail(\"Thrown \" + IllegalArgumentException.class.getName() + \" expected\");\n  } catch (final IllegalArgumentException e) {}\n}"
    },
    {
        "id": 35,
        "original": "@Test\npublic void testCreateSSLEngineFactory() throws Exception {\n  Configuration serverConfig = new Configuration();\n  serverConfig.setBoolean(SecurityOptions.SSL_ENABLED, true);\n  serverConfig.setString(SecurityOptions.SSL_KEYSTORE, \"src/test/resources/local127.keystore\");\n  serverConfig.setString(SecurityOptions.SSL_KEYSTORE_PASSWORD, \"password\");\n  serverConfig.setString(SecurityOptions.SSL_KEY_PASSWORD, \"password\");\n  serverConfig.setString(SecurityOptions.SSL_PROTOCOL, \"TLSv1\");\n  serverConfig.setString(SecurityOptions.SSL_ALGORITHMS, \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA,TLS_DHE_RSA_WITH_AES_128_CBC_SHA256\");\n  final SSLEngineFactory serverSSLEngineFactory = SSLUtils.createServerSSLEngineFactory(serverConfig);\n  final SSLEngine sslEngine = serverSSLEngineFactory.createSSLEngine();\n  assertThat(Arrays.asList(sslEngine.getEnabledProtocols()), contains(\"TLSv1\"));\n  assertThat(Arrays.asList(sslEngine.getEnabledCipherSuites()), containsInAnyOrder(\"TLS_DHE_RSA_WITH_AES_128_CBC_SHA\", \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA256\"));\n}",
        "prediction": "@Test\npublic void testCreateSSLEngineFactory() throws Exception {\n  Configuration serverConfig = new Configuration();\n  serverConfig.setBoolean(SecurityOptions.SSL_ENABLED, true);\n  serverConfig.setString(SecurityOptions.SSL_KEYSTORE, \"src/test/resources/local127.keystore\");\n  serverConfig.setString(SecurityOptions.SSL_KEYSTORE_PASSWORD, \"password\");\n  serverConfig.setString(SecurityOptions.SSL_KEY_PASSWORD, \"password\");\n  serverConfig.setString(SecurityOptions.SSL_PROTOCOL, \"TLSv1\");\n  serverConfig.setString(SecurityOptions.SSL_ALGORITHMS, \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA,TLS_DHE_RSA_WITH_AES_128_CBC_SHA256\");\n  final SSLEngineFactory serverSSLEngineFactory = SSLUtils.createInternalServerSSLEngineFactory(serverConfig);\n  final SSLEngine sslEngine = serverSSLEngineFactory.createSSLEngine();\n  assertThat(Arrays.asList(sslEngine.getEnabledProtocols()), contains(\"TLSv1\"));\n  assertThat(Arrays.asList(sslEngine.getEnabledCipherSuites()), containsInAnyOrder(\"TLS_DHE_RSA_WITH_AES_128_CBC_SHA\", \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA256\"));\n}",
        "reference": "@Test\npublic void testCreateSSLEngineFactory() throws Exception {\n  Configuration serverConfig = createInternalSslConfigWithKeyAndTrustStores();\n  serverConfig.setString(SecurityOptions.SSL_PROTOCOL, \"TLSv1\");\n  serverConfig.setString(SecurityOptions.SSL_ALGORITHMS, \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA,TLS_DHE_RSA_WITH_AES_128_CBC_SHA256\");\n  final SSLEngineFactory serverSSLEngineFactory = SSLUtils.createInternalServerSSLEngineFactory(serverConfig);\n  final SSLEngine sslEngine = serverSSLEngineFactory.createSSLEngine();\n  assertEquals(1, sslEngine.getEnabledProtocols().length);\n  assertEquals(\"TLSv1\", sslEngine.getEnabledProtocols()[0]);\n  assertEquals(2, sslEngine.getEnabledCipherSuites().length);\n  assertThat(sslEngine.getEnabledCipherSuites(), arrayContainingInAnyOrder(\"TLS_DHE_RSA_WITH_AES_128_CBC_SHA\", \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA256\"));\n}"
    },
    {
        "id": 36,
        "original": "@Test\npublic void testGetSnapshottingSettings() throws Exception {\n  ExecutionJobVertex jobVertex = mock(ExecutionJobVertex.class);\n  when(jobVertex.getJobVertexId()).thenReturn(new JobVertexID());\n  when(jobVertex.getParallelism()).thenReturn(1);\n  JobSnapshottingSettings snapshottingSettings = new JobSnapshottingSettings(Collections.singletonList(new JobVertexID()), Collections.singletonList(new JobVertexID()), Collections.singletonList(new JobVertexID()), 181238123L, 19191992L, 191929L, 123, ExternalizedCheckpointSettings.none(), null, false);\n  CheckpointStatsTracker tracker = new CheckpointStatsTracker(0, Collections.singletonList(jobVertex), snapshottingSettings, new UnregisteredMetricsGroup());\n  assertEquals(snapshottingSettings, tracker.getSnapshottingSettings());\n}",
        "prediction": "@Test\npublic void testGetSnapshottingSettings() throws Exception {\n  ExecutionJobVertex jobVertex = mock(ExecutionJobVertex.class);\n  when(jobVertex.getJobVertexId()).thenReturn(new JobVertexID());\n  when(jobVertex.getParallelism()).thenReturn(1);\n  JobCheckpointingSettings snapshottingSettings = new JobCheckpointingSettings(Collections.singletonList(new JobVertexID()), Collections.singletonList(new JobVertexID()), Collections.singletonList(new JobVertexID()), 181238123L, 19191992L, 191929L, 123, ExternalizedCheckpointSettings.none(), null, false);\n  CheckpointStatsTracker tracker = new CheckpointStatsTracker(0, Collections.singletonList(jobVertex), snapshottingSettings, new UnregisteredMetricsGroup());\n  assertEquals(snapshottingSettings, tracker.getSnapshottingSettings());\n}",
        "reference": "@Test\npublic void testGetSnapshottingSettings() throws Exception {\n  ExecutionJobVertex jobVertex = mock(ExecutionJobVertex.class);\n  when(jobVertex.getJobVertexId()).thenReturn(new JobVertexID());\n  when(jobVertex.getParallelism()).thenReturn(1);\n  JobCheckpointingSettings snapshottingSettings = new JobCheckpointingSettings(Collections.singletonList(new JobVertexID()), Collections.singletonList(new JobVertexID()), Collections.singletonList(new JobVertexID()), 181238123L, 19191992L, 191929L, 123, ExternalizedCheckpointSettings.none(), null, false);\n  CheckpointStatsTracker tracker = new CheckpointStatsTracker(0, Collections.singletonList(jobVertex), snapshottingSettings, new UnregisteredMetricsGroup());\n  assertEquals(snapshottingSettings, tracker.getSnapshottingSettings());\n}"
    },
    {
        "id": 37,
        "original": "@Test\npublic void testGetInputs() {\n  final Operator input1 = new OpImpl(0);\n  final Operator input2 = new OpImpl(1);\n  final Operator fixture = new OpImpl(0).withInputs(input1, input2);\n  final List<Operator.Output> result = fixture.getInputs();\n  assertNotNull(result);\n  assertEquals(2, result.size());\n  assertEquals(Arrays.asList(input1.getOutput(0), input2.getOutput(0)), result);\n}",
        "prediction": "@Test\npublic void testGetInputs() {\n  final Operator input1 = new OpImpl(0);\n  final Operator input2 = new OpImpl(1);\n  final Operator fixture = new OpImpl(0).withInputs(input1, input2);\n  final List<Operator<?>.Output> result = fixture.getInputs();\n  assertNotNull(result);\n  assertEquals(2, result.size());\n  assertEquals(Arrays.asList(input1.getOutput(0), input2.getOutput(0)), result);\n}",
        "reference": "@Test\npublic void testGetInputs() {\n  final Operator<?> input1 = new OpImpl(0);\n  final Operator<?> input2 = new OpImpl(1);\n  final Operator<?> fixture = new OpImpl(0).withInputs(input1, input2);\n  final List<Operator<?>.Output> result = fixture.getInputs();\n  assertNotNull(result);\n  assertEquals(2, result.size());\n  assertEquals(Arrays.asList(input1.getOutput(0), input2.getOutput(0)), result);\n}"
    },
    {
        "id": 38,
        "original": "@Test\npublic void testClearAndPut() {\n  for (int i = 0; i < CAPACITY; ++i) {\n    Assert.assertTrue(mailbox.tryPutMail(() -> {}));\n  }\n  mailbox.clearAndPut(POISON_LETTER);\n  Assert.assertTrue(mailbox.hasMail());\n  Assert.assertEquals(POISON_LETTER, mailbox.tryTakeMail().get());\n  Assert.assertFalse(mailbox.hasMail());\n}",
        "prediction": "@Test\npublic void testClearAndPut() throws MailboxStateException {\n  for (int i = 0; i < CAPACITY; ++i) {\n    Assert.assertTrue(mailbox.tryPutMail(() -> {}));\n  }\n  List<Runnable> droppedLetters = mailbox.clearAndPut(POISON_LETTER);\n  Assert.assertTrue(mailbox.hasMail());\n  Assert.assertEquals(POISON_LETTER, mailbox.tryTakeMail().get());\n  Assert.assertFalse(mailbox.hasMail());\n  Assert.assertEquals(CAPACITY, droppedLetters.size());\n}",
        "reference": "@Test\npublic void testClearAndPut() throws Exception {\n  Runnable letterInstance = () -> {};\n  for (int i = 0; i < CAPACITY; ++i) {\n    Assert.assertTrue(mailbox.tryPutMail(letterInstance));\n  }\n  List<Runnable> droppedLetters = mailbox.clearAndPut(POISON_LETTER);\n  Assert.assertTrue(mailbox.hasMail());\n  Assert.assertEquals(POISON_LETTER, mailbox.tryTakeMail().get());\n  Assert.assertFalse(mailbox.hasMail());\n  Assert.assertEquals(CAPACITY, droppedLetters.size());\n}"
    },
    {
        "id": 39,
        "original": "@Test\npublic void testSleep() throws Exception {\n  for (int i = 0; i < NUM_ATTEMPTS; i++) {\n    long expectedSleepTimeMs = new Random().nextInt(100);\n    long start = System.currentTimeMillis();\n    SysUtils.sleep(expectedSleepTimeMs);\n    long end = System.currentTimeMillis();\n    Assert.assertTrue((end - start) >= expectedSleepTimeMs);\n  }\n}",
        "prediction": "@Test\npublic void testSleep() throws Exception {\n  for (int i = 0; i < NUM_ATTEMPTS; i++) {\n    long expectedSleepTimeMs = new Random().nextInt(100);\n    Duration duration = Duration.ofMillis(expectedSleepTimeMs);\n    long start = System.currentTimeMillis();\n    SysUtils.sleep(duration);\n    long end = System.currentTimeMillis();\n    Assert.assertTrue((end - start) >= expectedSleepTimeMs);\n  }\n}",
        "reference": "@Test\npublic void testSleep() throws Exception {\n  for (int i = 0; i < NUM_ATTEMPTS; i++) {\n    Duration expectedSleepTime = Duration.ofMillis(new Random().nextInt(100));\n    long start = System.currentTimeMillis();\n    SysUtils.sleep(expectedSleepTime);\n    long end = System.currentTimeMillis();\n    Assert.assertTrue((end - start) >= expectedSleepTime.toMillis());\n  }\n}"
    },
    {
        "id": 40,
        "original": "@Test\npublic void testGetContainers() throws ResourceExceededException {\n  int paddingPercentage = 10;\n  Map<Integer, List<InstanceId>> packing = new HashMap<>();\n  packing.put(7, Arrays.asList(new InstanceId(\"spout\", 1, 0), new InstanceId(\"bolt\", 2, 0)));\n  packing.put(3, Arrays.asList(new InstanceId(\"spout\", 3, 0), new InstanceId(\"bolt\", 4, 0)));\n  PackingPlan packingPlan = generatePacking(packing);\n  Map<Integer, Container> containers = PackingPlanBuilder.getContainers(packingPlan, paddingPercentage, new HashMap<String, TreeSet<Integer>>(), new TreeSet<Integer>());\n  assertEquals(packing.size(), containers.size());\n  for (Integer containerId : packing.keySet()) {\n    Container foundContainer = containers.get(containerId);\n    assertEquals(paddingPercentage, foundContainer.getPaddingPercentage());\n    assertEquals(packingPlan.getMaxContainerResources(), foundContainer.getCapacity());\n    assertEquals(2, foundContainer.getInstances().size());\n  }\n}",
        "prediction": "@Test\npublic void testGetContainers() throws ResourceExceededException {\n  Map<Integer, List<InstanceId>> packing = new HashMap<>();\n  packing.put(7, Arrays.asList(new InstanceId(\"spout\", 1, 0), new InstanceId(\"bolt\", 2, 0)));\n  packing.put(3, Arrays.asList(new InstanceId(\"spout\", 3, 0), new InstanceId(\"bolt\", 4, 0)));\n  PackingPlan packingPlan = generatePacking(packing);\n  Resource maxContainerResource = packingPlan.getMaxContainerResources();\n  Resource padding = new Resource(10, 10, 10);\n  Map<Integer, Container> containers = PackingPlanBuilder.getContainers(packingPlan, maxContainerResource, padding, new HashMap<String, TreeSet<Integer>>(), new TreeSet<Integer>());\n  assertEquals(packing.size(), containers.size());\n  for (Integer containerId : packing.keySet()) {\n    Container foundContainer = containers.get(containerId);\n    assertEquals(padding, foundContainer.getPadding());\n    assertEquals(maxContainerResource, foundContainer.getCapacity());\n    assertEquals(2, foundContainer.getInstances().size());\n  }\n}",
        "reference": "@Test\npublic void testGetContainers() {\n  Resource padding = new Resource(1.0, ByteAmount.fromGigabytes(1), ByteAmount.fromGigabytes(1));\n  Map<Integer, List<InstanceId>> packing = new HashMap<>();\n  packing.put(7, Arrays.asList(new InstanceId(\"spout\", 1, 0), new InstanceId(\"bolt\", 2, 0)));\n  packing.put(3, Arrays.asList(new InstanceId(\"spout\", 3, 0), new InstanceId(\"bolt\", 4, 0)));\n  PackingPlan packingPlan = generatePacking(packing);\n  Map<Integer, Container> containers = PackingPlanBuilder.getContainers(packingPlan, packingPlan.getMaxContainerResources(), padding, new HashMap<String, TreeSet<Integer>>(), new TreeSet<Integer>());\n  assertEquals(packing.size(), containers.size());\n  for (Integer containerId : packing.keySet()) {\n    Container foundContainer = containers.get(containerId);\n    assertEquals(padding, foundContainer.getPadding());\n    assertEquals(packingPlan.getMaxContainerResources(), foundContainer.getCapacity());\n    assertEquals(2, foundContainer.getInstances().size());\n  }\n}"
    },
    {
        "id": 41,
        "original": "@Test\npublic void testAssign() {\n  executor.assign(\"foo\", \"2\", message);\n  Object var = executor.getState().get(\"foo\");\n  assertThat(var, instanceOf(Integer.class));\n  assertThat(var, equalTo(2));\n}",
        "prediction": "@Test\npublic void testAssign() {\n  Context stellarContext = new Context();\n  executor.assign(\"foo\", \"2\", message, stellarContext);\n  Object var = executor.getState().get(\"foo\");\n  assertThat(var, instanceOf(Integer.class));\n  assertThat(var, equalTo(2));\n}",
        "reference": "@Test\npublic void testAssign() {\n  executor.assign(\"foo\", \"2\", message, Context.EMPTY_CONTEXT());\n  Object var = executor.getState().get(\"foo\");\n  assertThat(var, instanceOf(Integer.class));\n  assertThat(var, equalTo(2));\n}"
    },
    {
        "id": 42,
        "original": "@Test\npublic void testExecuteTransformation() {\n  String actual = executor.execute(\"TO_UPPER('lowercase')\", message, String.class);\n  assertThat(actual, equalTo(\"LOWERCASE\"));\n}",
        "prediction": "@Test\npublic void testExecuteTransformation() {\n  String actual = executor.execute(\"TO_UPPER('lowercase')\", message, String.class, stellarContext);\n  assertThat(actual, equalTo(\"LOWERCASE\"));\n}",
        "reference": "@Test\npublic void testExecuteTransformation() {\n  String actual = executor.execute(\"TO_UPPER('lowercase')\", message, String.class, Context.EMPTY_CONTEXT());\n  assertThat(actual, equalTo(\"LOWERCASE\"));\n}"
    },
    {
        "id": 43,
        "original": "@Test\npublic void testRemovePartition() throws MetadataServiceException, URISyntaxException {\n  Services services = Services.get();\n  PartitionDependencyManagerService pdms = services.get(PartitionDependencyManagerService.class);\n  String newHCatDependency = \"hcat://hcat.yahoo.com:5080/mydb/clicks/?datastamp=12&region=us\";\n  String actionId = \"myAction\";\n  pdms.addMissingPartition(newHCatDependency, actionId);\n  HCatURI hcatUri = new HCatURI(newHCatDependency);\n  Map<String, PartitionsGroup> tablePartitionsMap = pdms.getHCatMap().get(hcatUri.getServerEndPoint() + \"#\" + hcatUri.getDb());\n  assertNotNull(tablePartitionsMap);\n  assertTrue(tablePartitionsMap.containsKey(\"clicks\"));\n  PartitionsGroup missingPartitions = tablePartitionsMap.get(hcatUri.getTable());\n  assertNotNull(missingPartitions);\n  pdms.removePartition(newHCatDependency, false);\n  assertFalse(missingPartitions.getPartitionsMap().containsKey(hcatUri.getPartitionMap()));\n  pdms.addMissingPartition(newHCatDependency, actionId);\n  assertNotNull(missingPartitions);\n  pdms.removePartition(newHCatDependency);\n  assertFalse(pdms.getHCatMap().containsKey(hcatUri.getTable()));\n}",
        "prediction": "@Test\npublic void testRemovePartition() throws MetadataServiceException, URISyntaxException {\n  Services services = Services.get();\n  PartitionDependencyManagerService pdms = services.get(PartitionDependencyManagerService.class);\n  String newHCatDependency = \"hcat://hcat.yahoo.com:5080/mydb/clicks/?datastamp=12&region=us\";\n  String actionId = \"myAction\";\n  pdms.addMissingPartition(newHCatDependency, actionId);\n  HCatURI hcatUri = new HCatURI(newHCatDependency);\n  Map<String, PartitionsGroup> tablePartitionsMap = pdms.getHCatMap().get(hcatUri.getServerEndPoint() + \"#\" + hcatUri.getDb());\n  assertNotNull(tablePartitionsMap);\n  assertTrue(tablePartitionsMap.containsKey(\"clicks\"));\n  PartitionsGroup missingPartitions = tablePartitionsMap.get(hcatUri.getTable());\n  assertNotNull(missingPartitions);\n  pdms.removePartition(newHCatDependency, false);\n  assertFalse(missingPartitions.getPartitionsMap().containsKey(hcatUri.getPartitionMap()));\n  pdms.addMissingPartition(newHCatDependency, actionId);\n  assertNotNull(missingPartitions);\n  try {\n    pdms.removePartition(newHCatDependency);\n  } catch (MetadataServiceException e) {\n    e.printStackTrace();\n  }\n  assertFalse(pdms.getHCatMap().containsKey(hcatUri.getTable()));\n}",
        "reference": "@Test\npublic void testRemovePartition() throws Exception {\n  Services services = Services.get();\n  PartitionDependencyManagerService pdms = services.get(PartitionDependencyManagerService.class);\n  String newHCatDependency = \"hcat://hcat.yahoo.com:5080/database/mydb/table/clicks/partition/datastamp=12,region=us\";\n  String actionId = \"myAction\";\n  pdms.addMissingPartition(newHCatDependency, actionId);\n  HCatURI hcatUri = new HCatURI(newHCatDependency);\n  Map<String, PartitionsGroup> tablePartitionsMap = pdms.getHCatMap().get(hcatUri.getServerEndPoint() + \"#\" + hcatUri.getDb());\n  assertNotNull(tablePartitionsMap);\n  assertTrue(tablePartitionsMap.containsKey(\"clicks\"));\n  PartitionsGroup missingPartitions = tablePartitionsMap.get(hcatUri.getTable());\n  assertNotNull(missingPartitions);\n  pdms.removePartition(newHCatDependency, false);\n  assertFalse(missingPartitions.getPartitionsMap().containsKey(hcatUri.getPartitionMap()));\n  pdms.addMissingPartition(newHCatDependency, actionId);\n  assertNotNull(missingPartitions);\n  pdms.removePartition(newHCatDependency);\n  assertFalse(pdms.getHCatMap().containsKey(hcatUri.getTable()));\n}"
    },
    {
        "id": 44,
        "original": "@Test\npublic void testParseServiceRequestPath() {\n  ServiceRequestPathInfo info = GatewayServlet.parseServiceRequestPath(null);\n  info = GatewayServlet.parseServiceRequestPath(\"/invalidpath\");\n  Assert.assertNull(info.orgId);\n  Assert.assertNull(info.serviceId);\n  Assert.assertNull(info.serviceVersion);\n  Assert.assertNull(info.resource);\n  info = GatewayServlet.parseServiceRequestPath(\"/invalid/path\");\n  Assert.assertNull(info.orgId);\n  Assert.assertNull(info.serviceId);\n  Assert.assertNull(info.serviceVersion);\n  Assert.assertNull(info.resource);\n  info = GatewayServlet.parseServiceRequestPath(\"/Org1/Service1/1.0\");\n  Assert.assertEquals(\"Org1\", info.orgId);\n  Assert.assertEquals(\"Service1\", info.serviceId);\n  Assert.assertEquals(\"1.0\", info.serviceVersion);\n  Assert.assertNull(info.resource);\n  info = GatewayServlet.parseServiceRequestPath(\"/MyOrg/Service-99/2.7\");\n  Assert.assertEquals(\"MyOrg\", info.orgId);\n  Assert.assertEquals(\"Service-99\", info.serviceId);\n  Assert.assertEquals(\"2.7\", info.serviceVersion);\n  Assert.assertNull(info.resource);\n  info = GatewayServlet.parseServiceRequestPath(\"/MyOrg/Service-99/2.7/resource\");\n  Assert.assertEquals(\"MyOrg\", info.orgId);\n  Assert.assertEquals(\"Service-99\", info.serviceId);\n  Assert.assertEquals(\"2.7\", info.serviceVersion);\n  Assert.assertEquals(\"/resource\", info.resource);\n  info = GatewayServlet.parseServiceRequestPath(\"/MyOrg/Service-99/2.7/path/to/resource\");\n  Assert.assertEquals(\"MyOrg\", info.orgId);\n  Assert.assertEquals(\"Service-99\", info.serviceId);\n  Assert.assertEquals(\"2.7\", info.serviceVersion);\n  Assert.assertEquals(\"/path/to/resource\", info.resource);\n  info = GatewayServlet.parseServiceRequestPath(\"/MyOrg/Service-99/2.7/path/to/resource?query=1234\");\n  Assert.assertEquals(\"MyOrg\", info.orgId);\n  Assert.assertEquals(\"Service-99\", info.serviceId);\n  Assert.assertEquals(\"2.7\", info.serviceVersion);\n  Assert.assertEquals(\"/path/to/resource?query=1234\", info.resource);\n}",
        "prediction": "@Test\npublic void testParseServiceRequestPath() {\n  HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\n  Mockito.when(request.getPathInfo()).thenReturn(null);\n  ServiceRequestPathInfo info = GatewayServlet.parseServiceRequestPath(request);\n  Assert.assertNull(info.orgId);\n  Assert.assertNull(info.serviceId);\n  Assert.assertNull(info.serviceVersion);\n  Assert.assertNull(info.resource);\n\n  Mockito.when(request.getPathInfo()).thenReturn(\"/invalidpath\");\n  info = GatewayServlet.parseServiceRequestPath(request);\n  Assert.assertNull(info.orgId);\n  Assert.assertNull(info.serviceId);\n  Assert.assertNull(info.serviceVersion);\n  Assert.assertNull(info.resource);\n\n  Mockito.when(request.getPathInfo()).thenReturn(\"/invalid/path\");\n  info = GatewayServlet.parseServiceRequestPath(request);\n  Assert.assertNull(info.orgId);\n  Assert.assertNull(info.serviceId);\n  Assert.assertNull(info.serviceVersion);\n  Assert.assertNull(info.resource);\n\n  Mockito.when(request.getPathInfo()).thenReturn(\"/Org1/Service1/1.0\");\n  info = GatewayServlet.parseServiceRequestPath(request);\n  Assert.assertEquals(\"Org1\", info.orgId);\n  Assert.assertEquals(\"Service1\", info.serviceId);\n  Assert.assertEquals(\"1.0\", info.serviceVersion);\n  Assert.assertNull(info.resource);\n\n  Mockito.when(request.getPathInfo()).thenReturn(\"/MyOrg/Service-99/2.7\");\n  info = GatewayServlet.parseServiceRequestPath(request);\n  Assert.assertEquals(\"MyOrg\", info.orgId);\n  Assert.assertEquals(\"Service-99\", info.serviceId);\n  Assert.assertEquals(\"2.7\", info.serviceVersion);\n  Assert.assertNull(info.resource);\n\n  Mockito.when(request.getPathInfo()).thenReturn(\"/MyOrg/Service-99/2.7/resource\");\n  info = GatewayServlet.parseServiceRequestPath(request);\n  Assert.assertEquals(\"MyOrg\", info.orgId);\n  Assert.assertEquals(\"Service-99\", info.serviceId);\n  Assert.assertEquals(\"2.7\", info.serviceVersion);\n  Assert.assertEquals(\"/resource\", info.resource);\n\n  Mockito.when(request.getPathInfo()).thenReturn(\"/MyOrg/Service-99/2.7/path/to/resource\");\n  info = GatewayServlet.parseServiceRequestPath(request);\n  Assert.assertEquals(\"MyOrg\", info.orgId);\n  Assert.assertEquals(\"Service-99\", info.serviceId);\n  Assert.assertEquals(\"2.7\", info.serviceVersion);\n  Assert.assertEquals(\"/path/to/resource\", info.resource);\n\n  Mockito.when(request.getPathInfo()).thenReturn(\"/MyOrg/Service-99/2.7/path/to/resource?query=1234\");\n  info = GatewayServlet.parseServiceRequestPath(request);\n  Assert.assertEquals(\"MyOrg\", info.orgId);\n  Assert.assertEquals(\"Service-99\", info.serviceId);\n  Assert.assertEquals(\"2.7\", info.serviceVersion);\n  Assert.assertEquals(\"/path/to/resource?query=1234\", info.resource);\n}",
        "reference": "@Test\npublic void testParseServiceRequestPath() {\n  ServiceRequestPathInfo info = parseServiceRequestPath(null);\n  info = parseServiceRequestPath(\"/invalidpath\");\n  Assert.assertNull(info.orgId);\n  Assert.assertNull(info.serviceId);\n  Assert.assertNull(info.serviceVersion);\n  Assert.assertNull(info.resource);\n  info = parseServiceRequestPath(\"/invalid/path\");\n  Assert.assertNull(info.orgId);\n  Assert.assertNull(info.serviceId);\n  Assert.assertNull(info.serviceVersion);\n  Assert.assertNull(info.resource);\n  info = parseServiceRequestPath(\"/Org1/Service1/1.0\");\n  Assert.assertEquals(\"Org1\", info.orgId);\n  Assert.assertEquals(\"Service1\", info.serviceId);\n  Assert.assertEquals(\"1.0\", info.serviceVersion);\n  Assert.assertNull(info.resource);\n  info = parseServiceRequestPath(\"/MyOrg/Service-99/2.7\");\n  Assert.assertEquals(\"MyOrg\", info.orgId);\n  Assert.assertEquals(\"Service-99\", info.serviceId);\n  Assert.assertEquals(\"2.7\", info.serviceVersion);\n  Assert.assertNull(info.resource);\n  info = parseServiceRequestPath(\"/MyOrg/Service-99/2.7/resource\");\n  Assert.assertEquals(\"MyOrg\", info.orgId);\n  Assert.assertEquals(\"Service-99\", info.serviceId);\n  Assert.assertEquals(\"2.7\", info.serviceVersion);\n  Assert.assertEquals(\"/resource\", info.resource);\n  info = parseServiceRequestPath(\"/MyOrg/Service-99/2.7/path/to/resource\");\n  Assert.assertEquals(\"MyOrg\", info.orgId);\n  Assert.assertEquals(\"Service-99\", info.serviceId);\n  Assert.assertEquals(\"2.7\", info.serviceVersion);\n  Assert.assertEquals(\"/path/to/resource\", info.resource);\n  info = parseServiceRequestPath(\"/MyOrg/Service-99/2.7/path/to/resource?query=1234\");\n  Assert.assertEquals(\"MyOrg\", info.orgId);\n  Assert.assertEquals(\"Service-99\", info.serviceId);\n  Assert.assertEquals(\"2.7\", info.serviceVersion);\n  Assert.assertEquals(\"/path/to/resource?query=1234\", info.resource);\n  info = parseServiceRequestPath(\"/MyOrg/Service-99/path/to/resource?query=1234\", null, \"2.7\");\n  Assert.assertEquals(\"MyOrg\", info.orgId);\n  Assert.assertEquals(\"Service-99\", info.serviceId);\n  Assert.assertEquals(\"2.7\", info.serviceVersion);\n  Assert.assertEquals(\"/path/to/resource?query=1234\", info.resource);\n  info = parseServiceRequestPath(\"/MyOrg/Service-99/path/to/resource?query=1234\", \"application/apiman.2.7+json\", null);\n  Assert.assertEquals(\"MyOrg\", info.orgId);\n  Assert.assertEquals(\"Service-99\", info.serviceId);\n  Assert.assertEquals(\"2.7\", info.serviceVersion);\n  Assert.assertEquals(\"/path/to/resource?query=1234\", info.resource);\n}"
    },
    {
        "id": 45,
        "original": "@Test\npublic void testVisitation() throws Exception {\n  VisitationRecorder recorder = new VisitationRecorder(\"srcs\");\n  mapper.visitLabels(recorder);\n  assertThat(recorder.labelsVisited).containsExactly(\"//p:a\", \"//p:b\", \"//p:c\");\n}",
        "prediction": "@Test\npublic void testVisitation() throws Exception {\n  VisitationRecorder recorder = new VisitationRecorder(\"srcs\");\n  Collection<DepEdge> edges = mapper.visitLabels();\n  List<String> labelsVisited = edges.stream()\n    .map(edge -> edge.getLabel().toString())\n    .collect(Collectors.toList());\n  assertThat(labelsVisited).containsExactly(\"//p:a\", \"//p:b\", \"//p:c\");\n}",
        "reference": "@Test\npublic void testVisitation() throws Exception {\n  assertThat(getLabelsForAttribute(mapper, \"srcs\")).containsExactly(\"//p:a\", \"//p:b\", \"//p:c\");\n}"
    },
    {
        "id": 46,
        "original": "@Test\npublic void testVisitationConfigurableAttribute() throws Exception {\n  Rule rule = scratchRule(\"a\", \"myrule\", \"sh_binary(name = 'myrule',\", \"          srcs = select({\", \"              '//conditions:a': ['a.sh'],\", \"              '//conditions:b': ['b.sh'],\", \"              '\" + BuildType.Selector.DEFAULT_CONDITION_KEY + \"': ['default.sh'],\", \"          }))\");\n  VisitationRecorder recorder = new VisitationRecorder(\"srcs\");\n  AggregatingAttributeMapper.of(rule).visitLabels(recorder);\n  assertThat(recorder.labelsVisited).containsExactlyElementsIn(ImmutableList.of(\"//a:a.sh\", \"//a:b.sh\", \"//a:default.sh\", \"//conditions:a\", \"//conditions:b\"));\n}",
        "prediction": "@Test\npublic void testVisitationConfigurableAttribute() throws Exception {\n  Rule rule = scratchRule(\"a\", \"myrule\", \"sh_binary(name = 'myrule',\", \"          srcs = select({\", \"              '//conditions:a': ['a.sh'],\", \"              '//conditions:b': ['b.sh'],\", \"              '\" + BuildType.Selector.DEFAULT_CONDITION_KEY + \"': ['default.sh'],\", \"          }))\");\n  VisitationRecorder recorder = new VisitationRecorder(\"srcs\");\n  Collection<DepEdge> labelsVisited = AggregatingAttributeMapper.of(rule).visitLabels();\n  for (DepEdge depEdge : labelsVisited) {\n    recorder.acceptLabelAttribute(depEdge.getAttributeName(), depEdge.getLabel());\n  }\n  assertThat(recorder.labelsVisited).containsExactlyElementsIn(ImmutableList.of(\"//a:a.sh\", \"//a:b.sh\", \"//a:default.sh\", \"//conditions:a\", \"//conditions:b\"));\n}",
        "reference": "@Test\npublic void testVisitationConfigurableAttribute() throws Exception {\n  Rule rule = scratchRule(\"a\", \"myrule\", \"sh_binary(name = 'myrule',\", \"          srcs = select({\", \"              '//conditions:a': ['a.sh'],\", \"              '//conditions:b': ['b.sh'],\", \"              '\" + BuildType.Selector.DEFAULT_CONDITION_KEY + \"': ['default.sh'],\", \"          }))\");\n  assertThat(getLabelsForAttribute(AggregatingAttributeMapper.of(rule), \"srcs\")).containsExactlyElementsIn(ImmutableList.of(\"//a:a.sh\", \"//a:b.sh\", \"//a:default.sh\", \"//conditions:a\", \"//conditions:b\"));\n}"
    },
    {
        "id": 47,
        "original": "@Test\npublic void testDivideInternally() throws StructureException, IOException {\n  Structure s = StructureIO.getStructure(\"4e3e\");\n  SubunitCluster sc1 = new SubunitCluster(new Subunit(StructureTools.getRepresentativeAtomArray(s.getChainByIndex(0)), \"chain 0\", null, s));\n  boolean divided = sc1.divideInternally(0.8, 3.0, 20);\n  assertTrue(divided);\n  assertEquals(sc1.size(), 2);\n  assertTrue(sc1.length() < 178);\n  assertEquals(sc1.getAlignedAtomsSubunit(0).length, sc1.getAlignedAtomsSubunit(1).length);\n}",
        "prediction": "@Test\npublic void testDivideInternally() throws StructureException, IOException {\n  Structure s = StructureIO.getStructure(\"4e3e\");\n  SubunitCluster sc1 = new SubunitCluster(new Subunit(StructureTools.getRepresentativeAtomArray(s.getChainByIndex(0)), \"chain 0\", null, s));\n  \n  SubunitClustererParameters clusterParams = new SubunitClustererParameters();\n  clusterParams.setMinimumSequenceLength(20);\n  clusterParams.setRMSDThreshold(3.0);\n  clusterParams.setStructureCoverageThreshold(0.8);\n  \n  boolean divided = sc1.divideInternally(clusterParams);\n  \n  assertTrue(divided);\n  assertEquals(sc1.size(), 2);\n  assertTrue(sc1.length() < 178);\n  assertEquals(sc1.getAlignedAtomsSubunit(0).length, sc1.getAlignedAtomsSubunit(1).length);\n}",
        "reference": "@Test\npublic void testDivideInternally() throws StructureException, IOException {\n  Structure s = StructureIO.getStructure(\"4e3e\");\n  SubunitCluster sc1 = new SubunitCluster(new Subunit(StructureTools.getRepresentativeAtomArray(s.getChainByIndex(0)), \"chain 0\", null, s));\n  SubunitClustererParameters clustererParameters = new SubunitClustererParameters();\n  clustererParameters.setStructureCoverageThreshold(0.8);\n  clustererParameters.setRMSDThreshold(3.0);\n  clustererParameters.setMinimumSequenceLength(20);\n  boolean divided = sc1.divideInternally(clustererParameters);\n  assertTrue(divided);\n  assertEquals(sc1.size(), 2);\n  assertTrue(sc1.length() < 178);\n  assertEquals(sc1.getAlignedAtomsSubunit(0).length, sc1.getAlignedAtomsSubunit(1).length);\n}"
    },
    {
        "id": 48,
        "original": "@Test\npublic void testMergeStructure() throws StructureException, IOException {\n  Structure s = StructureIO.getStructure(\"4hhb\");\n  SubunitCluster sc1 = new SubunitCluster(new Subunit(StructureTools.getRepresentativeAtomArray(s.getChainByIndex(0)), \"chain 0\", null, s));\n  SubunitCluster sc2 = new SubunitCluster(new Subunit(StructureTools.getRepresentativeAtomArray(s.getChainByIndex(1)), \"chain 1\", null, s));\n  SubunitCluster sc3 = new SubunitCluster(new Subunit(StructureTools.getRepresentativeAtomArray(s.getChainByIndex(2)), \"chain 2\", null, s));\n  SubunitCluster sc4 = new SubunitCluster(new Subunit(StructureTools.getRepresentativeAtomArray(s.getChainByIndex(3)), \"chain 3\", null, s));\n  boolean merged13 = sc1.mergeStructure(sc3, 3.0, 0.9);\n  boolean merged24 = sc2.mergeStructure(sc4, 3.0, 0.9);\n  assertTrue(merged13);\n  assertTrue(merged24);\n  assertEquals(sc1.size(), 2);\n  assertEquals(sc2.size(), 2);\n  assertEquals(sc1.length(), 141);\n  assertEquals(sc2.length(), 146);\n  assertEquals(sc1.getAlignedAtomsSubunit(0).length, sc1.getAlignedAtomsSubunit(1).length);\n  assertEquals(sc2.getAlignedAtomsSubunit(0).length, sc2.getAlignedAtomsSubunit(1).length);\n  boolean merged = sc1.mergeStructure(sc2, 3.0, 0.9);\n  assertTrue(merged);\n  assertEquals(sc1.size(), 4);\n  assertEquals(sc1.length(), 140, 2);\n  assertEquals(sc1.getAlignedAtomsSubunit(0).length, sc1.getAlignedAtomsSubunit(2).length);\n}",
        "prediction": "@Test\npublic void testMergeStructure() throws StructureException, IOException {\n  Structure s = StructureIO.getStructure(\"4hhb\");\n  SubunitCluster sc1 = new SubunitCluster(new Subunit(StructureTools.getRepresentativeAtomArray(s.getChainByIndex(0)), \"chain 0\", null, s));\n  SubunitCluster sc2 = new SubunitCluster(new Subunit(StructureTools.getRepresentativeAtomArray(s.getChainByIndex(1)), \"chain 1\", null, s));\n  SubunitCluster sc3 = new SubunitCluster(new Subunit(StructureTools.getRepresentativeAtomArray(s.getChainByIndex(2)), \"chain 2\", null, s));\n  SubunitCluster sc4 = new SubunitCluster(new Subunit(StructureTools.getRepresentativeAtomArray(s.getChainByIndex(3)), \"chain 3\", null, s));\n  \n  SubunitClustererParameters params = new SubunitClustererParameters();\n  params.setSuperpositionAlgorithm(CeMain.algorithmName);\n  params.setOptimizeAlignment(true);\n  params.setUseStructureCoverage(true);\n  params.setStructureCoverageThreshold(0.9);\n  params.setUseRMSD(true);\n  params.setRMSDThreshold(3.0);\n  \n  boolean merged13 = sc1.mergeStructure(sc3, params);\n  boolean merged24 = sc2.mergeStructure(sc4, params);\n  \n  assertTrue(merged13);\n  assertTrue(merged24);\n  assertEquals(sc1.size(), 2);\n  assertEquals(sc2.size(), 2);\n  assertEquals(sc1.length(), 141);\n  assertEquals(sc2.length(), 146);\n  assertEquals(sc1.getAlignedAtomsSubunit(0).length, sc1.getAlignedAtomsSubunit(1).length);\n  assertEquals(sc2.getAlignedAtomsSubunit(0).length, sc2.getAlignedAtomsSubunit(1).length);\n  \n  boolean merged = sc1.mergeStructure(sc2, params);\n  \n  assertTrue(merged);\n  assertEquals(sc1.size(), 4);\n  assertEquals(sc1.length(), 140, 2);\n  assertEquals(sc1.getAlignedAtomsSubunit(0).length, sc1.getAlignedAtomsSubunit(2).length);\n}",
        "reference": "@Test\npublic void testMergeStructure() throws StructureException, IOException {\n  Structure s = StructureIO.getStructure(\"4hhb\");\n  SubunitCluster sc1 = new SubunitCluster(new Subunit(StructureTools.getRepresentativeAtomArray(s.getChainByIndex(0)), \"chain 0\", null, s));\n  SubunitCluster sc2 = new SubunitCluster(new Subunit(StructureTools.getRepresentativeAtomArray(s.getChainByIndex(1)), \"chain 1\", null, s));\n  SubunitCluster sc3 = new SubunitCluster(new Subunit(StructureTools.getRepresentativeAtomArray(s.getChainByIndex(2)), \"chain 2\", null, s));\n  SubunitCluster sc4 = new SubunitCluster(new Subunit(StructureTools.getRepresentativeAtomArray(s.getChainByIndex(3)), \"chain 3\", null, s));\n  SubunitClustererParameters clustererParameters = new SubunitClustererParameters();\n  clustererParameters.setRMSDThreshold(3.0);\n  clustererParameters.setStructureCoverageThreshold(0.9);\n  boolean merged13 = sc1.mergeStructure(sc3, clustererParameters);\n  boolean merged24 = sc2.mergeStructure(sc4, clustererParameters);\n  assertTrue(merged13);\n  assertTrue(merged24);\n  assertEquals(sc1.size(), 2);\n  assertEquals(sc2.size(), 2);\n  assertEquals(sc1.length(), 141);\n  assertEquals(sc2.length(), 146);\n  assertEquals(sc1.getAlignedAtomsSubunit(0).length, sc1.getAlignedAtomsSubunit(1).length);\n  assertEquals(sc2.getAlignedAtomsSubunit(0).length, sc2.getAlignedAtomsSubunit(1).length);\n  boolean merged = sc1.mergeStructure(sc2, clustererParameters);\n  assertTrue(merged);\n  assertEquals(sc1.size(), 4);\n  assertEquals(sc1.length(), 140, 2);\n  assertEquals(sc1.getAlignedAtomsSubunit(0).length, sc1.getAlignedAtomsSubunit(2).length);\n}"
    },
    {
        "id": 49,
        "original": "@Test\npublic void testGetPercentageOfIdentity() {\n  assertEquals(global.getPercentageOfIdentity(), 1.0, 0.01);\n  assertEquals(local.getPercentageOfIdentity(), 1.0, 0.01);\n}",
        "prediction": "@Test\npublic void testGetPercentageOfIdentity() {\n  assertEquals(global.getPercentageOfIdentity(true), 1.0, 0.01);\n  assertEquals(local.getPercentageOfIdentity(true), 1.0, 0.01);\n}",
        "reference": "@Test\npublic void testGetPercentageOfIdentity() {\n  assertEquals(global.getPercentageOfIdentity(false), 1.0, 0.01);\n  assertEquals(local.getPercentageOfIdentity(false), 1.0, 0.01);\n}"
    },
    {
        "id": 50,
        "original": "@Test\npublic void testDeploy() throws Exception {\n  HttpResponse response = deploy(\"WordCount.jar\");\n  Assert.assertEquals(200, response.getStatusLine().getStatusCode());\n}",
        "prediction": "@Test\npublic void testDeploy() throws Exception {\n  HttpResponse response = deploy(WordCount.class);\n  Assert.assertEquals(200, response.getStatusLine().getStatusCode());\n}",
        "reference": "@Test\npublic void testDeploy() throws Exception {\n  HttpResponse response = deploy(WordCount.class);\n  Assert.assertEquals(200, response.getStatusLine().getStatusCode());\n}"
    },
    {
        "id": 51,
        "original": "@Test\r\npublic void testHypergeometricCdf() {\r\n  logger.info(\"HypergeometricCdf\");\r\n  int k = 3;\r\n  int n = 10;\r\n  int Kp = 30;\r\n  int Np = 100;\r\n  double expResult = 0.65401998866081;\r\n  double result = DiscreteDistributions.HypergeometricCdf(k, n, Kp, Np);\r\n  assertEquals(expResult, result, TestConfiguration.DOUBLE_ACCURACY_HIGH);\r\n}",
        "prediction": "@Test\npublic void testHypergeometricCdf() {\n  logger.info(\"HypergeometricCdf\");\n  int k = 3;\n  int n = 10;\n  int Kp = 30;\n  int Np = 100;\n  double expResult = 0.65401998866081;\n  double result = DiscreteDistributions.hypergeometricCdf(k, n, Kp, Np);\n  assertEquals(expResult, result, TestConfiguration.DOUBLE_ACCURACY_HIGH);\n}",
        "reference": "@Test\r\npublic void testHypergeometricCdf() {\r\n  logger.info(\"HypergeometricCdf\");\r\n  int k = 3;\r\n  int n = 10;\r\n  int Kp = 30;\r\n  int Np = 100;\r\n  double expResult = 0.65401998866081;\r\n  double result = DiscreteDistributions.hypergeometricCdf(k, n, Kp, Np);\r\n  assertEquals(expResult, result, TestConfiguration.DOUBLE_ACCURACY_HIGH);\r\n}"
    },
    {
        "id": 52,
        "original": "@Test\r\npublic void testGetColumns() {\r\n  TestUtils.log(this.getClass(), \"getColumns\");\r\n  RandomSingleton.getInstance().setSeed(TestConfiguration.RANDOM_SEED);\r\n  DatabaseConfiguration dbConf = TestUtils.getDBConfig();\r\n  Dataset instance = new Dataset(dbConf);\r\n  AssociativeArray xData1 = new AssociativeArray();\r\n  xData1.put(\"1\", true);\r\n  instance.add(new Record(xData1, null));\r\n  AssociativeArray xData2 = new AssociativeArray();\r\n  xData2.put(\"2\", 1.0);\r\n  instance.add(new Record(xData2, null));\r\n  AssociativeArray xData3 = new AssociativeArray();\r\n  xData3.put(\"3\", (short)1);\r\n  instance.add(new Record(xData3, null));\r\n  AssociativeArray xData4 = new AssociativeArray();\r\n  xData4.put(\"4\", \"s\");\r\n  instance.add(new Record(xData4, null));\r\n  Map<Object, Dataset.ColumnType> expResult = new LinkedHashMap<>();\r\n  expResult.put(\"1\", Dataset.ColumnType.DUMMYVAR);\r\n  expResult.put(\"2\", Dataset.ColumnType.NUMERICAL);\r\n  expResult.put(\"3\", Dataset.ColumnType.ORDINAL);\r\n  expResult.put(\"4\", Dataset.ColumnType.CATEGORICAL);\r\n  Map<Object, Dataset.ColumnType> result = instance.getColumns();\r\n  assertEquals(expResult, result);\r\n}",
        "prediction": "@Test\npublic void testGetXDataTypes() {\n  TestUtils.log(this.getClass(), \"getXDataTypes\");\n  RandomSingleton.getInstance().setSeed(TestConfiguration.RANDOM_SEED);\n  DatabaseConfiguration dbConf = TestUtils.getDBConfig();\n  Dataset instance = new Dataset(dbConf);\n  AssociativeArray xData1 = new AssociativeArray();\n  xData1.put(\"1\", true);\n  instance.add(new Record(xData1, null));\n  AssociativeArray xData2 = new AssociativeArray();\n  xData2.put(\"2\", 1.0);\n  instance.add(new Record(xData2, null));\n  AssociativeArray xData3 = new AssociativeArray();\n  xData3.put(\"3\", (short)1);\n  instance.add(new Record(xData3, null));\n  AssociativeArray xData4 = new AssociativeArray();\n  xData4.put(\"4\", \"s\");\n  instance.add(new Record(xData4, null));\n  Map<Object, TypeInference.DataType> expResult = new LinkedHashMap<>();\n  expResult.put(\"1\", TypeInference.DataType.DUMMYVAR);\n  expResult.put(\"2\", TypeInference.DataType.NUMERICAL);\n  expResult.put(\"3\", TypeInference.DataType.ORDINAL);\n  expResult.put(\"4\", TypeInference.DataType.CATEGORICAL);\n  Map<Object, TypeInference.DataType> result = instance.getXDataTypes();\n  assertEquals(expResult, result);\n}",
        "reference": "@Test\r\npublic void testGetColumns() {\r\n  TestUtils.log(this.getClass(), \"getColumns\");\r\n  RandomSingleton.getInstance().setSeed(TestConfiguration.RANDOM_SEED);\r\n  DatabaseConfiguration dbConf = TestUtils.getDBConfig();\r\n  Dataset instance = new Dataset(dbConf);\r\n  AssociativeArray xData1 = new AssociativeArray();\r\n  xData1.put(\"1\", true);\r\n  instance.add(new Record(xData1, null));\r\n  AssociativeArray xData2 = new AssociativeArray();\r\n  xData2.put(\"2\", 1.0);\r\n  instance.add(new Record(xData2, null));\r\n  AssociativeArray xData3 = new AssociativeArray();\r\n  xData3.put(\"3\", (short)1);\r\n  instance.add(new Record(xData3, null));\r\n  AssociativeArray xData4 = new AssociativeArray();\r\n  xData4.put(\"4\", \"s\");\r\n  instance.add(new Record(xData4, null));\r\n  Map<Object, TypeInference.DataType> expResult = new LinkedHashMap<>();\r\n  expResult.put(\"1\", TypeInference.DataType.BOOLEAN);\r\n  expResult.put(\"2\", TypeInference.DataType.NUMERICAL);\r\n  expResult.put(\"3\", TypeInference.DataType.ORDINAL);\r\n  expResult.put(\"4\", TypeInference.DataType.CATEGORICAL);\r\n  Map<Object, TypeInference.DataType> result = instance.getXDataTypes();\r\n  assertEquals(expResult, result);\r\n}"
    },
    {
        "id": 53,
        "original": "@Test\npublic void testAllStoredEventsSince() {\n  System.out.println(\"allStoredEventsSince\");\n  Date occurredFrom = null;\n  HibernateEventStore instance = new HibernateEventStore();\n  List<StoredEvent> expResult = null;\n  List<StoredEvent> result = instance.allStoredEventsSince(occurredFrom);\n  assertEquals(expResult, result);\n  fail(\"The test case is a prototype.\");\n}",
        "prediction": "@Test\npublic void testFindStoredEventsSince() {\n  System.out.println(\"findStoredEventsSince\");\n  Date occurredFrom = null;\n  HibernateEventStore instance = new HibernateEventStore();\n  List<StoredEvent> expResult = null;\n  List<StoredEvent> result = instance.findStoredEventsSince(occurredFrom);\n  assertEquals(expResult, result);\n  fail(\"The test case is a prototype.\");\n}",
        "reference": "@Test\npublic void testFindStoredEventsSince() {\n  System.out.println(\"findStoredEventsSince\");\n  Date occurredFrom = null;\n  HibernateEventStore instance = new HibernateEventStore();\n  List<StoredEvent> expResult = null;\n  List<StoredEvent> result = instance.findStoredEventsSince(occurredFrom);\n  assertEquals(expResult, result);\n  fail(\"The test case is a prototype.\");\n}"
    },
    {
        "id": 54,
        "original": "@Test\npublic void testPutAll_MultiMap_Simple() {\n  MultiMap<String> mm = new MultiMap<String>();\n  assertMapSize(mm, 0);\n  MultiMap<String> input = new MultiMap<String>();\n  input.put(\"food\", \"apple\");\n  input.put(\"color\", \"red\");\n  input.put(\"amount\", \"bushel\");\n  mm.putAll(input);\n  assertMapSize(mm, 3);\n  assertValues(mm, \"food\", \"apple\");\n  assertValues(mm, \"color\", \"red\");\n  assertValues(mm, \"amount\", \"bushel\");\n}",
        "prediction": "@Test\npublic void testPutAll_MultiMap_Simple() {\n  MultiMap<String> mm = new MultiMap<String>();\n  assertMapSize(mm, 0);\n  Map<String, Object> input = new HashMap<String, Object>();\n  input.put(\"food\", \"apple\");\n  input.put(\"color\", \"red\");\n  input.put(\"amount\", \"bushel\");\n  mm.putAll(input);\n  assertMapSize(mm, 3);\n  assertValues(mm, \"food\", \"apple\");\n  assertValues(mm, \"color\", \"red\");\n  assertValues(mm, \"amount\", \"bushel\");\n}",
        "reference": "@Test\npublic void testPutAll_MultiMap_Simple() {\n  MultiMap mm = new MultiMap();\n  assertMapSize(mm, 0);\n  MultiMap input = new MultiMap();\n  input.put(\"food\", \"apple\");\n  input.put(\"color\", \"red\");\n  input.put(\"amount\", \"bushel\");\n  mm.putAll(input);\n  assertMapSize(mm, 3);\n  assertValues(mm, \"food\", \"apple\");\n  assertValues(mm, \"color\", \"red\");\n  assertValues(mm, \"amount\", \"bushel\");\n}"
    },
    {
        "id": 55,
        "original": "@Test\npublic void testTransact_getsNewTimestampOnEachTry() {\n  ofy().transact(new VoidWork() {\n    DateTime firstAttemptTime;\n    @Override\n    public void vrun() {\n      if (firstAttemptTime == null) {\n        firstAttemptTime = ofy().getTransactionTime();\n        sleepUninterruptibly(10, MILLISECONDS);\n        throw new ConcurrentModificationException();\n      }\n      assertThat(ofy().getTransactionTime()).isGreaterThan(firstAttemptTime);\n    }\n  });\n}",
        "prediction": "@Test\npublic void testTransact_getsNewTimestampOnEachTry() {\n  ofy().transact(new Runnable() {\n    DateTime firstAttemptTime;\n    @Override\n    public void run() {\n      if (firstAttemptTime == null) {\n        firstAttemptTime = ofy().getTransactionTime();\n        sleepUninterruptibly(10, MILLISECONDS);\n        throw new ConcurrentModificationException();\n      }\n      assertThat(ofy().getTransactionTime()).isGreaterThan(firstAttemptTime);\n    }\n  });\n}",
        "reference": "@Test\npublic void testTransact_getsNewTimestampOnEachTry() {\n  tm().transact(new Runnable() {\n    DateTime firstAttemptTime;\n    @Override\n    public void run() {\n      if (firstAttemptTime == null) {\n        firstAttemptTime = tm().getTransactionTime();\n        sleepUninterruptibly(10, MILLISECONDS);\n        throw new ConcurrentModificationException();\n      }\n      assertThat(tm().getTransactionTime()).isGreaterThan(firstAttemptTime);\n    }\n  });\n}"
    },
    {
        "id": 56,
        "original": "@Test\npublic void testPromote_shouldPromoteKey() throws Exception {\n  int primaryKeyId = 42;\n  int newPrimaryKeyId = 43;\n  KeysetHandle handle = KeysetHandle.fromKeyset(TestUtil.createKeyset(createEnabledKey(primaryKeyId), createEnabledKey(newPrimaryKeyId)));\n  Keyset keyset = KeysetManager.withKeysetHandle(handle).promote(newPrimaryKeyId).getKeysetHandle().getKeyset();\n  assertThat(keyset.getKeyCount()).isEqualTo(2);\n  assertThat(keyset.getPrimaryKeyId()).isEqualTo(newPrimaryKeyId);\n}",
        "prediction": "@Test\npublic void testPromote_shouldPromoteKey() throws Exception {\n  int primaryKeyId = 42;\n  int newPrimaryKeyId = 43;\n  KeysetHandle handle = KeysetHandle.fromKeyset(TestUtil.createKeyset(createEnabledKey(primaryKeyId), createEnabledKey(newPrimaryKeyId)));\n  Keyset keyset = KeysetManager.withKeysetHandle(handle).setPrimary(newPrimaryKeyId).getKeysetHandle().getKeyset();\n  assertThat(keyset.getKeyCount()).isEqualTo(2);\n  assertThat(keyset.getPrimaryKeyId()).isEqualTo(newPrimaryKeyId);\n}",
        "reference": "@Test\npublic void testSetPrimary_shouldSetPrimary() throws Exception {\n  int primaryKeyId = 42;\n  int newPrimaryKeyId = 43;\n  KeysetHandle handle = KeysetHandle.fromKeyset(TestUtil.createKeyset(createEnabledKey(primaryKeyId), createEnabledKey(newPrimaryKeyId)));\n  Keyset keyset = KeysetManager.withKeysetHandle(handle).setPrimary(newPrimaryKeyId).getKeysetHandle().getKeyset();\n  assertThat(keyset.getKeyCount()).isEqualTo(2);\n  assertThat(keyset.getPrimaryKeyId()).isEqualTo(newPrimaryKeyId);\n}"
    },
    {
        "id": 57,
        "original": "@Test\npublic void testCurrentlyPreparedTxs() {\n  txPrepare(1);\n  txKeyWrite(1, 10);\n  txKeyWrite(1, 11);\n  txPrepare(2);\n  txKeyWrite(2, 20);\n  txKeyWrite(2, 21);\n  txKeyWrite(2, 22);\n  txPrepare(3);\n  txKeyWrite(3, 30);\n  txCommit(2);\n  tracker.writeLockState();\n  try {\n    Map<GridCacheVersion, WALPointer> currentlyPreparedTxs = tracker.currentlyPreparedTxs();\n    assertEquals(2, currentlyPreparedTxs.size());\n    assertTrue(currentlyPreparedTxs.containsKey(nearXidVersion(1)));\n    assertTrue(currentlyPreparedTxs.containsKey(nearXidVersion(3)));\n  } finally {\n    tracker.writeUnlockState();\n  }\n  txKeyWrite(3, 31);\n  txCommit(3);\n  tracker.writeLockState();\n  try {\n    Map<GridCacheVersion, WALPointer> currentlyPreparedTxs = tracker.currentlyPreparedTxs();\n    assertEquals(1, currentlyPreparedTxs.size());\n    assertTrue(currentlyPreparedTxs.containsKey(nearXidVersion(1)));\n  } finally {\n    tracker.writeUnlockState();\n  }\n}",
        "prediction": "@Test\npublic void testCurrentlyPreparedTxs() {\n  txPrepare(1);\n  txKeyWrite(1, 10);\n  txKeyWrite(1, 11);\n  txPrepare(2);\n  txKeyWrite(2, 20);\n  txKeyWrite(2, 21);\n  txKeyWrite(2, 22);\n  txPrepare(3);\n  txKeyWrite(3, 30);\n  txCommit(2);\n  tracker.writeLockState();\n  try {\n    Set<GridCacheVersion> currentlyPreparedTxs = tracker.currentlyPreparedTxs();\n    assertEquals(2, currentlyPreparedTxs.size());\n    assertTrue(currentlyPreparedTxs.contains(nearXidVersion(1)));\n    assertTrue(currentlyPreparedTxs.contains(nearXidVersion(3)));\n  } finally {\n    tracker.writeUnlockState();\n  }\n  txKeyWrite(3, 31);\n  txCommit(3);\n  tracker.writeLockState();\n  try {\n    Set<GridCacheVersion> currentlyPreparedTxs = tracker.currentlyPreparedTxs();\n    assertEquals(1, currentlyPreparedTxs.size());\n    assertTrue(currentlyPreparedTxs.contains(nearXidVersion(1)));\n  } finally {\n    tracker.writeUnlockState();\n  }\n}",
        "reference": "@Test\npublic void testCurrentlyPreparedTxs() {\n  txPrepare(1);\n  txKeyWrite(1, 10);\n  txKeyWrite(1, 11);\n  txPrepare(2);\n  txKeyWrite(2, 20);\n  txKeyWrite(2, 21);\n  txKeyWrite(2, 22);\n  txPrepare(3);\n  txKeyWrite(3, 30);\n  txCommit(2);\n  tracker.writeLockState();\n  try {\n    Set<GridCacheVersion> currentlyPreparedTxs = tracker.currentlyPreparedTxs();\n    assertEquals(2, currentlyPreparedTxs.size());\n    assertTrue(currentlyPreparedTxs.contains(nearXidVersion(1)));\n    assertTrue(currentlyPreparedTxs.contains(nearXidVersion(3)));\n  } finally {\n    tracker.writeUnlockState();\n  }\n  txKeyWrite(3, 31);\n  txCommit(3);\n  tracker.writeLockState();\n  try {\n    Set<GridCacheVersion> currentlyPreparedTxs = tracker.currentlyPreparedTxs();\n    assertEquals(1, currentlyPreparedTxs.size());\n    assertTrue(currentlyPreparedTxs.contains(nearXidVersion(1)));\n  } finally {\n    tracker.writeUnlockState();\n  }\n}"
    },
    {
        "id": 58,
        "original": "@Test\npublic void testSolve_doubleArrArr_doubleArrArr() {\n  System.out.println(\"solve\");\n  double[][] A = {{0.9000, 0.4000, 0.7000}, {0.4000, 0.5000, 0.3000}, {0.7000, 0.3000, 0.8000}};\n  double[][] B2 = {{0.5, 0.2}, {0.5, 0.8}, {0.5, 0.3}};\n  double[][] X2 = {{-0.2027027, -1.2837838}, {0.8783784, 2.2297297}, {0.4729730, 0.6621622}};\n  double[][] x = Math.solve(A, B2);\n  assertEquals(X2.length, x.length);\n  assertEquals(X2[0].length, x[0].length);\n  for (int i = 0; i < X2.length; i++) {\n    for (int j = 0; j < X2[i].length; j++) {\n      assertEquals(X2[i][j], x[i][j], 1E-7);\n    }\n  }\n}",
        "prediction": "@Test\npublic void testSolve_doubleArrArr_doubleArrArr() {\n  System.out.println(\"solve\");\n  double[][] A = {{0.9000, 0.4000, 0.7000}, {0.4000, 0.5000, 0.3000}, {0.7000, 0.3000, 0.8000}};\n  double[][] B2 = {{0.5, 0.2}, {0.5, 0.8}, {0.5, 0.3}};\n  double[][] X2 = {{-0.2027027, -1.2837838}, {0.8783784, 2.2297297}, {0.4729730, 0.6621622}};\n  DenseMatrix x = Math.solve(A, B2);\n  double[][] xArray = x.toArray();\n  assertEquals(X2.length, xArray.length);\n  assertEquals(X2[0].length, xArray[0].length);\n  for (int i = 0; i < X2.length; i++) {\n    for (int j = 0; j < X2[i].length; j++) {\n      assertEquals(X2[i][j], xArray[i][j], 1E-7);\n    }\n  }\n}",
        "reference": "@Test\npublic void testSolve_doubleArrArr_doubleArrArr() {\n  System.out.println(\"solve\");\n  double[][] A = {{0.9000, 0.4000, 0.7000}, {0.4000, 0.5000, 0.3000}, {0.7000, 0.3000, 0.8000}};\n  double[][] B2 = {{0.5, 0.2}, {0.5, 0.8}, {0.5, 0.3}};\n  double[][] X2 = {{-0.2027027, -1.2837838}, {0.8783784, 2.2297297}, {0.4729730, 0.6621622}};\n  DenseMatrix x = Math.solve(A, B2);\n  assertEquals(X2.length, x.nrows());\n  assertEquals(X2[0].length, x.ncols());\n  for (int i = 0; i < X2.length; i++) {\n    for (int j = 0; j < X2[i].length; j++) {\n      assertEquals(X2[i][j], x.get(i, j), 1E-7);\n    }\n  }\n}"
    },
    {
        "id": 59,
        "original": "@Test\npublic void testColSum() {\n  System.out.println(\"colSum\");\n  double[][] A = {{0.7220180, 0.07121225, 0.6881997}, {-0.2648886, -0.89044952, 0.3700456}, {-0.6391588, 0.44947578, 0.6240573}};\n  double[] r = {-0.1820294, -0.3697615, 1.6823026};\n  double[] result = Math.colSum(A);\n  for (int i = 0; i < r.length; i++) {\n    assertEquals(result[i], r[i], 1E-7);\n  }\n}",
        "prediction": "@Test\npublic void testColSum() {\n  System.out.println(\"colSum\");\n  double[][] A = {{0.7220180, 0.07121225, 0.6881997}, {-0.2648886, -0.89044952, 0.3700456}, {-0.6391588, 0.44947578, 0.6240573}};\n  double[] r = {-0.1820294, -0.3697615, 1.6823026};\n  double[] result = Math.colSums(A);\n  for (int i = 0; i < r.length; i++) {\n    assertEquals(result[i], r[i], 1E-7);\n  }\n}",
        "reference": "@Test\npublic void testColSums() {\n  System.out.println(\"colSums\");\n  double[][] A = {{0.7220180, 0.07121225, 0.6881997}, {-0.2648886, -0.89044952, 0.3700456}, {-0.6391588, 0.44947578, 0.6240573}};\n  double[] r = {-0.1820294, -0.3697615, 1.6823026};\n  double[] result = Math.colSums(A);\n  for (int i = 0; i < r.length; i++) {\n    assertEquals(result[i], r[i], 1E-7);\n  }\n}"
    },
    {
        "id": 60,
        "original": "@Test\npublic void addAllAsync_manyTimesRoundTheRing() throws Exception {\n  RingbufferConfig c = config.getRingbufferConfig(ringbuffer.getName());\n  Random random = new Random();\n  for (int iteration = 0; iteration < 1000; iteration++) {\n    List<String> items = randomList(max(1, random.nextInt(c.getCapacity())));\n    long previousTailSeq = ringbuffer.tailSequence();\n    long result = ringbuffer.addAllAsync(items, OVERWRITE).get();\n    assertEquals(previousTailSeq + items.size(), ringbuffer.tailSequence());\n    if (ringbuffer.tailSequence() < c.getCapacity()) {\n      assertEquals(0, ringbuffer.headSequence());\n    } else {\n      assertEquals(ringbuffer.tailSequence() - c.getCapacity() + 1, ringbuffer.headSequence());\n    }\n    assertEquals(ringbuffer.tailSequence(), result);\n    long startSequence = previousTailSeq + 1;\n    for (int k = 0; k < items.size(); k++) {\n      assertEquals(items.get(k), ringbuffer.readOne(startSequence + k));\n    }\n  }\n}",
        "prediction": "@Test\npublic void addAllAsync_manyTimesRoundTheRing() throws Exception {\n  RingbufferConfig c = config.getRingbufferConfig(ringbuffer.getName());\n  Random random = new Random();\n  for (int iteration = 0; iteration < 1000; iteration++) {\n    List<String> items = randomList(max(1, random.nextInt(c.getCapacity())));\n    long previousTailSeq = ringbuffer.tailSequence();\n    long result = ringbuffer.addAllAsync(items, OVERWRITE).toCompletableFuture().get();\n    assertEquals(previousTailSeq + items.size(), ringbuffer.tailSequence());\n    if (ringbuffer.tailSequence() < c.getCapacity()) {\n      assertEquals(0, ringbuffer.headSequence());\n    } else {\n      assertEquals(ringbuffer.tailSequence() - c.getCapacity() + 1, ringbuffer.headSequence());\n    }\n    assertEquals(ringbuffer.tailSequence(), result);\n    long startSequence = previousTailSeq + 1;\n    for (int k = 0; k < items.size(); k++) {\n      assertEquals(items.get(k), ringbuffer.readOne(startSequence + k));\n    }\n  }\n}",
        "reference": "@Test\npublic void addAllAsync_manyTimesRoundTheRing() throws Exception {\n  RingbufferConfig c = config.getRingbufferConfig(ringbuffer.getName());\n  Random random = new Random();\n  for (int iteration = 0; iteration < 1000; iteration++) {\n    List<String> items = randomList(max(1, random.nextInt(c.getCapacity())));\n    long previousTailSeq = ringbuffer.tailSequence();\n    long result = ringbuffer.addAllAsync(items, OVERWRITE).toCompletableFuture().get();\n    assertEquals(previousTailSeq + items.size(), ringbuffer.tailSequence());\n    if (ringbuffer.tailSequence() < c.getCapacity()) {\n      assertEquals(0, ringbuffer.headSequence());\n    } else {\n      assertEquals(ringbuffer.tailSequence() - c.getCapacity() + 1, ringbuffer.headSequence());\n    }\n    assertEquals(ringbuffer.tailSequence(), result);\n    long startSequence = previousTailSeq + 1;\n    for (int k = 0; k < items.size(); k++) {\n      assertEquals(items.get(k), ringbuffer.readOne(startSequence + k));\n    }\n  }\n}"
    },
    {
        "id": 61,
        "original": "@Test\npublic void testGetUntaggedName() throws VersioningSyntaxException {\n  VersioningService instance = new VersioningService();\n  String expression = APPLICATION_NAME + VersioningService.EXPRESSION_SEPARATOR + \"RC-\" + VersioningService.EXPRESSION_WILDCARD;\n  String result = instance.getUntaggedName(expression);\n  assertEquals(APPLICATION_NAME, result);\n  expression = APPLICATION_NAME + VersioningService.EXPRESSION_SEPARATOR + \"RC-1.0.0\";\n  result = instance.getUntaggedName(expression);\n  assertEquals(APPLICATION_NAME, result);\n  expression = APPLICATION_NAME;\n  result = instance.getUntaggedName(expression);\n  assertEquals(APPLICATION_NAME, result);\n  expression = APPLICATION_NAME + VersioningService.EXPRESSION_SEPARATOR;\n  try {\n    result = instance.getUntaggedName(expression);\n    fail(\"the getUntagged method did not throw a VersioningSyntaxException\");\n  } catch (VersioningSyntaxException e) {}\n}",
        "prediction": "@Test\npublic void testGetUntaggedName() throws VersioningSyntaxException {\n  String expression = APPLICATION_NAME + VersioningService.EXPRESSION_SEPARATOR + \"RC-\" + VersioningService.EXPRESSION_WILDCARD;\n  String result = VersioningService.getUntaggedName(expression);\n  assertEquals(APPLICATION_NAME, result);\n  expression = APPLICATION_NAME + VersioningService.EXPRESSION_SEPARATOR + \"RC-1.0.0\";\n  result = VersioningService.getUntaggedName(expression);\n  assertEquals(APPLICATION_NAME, result);\n  expression = APPLICATION_NAME;\n  result = VersioningService.getUntaggedName(expression);\n  assertEquals(APPLICATION_NAME, result);\n  expression = APPLICATION_NAME + VersioningService.EXPRESSION_SEPARATOR;\n  try {\n    result = VersioningService.getUntaggedName(expression);\n    fail(\"the getUntagged method did not throw a VersioningSyntaxException\");\n  } catch (VersioningSyntaxException e) {}\n}",
        "reference": "@Test\npublic void testGetUntaggedName() throws VersioningSyntaxException {\n  String expression = APPLICATION_NAME + VersioningService.EXPRESSION_SEPARATOR + \"RC-\" + VersioningService.EXPRESSION_WILDCARD;\n  String result = VersioningService.getUntaggedName(expression);\n  assertEquals(APPLICATION_NAME, result);\n  expression = APPLICATION_NAME + VersioningService.EXPRESSION_SEPARATOR + \"RC-1.0.0\";\n  result = VersioningService.getUntaggedName(expression);\n  assertEquals(APPLICATION_NAME, result);\n  expression = APPLICATION_NAME;\n  result = VersioningService.getUntaggedName(expression);\n  assertEquals(APPLICATION_NAME, result);\n  expression = APPLICATION_NAME + VersioningService.EXPRESSION_SEPARATOR;\n  try {\n    result = VersioningService.getUntaggedName(expression);\n    fail(\"the getUntagged method did not throw a VersioningSyntaxException\");\n  } catch (VersioningSyntaxException e) {}\n}"
    },
    {
        "id": 62,
        "original": "@Test(description = \"PUT /vApp/{id}\", dependsOnMethods = {\"testGetVApp\"})\npublic void testModifyVApp() {\n  VApp newVApp = VApp.builder().name(name(\"new-name-\")).description(\"New Description\").build();\n  vAppNames.add(newVApp.getName());\n  Task modifyVApp = vAppApi.modifyVApp(vApp.getHref(), newVApp);\n  assertTrue(retryTaskSuccess.apply(modifyVApp), String.format(TASK_COMPLETE_TIMELY, \"modifyVApp\"));\n  vApp = vAppApi.getVApp(vApp.getHref());\n  assertEquals(vApp.getName(), newVApp.getName(), String.format(OBJ_FIELD_EQ, VAPP, \"Name\", newVApp.getName(), vApp.getName()));\n  assertEquals(vApp.getDescription(), newVApp.getDescription(), String.format(OBJ_FIELD_EQ, VAPP, \"Description\", newVApp.getDescription(), vApp.getDescription()));\n}",
        "prediction": "@Test(description = \"PUT /vApp/{id}\", dependsOnMethods = {\"testGetVApp\"})\npublic void testModifyVApp() {\n  VApp newVApp = VApp.builder().name(name(\"new-name-\")).description(\"New Description\").build();\n  vAppNames.add(newVApp.getName());\n  Task modifyVApp = vAppApi.editVApp(vApp.getHref(), newVApp);\n  assertTrue(retryTaskSuccess.apply(modifyVApp), String.format(TASK_COMPLETE_TIMELY, \"modifyVApp\"));\n  vApp = vAppApi.getVApp(vApp.getHref());\n  assertEquals(vApp.getName(), newVApp.getName(), String.format(OBJ_FIELD_EQ, VAPP, \"Name\", newVApp.getName(), vApp.getName()));\n  assertEquals(vApp.getDescription(), newVApp.getDescription(), String.format(OBJ_FIELD_EQ, VAPP, \"Description\", newVApp.getDescription(), vApp.getDescription()));\n}",
        "reference": "@Test(description = \"PUT /vApp/{id}\", dependsOnMethods = {\"testGetVApp\"})\npublic void testEditVApp() {\n  VApp newVApp = VApp.builder().name(name(\"new-name-\")).description(\"New Description\").build();\n  vAppNames.add(newVApp.getName());\n  Task editVApp = vAppApi.editVApp(vApp.getHref(), newVApp);\n  assertTrue(retryTaskSuccess.apply(editVApp), String.format(TASK_COMPLETE_TIMELY, \"editVApp\"));\n  vApp = vAppApi.getVApp(vApp.getHref());\n  assertEquals(vApp.getName(), newVApp.getName(), String.format(OBJ_FIELD_EQ, VAPP, \"Name\", newVApp.getName(), vApp.getName()));\n  assertEquals(vApp.getDescription(), newVApp.getDescription(), String.format(OBJ_FIELD_EQ, VAPP, \"Description\", newVApp.getDescription(), vApp.getDescription()));\n}"
    },
    {
        "id": 63,
        "original": "@Test(description = \"GET /v${apiVersion}/{tenantId}/flavors/detail\")\npublic void testListFlavorsInDetail() throws Exception {\n  for (String zoneId : zones) {\n    FlavorApi api = novaContext.getApi().getFlavorApiForZone(zoneId);\n    Set<? extends Flavor> response = api.listFlavorsInDetail();\n    assertNotNull(response);\n    assertFalse(response.isEmpty());\n    for (Flavor flavor : response) {\n      assertNotNull(flavor.getId());\n      assertNotNull(flavor.getName());\n      assertNotNull(flavor.getLinks());\n      assertTrue(flavor.getRam() > 0);\n      assertTrue(flavor.getDisk() > 0);\n      assertTrue(flavor.getVcpus() > 0);\n    }\n  }\n}",
        "prediction": "@Test(description = \"GET /v${apiVersion}/{tenantId}/flavors/detail\")\npublic void testListFlavorsInDetail() throws Exception {\n  for (String zoneId : zones) {\n    FlavorApi api = novaContext.getApi().getFlavorApiForZone(zoneId);\n    PagedIterable<? extends Flavor> response = api.listInDetail();\n    assertNotNull(response);\n    assertFalse(response.isEmpty());\n    for (Flavor flavor : response) {\n      assertNotNull(flavor.getId());\n      assertNotNull(flavor.getName());\n      assertNotNull(flavor.getLinks());\n      assertTrue(flavor.getRam() > 0);\n      assertTrue(flavor.getDisk() > 0);\n      assertTrue(flavor.getVcpus() > 0);\n    }\n  }\n}",
        "reference": "@Test(description = \"GET /v${apiVersion}/{tenantId}/flavors/detail\")\npublic void testListFlavorsInDetail() throws Exception {\n  for (String zoneId : zones) {\n    FlavorApi api = novaContext.getApi().getFlavorApiForZone(zoneId);\n    Set<? extends Flavor> response = api.listInDetail().concat().toImmutableSet();\n    assertNotNull(response);\n    assertFalse(response.isEmpty());\n    for (Flavor flavor : response) {\n      assertNotNull(flavor.getId());\n      assertNotNull(flavor.getName());\n      assertNotNull(flavor.getLinks());\n      assertTrue(flavor.getRam() > 0);\n      assertTrue(flavor.getDisk() > 0);\n      assertTrue(flavor.getVcpus() > 0);\n    }\n  }\n}"
    },
    {
        "id": 64,
        "original": "@Test(description = \"GET /v${apiVersion}/{tenantId}/flavors\")\npublic void testListFlavors() throws Exception {\n  for (String zoneId : zones) {\n    FlavorApi api = novaContext.getApi().getFlavorApiForZone(zoneId);\n    Set<? extends Resource> response = api.listFlavors();\n    assertNotNull(response);\n    assertFalse(response.isEmpty());\n    for (Resource flavor : response) {\n      assertNotNull(flavor.getId());\n      assertNotNull(flavor.getName());\n      assertNotNull(flavor.getLinks());\n    }\n  }\n}",
        "prediction": "@Test(description = \"GET /v${apiVersion}/{tenantId}/flavors\")\npublic void testListFlavors() throws Exception {\n  for (String zoneId : zones) {\n    FlavorApi api = novaContext.getApi().getFlavorApiForZone(zoneId);\n    PagedIterable<? extends Resource> response = api.list();\n    assertNotNull(response);\n    assertFalse(response.isEmpty());\n    for (Resource flavor : response) {\n      assertNotNull(flavor.getId());\n      assertNotNull(flavor.getName());\n      assertNotNull(flavor.getLinks());\n    }\n  }\n}",
        "reference": "@Test(description = \"GET /v${apiVersion}/{tenantId}/flavors\")\npublic void testListFlavors() throws Exception {\n  for (String zoneId : zones) {\n    FlavorApi api = novaContext.getApi().getFlavorApiForZone(zoneId);\n    Set<? extends Resource> response = api.list().concat().toImmutableSet();\n    assertNotNull(response);\n    assertFalse(response.isEmpty());\n    for (Resource flavor : response) {\n      assertNotNull(flavor.getId());\n      assertNotNull(flavor.getName());\n      assertNotNull(flavor.getLinks());\n    }\n  }\n}"
    },
    {
        "id": 65,
        "original": "@Test\npublic void testGetChecksum_FileNotFound() throws Exception {\n  System.out.println(\"getChecksum (invalid path)\");\n  String algorithm = \"MD5\";\n  File file = new File(\"not a valid file\");\n  boolean exceptionThrown = false;\n  try {\n    byte[] result = Checksum.getChecksum(algorithm, file);\n  } catch (FileNotFoundException ex) {\n    exceptionThrown = true;\n  }\n  assertTrue(exceptionThrown);\n}",
        "prediction": "@Test\npublic void testGetChecksum_FileNotFound() throws Exception {\n  System.out.println(\"getChecksum (invalid path)\");\n  String algorithm = \"MD5\";\n  File file = new File(\"not a valid file\");\n  boolean exceptionThrown = false;\n  try {\n    byte[] result = Checksum.getChecksum(algorithm, file);\n  } catch (IOException ex) {\n    exceptionThrown = true;\n  }\n  assertTrue(exceptionThrown);\n}",
        "reference": "@Test\npublic void testGetChecksum_FileNotFound() throws Exception {\n  System.out.println(\"getChecksum (invalid path)\");\n  String algorithm = \"MD5\";\n  File file = new File(\"not a valid file\");\n  boolean exceptionThrown = false;\n  try {\n    byte[] result = Checksum.getChecksum(algorithm, file);\n  } catch (IOException ex) {\n    exceptionThrown = true;\n  }\n  assertTrue(exceptionThrown);\n}"
    },
    {
        "id": 66,
        "original": "@Test\npublic void testAnalyze() throws Exception {\n  System.out.println(\"analyze\");\n  File file = new File(this.getClass().getClassLoader().getResource(\"struts2-core-2.1.2.jar\").getPath());\n  Dependency result = new Dependency(file);\n  FileNameAnalyzer instance = new FileNameAnalyzer();\n  instance.analyze(result);\n  assertTrue(result.getVendorEvidence().toString().toLowerCase().contains(\"struts\"));\n}",
        "prediction": "@Test\npublic void testAnalyze() throws Exception {\n  System.out.println(\"analyze\");\n  File file = new File(this.getClass().getClassLoader().getResource(\"struts2-core-2.1.2.jar\").getPath());\n  Dependency result = new Dependency(file);\n  FileNameAnalyzer instance = new FileNameAnalyzer();\n  Engine engine = new Engine();\n  instance.analyze(result, engine);\n  assertTrue(result.getVendorEvidence().toString().toLowerCase().contains(\"struts\"));\n}",
        "reference": "@Test\npublic void testAnalyze() throws Exception {\n  System.out.println(\"analyze\");\n  File file = new File(this.getClass().getClassLoader().getResource(\"struts2-core-2.1.2.jar\").getPath());\n  Dependency result = new Dependency(file);\n  FileNameAnalyzer instance = new FileNameAnalyzer();\n  instance.analyze(result, null);\n  assertTrue(result.getVendorEvidence().toString().toLowerCase().contains(\"struts\"));\n}"
    },
    {
        "id": 67,
        "original": "@Test\npublic void testRemoveProperty() {\n  String key = \"SomeKey\";\n  String value = \"value\";\n  String dfault = \"default\";\n  Settings.setString(key, value);\n  String ret = Settings.getString(key);\n  Assert.assertEquals(value, ret);\n  Settings.removeProperty(key);\n  ret = Settings.getString(key, dfault);\n  Assert.assertEquals(dfault, ret);\n}",
        "prediction": "@Test\npublic void testRemoveProperty() {\n  String key = \"SomeKey\";\n  String value = \"value\";\n  String dfault = \"default\";\n  Settings settings = new Settings();\n  settings.setString(key, value);\n  String ret = settings.getString(key);\n  Assert.assertEquals(value, ret);\n  settings.removeProperty(key);\n  ret = settings.getString(key, dfault);\n  Assert.assertEquals(dfault, ret);\n}",
        "reference": "@Test\npublic void testRemoveProperty() {\n  String key = \"SomeKey\";\n  String value = \"value\";\n  String dfault = \"default\";\n  getSettings().setString(key, value);\n  String ret = getSettings().getString(key);\n  Assert.assertEquals(value, ret);\n  getSettings().removeProperty(key);\n  ret = getSettings().getString(key, dfault);\n  Assert.assertEquals(dfault, ret);\n}"
    },
    {
        "id": 68,
        "original": "@Test\npublic void testInAbbrevJournalNames_case1() throws Exception {\n  String input = \"Nature\";\n  List<OffsetPosition> journalsPositions = target.inAbbrevJournalNames(input);\n  assertNotNull(journalsPositions);\n  assertThat(journalsPositions, hasSize(1));\n  assertThat(journalsPositions.get(0).start, is(0));\n}",
        "prediction": "@Test\npublic void testInAbbrevJournalNames_case1() throws Exception {\n  String input = \"Nature\";\n  List<OffsetPosition> journalsPositions = target.tokenPositionsAbbrevJournalNames(input);\n  assertNotNull(journalsPositions);\n  assertThat(journalsPositions, hasSize(1));\n  assertThat(journalsPositions.get(0).start, is(0));\n}",
        "reference": "@Test\npublic void testInAbbrevJournalNames_case1() throws Exception {\n  String input = \"Nature\";\n  List<OffsetPosition> journalsPositions = target.tokenPositionsAbbrevJournalNames(input);\n  assertNotNull(journalsPositions);\n  assertThat(journalsPositions, hasSize(1));\n  assertThat(journalsPositions.get(0).start, is(0));\n}"
    },
    {
        "id": 69,
        "original": "@Test\npublic void testMatcherList_location() throws Exception {\n  target = new FastMatcher(this.getClass().getResourceAsStream(\"location.txt\"));\n  final List<OffsetPosition> offsetPositions = target.matcher(Arrays.asList(\"I\", \"m\", \"walking\", \"in\", \"The\", \"Bronx\"));\n  assertThat(offsetPositions, hasSize(2));\n  assertThat(offsetPositions.get(0).start, is(4));\n  assertThat(offsetPositions.get(0).end, is(5));\n  assertThat(offsetPositions.get(1).start, is(5));\n  assertThat(offsetPositions.get(1).end, is(5));\n}",
        "prediction": "@Test\npublic void testMatcherList_location() throws Exception {\n  target = new FastMatcher(this.getClass().getResourceAsStream(\"location.txt\"));\n  final List<LayoutToken> tokens = Arrays.asList(new LayoutToken(\"I\"), new LayoutToken(\"m\"), new LayoutToken(\"walking\"), new LayoutToken(\"in\"), new LayoutToken(\"The\"), new LayoutToken(\"Bronx\"));\n  final List<OffsetPosition> offsetPositions = target.matchLayoutToken(tokens);\n  assertThat(offsetPositions, hasSize(2));\n  assertThat(offsetPositions.get(0).start, is(4));\n  assertThat(offsetPositions.get(0).end, is(5));\n  assertThat(offsetPositions.get(1).start, is(5));\n  assertThat(offsetPositions.get(1).end, is(5));\n}",
        "reference": "@Test\npublic void testMatcherList_location() throws Exception {\n  target = new FastMatcher(this.getClass().getResourceAsStream(\"location.txt\"));\n  final String input = \"I'm walking in The Bronx\";\n  List<LayoutToken> tokenisedInput = GrobidAnalyzer.getInstance().tokenizeWithLayoutToken(input);\n  final List<OffsetPosition> offsetPositions = target.matchLayoutToken(tokenisedInput);\n  assertThat(offsetPositions, hasSize(2));\n  assertThat(offsetPositions.get(0).start, is(8));\n  assertThat(offsetPositions.get(0).end, is(10));\n  assertThat(offsetPositions.get(1).start, is(10));\n  assertThat(offsetPositions.get(1).end, is(10));\n}"
    },
    {
        "id": 70,
        "original": "@Test\npublic void testMatchString_location() throws Exception {\n  target = new FastMatcher(this.getClass().getResourceAsStream(\"location.txt\"));\n  final String input = \"I'm walking in The Bronx\";\n  final List<OffsetPosition> positions = target.match(input);\n  assertThat(positions, hasSize(2));\n  assertThat(positions.get(0).start, is(15));\n  assertThat(positions.get(0).end, is(24));\n  assertThat(positions.get(1).start, is(19));\n  assertThat(positions.get(1).end, is(24));\n}",
        "prediction": "@Test\npublic void testMatchString_location() throws Exception {\n  target = new FastMatcher(this.getClass().getResourceAsStream(\"location.txt\"));\n  final String input = \"I'm walking in The Bronx\";\n  final List<OffsetPosition> positions = target.matchCharacter(input);\n  assertThat(positions, hasSize(2));\n  assertThat(positions.get(0).start, is(15));\n  assertThat(positions.get(0).end, is(24));\n  assertThat(positions.get(1).start, is(19));\n  assertThat(positions.get(1).end, is(24));\n}",
        "reference": "@Test\npublic void testMatchString_location() throws Exception {\n  target = new FastMatcher(this.getClass().getResourceAsStream(\"location.txt\"));\n  final String input = \"I'm walking in The Bronx\";\n  final List<OffsetPosition> positions = target.matchCharacter(input);\n  assertThat(positions, hasSize(2));\n  assertThat(positions.get(0).start, is(15));\n  assertThat(positions.get(0).end, is(24));\n  assertThat(positions.get(1).start, is(19));\n  assertThat(positions.get(1).end, is(24));\n}"
    },
    {
        "id": 71,
        "original": "@Test\npublic void testMatchList_location_1Match() throws Exception {\n  target = new FastMatcher(this.getClass().getResourceAsStream(\"location.txt\"));\n  final String input = \"This is Bronx\";\n  final List<OffsetPosition> offsetPositions = target.match(Arrays.asList(input.split(\" \")));\n  assertThat(offsetPositions, hasSize(1));\n  assertThat(offsetPositions.get(0).start, is(2));\n  assertThat(offsetPositions.get(0).end, is(2));\n}",
        "prediction": "@Test\npublic void testMatchList_location_1Match() throws Exception {\n  target = new FastMatcher(this.getClass().getResourceAsStream(\"location.txt\"));\n  final String input = \"This is Bronx\";\n  final List<LayoutToken> layoutTokens = Arrays.asList(input.split(\" \")).stream()\n      .map(LayoutToken::new)\n      .collect(Collectors.toList());\n  final List<OffsetPosition> offsetPositions = target.matchCharacterLayoutToken(layoutTokens);\n  assertThat(offsetPositions, hasSize(1));\n  assertThat(offsetPositions.get(0).start, is(2));\n  assertThat(offsetPositions.get(0).end, is(2));\n}",
        "reference": "@Test\npublic void testMatchList_location_1Match() throws Exception {\n  target = new FastMatcher(this.getClass().getResourceAsStream(\"location.txt\"));\n  final String input = \"This is Bronx\";\n  List<LayoutToken> tokenisedInput = GrobidAnalyzer.getInstance().tokenizeWithLayoutToken(input);\n  final List<OffsetPosition> offsetPositions = target.matchCharacterLayoutToken(tokenisedInput);\n  assertThat(offsetPositions, hasSize(1));\n  assertThat(offsetPositions.get(0).start, is(4));\n  assertThat(offsetPositions.get(0).end, is(4));\n}"
    },
    {
        "id": 72,
        "original": "@Test\npublic void testDownloadFileFromServer() throws Exception {\n  final RestfulMgr restfulMgr = new RestfulMgrMock().getMockInstance();\n  FetcherMgr fetcherMgr = new FetcherMgrImpl(restfulMgr, 3, 5, true, \"\", new ArrayList<String>());\n  try {\n    String valueString = fetcherMgr.downloadFileFromServer(requestUrl, RestfulMgrMock.defaultFileName);\n    Assert.assertEquals(RestfulMgrMock.defaultFileName, valueString);\n  } catch (Exception e) {\n    e.printStackTrace();\n    Assert.assertTrue(false);\n  }\n}",
        "prediction": "@Test\npublic void testDownloadFileFromServer() throws Exception {\n  final RestfulMgr restfulMgr = new RestfulMgrMock().getMockInstance();\n  FetcherMgr fetcherMgr = new FetcherMgrImpl(restfulMgr, 3, 5, true, \"\", new ArrayList<String>());\n  try {\n    String targetFileDir = \"targetDirectory\"; // Add target directory based on your requirement\n    String valueString = fetcherMgr.downloadFileFromServer(requestUrl, RestfulMgrMock.defaultFileName, targetFileDir);\n    Assert.assertEquals(RestfulMgrMock.defaultFileName, valueString);\n  } catch (Exception e) {\n    e.printStackTrace();\n    Assert.assertTrue(false);\n  }\n}",
        "reference": "@Test\npublic void testDownloadFileFromServer() throws Exception {\n  final RestfulMgr restfulMgr = new RestfulMgrMock().getMockInstance();\n  FetcherMgr fetcherMgr = new FetcherMgrImpl(restfulMgr, 3, 5, true, \"\", new ArrayList<String>());\n  try {\n    String valueString = fetcherMgr.downloadFileFromServer(requestUrl, RestfulMgrMock.defaultFileName, \"./disconf\");\n    Assert.assertEquals(RestfulMgrMock.defaultFileName, valueString);\n  } catch (Exception e) {\n    e.printStackTrace();\n    Assert.assertTrue(false);\n  }\n}"
    },
    {
        "id": 73,
        "original": "@Test\npublic void setImage() {\n  ImageFloat32 image = new ImageFloat32(640, 480);\n  GImageMiscOps.fillUniform(image, rand, 0, 200);\n  UnrollSiftScaleSpaceGradient alg = new UnrollSiftScaleSpaceGradient(new SiftScaleSpace(-1, 3, 3, 2));\n  alg.setImage(image);\n  SiftScaleSpace ss = new SiftScaleSpace(-1, 3, 3, 2);\n  ss.initialize(image);\n  ImageFloat32 derivX = new ImageFloat32(640, 480);\n  ImageFloat32 derivY = new ImageFloat32(640, 480);\n  int total = 0;\n  do {\n    for (int i = 0; i < ss.getNumScales(); i++, total++) {\n      ImageFloat32 scaleImage = ss.getImageScale(i);\n      derivX.reshape(scaleImage.width, scaleImage.height);\n      derivY.reshape(scaleImage.width, scaleImage.height);\n      GImageDerivativeOps.gradient(DerivativeType.THREE, scaleImage, derivX, derivY, BorderType.EXTENDED);\n      UnrollSiftScaleSpaceGradient.ImageScale found = alg.usedScales.get(total);\n      BoofTesting.assertEquals(derivX, found.derivX, 1e-4);\n      BoofTesting.assertEquals(derivY, found.derivY, 1e-4);\n      assertEquals(ss.computeSigmaScale(i), found.sigma, 1e-4);\n      assertEquals(image.width / (double)scaleImage.width, found.imageToInput, 1e-4);\n    }\n  } while (ss.computeNextOctave());\n}",
        "prediction": "@Test\npublic void setImage() {\n  GrayF32 image = new GrayF32(640, 480);\n  GImageMiscOps.fillUniform(image, rand, 0, 200);\n  UnrollSiftScaleSpaceGradient alg = new UnrollSiftScaleSpaceGradient(new SiftScaleSpace(-1, 3, 3, 2));\n  alg.setImage(image);\n  SiftScaleSpace ss = new SiftScaleSpace(-1, 3, 3, 2);\n  ss.initialize(image);\n  GrayF32 derivX = new GrayF32(640, 480);\n  GrayF32 derivY = new GrayF32(640, 480);\n  int total = 0;\n  do {\n    for (int i = 0; i < ss.getNumScales(); i++, total++) {\n      GrayF32 scaleImage = ss.getImageScale(i);\n      derivX.reshape(scaleImage.width, scaleImage.height);\n      derivY.reshape(scaleImage.width, scaleImage.height);\n      GImageDerivativeOps.gradient(DerivativeType.THREE, scaleImage, derivX, derivY, BorderType.EXTENDED);\n      UnrollSiftScaleSpaceGradient.ImageScale found = alg.usedScales.get(total);\n      BoofTesting.assertEquals(derivX, found.derivX, 1e-4);\n      BoofTesting.assertEquals(derivY, found.derivY, 1e-4);\n      assertEquals(ss.computeSigmaScale(i), found.sigma, 1e-4);\n      assertEquals(image.width / (double)scaleImage.width, found.imageToInput, 1e-4);\n    }\n  } while (ss.computeNextOctave());\n}",
        "reference": "@Test\npublic void setImage() {\n  GrayF32 image = new GrayF32(640, 480);\n  GImageMiscOps.fillUniform(image, rand, 0, 200);\n  UnrollSiftScaleSpaceGradient alg = new UnrollSiftScaleSpaceGradient(new SiftScaleSpace(-1, 3, 3, 2));\n  alg.setImage(image);\n  SiftScaleSpace ss = new SiftScaleSpace(-1, 3, 3, 2);\n  ss.initialize(image);\n  GrayF32 derivX = new GrayF32(640, 480);\n  GrayF32 derivY = new GrayF32(640, 480);\n  int total = 0;\n  do {\n    for (int i = 0; i < ss.getNumScales(); i++, total++) {\n      GrayF32 scaleImage = ss.getImageScale(i);\n      derivX.reshape(scaleImage.width, scaleImage.height);\n      derivY.reshape(scaleImage.width, scaleImage.height);\n      GImageDerivativeOps.gradient(DerivativeType.THREE, scaleImage, derivX, derivY, BorderType.EXTENDED);\n      UnrollSiftScaleSpaceGradient.ImageScale found = alg.usedScales.get(total);\n      BoofTesting.assertEquals(derivX, found.derivX, 1e-4);\n      BoofTesting.assertEquals(derivY, found.derivY, 1e-4);\n      assertEquals(ss.computeSigmaScale(i), found.sigma, 1e-4);\n      assertEquals(image.width / (double)scaleImage.width, found.imageToInput, 1e-4);\n    }\n  } while (ss.computeNextOctave());\n}"
    },
    {
        "id": 74,
        "original": "@Test\npublic void fit_obvious() {\n  List<Point2D_I32> contours = createSquare(10, 12, 20, 30);\n  GrowQueue_I32 corners = createSquareCorners(10, 12, 20, 30);\n  corners.add(corners.get(3) + 4);\n  MinimizeEnergyPrune alg = new MinimizeEnergyPrune(1);\n  GrowQueue_I32 output = new GrowQueue_I32();\n  alg.fit(contours, corners, output);\n  assertEquals(4, output.size());\n  for (int i = 0; i < 4; i++) {\n    assertEquals(corners.get(i), output.get(i));\n  }\n}",
        "prediction": "@Test\npublic void fit_obvious() {\n  List<Point2D_I32> contours = createSquare(10, 12, 20, 30);\n  GrowQueue_I32 corners = createSquareCorners(10, 12, 20, 30);\n  corners.add(corners.get(3) + 4);\n  MinimizeEnergyPrune alg = new MinimizeEnergyPrune(1);\n  GrowQueue_I32 output = new GrowQueue_I32();\n  alg.prune(contours, corners, output);\n  assertEquals(4, output.size());\n  for (int i = 0; i < 4; i++) {\n    assertEquals(corners.get(i), output.get(i));\n  }\n}",
        "reference": "@Test\npublic void prune_obvious() {\n  List<Point2D_I32> contours = createSquare(10, 12, 20, 30);\n  GrowQueue_I32 corners = createSquareCorners(10, 12, 20, 30);\n  corners.add(corners.get(3) + 4);\n  MinimizeEnergyPrune alg = new MinimizeEnergyPrune(1);\n  GrowQueue_I32 output = new GrowQueue_I32();\n  alg.prune(contours, corners, output);\n  assertEquals(4, output.size());\n  checkMatched(corners, output);\n}"
    },
    {
        "id": 75,
        "original": "@Test\nvoid computeCostInnerD() {\n  Planar<GrayU16> costYXD = new Planar<>(GrayU16.class, rangeD, width, height);\n  GImageMiscOps.fillUniform(costYXD, rand, 0, SgmDisparityCost.MAX_COST);\n  SgmCostAggregation alg = new SgmCostAggregation();\n  alg.init(costYXD);\n  for (int i = 0; i < alg.workCostLr.length; i++) {\n    alg.workCostLr[i] = (short)rand.nextInt(SgmDisparityCost.MAX_COST);\n  }\n  GrayU16 costXD = costYXD.getBand(2);\n  int x = rangeD + 2;\n  int pathI = 3;\n  int idxCost = costXD.getIndex(0, x);\n  int idxWork = alg.lengthD * pathI;\n  alg.computeCostInnerD(costXD, idxCost, idxWork, rangeD);\n  for (int d = 1; d < rangeD - 1; d++) {\n    int cost_p_d = costXD.get(d, x);\n    int l0 = workArray(alg, pathI, d);\n    int l1 = workArray(alg, pathI, d - 1) + alg.penalty1;\n    int l2 = workArray(alg, pathI, d + 1) + alg.penalty1;\n    int l3 = alg.penalty2;\n    int v = min(min(min(l0, l1), l2), l3);\n    int expected = cost_p_d + v;\n    int found = workArray(alg, pathI + 1, d);\n    assertEquals(expected, found);\n  }\n}",
        "prediction": "@Test\nvoid computeCostInnerD() {\n  Planar<GrayU16> costYXD = new Planar<>(GrayU16.class, rangeD, width, height);\n  GImageMiscOps.fillUniform(costYXD, rand, 0, SgmDisparityCost.MAX_COST);\n  SgmCostAggregation alg = new SgmCostAggregation();\n  alg.init(costYXD);\n  for (int i = 0; i < alg.workCostLr.length; i++) {\n    alg.workCostLr[i] = (short)rand.nextInt(SgmDisparityCost.MAX_COST);\n  }\n  GrayU16 costXD = costYXD.getBand(2);\n  int x = rangeD + 2;\n  int pathI = 3;\n  int idxCost = costXD.getIndex(0, x);\n  int idxWork = alg.lengthD * pathI;\n  alg.computeCostInnerD(costXD, idxCost, idxWork, rangeD, alg.workCostLr);\n  for (int d = 1; d < rangeD - 1; d++) {\n    int cost_p_d = costXD.get(d, x);\n    int l0 = workArray(alg, pathI, d);\n    int l1 = workArray(alg, pathI, d - 1) + alg.penalty1;\n    int l2 = workArray(alg, pathI, d + 1) + alg.penalty1;\n    int l3 = alg.penalty2;\n    int v = min(min(min(l0, l1), l2), l3);\n    int expected = cost_p_d + v;\n    int found = workArray(alg, pathI + 1, d);\n    assertEquals(expected, found);\n  }\n}",
        "reference": "@Test\nvoid computeCostInnerD() {\n  Planar<GrayU16> costYXD = new Planar<>(GrayU16.class, rangeD, width, height);\n  GImageMiscOps.fillUniform(costYXD, rand, 0, SgmDisparityCost.MAX_COST);\n  SgmCostAggregation alg = new SgmCostAggregation();\n  alg.init(costYXD);\n  short[] workCostLr = alg.workspace.get(0).workCostLr;\n  for (int i = 0; i < workCostLr.length; i++) {\n    workCostLr[i] = (short)rand.nextInt(SgmDisparityCost.MAX_COST);\n  }\n  GrayU16 costXD = costYXD.getBand(2);\n  int x = rangeD + 2;\n  int pathI = 3;\n  int idxCost = costXD.getIndex(0, x);\n  int idxWork = alg.lengthD * pathI;\n  alg.computeCostInnerD(costXD, idxCost, idxWork, rangeD, workCostLr);\n  for (int d = 1; d < rangeD - 1; d++) {\n    int cost_p_d = costXD.get(d, x);\n    int l0 = workArray(alg, pathI, d);\n    int l1 = workArray(alg, pathI, d - 1) + alg.penalty1;\n    int l2 = workArray(alg, pathI, d + 1) + alg.penalty1;\n    int l3 = alg.penalty2;\n    int v = min(min(min(l0, l1), l2), l3);\n    int expected = cost_p_d + v;\n    int found = workArray(alg, pathI + 1, d);\n    assertEquals(expected, found);\n  }\n}"
    },
    {
        "id": 76,
        "original": "@Test\npublic void gaussian() {\n  for (int totalOrder = 1; totalOrder <= 4; totalOrder++) {\n    for (int orderX = 0; orderX <= totalOrder; orderX++) {\n      int orderY = totalOrder - orderX;\n      SteerableKernel<Kernel2D_F32> alg = FactorySteerable.gaussian(Kernel2D_F32.class, orderX, orderY, 10);\n      Kernel2D_F32 k = alg.compute(0.1);\n      boolean notZero = false;\n      for (int y = 0; y < k.width; y++) {\n        for (int x = 0; x < k.width; x++) {\n          if (k.get(x, y) != 0)\n            notZero = true;\n        }\n      }\n      assertTrue(notZero);\n    }\n  }\n}",
        "prediction": "@Test\npublic void gaussian() {\n  for (int totalOrder = 1; totalOrder <= 4; totalOrder++) {\n    for (int orderX = 0; orderX <= totalOrder; orderX++) {\n      int orderY = totalOrder - orderX;\n      double sigma = 1.0; // or any other appropriate value\n      SteerableKernel<Kernel2D_F32> alg = FactorySteerable.gaussian(Kernel2D_F32.class, orderX, orderY, sigma, 10);\n      Kernel2D_F32 k = alg.compute(0.1);\n      boolean notZero = false;\n      for (int y = 0; y < k.width; y++) {\n        for (int x = 0; x < k.width; x++) {\n          if (k.get(x, y) != 0)\n            notZero = true;\n        }\n      }\n      assertTrue(notZero);\n    }\n  }\n}",
        "reference": "@Test\npublic void gaussian() {\n  for (int totalOrder = 1; totalOrder <= 4; totalOrder++) {\n    for (int orderX = 0; orderX <= totalOrder; orderX++) {\n      int orderY = totalOrder - orderX;\n      SteerableKernel<Kernel2D_F32> alg = FactorySteerable.gaussian(Kernel2D_F32.class, orderX, orderY, -1, 10);\n      Kernel2D_F32 k = alg.compute(0.1);\n      boolean notZero = false;\n      for (int y = 0; y < k.width; y++) {\n        for (int x = 0; x < k.width; x++) {\n          if (k.get(x, y) != 0)\n            notZero = true;\n        }\n      }\n      assertTrue(notZero);\n    }\n  }\n}"
    },
    {
        "id": 77,
        "original": "@Test\npublic void fullView_Transform() {\n  IntrinsicParameters param = new IntrinsicParameters().fsetK(300, 320, 0, 150, 130, width, height).fsetRadial(0.1, 0.05);\n  PointTransform_F32 adjToDist = LensDistortionOps.fullView(param, null, true);\n  PointTransform_F32 distToAdj = LensDistortionOps.fullView(param, null, false);\n  checkBorderOutside(adjToDist, distToAdj);\n  param = new IntrinsicParameters().fsetK(300, 320, 0, 150, 130, width, height).fsetRadial(-0.1, -0.05);\n  adjToDist = LensDistortionOps.fullView(param, null, true);\n  distToAdj = LensDistortionOps.fullView(param, null, false);\n  checkBorderOutside(adjToDist, distToAdj);\n}",
        "prediction": "@Test\npublic void fullView_Transform() {\n  IntrinsicParameters param = new IntrinsicParameters().fsetK(300, 320, 0, 150, 130, width, height).fsetRadial(0.1, 0.05);\n  PointTransform_F32 adjToDist = LensDistortionOps.transform_F32(AdjustmentType.FULL_VIEW, param, null, true);\n  PointTransform_F32 distToAdj = LensDistortionOps.transform_F32(AdjustmentType.FULL_VIEW, param, null, false);\n  checkBorderOutside(adjToDist, distToAdj);\n  param = new IntrinsicParameters().fsetK(300, 320, 0, 150, 130, width, height).fsetRadial(-0.1, -0.05);\n  adjToDist = LensDistortionOps.transform_F32(AdjustmentType.FULL_VIEW, param, null, true);\n  distToAdj = LensDistortionOps.transform_F32(AdjustmentType.FULL_VIEW, param, null, false);\n  checkBorderOutside(adjToDist, distToAdj);\n}",
        "reference": "@Test\npublic void transform_F32_fullView() {\n  IntrinsicParameters param = new IntrinsicParameters().fsetK(300, 320, 0, 150, 130, width, height).fsetRadial(0.1, 0.05);\n  PointTransform_F32 adjToDist = LensDistortionOps.transform_F32(AdjustmentType.FULL_VIEW, param, null, true);\n  PointTransform_F32 distToAdj = LensDistortionOps.transform_F32(AdjustmentType.FULL_VIEW, param, null, false);\n  checkBorderOutside(adjToDist, distToAdj);\n  param = new IntrinsicParameters().fsetK(300, 320, 0, 150, 130, width, height).fsetRadial(-0.1, -0.05);\n  adjToDist = LensDistortionOps.transform_F32(AdjustmentType.FULL_VIEW, param, null, true);\n  distToAdj = LensDistortionOps.transform_F32(AdjustmentType.FULL_VIEW, param, null, false);\n  checkBorderOutside(adjToDist, distToAdj);\n}"
    },
    {
        "id": 78,
        "original": "@Test\npublic void allInside_Transform() {\n  IntrinsicParameters param = new IntrinsicParameters().fsetK(300, 320, 0, 150, 130, width, height).fsetRadial(0.1, 1e-4);\n  PointTransform_F32 adjToDist = LensDistortionOps.allInside(param, null, true);\n  PointTransform_F32 distToAdj = LensDistortionOps.allInside(param, null, false);\n  checkInside(adjToDist, distToAdj);\n  param = new IntrinsicParameters().fsetK(300, 320, 0, 150, 130, width, height).fsetRadial(-0.1, -1e-4);\n  adjToDist = LensDistortionOps.allInside(param, null, true);\n  distToAdj = LensDistortionOps.allInside(param, null, false);\n  checkInside(adjToDist, distToAdj);\n}",
        "prediction": "@Test\npublic void allInside_Transform() {\n  IntrinsicParameters param = new IntrinsicParameters().fsetK(300, 320, 0, 150, 130, width, height).fsetRadial(0.1, 1e-4);\n  PointTransform_F32 adjToDist = LensDistortionOps.transform_F32(AdjustmentType.SHRINK, param, null, true);\n  PointTransform_F32 distToAdj = LensDistortionOps.transform_F32(AdjustmentType.SHRINK, param, null, false);\n  checkInside(adjToDist, distToAdj);\n  param = new IntrinsicParameters().fsetK(300, 320, 0, 150, 130, width, height).fsetRadial(-0.1, -1e-4);\n  adjToDist = LensDistortionOps.transform_F32(AdjustmentType.SHRINK, param, null, true);\n  distToAdj = LensDistortionOps.transform_F32(AdjustmentType.SHRINK, param, null, false);\n  checkInside(adjToDist, distToAdj);\n}",
        "reference": "@Test\npublic void transform_F32_shrink() {\n  IntrinsicParameters param = new IntrinsicParameters().fsetK(300, 320, 0, 150, 130, width, height).fsetRadial(0.1, 1e-4);\n  PointTransform_F32 adjToDist = LensDistortionOps.transform_F32(AdjustmentType.SHRINK, param, null, true);\n  PointTransform_F32 distToAdj = LensDistortionOps.transform_F32(AdjustmentType.SHRINK, param, null, false);\n  checkInside(adjToDist, distToAdj);\n  param = new IntrinsicParameters().fsetK(300, 320, 0, 150, 130, width, height).fsetRadial(-0.1, -1e-4);\n  adjToDist = LensDistortionOps.transform_F32(AdjustmentType.SHRINK, param, null, true);\n  distToAdj = LensDistortionOps.transform_F32(AdjustmentType.SHRINK, param, null, false);\n  checkInside(adjToDist, distToAdj);\n}"
    },
    {
        "id": 79,
        "original": "@Test\npublic void hessian_F32() {\n  ImageFloat32 original = new ImageFloat32(width, height);\n  ImageFloat32 integral = new ImageFloat32(width, height);\n  ImageFloat32 found = new ImageFloat32(width, height);\n  ImageFloat32 expected = new ImageFloat32(width, height);\n  GImageMiscOps.fillUniform(original, rand, 0, 50);\n  IntegralImageOps.transform(original, integral);\n  int size = 9;\n  for (int skip = 1; skip <= 4; skip++) {\n    found.reshape(width / skip, height / skip);\n    expected.reshape(width / skip, height / skip);\n    ImplIntegralImageFeatureIntensity.hessianNaive(integral, skip, size, expected);\n    IntegralImageFeatureIntensity.hessian(integral, skip, size, found);\n    BoofTesting.assertEquals(expected, found, 1e-4f);\n  }\n}",
        "prediction": "@Test\npublic void hessian_F32() {\n  GrayF32 original = new GrayF32(width, height);\n  GrayF32 integral = new GrayF32(width, height);\n  GrayF32 found = new GrayF32(width, height);\n  GrayF32 expected = new GrayF32(width, height);\n  GImageMiscOps.fillUniform(original, rand, 0, 50);\n  IntegralImageOps.transform(original, integral);\n  int size = 9;\n  for (int skip = 1; skip <= 4; skip++) {\n    found.reshape(width / skip, height / skip);\n    expected.reshape(width / skip, height / skip);\n    ImplIntegralImageFeatureIntensity.hessianNaive(integral, skip, size, expected);\n    IntegralImageFeatureIntensity.hessian(integral, skip, size, found);\n    BoofTesting.assertEquals(expected, found, 1e-4f);\n  }\n}",
        "reference": "@Test\npublic void hessian_F32() {\n  GrayF32 original = new GrayF32(width, height);\n  GrayF32 integral = new GrayF32(width, height);\n  GrayF32 found = new GrayF32(width, height);\n  GrayF32 expected = new GrayF32(width, height);\n  GImageMiscOps.fillUniform(original, rand, 0, 50);\n  IntegralImageOps.transform(original, integral);\n  int size = 9;\n  for (int skip = 1; skip <= 4; skip++) {\n    found.reshape(width / skip, height / skip);\n    expected.reshape(width / skip, height / skip);\n    ImplIntegralImageFeatureIntensity.hessianNaive(integral, skip, size, expected);\n    IntegralImageFeatureIntensity.hessian(integral, skip, size, found);\n    BoofTesting.assertEquals(expected, found, 1e-4f);\n  }\n}"
    },
    {
        "id": 80,
        "original": "@Test\npublic void findErrorLocatorBM() {\n  GrowQueue_I8 message = GrowQueue_I8.parseHex(\"[ 0x40, 0xd2, 0x75, 0x47, 0x76, 0x17, 0x32, 0x06, 0x27, 0x26, 0x96, 0xc6, 0xc6, 0x96, 0x70, 0xec ]\");\n  GrowQueue_I8 ecc = new GrowQueue_I8();\n  int nsyn = 10;\n  int syndromes[] = new int[nsyn];\n  ReidSolomonCodes alg = new ReidSolomonCodes(8, primitive8);\n  alg.generator(nsyn);\n  alg.computeECC(message, ecc);\n  message.data[0] = 0;\n  alg.computeSyndromes(message, ecc, syndromes);\n  GrowQueue_I8 errorLocator = new GrowQueue_I8();\n  alg.findErrorLocatorBM(syndromes, nsyn, errorLocator);\n  assertEquals(2, errorLocator.size);\n  assertEquals(3, errorLocator.get(0));\n  assertEquals(1, errorLocator.get(1));\n  message.data[6] = 10;\n  alg.computeSyndromes(message, ecc, syndromes);\n  alg.findErrorLocatorBM(syndromes, nsyn, errorLocator);\n  assertEquals(3, errorLocator.size);\n  assertEquals(238, errorLocator.get(0) & 0xFF);\n  assertEquals(89, errorLocator.get(1));\n  assertEquals(1, errorLocator.get(2));\n}",
        "prediction": "@Test\npublic void findErrorLocatorBM() {\n  GrowQueue_I8 message = GrowQueue_I8.parseHex(\"[ 0x40, 0xd2, 0x75, 0x47, 0x76, 0x17, 0x32, 0x06, 0x27, 0x26, 0x96, 0xc6, 0xc6, 0x96, 0x70, 0xec ]\");\n  GrowQueue_I8 ecc = new GrowQueue_I8();\n  int nsyn = 10;\n  int syndromes[] = new int[nsyn];\n  ReidSolomonCodes alg = new ReidSolomonCodes(8, primitive8);\n  alg.generator(nsyn);\n  alg.computeECC(message, ecc);\n  message.data[0] = 0;\n  alg.computeSyndromes(message, ecc, syndromes);\n  GrowQueue_I8 errorLocator = new GrowQueue_I8();\n  alg.findErrorLocatorPolynomialBM(syndromes, nsyn, errorLocator);\n  assertEquals(2, errorLocator.size);\n  assertEquals(3, errorLocator.get(0));\n  assertEquals(1, errorLocator.get(1));\n  message.data[6] = 10;\n  alg.computeSyndromes(message, ecc, syndromes);\n  alg.findErrorLocatorPolynomialBM(syndromes, nsyn, errorLocator);\n  assertEquals(3, errorLocator.size);\n  assertEquals(238, errorLocator.get(0) & 0xFF);\n  assertEquals(89, errorLocator.get(1));\n  assertEquals(1, errorLocator.get(2));\n}",
        "reference": "@Test\npublic void findErrorLocatorPolynomialBM() {\n  GrowQueue_I8 message = GrowQueue_I8.parseHex(\"[ 0x40, 0xd2, 0x75, 0x47, 0x76, 0x17, 0x32, 0x06, 0x27, 0x26, 0x96, 0xc6, 0xc6, 0x96, 0x70, 0xec ]\");\n  GrowQueue_I8 ecc = new GrowQueue_I8();\n  int nsyn = 10;\n  int syndromes[] = new int[nsyn];\n  ReidSolomonCodes alg = new ReidSolomonCodes(8, primitive8);\n  alg.generator(nsyn);\n  alg.computeECC(message, ecc);\n  message.data[0] = 0;\n  alg.computeSyndromes(message, ecc, syndromes);\n  GrowQueue_I8 errorLocator = new GrowQueue_I8();\n  alg.findErrorLocatorPolynomialBM(syndromes, nsyn, errorLocator);\n  assertEquals(2, errorLocator.size);\n  assertEquals(3, errorLocator.get(0));\n  assertEquals(1, errorLocator.get(1));\n  message.data[6] = 10;\n  alg.computeSyndromes(message, ecc, syndromes);\n  alg.findErrorLocatorPolynomialBM(syndromes, nsyn, errorLocator);\n  assertEquals(3, errorLocator.size);\n  assertEquals(238, errorLocator.get(0) & 0xFF);\n  assertEquals(89, errorLocator.get(1));\n  assertEquals(1, errorLocator.get(2));\n}"
    },
    {
        "id": 81,
        "original": "@Test\npublic void scaleSpace() {\n  double ss[] = new double[] {1, 2, 4, 6, 8, 10};\n  PyramidFloat<ImageFloat32> pyramid = FactoryPyramid.scaleSpacePyramid(ss, ImageFloat32.class);\n  for (int i = 0; i < ss.length; i++) {\n    assertEquals(ss[i], pyramid.getSigma(i), 1e-8);\n    assertEquals(ss[i], pyramid.getScale(i), 1e-8);\n    if (i > 1)\n      assertTrue(Math.abs(ss[i] - ((PyramidFloatGaussianScale)pyramid).getSigmaLayers()[i]) > 0.1);\n  }\n}",
        "prediction": "@Test\npublic void scaleSpace() {\n  double ss[] = new double[] {1, 2, 4, 6, 8, 10};\n  PyramidFloat<ImageGray> pyramid = FactoryPyramid.scaleSpacePyramid(ss, ImageGray.class);\n  for (int i = 0; i < ss.length; i++) {\n    assertEquals(ss[i], pyramid.getSigma(i), 1e-8);\n    assertEquals(ss[i], pyramid.getScale(i), 1e-8);\n    if (i > 1)\n      assertTrue(Math.abs(ss[i] - ((PyramidFloatGaussianScale)pyramid).getSigmaLayers()[i]) > 0.1);\n  }\n}",
        "reference": "@Test\npublic void scaleSpace() {\n  double ss[] = new double[] {1, 2, 4, 6, 8, 10};\n  PyramidFloat<GrayF32> pyramid = FactoryPyramid.scaleSpacePyramid(ss, GrayF32.class);\n  for (int i = 0; i < ss.length; i++) {\n    assertEquals(ss[i], pyramid.getSigma(i), 1e-8);\n    assertEquals(ss[i], pyramid.getScale(i), 1e-8);\n    if (i > 1)\n      assertTrue(Math.abs(ss[i] - ((PyramidFloatGaussianScale)pyramid).getSigmaLayers()[i]) > 0.1);\n  }\n}"
    },
    {
        "id": 82,
        "original": "@Test\npublic void copyTest() throws IOException, StoreException {\n  storeCopier.copy(new StoreFindTokenFactory(STORE_KEY_FACTORY).getNewFindToken());\n  storeCopier.close();\n  StoreMetrics storeMetrics = new StoreMetrics(new MetricRegistry());\n  Files.copy(new File(srcDir, StoreDescriptor.STORE_DESCRIPTOR_FILENAME).toPath(), new File(tgtDir, StoreDescriptor.STORE_DESCRIPTOR_FILENAME).toPath(), StandardCopyOption.REPLACE_EXISTING);\n  BlobStore tgt = new BlobStore(STORE_ID, storeConfig, null, null, DISK_IO_SCHEDULER, StoreTestUtils.DEFAULT_DISK_SPACE_ALLOCATOR, storeMetrics, storeMetrics, tgtDir.getAbsolutePath(), STORE_CAPACITY, STORE_KEY_FACTORY, null, null, time);\n  tgt.start();\n  try {\n    StoreKey[] failKeys = {expiredId, deletedId};\n    for (StoreKey key : failKeys) {\n      try {\n        tgt.get(Collections.singletonList(key), EnumSet.allOf(StoreGetOptions.class));\n        fail(\"Should have failed to get \" + key);\n      } catch (StoreException e) {\n        assertEquals(\"Unexpected StoreErrorCode\", StoreErrorCodes.ID_Not_Found, e.getErrorCode());\n      }\n    }\n    StoreInfo storeInfo = tgt.get(Collections.singletonList(putId), EnumSet.noneOf(StoreGetOptions.class));\n    MessageInfo messageInfo = storeInfo.getMessageReadSetInfo().get(0);\n    assertEquals(\"Size does not match\", putData.length, messageInfo.getSize());\n    assertEquals(\"Size does not match\", putData.length, storeInfo.getMessageReadSet().sizeInBytes(0));\n    assertFalse(\"Should not be deleted or expired\", messageInfo.isDeleted() || messageInfo.isExpired());\n    ByteBufferChannel channel = new ByteBufferChannel(ByteBuffer.allocate(putData.length));\n    storeInfo.getMessageReadSet().writeTo(0, channel, 0, putData.length);\n    assertArrayEquals(\"Data put does not match data copied\", putData, channel.getBuffer().array());\n  } finally {\n    tgt.shutdown();\n  }\n}",
        "prediction": "@Test\npublic void copyTest() throws Exception {\n  storeCopier.copy(new StoreFindTokenFactory(STORE_KEY_FACTORY).getNewFindToken());\n  storeCopier.close();\n  StoreMetrics storeMetrics = new StoreMetrics(new MetricRegistry());\n  Files.copy(new File(srcDir, StoreDescriptor.STORE_DESCRIPTOR_FILENAME).toPath(), new File(tgtDir, StoreDescriptor.STORE_DESCRIPTOR_FILENAME).toPath(), StandardCopyOption.REPLACE_EXISTING);\n  BlobStore tgt = new BlobStore(STORE_ID, storeConfig, null, null, DISK_IO_SCHEDULER, StoreTestUtils.DEFAULT_DISK_SPACE_ALLOCATOR, storeMetrics, storeMetrics, tgtDir.getAbsolutePath(), STORE_CAPACITY, STORE_KEY_FACTORY, null, null, time);\n  tgt.start();\n  try {\n    StoreKey[] failKeys = {expiredId, deletedId};\n    for (StoreKey key : failKeys) {\n      try {\n        tgt.get(Collections.singletonList(key), EnumSet.allOf(StoreGetOptions.class));\n        fail(\"Should have failed to get \" + key);\n      } catch (StoreException e) {\n        assertEquals(\"Unexpected StoreErrorCode\", StoreErrorCodes.ID_Not_Found, e.getErrorCode());\n      }\n    }\n    StoreInfo storeInfo = tgt.get(Collections.singletonList(putId), EnumSet.noneOf(StoreGetOptions.class));\n    MessageInfo messageInfo = storeInfo.getMessageReadSetInfo().get(0);\n    assertEquals(\"Size does not match\", putData.length, messageInfo.getSize());\n    assertEquals(\"Size does not match\", putData.length, storeInfo.getMessageReadSet().sizeInBytes(0));\n    assertFalse(\"Should not be deleted or expired\", messageInfo.isDeleted() || messageInfo.isExpired());\n    ByteBufferChannel channel = new ByteBufferChannel(ByteBuffer.allocate(putData.length));\n    storeInfo.getMessageReadSet().writeTo(0, channel, 0, putData.length);\n    assertArrayEquals(\"Data put does not match data copied\", putData, channel.getBuffer().array());\n  } finally {\n    tgt.shutdown();\n  }\n}",
        "reference": "@Test\npublic void copyTest() throws Exception {\n  storeCopier.copy(new StoreFindTokenFactory(STORE_KEY_FACTORY).getNewFindToken());\n  storeCopier.close();\n  StoreMetrics storeMetrics = new StoreMetrics(new MetricRegistry());\n  Files.copy(new File(srcDir, StoreDescriptor.STORE_DESCRIPTOR_FILENAME).toPath(), new File(tgtDir, StoreDescriptor.STORE_DESCRIPTOR_FILENAME).toPath(), StandardCopyOption.REPLACE_EXISTING);\n  BlobStore tgt = new BlobStore(STORE_ID, storeConfig, null, null, DISK_IO_SCHEDULER, StoreTestUtils.DEFAULT_DISK_SPACE_ALLOCATOR, storeMetrics, storeMetrics, tgtDir.getAbsolutePath(), STORE_CAPACITY, STORE_KEY_FACTORY, null, null, time);\n  tgt.start();\n  try {\n    StoreKey[] failKeys = {expiredId, deletedId};\n    for (StoreKey key : failKeys) {\n      try {\n        tgt.get(Collections.singletonList(key), EnumSet.allOf(StoreGetOptions.class));\n        fail(\"Should have failed to get \" + key);\n      } catch (StoreException e) {\n        assertEquals(\"Unexpected StoreErrorCode\", StoreErrorCodes.ID_Not_Found, e.getErrorCode());\n      }\n    }\n    StoreInfo storeInfo = tgt.get(Collections.singletonList(putId), EnumSet.noneOf(StoreGetOptions.class));\n    MessageInfo messageInfo = storeInfo.getMessageReadSetInfo().get(0);\n    assertEquals(\"Size does not match\", putData.length, messageInfo.getSize());\n    assertEquals(\"Size does not match\", putData.length, storeInfo.getMessageReadSet().sizeInBytes(0));\n    assertFalse(\"Should not be deleted or expired\", messageInfo.isDeleted() || messageInfo.isExpired());\n    ByteBufferChannel channel = new ByteBufferChannel(ByteBuffer.allocate(putData.length));\n    storeInfo.getMessageReadSet().writeTo(0, channel, 0, putData.length);\n    assertArrayEquals(\"Data put does not match data copied\", putData, channel.getBuffer().array());\n  } finally {\n    tgt.shutdown();\n  }\n}"
    },
    {
        "id": 83,
        "original": "@Test\npublic void testReplenishConnections() {\n  connectionTracker = new ConnectionTracker(routerConfig.routerScalingUnitMaxConnectionsPerPortPlainText, routerConfig.routerScalingUnitMaxConnectionsPerPortSsl);\n  int minActiveConnectionsCount = 0;\n  int totalConnectionsCount = 0;\n  int availableCount = 0;\n  MockDataNodeId dataNodeId1 = new MockDataNodeId(\"host1\", Collections.singletonList(plainTextPort), Collections.emptyList(), \"DC1\");\n  MockDataNodeId dataNodeId2 = new MockDataNodeId(\"host2\", Arrays.asList(plainTextPort, sslPort), Collections.emptyList(), \"DC1\");\n  dataNodeId2.setSslEnabledDataCenters(Collections.singletonList(\"DC1\"));\n  connectionTracker.setMinimumActiveConnectionsPercentage(dataNodeId1, 50);\n  minActiveConnectionsCount += 50 * routerConfig.routerScalingUnitMaxConnectionsPerPortPlainText / 100;\n  connectionTracker.setMinimumActiveConnectionsPercentage(dataNodeId2, 200);\n  minActiveConnectionsCount += routerConfig.routerScalingUnitMaxConnectionsPerPortSsl;\n  assertCounts(totalConnectionsCount, availableCount);\n  connectionTracker.replenishConnections(this::mockNewConnection);\n  totalConnectionsCount += minActiveConnectionsCount;\n  assertCounts(totalConnectionsCount, availableCount);\n  List<String> newConnections = getNewlyEstablishedConnections();\n  newConnections.forEach(connectionTracker::checkInConnection);\n  availableCount += minActiveConnectionsCount;\n  assertCounts(totalConnectionsCount, availableCount);\n  Assert.assertTrue(connectionTracker.mayCreateNewConnection(\"host1\", plainTextPort, dataNodeId1));\n  Assert.assertFalse(connectionTracker.mayCreateNewConnection(\"host2\", sslPort, dataNodeId2));\n  newConnections.stream().limit(2).forEach(connectionTracker::removeConnection);\n  totalConnectionsCount -= 2;\n  availableCount -= 2;\n  assertCounts(totalConnectionsCount, availableCount);\n  connectionTracker.replenishConnections(this::mockNewConnection);\n  totalConnectionsCount += 2;\n  assertCounts(totalConnectionsCount, availableCount);\n  newConnections = getNewlyEstablishedConnections();\n  newConnections.forEach(connectionTracker::checkInConnection);\n  availableCount += 2;\n  assertCounts(totalConnectionsCount, availableCount);\n  String conn1 = connectionTracker.checkOutConnection(\"host1\", plainTextPort, dataNodeId1);\n  Assert.assertNotNull(conn1);\n  String conn2 = connectionTracker.checkOutConnection(\"host2\", sslPort, dataNodeId2);\n  Assert.assertNotNull(conn2);\n  availableCount -= 2;\n  assertCounts(totalConnectionsCount, availableCount);\n  connectionTracker.removeConnection(conn1);\n  connectionTracker.checkInConnection(conn2);\n  totalConnectionsCount -= 1;\n  availableCount += 1;\n  assertCounts(totalConnectionsCount, availableCount);\n  connectionTracker.replenishConnections(this::mockNewConnection);\n  totalConnectionsCount += 1;\n  assertCounts(totalConnectionsCount, availableCount);\n}",
        "prediction": "@Test\npublic void testReplenishConnections() {\n  connectionTracker = new ConnectionTracker(routerConfig.routerScalingUnitMaxConnectionsPerPortPlainText, routerConfig.routerScalingUnitMaxConnectionsPerPortSsl);\n  int minActiveConnectionsCount = 0;\n  int totalConnectionsCount = 0;\n  int availableCount = 0;\n  MockDataNodeId dataNodeId1 = new MockDataNodeId(\"host1\", Collections.singletonList(plainTextPort), Collections.emptyList(), \"DC1\");\n  MockDataNodeId dataNodeId2 = new MockDataNodeId(\"host2\", Arrays.asList(plainTextPort, sslPort), Collections.emptyList(), \"DC1\");\n  dataNodeId2.setSslEnabledDataCenters(Collections.singletonList(\"DC1\"));\n  connectionTracker.setMinimumActiveConnectionsPercentage(dataNodeId1, 50);\n  minActiveConnectionsCount += 50 * routerConfig.routerScalingUnitMaxConnectionsPerPortPlainText / 100;\n  connectionTracker.setMinimumActiveConnectionsPercentage(dataNodeId2, 200);\n  minActiveConnectionsCount += routerConfig.routerScalingUnitMaxConnectionsPerPortSsl;\n  assertCounts(totalConnectionsCount, availableCount);\n  connectionTracker.replenishConnections(this::mockNewConnection, 100);\n  totalConnectionsCount += minActiveConnectionsCount;\n  assertCounts(totalConnectionsCount, availableCount);\n  List<String> newConnections = getNewlyEstablishedConnections();\n  newConnections.forEach(connectionTracker::checkInConnection);\n  availableCount += minActiveConnectionsCount;\n  assertCounts(totalConnectionsCount, availableCount);\n  Assert.assertTrue(connectionTracker.mayCreateNewConnection(\"host1\", plainTextPort, dataNodeId1));\n  Assert.assertFalse(connectionTracker.mayCreateNewConnection(\"host2\", sslPort, dataNodeId2));\n  newConnections.stream().limit(2).forEach(connectionTracker::removeConnection);\n  totalConnectionsCount -= 2;\n  availableCount -= 2;\n  assertCounts(totalConnectionsCount, availableCount);\n  connectionTracker.replenishConnections(this::mockNewConnection, 100);\n  totalConnectionsCount += 2;\n  assertCounts(totalConnectionsCount, availableCount);\n  newConnections = getNewlyEstablishedConnections();\n  newConnections.forEach(connectionTracker::checkInConnection);\n  availableCount += 2;\n  assertCounts(totalConnectionsCount, availableCount);\n  String conn1 = connectionTracker.checkOutConnection(\"host1\", plainTextPort, dataNodeId1);\n  Assert.assertNotNull(conn1);\n  String conn2 = connectionTracker.checkOutConnection(\"host2\", sslPort, dataNodeId2);\n  Assert.assertNotNull(conn2);\n  availableCount -= 2;\n  assertCounts(totalConnectionsCount, availableCount);\n  connectionTracker.removeConnection(conn1);\n  connectionTracker.checkInConnection(conn2);\n  totalConnectionsCount -= 1;\n  availableCount += 1;\n  assertCounts(totalConnectionsCount, availableCount);\n  connectionTracker.replenishConnections(this::mockNewConnection, 100);\n  totalConnectionsCount += 1;\n  assertCounts(totalConnectionsCount, availableCount);\n}",
        "reference": "@Test\npublic void testReplenishConnections() {\n  connectionTracker = new ConnectionTracker(routerConfig.routerScalingUnitMaxConnectionsPerPortPlainText, routerConfig.routerScalingUnitMaxConnectionsPerPortSsl);\n  int minActiveConnectionsCount = 0;\n  int totalConnectionsCount = 0;\n  int availableCount = 0;\n  MockDataNodeId dataNodeId1 = new MockDataNodeId(\"host1\", Collections.singletonList(plainTextPort), Collections.emptyList(), \"DC1\");\n  MockDataNodeId dataNodeId2 = new MockDataNodeId(\"host2\", Arrays.asList(plainTextPort, sslPort), Collections.emptyList(), \"DC1\");\n  dataNodeId2.setSslEnabledDataCenters(Collections.singletonList(\"DC1\"));\n  connectionTracker.setMinimumActiveConnectionsPercentage(dataNodeId1, 50);\n  minActiveConnectionsCount += 50 * routerConfig.routerScalingUnitMaxConnectionsPerPortPlainText / 100;\n  connectionTracker.setMinimumActiveConnectionsPercentage(dataNodeId2, 200);\n  minActiveConnectionsCount += routerConfig.routerScalingUnitMaxConnectionsPerPortSsl;\n  assertCounts(totalConnectionsCount, availableCount);\n  connectionTracker.replenishConnections(this::mockNewConnection, Integer.MAX_VALUE);\n  totalConnectionsCount += minActiveConnectionsCount;\n  assertCounts(totalConnectionsCount, availableCount);\n  List<String> newConnections = getNewlyEstablishedConnections();\n  newConnections.forEach(connectionTracker::checkInConnection);\n  availableCount += minActiveConnectionsCount;\n  assertCounts(totalConnectionsCount, availableCount);\n  Assert.assertTrue(connectionTracker.mayCreateNewConnection(\"host1\", plainTextPort, dataNodeId1));\n  Assert.assertFalse(connectionTracker.mayCreateNewConnection(\"host2\", sslPort, dataNodeId2));\n  newConnections.stream().limit(2).forEach(connectionTracker::removeConnection);\n  totalConnectionsCount -= 2;\n  availableCount -= 2;\n  assertCounts(totalConnectionsCount, availableCount);\n  connectionTracker.replenishConnections(this::mockNewConnection, Integer.MAX_VALUE);\n  totalConnectionsCount += 2;\n  assertCounts(totalConnectionsCount, availableCount);\n  newConnections = getNewlyEstablishedConnections();\n  newConnections.forEach(connectionTracker::checkInConnection);\n  availableCount += 2;\n  assertCounts(totalConnectionsCount, availableCount);\n  String conn1 = connectionTracker.checkOutConnection(\"host1\", plainTextPort, dataNodeId1);\n  Assert.assertNotNull(conn1);\n  String conn2 = connectionTracker.checkOutConnection(\"host2\", sslPort, dataNodeId2);\n  Assert.assertNotNull(conn2);\n  availableCount -= 2;\n  assertCounts(totalConnectionsCount, availableCount);\n  connectionTracker.removeConnection(conn1);\n  connectionTracker.checkInConnection(conn2);\n  totalConnectionsCount -= 1;\n  availableCount += 1;\n  assertCounts(totalConnectionsCount, availableCount);\n  connectionTracker.replenishConnections(this::mockNewConnection, Integer.MAX_VALUE);\n  totalConnectionsCount += 1;\n  assertCounts(totalConnectionsCount, availableCount);\n  String connId;\n  while ((connId = connectionTracker.checkOutConnection(\"host2\", sslPort, dataNodeId2)) != null) {\n    connectionTracker.removeConnection(connId);\n  }\n  totalConnectionsCount -= 2;\n  availableCount -= 2;\n  assertCounts(totalConnectionsCount, availableCount);\n  connectionTracker.replenishConnections(this::mockNewConnection, 1);\n  totalConnectionsCount += 1;\n  assertCounts(totalConnectionsCount, availableCount);\n  connectionTracker.replenishConnections(this::mockNewConnection, 1);\n  totalConnectionsCount += 1;\n  assertCounts(totalConnectionsCount, availableCount);\n}"
    },
    {
        "id": 84,
        "original": "@Test\npublic void testGetMuleHomeFile() {\n  File muleHome = MuleContainerBootstrapUtils.getMuleHomeFile();\n  assertNotNull(muleHome.getAbsolutePath());\n}",
        "prediction": "@Test\npublic void testGetMuleHomeFile() {\n  File muleHome = MuleContainerBootstrapUtils.getMuleHome();\n  assertNotNull(muleHome.getAbsolutePath());\n}",
        "reference": "@Test\npublic void testGetMuleHomeFile() {\n  File muleHome = MuleContainerBootstrapUtils.getMuleHome();\n  assertNotNull(muleHome.getAbsolutePath());\n}"
    },
    {
        "id": 85,
        "original": "@Test\npublic void testSaveOrUpdateUserDetail() {\n  ModelMap model = new ModelMap();\n  User currUser = getTestUser();\n  currUser.setUserName(\"new name\");\n  userController.saveOrUpdateUserDetail(currUser, model, currUser, null);\n  userController.getUserDetail(getTestUser(), model, currUser.getUserId());\n  User user = (User)model.get(\"user\");\n  assertThat(user.getUserName(), is(\"new name\"));\n  assertThat(user.getPassword(), is(currUser.getPassword()));\n  User admin = getAdminUser();\n  User temp = new User(\"temp1\", \"temp1\", \"temp1\", \"temp@nhn.com\", Role.USER);\n  userController.saveOrUpdateUserDetail(admin, model, temp, null);\n  temp = new User(\"temp2\", \"temp2\", \"temp2\", \"temp@nhn.com\", Role.USER);\n  userController.saveOrUpdateUserDetail(admin, model, temp, null);\n  model.clear();\n  userController.saveOrUpdateUserDetail(currUser, model, currUser, \"temp1, temp2\");\n  userController.getUserDetail(getTestUser(), model, currUser.getUserId());\n  user = (User)model.get(\"user\");\n  assertThat(user.getFollowers().size(), is(2));\n  assertThat(user.getFollowers().get(0).getUserId(), is(\"temp1\"));\n}",
        "prediction": "@Test\npublic void testSaveOrUpdateUserDetail() {\n  ModelMap model = new ModelMap();\n  User currUser = getTestUser();\n  currUser.setUserName(\"new name\");\n  userController.saveUser(currUser, model, currUser);\n  userController.getUserDetail(getTestUser(), model, currUser.getUserId());\n  User user = (User)model.get(\"user\");\n  assertThat(user.getUserName(), is(\"new name\"));\n  assertThat(user.getPassword(), is(currUser.getPassword()));\n  User admin = getAdminUser();\n  User temp = new User(\"temp1\", \"temp1\", \"temp1\", \"temp@nhn.com\", Role.USER);\n  userController.saveUser(admin, model, temp);\n  temp = new User(\"temp2\", \"temp2\", \"temp2\", \"temp@nhn.com\", Role.USER);\n  userController.saveUser(admin, model, temp);\n  model.clear();\n  userController.saveUser(currUser, model, currUser);\n  userController.getUserDetail(getTestUser(), model, currUser.getUserId());\n  user = (User)model.get(\"user\");\n  assertThat(user.getFollowers().size(), is(2));\n  assertThat(user.getFollowers().get(0).getUserId(), is(\"temp1\"));\n}",
        "reference": "@Test\npublic void testSaveOrUpdateUserDetail() {\n  ModelMap model = new ModelMap();\n  User currUser = getTestUser();\n  currUser.setUserName(\"new name\");\n  userController.saveUser(currUser, model, currUser);\n  userController.getUserDetail(getTestUser(), model, currUser.getUserId());\n  User user = (User)model.get(\"user\");\n  assertThat(user.getUserName(), is(\"new name\"));\n  assertThat(user.getPassword(), is(currUser.getPassword()));\n  User admin = getAdminUser();\n  User temp = new User(\"temp1\", \"temp1\", \"temp1\", \"temp@nhn.com\", Role.USER);\n  userController.saveUser(admin, model, temp);\n  temp = new User(\"temp2\", \"temp2\", \"temp2\", \"temp@nhn.com\", Role.USER);\n  userController.saveUser(admin, model, temp);\n  model.clear();\n  currUser.setFollowersStr(\"temp1, temp2\");\n  userController.saveUser(currUser, model, currUser);\n  userController.getUserDetail(getTestUser(), model, currUser.getUserId());\n  user = (User)model.get(\"user\");\n  assertThat(user.getFollowers().size(), is(2));\n  assertThat(user.getFollowers().get(0).getUserId(), is(\"temp1\"));\n}"
    },
    {
        "id": 86,
        "original": "@Test\npublic void testBoolean() {\n  Buffer buffer = new FixedBuffer(16);\n  buffer.put(true);\n  buffer.put(false);\n  Buffer read = new FixedBuffer(buffer.getBuffer());\n  boolean b = read.readBoolean();\n  Assert.assertEquals(true, b);\n  boolean c = read.readBoolean();\n  Assert.assertEquals(false, c);\n}",
        "prediction": "@Test\npublic void testBoolean() {\n  Buffer buffer = new FixedBuffer(16);\n  buffer.putBoolean(true);\n  buffer.putBoolean(false);\n  Buffer read = new FixedBuffer(buffer.getBuffer());\n  boolean b = read.readBoolean();\n  Assert.assertEquals(true, b);\n  boolean c = read.readBoolean();\n  Assert.assertEquals(false, c);\n}",
        "reference": "@Test\npublic void testBoolean() {\n  Buffer buffer = new FixedBuffer(16);\n  buffer.putBoolean(true);\n  buffer.putBoolean(false);\n  Buffer read = new FixedBuffer(buffer.getBuffer());\n  boolean b = read.readBoolean();\n  Assert.assertEquals(true, b);\n  boolean c = read.readBoolean();\n  Assert.assertEquals(false, c);\n}"
    },
    {
        "id": 87,
        "original": "@Test\r\n@Verifies(value = \"set this care setting to new order\", method = \"cloneForDiscontinuing(Order)\")\r\npublic void cloneForDiscontinuing_shouldSetThisCareSettingToNewOrder() {\r\n  Order anOrder = new Order();\r\n  CareSetting careSetting = new CareSetting();\r\n  anOrder.setCareSetting(careSetting);\r\n  Order orderThatCanDiscontinueTheOrder = anOrder.cloneForDiscontinuing();\r\n  assertEquals(anOrder.getCareSetting(), orderThatCanDiscontinueTheOrder.getCareSetting());\r\n}",
        "prediction": "@Test\n@Verifies(value = \"set this care setting to new order\", method = \"cloneForDiscontinuing(Order)\")\npublic void cloneForDiscontinuing_shouldSetThisCareSettingToNewOrder() throws IllegalAccessException, InstantiationException {\n  Order anOrder = new Order();\n  CareSetting careSetting = new CareSetting();\n  anOrder.setCareSetting(careSetting);\n  Order orderThatCanDiscontinueTheOrder = anOrder.cloneForDiscontinuing();\n  assertEquals(anOrder.getCareSetting(), orderThatCanDiscontinueTheOrder.getCareSetting());\n}",
        "reference": "@Test\r\n@Verifies(value = \"set this care setting to new order\", method = \"cloneForDiscontinuing(Order)\")\r\npublic void cloneForDiscontinuing_shouldSetThisCareSettingToNewOrder() throws Exception {\r\n  Order anOrder = new Order();\r\n  CareSetting careSetting = new CareSetting();\r\n  anOrder.setCareSetting(careSetting);\r\n  Order orderThatCanDiscontinueTheOrder = anOrder.cloneForDiscontinuing();\r\n  assertEquals(anOrder.getCareSetting(), orderThatCanDiscontinueTheOrder.getCareSetting());\r\n}"
    },
    {
        "id": 88,
        "original": "@Test\npublic void getConstructorTest() {\n  JavaAttributeInfo testAttr = getTestAttribute();\n  String method = getConstructor(CLASS_NAME, testAttr, GENERATE_SERVICE_AND_MANAGER);\n  assertThat(true, is(method.contains(THIS + PERIOD + CLASS_NAME + SPACE + EQUAL + SPACE + \"builder\" + OBJECT + PERIOD + GET_METHOD_PREFIX + \"Testname\" + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN)));\n}",
        "prediction": "@Test\npublic void getConstructorTest() {\n  JavaAttributeInfo testAttr = getTestAttribute();\n  YangPluginConfig pluginConfig = getPluginConfig();\n  String method = getConstructor(CLASS_NAME, testAttr, GENERATE_SERVICE_AND_MANAGER, pluginConfig);\n  assertThat(true, is(method.contains(THIS + PERIOD + CLASS_NAME + SPACE + EQUAL + SPACE + \"builder\" + OBJECT + PERIOD + GET_METHOD_PREFIX + \"Testname\" + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN)));\n}",
        "reference": "@Test\npublic void getConstructorTest() {\n  JavaAttributeInfo testAttr = getTestAttribute();\n  YangPluginConfig pluginConfig = new YangPluginConfig();\n  String method = getConstructor(CLASS_NAME, testAttr, GENERATE_SERVICE_AND_MANAGER, pluginConfig);\n  assertThat(true, is(method.contains(THIS + PERIOD + CLASS_NAME + SPACE + EQUAL + SPACE + \"builder\" + OBJECT + PERIOD + GET_METHOD_PREFIX + \"Testname\" + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN)));\n}"
    },
    {
        "id": 89,
        "original": "@Test\npublic void testGetTunnelInfos() {\n  testAddTunnelInfo();\n  Map<TunnelId, PceccTunnelInfo> tunnelInfoMap = distrPceStore.getTunnelInfos();\n  assertThat(tunnelInfoMap, is(notNullValue()));\n  assertThat(tunnelInfoMap.isEmpty(), is(false));\n  assertThat(tunnelInfoMap.size(), is(2));\n}",
        "prediction": "@Test\npublic void testGetTunnelInfos() {\n  testAddTunnelInfo();\n  Map<TunnelId, ResourceConsumer> tunnelInfoMap = distrPceStore.getTunnelInfos();\n  assertThat(tunnelInfoMap, is(notNullValue()));\n  assertThat(tunnelInfoMap.isEmpty(), is(false));\n  assertThat(tunnelInfoMap.size(), is(2));\n}",
        "reference": "@Test\npublic void testGetTunnelInfos() {\n  testAddTunnelInfo();\n  Map<TunnelId, ResourceConsumer> tunnelInfoMap = distrPceStore.getTunnelInfos();\n  assertThat(tunnelInfoMap, is(notNullValue()));\n  assertThat(tunnelInfoMap.isEmpty(), is(false));\n  assertThat(tunnelInfoMap.size(), is(2));\n}"
    },
    {
        "id": 90,
        "original": "@Test\npublic void testGetTunnelInfo() {\n  testAddTunnelInfo();\n  assertThat(tunnelId1, is(notNullValue()));\n  assertThat(distrPceStore.getTunnelInfo(tunnelId1), is(pceccTunnelInfo1));\n  assertThat(tunnelId2, is(notNullValue()));\n  assertThat(distrPceStore.getTunnelInfo(tunnelId2), is(pceccTunnelInfo2));\n}",
        "prediction": "@Test\npublic void testGetTunnelInfo() {\n  testAddTunnelInfo();\n  assertThat(tunnelId1, is(notNullValue()));\n  assertThat(distrPceStore.getTunnelInfo(tunnelId1), is(instanceOf(ResourceConsumer.class)));\n  assertThat(tunnelId2, is(notNullValue()));\n  assertThat(distrPceStore.getTunnelInfo(tunnelId2), is(instanceOf(ResourceConsumer.class)));\n}",
        "reference": "@Test\npublic void testGetTunnelInfo() {\n  testAddTunnelInfo();\n  assertThat(tunnelId1, is(notNullValue()));\n  assertThat(distrPceStore.getTunnelInfo(tunnelId1), is(tunnelConsumerId1));\n  assertThat(tunnelId2, is(notNullValue()));\n  assertThat(distrPceStore.getTunnelInfo(tunnelId2), is(tunnelConsumerId2));\n}"
    },
    {
        "id": 91,
        "original": "@Test\npublic void testAddTunnelInfo() {\n  distrPceStore.storageService = new TestStorageService();\n  distrPceStore.activate();\n  distrPceStore.addTunnelInfo(tunnelId1, pceccTunnelInfo1);\n  assertThat(distrPceStore.existsTunnelInfo(tunnelId1), is(true));\n  assertThat(distrPceStore.getTunnelInfo(tunnelId1), is(pceccTunnelInfo1));\n  distrPceStore.addTunnelInfo(tunnelId2, pceccTunnelInfo2);\n  assertThat(distrPceStore.existsTunnelInfo(tunnelId2), is(true));\n  assertThat(distrPceStore.getTunnelInfo(tunnelId2), is(pceccTunnelInfo2));\n}",
        "prediction": "@Test\npublic void testAddTunnelInfo() {\n  distrPceStore.storageService = new TestStorageService();\n  distrPceStore.activate();\n  distrPceStore.addTunnelInfo(tunnelId1, tunnelConsumerId1);\n  assertThat(distrPceStore.existsTunnelInfo(tunnelId1), is(true));\n  assertThat(distrPceStore.getTunnelInfo(tunnelId1), is(tunnelConsumerId1));\n  distrPceStore.addTunnelInfo(tunnelId2, tunnelConsumerId2);\n  assertThat(distrPceStore.existsTunnelInfo(tunnelId2), is(true));\n  assertThat(distrPceStore.getTunnelInfo(tunnelId2), is(tunnelConsumerId2));\n}",
        "reference": "@Test\npublic void testAddTunnelInfo() {\n  distrPceStore.storageService = new TestStorageService();\n  distrPceStore.activate();\n  distrPceStore.addTunnelInfo(tunnelId1, tunnelConsumerId1);\n  assertThat(distrPceStore.existsTunnelInfo(tunnelId1), is(true));\n  assertThat(distrPceStore.getTunnelInfo(tunnelId1), is(tunnelConsumerId1));\n  distrPceStore.addTunnelInfo(tunnelId2, tunnelConsumerId2);\n  assertThat(distrPceStore.existsTunnelInfo(tunnelId2), is(true));\n  assertThat(distrPceStore.getTunnelInfo(tunnelId2), is(tunnelConsumerId2));\n}"
    },
    {
        "id": 92,
        "original": "@Test\npublic void testBuildNdpSolicit() throws Exception {\n  Ethernet ethPacket = NeighborSolicitation.buildNdpSolicit(TARGET_IP.toOctets(), SRC_IP.toOctets(), DST_IP.toOctets(), SRC_MAC.toBytes(), DST_MAC.toBytes(), VLAN_ID);\n  IPv6 ipPacket = (IPv6)ethPacket.getPayload();\n  ICMP6 icmp6Packet = (ICMP6)ipPacket.getPayload();\n  NeighborSolicitation nsPacket = (NeighborSolicitation)icmp6Packet.getPayload();\n  assertEquals(\"Non-DAD NS should have 1 option\", 1, nsPacket.getOptions().size());\n  assertEquals(\"The option should be SRC_LL_ADDR type\", TYPE_SOURCE_LL_ADDRESS, nsPacket.getOptions().stream().findFirst().get().type());\n}",
        "prediction": "@Test\npublic void testBuildNdpSolicit() throws Exception {\n  Ethernet ethPacket = NeighborSolicitation.buildNdpSolicit(TARGET_IP, SRC_IP, DST_IP, SRC_MAC, DST_MAC, VLAN_ID);\n  IPv6 ipPacket = (IPv6)ethPacket.getPayload();\n  ICMP6 icmp6Packet = (ICMP6)ipPacket.getPayload();\n  NeighborSolicitation nsPacket = (NeighborSolicitation)icmp6Packet.getPayload();\n  assertEquals(\"Non-DAD NS should have 1 option\", 1, nsPacket.getOptions().size());\n  assertEquals(\"The option should be SRC_LL_ADDR type\", TYPE_SOURCE_LL_ADDRESS, nsPacket.getOptions().stream().findFirst().get().type());\n}",
        "reference": "@Test\npublic void testBuildNdpSolicit() throws Exception {\n  final Ethernet ethPacket = NeighborSolicitation.buildNdpSolicit(TARGET_IP, SRC_IP, DST_IP, SRC_MAC, DST_MAC, VLAN_ID);\n  assertTrue(ethPacket.getDestinationMAC().equals(DST_MAC));\n  assertTrue(ethPacket.getSourceMAC().equals(SRC_MAC));\n  assertTrue(ethPacket.getEtherType() == Ethernet.TYPE_IPV6);\n  assertTrue(ethPacket.getVlanID() == VLAN_ID.id());\n  final IPv6 ipPacket = (IPv6)ethPacket.getPayload();\n  assertArrayEquals(ipPacket.getSourceAddress(), SRC_IP.toOctets());\n  assertArrayEquals(ipPacket.getDestinationAddress(), DST_IP.toOctets());\n  final ICMP6 icmp6Packet = (ICMP6)ipPacket.getPayload();\n  final NeighborSolicitation nsPacket = (NeighborSolicitation)icmp6Packet.getPayload();\n  assertArrayEquals(nsPacket.getTargetAddress(), TARGET_IP.toOctets());\n  assertEquals(\"Non-DAD NS should have 1 option\", 1, nsPacket.getOptions().size());\n  assertEquals(\"The option should be SRC_LL_ADDR type\", TYPE_SOURCE_LL_ADDRESS, nsPacket.getOptions().stream().findFirst().get().type());\n}"
    },
    {
        "id": 93,
        "original": "@Test\npublic void testBuildNdpSolicitDad() throws Exception {\n  Ethernet ethPacket = NeighborSolicitation.buildNdpSolicit(TARGET_IP.toOctets(), Ip6Address.ZERO.toOctets(), DST_IP.toOctets(), SRC_MAC.toBytes(), DST_MAC.toBytes(), VLAN_ID);\n  IPv6 ipPacket = (IPv6)ethPacket.getPayload();\n  ICMP6 icmp6Packet = (ICMP6)ipPacket.getPayload();\n  NeighborSolicitation nsPacket = (NeighborSolicitation)icmp6Packet.getPayload();\n  assertEquals(\"DAD NS should have no option\", 0, nsPacket.getOptions().size());\n}",
        "prediction": "@Test\npublic void testBuildNdpSolicitDad() throws Exception {\n  Ethernet ethPacket = NeighborSolicitation.buildNdpSolicit(TARGET_IP, Ip6Address.ZERO, DST_IP, SRC_MAC, DST_MAC, VLAN_ID);\n  IPv6 ipPacket = (IPv6)ethPacket.getPayload();\n  ICMP6 icmp6Packet = (ICMP6)ipPacket.getPayload();\n  NeighborSolicitation nsPacket = (NeighborSolicitation)icmp6Packet.getPayload();\n  assertEquals(\"DAD NS should have no option\", 0, nsPacket.getOptions().size());\n}",
        "reference": "@Test\npublic void testBuildNdpSolicitDad() throws Exception {\n  Ethernet ethPacket = NeighborSolicitation.buildNdpSolicit(TARGET_IP, Ip6Address.ZERO, DST_IP, SRC_MAC, DST_MAC, VLAN_ID);\n  IPv6 ipPacket = (IPv6)ethPacket.getPayload();\n  ICMP6 icmp6Packet = (ICMP6)ipPacket.getPayload();\n  NeighborSolicitation nsPacket = (NeighborSolicitation)icmp6Packet.getPayload();\n  assertEquals(\"DAD NS should have no option\", 0, nsPacket.getOptions().size());\n}"
    },
    {
        "id": 94,
        "original": "@Test\npublic void getRootPackageTest() {\n  conflictResolver.setPrefixForIdentifier(null);\n  String rootPackage = getRootPackage((byte)1, CHILD_PACKAGE, DATE1, conflictResolver);\n  assertThat(rootPackage.equals(DEFAULT_BASE_PKG + PERIOD + VERSION_NUMBER + PERIOD + CHILD_WITH_PERIOD + PERIOD + DATE_WITH_REV1), is(true));\n}",
        "prediction": "@Test\npublic void getRootPackageTest() throws ParseException {\n  conflictResolver.setPrefixForIdentifier(null);\n  SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\n  Date revisionDate = sdf.parse(DATE1);\n  String rootPackage = getRootPackage((byte)1, CHILD_PACKAGE, revisionDate, conflictResolver);\n  assertThat(rootPackage.equals(DEFAULT_BASE_PKG + PERIOD + VERSION_NUMBER + PERIOD + CHILD_WITH_PERIOD + PERIOD + DATE_WITH_REV1), is(true));\n}",
        "reference": "@Test\npublic void getRootPackageTest() throws ParseException {\n  conflictResolver.setPrefixForIdentifier(null);\n  Date date = simpleDateFormat.parse(DATE1);\n  String rootPackage = getRootPackage((byte)1, CHILD_PACKAGE, date, conflictResolver);\n  assertThat(rootPackage.equals(DEFAULT_BASE_PKG + PERIOD + VERSION_NUMBER + PERIOD + CHILD_WITH_PERIOD + PERIOD + DATE_WITH_REV1), is(true));\n}"
    },
    {
        "id": 95,
        "original": "@Test\npublic void getRootPackageWithRevTest() {\n  String rootPkgWithRev = getRootPackage((byte)1, CHILD_PACKAGE, DATE2, null);\n  assertThat(rootPkgWithRev.equals(DEFAULT_BASE_PKG + PERIOD + VERSION_NUMBER + PERIOD + CHILD_WITH_PERIOD + PERIOD + DATE_WITH_REV2), is(true));\n}",
        "prediction": "@Test\npublic void getRootPackageWithRevTest() throws ParseException {\n  SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\n  Date revisionDate = sdf.parse(DATE2);\n  String rootPkgWithRev = getRootPackage((byte)1, CHILD_PACKAGE, revisionDate, null);\n  assertThat(rootPkgWithRev.equals(DEFAULT_BASE_PKG + PERIOD + VERSION_NUMBER + PERIOD + CHILD_WITH_PERIOD + PERIOD + DATE_WITH_REV2), is(true));\n}",
        "reference": "@Test\npublic void getRootPackageWithRevTest() throws ParseException {\n  Date date = simpleDateFormat.parse(DATE2);\n  String rootPkgWithRev = getRootPackage((byte)1, CHILD_PACKAGE, date, null);\n  assertThat(rootPkgWithRev.equals(DEFAULT_BASE_PKG + PERIOD + VERSION_NUMBER + PERIOD + CHILD_WITH_PERIOD + PERIOD + DATE_WITH_REV2), is(true));\n}"
    },
    {
        "id": 96,
        "original": "@Test\npublic void addPackageInfoTest() throws IOException {\n  File dirPath = new File(CREATE_PATH);\n  dirPath.mkdirs();\n  addPackageInfo(dirPath, CHECK1, CREATE_PATH, false);\n  File filePath = new File(dirPath + File.separator + PKG_INFO);\n  assertThat(filePath.isFile(), is(true));\n}",
        "prediction": "@Test\npublic void addPackageInfoTest() throws IOException {\n  File dirPath = new File(CREATE_PATH);\n  dirPath.mkdirs();\n  YangPluginConfig pluginConfig = new YangPluginConfig();\n  addPackageInfo(dirPath, CHECK1, CREATE_PATH, false, pluginConfig);\n  File filePath = new File(dirPath + File.separator + PKG_INFO);\n  assertThat(filePath.isFile(), is(true));\n}",
        "reference": "@Test\npublic void addPackageInfoTest() throws IOException {\n  File dirPath = new File(CREATE_PATH);\n  dirPath.mkdirs();\n  addPackageInfo(dirPath, CHECK1, CREATE_PATH, false, getStubPluginConfig());\n  File filePath = new File(dirPath + File.separator + PKG_INFO);\n  assertThat(filePath.isFile(), is(true));\n}"
    },
    {
        "id": 97,
        "original": "@Test\npublic void addPackageInfoTest() throws IOException {\n  File dirPath = new File(CREATE_PATH);\n  dirPath.mkdirs();\n  addPackageInfo(dirPath, \"check1\", CREATE_PATH);\n  File filePath = new File(dirPath + File.separator + \"package-info.java\");\n  assertThat(filePath.isFile(), is(true));\n}",
        "prediction": "@Test\npublic void addPackageInfoTest() throws IOException {\n  File dirPath = new File(CREATE_PATH);\n  dirPath.mkdirs();\n  addPackageInfo(dirPath, \"check1\", CREATE_PATH, false);\n  File filePath = new File(dirPath + File.separator + \"package-info.java\");\n  assertThat(filePath.isFile(), is(true));\n}",
        "reference": "@Test\npublic void addPackageInfoTest() throws IOException {\n  File dirPath = new File(CREATE_PATH);\n  dirPath.mkdirs();\n  addPackageInfo(dirPath, CHECK1, CREATE_PATH, false);\n  File filePath = new File(dirPath + File.separator + PKG_INFO);\n  assertThat(filePath.isFile(), is(true));\n}"
    },
    {
        "id": 98,
        "original": "@Test\npublic void testSetExcludePorts() throws Exception {\n  ImmutableSet.Builder<String> builder = ImmutableSet.builder();\n  builder.add(PORT_NAME_3);\n  config.setExcludePorts(builder.build());\n  Set<String> excludePorts = config.excludePorts();\n  assertThat(excludePorts.size(), is(1));\n  assertTrue(excludePorts.contains(PORT_NAME_3));\n}",
        "prediction": "@Test\npublic void testSetSuppressHost() throws Exception {\n  ImmutableSet.Builder<ConnectPoint> builder = ImmutableSet.builder();\n  builder.add(CONNECT_POINT_3);\n  config.setSuppressHost(builder.build());\n  Set<ConnectPoint> suppressHost = config.suppressHost();\n  assertThat(suppressHost.size(), is(1));\n  assertTrue(suppressHost.contains(CONNECT_POINT_3));\n}",
        "reference": "@Test\npublic void testSetSuppressHost() throws Exception {\n  ImmutableSet.Builder<ConnectPoint> builder = ImmutableSet.builder();\n  builder.add(PORT_3);\n  config.setSuppressHost(builder.build());\n  Set<ConnectPoint> suppressHost = config.suppressHost();\n  assertNotNull(\"suppressHost should not be null\", suppressHost);\n  assertThat(suppressHost.size(), is(1));\n  assertTrue(suppressHost.contains(PORT_3));\n}"
    },
    {
        "id": 99,
        "original": "@Test\npublic void setSelectedDatabaseConnection() {\n  AbstractSqoopJobEntryController controller = new TestSqoopJobEntryController();\n  String database = \"testing\";\n  controller.setSelectedDatabaseConnection(database);\n  assertNull(\"Setting a database to one that doesn't exist in the JobMeta should not work\", controller.getConfig().getDatabase());\n  controller.getJobMeta().addDatabase(new DatabaseMeta(database, \"MYSQL\", null, null, null, null, null, null));\n  controller.setSelectedDatabaseConnection(database);\n  assertEquals(database, controller.getConfig().getDatabase());\n}",
        "prediction": "@Test\npublic void setSelectedDatabaseConnection() {\n  AbstractSqoopJobEntryController controller = new TestSqoopJobEntryController();\n  String databaseName = \"testing\";\n  DatabaseMeta databaseMeta = new DatabaseMeta(databaseName, \"MYSQL\", null, null, null, null, null, null);\n  DatabaseItem databaseItem = new DatabaseItem(databaseMeta);\n  \n  controller.setSelectedDatabaseConnection(databaseItem);\n  assertNull(\"Setting a database to one that doesn't exist in the JobMeta should not work\", controller.getConfig().getDatabase());\n  \n  controller.getJobMeta().addDatabase(databaseMeta);\n  controller.setSelectedDatabaseConnection(databaseItem);\n  assertEquals(databaseName, controller.getConfig().getDatabase());\n}",
        "reference": "@Test\npublic void setSelectedDatabaseConnection() throws KettleDatabaseException {\n  AbstractSqoopJobEntryController controller = new TestSqoopJobEntryController();\n  String connect = \"jdbc:bogus://bogus\";\n  String username = \"username\";\n  String password = \"password\";\n  controller.getConfig().setConnect(connect);\n  controller.getConfig().setUsername(username);\n  controller.getConfig().setPassword(password);\n  String connectAdvanced = \"jdbc:advanced://bogus\";\n  String usernameAdvanced = \"advanced_user\";\n  String passwordAdvanced = \"super password!\";\n  controller.getConfig().setConnectFromAdvanced(connectAdvanced);\n  controller.getConfig().setUsernameFromAdvanced(usernameAdvanced);\n  controller.getConfig().setPasswordFromAdvanced(passwordAdvanced);\n  DatabaseItem test = new DatabaseItem(\"test\");\n  DatabaseMeta database = new DatabaseMeta(test.getName(), \"MYSQL\", null, null, null, null, null, null);\n  controller.getJobMeta().addDatabase(database);\n  controller.setSelectedDatabaseConnection(test);\n  assertEquals(test, controller.getSelectedDatabaseConnection());\n  assertEquals(test.getName(), controller.getConfig().getDatabase());\n  assertEquals(database.getURL(), controller.getConfig().getConnect());\n  assertEquals(database.getUsername(), controller.getConfig().getUsername());\n  assertEquals(database.getPassword(), controller.getConfig().getPassword());\n  assertEquals(connectAdvanced, controller.getConfig().getConnectFromAdvanced());\n  assertEquals(usernameAdvanced, controller.getConfig().getUsernameFromAdvanced());\n  assertEquals(passwordAdvanced, controller.getConfig().getPasswordFromAdvanced());\n  controller.setSelectedDatabaseConnection(controller.USE_ADVANCED_OPTIONS);\n  assertEquals(controller.USE_ADVANCED_OPTIONS, controller.getSelectedDatabaseConnection());\n  assertNull(controller.getConfig().getDatabase());\n  assertEquals(connectAdvanced, controller.getConfig().getConnect());\n  assertEquals(usernameAdvanced, controller.getConfig().getUsername());\n  assertEquals(passwordAdvanced, controller.getConfig().getPassword());\n  assertEquals(connectAdvanced, controller.getConfig().getConnectFromAdvanced());\n  assertEquals(usernameAdvanced, controller.getConfig().getUsernameFromAdvanced());\n  assertEquals(passwordAdvanced, controller.getConfig().getPasswordFromAdvanced());\n  controller.setSelectedDatabaseConnection(test);\n  assertEquals(test, controller.getSelectedDatabaseConnection());\n  assertEquals(test.getName(), controller.getConfig().getDatabase());\n  assertEquals(database.getURL(), controller.getConfig().getConnect());\n  assertEquals(database.getUsername(), controller.getConfig().getUsername());\n  assertEquals(database.getPassword(), controller.getConfig().getPassword());\n  assertEquals(connectAdvanced, controller.getConfig().getConnectFromAdvanced());\n  assertEquals(usernameAdvanced, controller.getConfig().getUsernameFromAdvanced());\n  assertEquals(passwordAdvanced, controller.getConfig().getPasswordFromAdvanced());\n}"
    },
    {
        "id": 100,
        "original": "@Test\npublic void testConcat() throws Exception {\n  final String context = \"Concat\";\n  try (Storage s = createStorage()) {\n    s.initialize(0);\n    HashMap<String, ByteArrayOutputStream> appendData = populate(s, context);\n    val firstSegmentName = getSegmentName(0, context);\n    val firstSegmentHandle = s.openWrite(firstSegmentName).join();\n    AtomicLong firstSegmentLength = new AtomicLong(s.getStreamSegmentInfo(firstSegmentName, TIMEOUT).join().getLength());\n    assertThrows(\"concat() did not throw for non-existent target segment name.\", () -> s.concat(createHandle(\"foo1\", false), 0, firstSegmentHandle, TIMEOUT), ex -> ex instanceof StreamSegmentNotExistsException);\n    assertThrows(\"concat() did not throw for invalid source StreamSegment name.\", () -> s.concat(firstSegmentHandle, firstSegmentLength.get(), createHandle(\"foo2\", false), TIMEOUT), ex -> ex instanceof StreamSegmentNotExistsException);\n    ArrayList<String> concatOrder = new ArrayList<>();\n    concatOrder.add(firstSegmentName);\n    for (String sourceSegment : appendData.keySet()) {\n      if (sourceSegment.equals(firstSegmentName)) {\n        continue;\n      }\n      val sourceWriteHandle = s.openWrite(sourceSegment).join();\n      assertThrows(\"Concat allowed when source segment is not sealed.\", () -> s.concat(firstSegmentHandle, firstSegmentLength.get(), sourceWriteHandle, TIMEOUT), ex -> ex instanceof IllegalStateException);\n      s.seal(sourceWriteHandle, TIMEOUT).join();\n      SegmentProperties preConcatTargetProps = s.getStreamSegmentInfo(firstSegmentName, TIMEOUT).join();\n      SegmentProperties sourceProps = s.getStreamSegmentInfo(sourceSegment, TIMEOUT).join();\n      s.concat(firstSegmentHandle, firstSegmentLength.get(), sourceWriteHandle, TIMEOUT).join();\n      concatOrder.add(sourceSegment);\n      SegmentProperties postConcatTargetProps = s.getStreamSegmentInfo(firstSegmentName, TIMEOUT).join();\n      Assert.assertFalse(\"concat() did not delete source segment\", s.exists(sourceSegment, TIMEOUT).join());\n      Assert.assertEquals(\"Unexpected target StreamSegment.length after concatenation.\", preConcatTargetProps.getLength() + sourceProps.getLength(), postConcatTargetProps.getLength());\n      firstSegmentLength.set(postConcatTargetProps.getLength());\n    }\n    SegmentProperties segmentProperties = s.getStreamSegmentInfo(firstSegmentName, TIMEOUT).join();\n    byte[] readBuffer = new byte[(int)segmentProperties.getLength()];\n    int bytesRead = s.read(firstSegmentHandle, 0, readBuffer, 0, readBuffer.length, TIMEOUT).join();\n    Assert.assertEquals(\"Unexpected number of bytes read.\", readBuffer.length, bytesRead);\n    int offset = 0;\n    for (String segmentName : concatOrder) {\n      byte[] concatData = appendData.get(segmentName).toByteArray();\n      AssertExtensions.assertArrayEquals(\"Unexpected concat data.\", concatData, 0, readBuffer, offset, concatData.length);\n      offset += concatData.length;\n    }\n    Assert.assertEquals(\"Concat included more bytes than expected.\", offset, readBuffer.length);\n  }\n}",
        "prediction": "@Test\npublic void testConcat() throws Exception {\n  final String context = \"Concat\";\n  try (Storage s = createStorage()) {\n    s.initialize(0);\n    HashMap<String, ByteArrayOutputStream> appendData = populate(s, context);\n    val firstSegmentName = getSegmentName(0, context);\n    val firstSegmentHandle = s.openWrite(firstSegmentName).join();\n    AtomicLong firstSegmentLength = new AtomicLong(s.getStreamSegmentInfo(firstSegmentName, TIMEOUT).join().getLength());\n    assertThrows(\"concat() did not throw for non-existent target segment name.\", () -> s.concat(createHandle(\"foo1\", false), 0, \"foo1\", TIMEOUT), ex -> ex instanceof StreamSegmentNotExistsException);\n    assertThrows(\"concat() did not throw for invalid source StreamSegment name.\", () -> s.concat(firstSegmentHandle, firstSegmentLength.get(), \"foo2\", TIMEOUT), ex -> ex instanceof StreamSegmentNotExistsException);\n    ArrayList<String> concatOrder = new ArrayList<>();\n    concatOrder.add(firstSegmentName);\n    for (String sourceSegment : appendData.keySet()) {\n      if (sourceSegment.equals(firstSegmentName)) {\n        continue;\n      }\n      val sourceWriteHandle = s.openWrite(sourceSegment).join();\n      assertThrows(\"Concat allowed when source segment is not sealed.\", () -> s.concat(firstSegmentHandle, firstSegmentLength.get(), sourceSegment, TIMEOUT), ex -> ex instanceof IllegalStateException);\n      s.seal(sourceWriteHandle, TIMEOUT).join();\n      SegmentProperties preConcatTargetProps = s.getStreamSegmentInfo(firstSegmentName, TIMEOUT).join();\n      SegmentProperties sourceProps = s.getStreamSegmentInfo(sourceSegment, TIMEOUT).join();\n      s.concat(firstSegmentHandle, firstSegmentLength.get(), sourceSegment, TIMEOUT).join();\n      concatOrder.add(sourceSegment);\n      SegmentProperties postConcatTargetProps = s.getStreamSegmentInfo(firstSegmentName, TIMEOUT).join();\n      Assert.assertFalse(\"concat() did not delete source segment\", s.exists(sourceSegment, TIMEOUT).join());\n      Assert.assertEquals(\"Unexpected target StreamSegment.length after concatenation.\", preConcatTargetProps.getLength() + sourceProps.getLength(), postConcatTargetProps.getLength());\n      firstSegmentLength.set(postConcatTargetProps.getLength());\n    }\n    SegmentProperties segmentProperties = s.getStreamSegmentInfo(firstSegmentName, TIMEOUT).join();\n    byte[] readBuffer = new byte[(int)segmentProperties.getLength()];\n    int bytesRead = s.read(firstSegmentHandle, 0, readBuffer, 0, readBuffer.length, TIMEOUT).join();\n    Assert.assertEquals(\"Unexpected number of bytes read.\", readBuffer.length, bytesRead);\n    int offset = 0;\n    for (String segmentName : concatOrder) {\n      byte[] concatData = appendData.get(segmentName).toByteArray();\n      AssertExtensions.assertArrayEquals(\"Unexpected concat data.\", concatData, 0, readBuffer, offset, concatData.length);\n      offset += concatData.length;\n    }\n    Assert.assertEquals(\"Concat included more bytes than expected.\", offset, readBuffer.length);\n  }\n}",
        "reference": "@Test\npublic void testConcat() throws Exception {\n  final String context = \"Concat\";\n  try (Storage s = createStorage()) {\n    s.initialize(DEFAULT_EPOCH);\n    HashMap<String, ByteArrayOutputStream> appendData = populate(s, context);\n    val firstSegmentName = getSegmentName(0, context);\n    val firstSegmentHandle = s.openWrite(firstSegmentName).join();\n    AtomicLong firstSegmentLength = new AtomicLong(s.getStreamSegmentInfo(firstSegmentName, TIMEOUT).join().getLength());\n    assertThrows(\"concat() did not throw for non-existent target segment name.\", () -> s.concat(createHandle(\"foo1\", false, DEFAULT_EPOCH), 0, firstSegmentName, TIMEOUT), ex -> ex instanceof StreamSegmentNotExistsException);\n    assertThrows(\"concat() did not throw for invalid source StreamSegment name.\", () -> s.concat(firstSegmentHandle, firstSegmentLength.get(), \"foo2\", TIMEOUT), ex -> ex instanceof StreamSegmentNotExistsException);\n    ArrayList<String> concatOrder = new ArrayList<>();\n    concatOrder.add(firstSegmentName);\n    for (String sourceSegment : appendData.keySet()) {\n      if (sourceSegment.equals(firstSegmentName)) {\n        continue;\n      }\n      assertThrows(\"Concat allowed when source segment is not sealed.\", () -> s.concat(firstSegmentHandle, firstSegmentLength.get(), sourceSegment, TIMEOUT), ex -> ex instanceof IllegalStateException);\n      val sourceWriteHandle = s.openWrite(sourceSegment).join();\n      s.seal(sourceWriteHandle, TIMEOUT).join();\n      SegmentProperties preConcatTargetProps = s.getStreamSegmentInfo(firstSegmentName, TIMEOUT).join();\n      SegmentProperties sourceProps = s.getStreamSegmentInfo(sourceSegment, TIMEOUT).join();\n      s.concat(firstSegmentHandle, firstSegmentLength.get(), sourceSegment, TIMEOUT).join();\n      concatOrder.add(sourceSegment);\n      SegmentProperties postConcatTargetProps = s.getStreamSegmentInfo(firstSegmentName, TIMEOUT).join();\n      Assert.assertFalse(\"concat() did not delete source segment\", s.exists(sourceSegment, TIMEOUT).join());\n      Assert.assertEquals(\"Unexpected target StreamSegment.length after concatenation.\", preConcatTargetProps.getLength() + sourceProps.getLength(), postConcatTargetProps.getLength());\n      firstSegmentLength.set(postConcatTargetProps.getLength());\n    }\n    SegmentProperties segmentProperties = s.getStreamSegmentInfo(firstSegmentName, TIMEOUT).join();\n    byte[] readBuffer = new byte[(int)segmentProperties.getLength()];\n    int bytesRead = s.read(firstSegmentHandle, 0, readBuffer, 0, readBuffer.length, TIMEOUT).join();\n    Assert.assertEquals(\"Unexpected number of bytes read.\", readBuffer.length, bytesRead);\n    int offset = 0;\n    for (String segmentName : concatOrder) {\n      byte[] concatData = appendData.get(segmentName).toByteArray();\n      AssertExtensions.assertArrayEquals(\"Unexpected concat data.\", concatData, 0, readBuffer, offset, concatData.length);\n      offset += concatData.length;\n    }\n    Assert.assertEquals(\"Concat included more bytes than expected.\", offset, readBuffer.length);\n  }\n}"
    },
    {
        "id": 101,
        "original": "@Test\npublic void testRemoveFinishedWrites() {\n  final int timeIncrement = 1234 * 1000;\n  AtomicLong time = new AtomicLong();\n  val q = new WriteQueue(MAX_PARALLELISM, time::get);\n  val writes = new ArrayDeque<Write>();\n  for (int i = 0; i < ITEM_COUNT; i++) {\n    time.addAndGet(timeIncrement);\n    val w = new Write(new ByteArraySegment(new byte[i]), new TestWriteLedger(i), new CompletableFuture<>());\n    if (i % 2 == 0) {\n      w.complete(new TestLogAddress(i));\n    }\n    q.add(w);\n    writes.addLast(w);\n  }\n  while (!writes.isEmpty()) {\n    val write = writes.pollFirst();\n    if (!write.isDone()) {\n      boolean result1 = q.removeFinishedWrites();\n      Assert.assertTrue(\"Unexpected value from removeFinishedWrites when there were writes left in the queue.\", result1);\n      val stats1 = q.getStatistics();\n      Assert.assertEquals(\"Unexpected size after removeFinishedWrites with no effect.\", writes.size() + 1, stats1.getSize());\n      write.complete(new TestLogAddress(time.get()));\n    }\n    long expectedElapsed = write.getTimestamp();\n    int removed = 1;\n    while (!writes.isEmpty() && writes.peekFirst().isDone()) {\n      expectedElapsed += writes.pollFirst().getTimestamp();\n      removed++;\n    }\n    expectedElapsed = (time.get() * removed - expectedElapsed) / AbstractTimer.NANOS_TO_MILLIS / removed;\n    boolean result2 = q.removeFinishedWrites();\n    Assert.assertEquals(\"Unexpected result from removeFinishedWrites.\", !writes.isEmpty(), result2);\n    val stats2 = q.getStatistics();\n    Assert.assertEquals(\"Unexpected size after removeFinishedWrites.\", writes.size(), stats2.getSize());\n    Assert.assertEquals(\"Unexpected getExpectedProcessingTimeMillis after clear.\", expectedElapsed, stats2.getExpectedProcessingTimeMillis());\n  }\n}",
        "prediction": "@Test\npublic void testRemoveFinishedWrites() {\n  final int timeIncrement = 1234 * 1000;\n  AtomicLong time = new AtomicLong();\n  val q = new WriteQueue(MAX_PARALLELISM, time::get);\n  val writes = new ArrayDeque<Write>();\n  for (int i = 0; i < ITEM_COUNT; i++) {\n    time.addAndGet(timeIncrement);\n    val w = new Write(new ByteArraySegment(new byte[i]), new TestWriteLedger(i), new CompletableFuture<>());\n    if (i % 2 == 0) {\n      w.complete(new TestLogAddress(i));\n    }\n    q.add(w);\n    writes.addLast(w);\n  }\n  while (!writes.isEmpty()) {\n    val write = writes.pollFirst();\n    if (!write.isDone()) {\n      EnumSet<CleanupStatus> result1 = q.removeFinishedWrites();\n      Assert.assertTrue(\"Unexpected value from removeFinishedWrites when there were writes left in the queue.\", result1.contains(CleanupStatus.QueueNotEmpty));\n      val stats1 = q.getStatistics();\n      Assert.assertEquals(\"Unexpected size after removeFinishedWrites with no effect.\", writes.size() + 1, stats1.getSize());\n      write.complete(new TestLogAddress(time.get()));\n    }\n    long expectedElapsed = write.getTimestamp();\n    int removed = 1;\n    while (!writes.isEmpty() && writes.peekFirst().isDone()) {\n      expectedElapsed += writes.pollFirst().getTimestamp();\n      removed++;\n    }\n    expectedElapsed = (time.get() * removed - expectedElapsed) / AbstractTimer.NANOS_TO_MILLIS / removed;\n    EnumSet<CleanupStatus> result2 = q.removeFinishedWrites();\n    Assert.assertEquals(\"Unexpected result from removeFinishedWrites.\", writes.isEmpty() ? CleanupStatus.QueueEmpty : CleanupStatus.QueueNotEmpty, result2.iterator().next());\n    val stats2 = q.getStatistics();\n    Assert.assertEquals(\"Unexpected size after removeFinishedWrites.\", writes.size(), stats2.getSize());\n    Assert.assertEquals(\"Unexpected getExpectedProcessingTimeMillis after clear.\", expectedElapsed, stats2.getExpectedProcessingTimeMillis());\n  }\n}",
        "reference": "@Test\npublic void testRemoveFinishedWrites() {\n  final int timeIncrement = 1234 * 1000;\n  AtomicLong time = new AtomicLong();\n  val q = new WriteQueue(MAX_PARALLELISM, time::get);\n  val writes = new ArrayDeque<Write>();\n  for (int i = 0; i < ITEM_COUNT; i++) {\n    time.addAndGet(timeIncrement);\n    val w = new Write(new ByteArraySegment(new byte[i]), new TestWriteLedger(i), new CompletableFuture<>());\n    if (i % 2 == 0) {\n      w.setEntryId(i);\n      w.complete();\n    }\n    q.add(w);\n    writes.addLast(w);\n  }\n  while (!writes.isEmpty()) {\n    val write = writes.pollFirst();\n    if (!write.isDone()) {\n      val result1 = q.removeFinishedWrites();\n      AssertExtensions.assertContainsSameElements(\"Unexpected value from removeFinishedWrites when there were writes left in the queue.\", EnumSet.of(WriteQueue.CleanupStatus.QueueNotEmpty), result1);\n      val stats1 = q.getStatistics();\n      Assert.assertEquals(\"Unexpected size after removeFinishedWrites with no effect.\", writes.size() + 1, stats1.getSize());\n      write.setEntryId(time.get());\n      write.complete();\n    }\n    long expectedElapsed = write.getTimestamp();\n    int removed = 1;\n    while (!writes.isEmpty() && writes.peekFirst().isDone()) {\n      expectedElapsed += writes.pollFirst().getTimestamp();\n      removed++;\n    }\n    expectedElapsed = (time.get() * removed - expectedElapsed) / AbstractTimer.NANOS_TO_MILLIS / removed;\n    val result2 = q.removeFinishedWrites();\n    val expectedResult = EnumSet.of(writes.isEmpty() ? WriteQueue.CleanupStatus.QueueEmpty : WriteQueue.CleanupStatus.QueueNotEmpty);\n    AssertExtensions.assertContainsSameElements(\"Unexpected result from removeFinishedWrites.\", expectedResult, result2);\n    val stats2 = q.getStatistics();\n    Assert.assertEquals(\"Unexpected size after removeFinishedWrites.\", writes.size(), stats2.getSize());\n    Assert.assertEquals(\"Unexpected getExpectedProcessingTimeMillis after clear.\", expectedElapsed, stats2.getExpectedProcessingTimeMillis());\n  }\n  val w3 = new Write(new ByteArraySegment(new byte[1]), new TestWriteLedger(0), new CompletableFuture<>());\n  q.add(w3);\n  w3.fail(new IntentionalException(), true);\n  val result3 = q.removeFinishedWrites();\n  AssertExtensions.assertContainsSameElements(\"Unexpected value from removeFinishedWrites when there were failed writes.\", EnumSet.of(WriteQueue.CleanupStatus.QueueEmpty, WriteQueue.CleanupStatus.WriteFailed), result3);\n}"
    },
    {
        "id": 102,
        "original": "@Test\npublic void createUserWithInvalidLoginName() {\n  User user = UserData.randomUser();\n  UserDTO userDTO = BeanMapper.map(user, UserDTO.class);\n  userDTO.setLoginName(null);\n  IdResponse response = accountWebServiceClient.createUser(userDTO);\n  assertEquals(WSResponse.PARAMETER_ERROR, response.getCode());\n  userDTO.setLoginName(\"user\");\n  response = accountWebServiceClient.createUser(userDTO);\n  assertEquals(WSResponse.PARAMETER_ERROR, response.getCode());\n}",
        "prediction": "@Test\npublic void createUserWithInvalidLoginName() {\n  User user = UserData.randomUser();\n  UserDTO userDTO = BeanMapper.map(user, UserDTO.class);\n  userDTO.setLoginName(null);\n  IdResult result = accountWebServiceClient.createUser(userDTO);\n  assertEquals(WSResponse.PARAMETER_ERROR, result.getCode());\n  userDTO.setLoginName(\"user\");\n  result = accountWebServiceClient.createUser(userDTO);\n  assertEquals(WSResponse.PARAMETER_ERROR, result.getCode());\n}",
        "reference": "@Test\npublic void createUserWithInvalidLoginName() {\n  User user = UserData.randomUser();\n  UserDTO userDTO = BeanMapper.map(user, UserDTO.class);\n  userDTO.setLoginName(null);\n  IdResult response = accountWebServiceClient.createUser(userDTO);\n  assertEquals(WSResult.PARAMETER_ERROR, response.getCode());\n  userDTO.setLoginName(\"user\");\n  response = accountWebServiceClient.createUser(userDTO);\n  assertEquals(WSResult.PARAMETER_ERROR, response.getCode());\n}"
    },
    {
        "id": 103,
        "original": "@Test\n@Category(Smoke.class)\npublic void getUser() {\n  GetUserResponse response = accountWebServiceClient.getUser(1L);\n  assertEquals(\"admin\", response.getUser().getLoginName());\n}",
        "prediction": "@Test\n@Category(Smoke.class)\npublic void getUser() {\n  GetUserResult result = accountWebServiceClient.getUser(1L);\n  assertEquals(\"admin\", result.getUser().getLoginName());\n}",
        "reference": "@Test\n@Category(Smoke.class)\npublic void getUser() {\n  GetUserResult response = accountWebServiceClient.getUser(1L);\n  assertEquals(\"admin\", response.getUser().getLoginName());\n}"
    },
    {
        "id": 104,
        "original": "@Test\npublic void changeReplicationFactor_missingExecutable(TestContext context) {\n  MockAdminClient adminClient = new MockAdminClient();\n  Vertx vertx = Vertx.vertx();\n  Topic topic = new Topic.Builder(\"changeReplicationFactor\", 2, (short)2, emptyMap()).build();\n  String[] partitions = new String[] {\"changeReplicationFactor-0\", \"changeReplicationFactor-1\"};\n  final String doesNotExist = \"/some/executable/that/does/not/exist\";\n  Subclass sub = new Subclass(adminClient, vertx, config, doesNotExist, asList(Subclass.generate(\"{\\\"version\\\":1,\\\"partitions\\\":[{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":0,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]},{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":1,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]}]}\", \"{\\\"version\\\":1,\\\"partitions\\\":[{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":0,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]},{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":1,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]}]}\"), Subclass.executeStarted(), Subclass.verifyInProgress(partitions), Subclass.verifySuccess(partitions)));\n  Async async = context.async();\n  sub.changeReplicationFactor(topic, ar -> {\n    context.assertFalse(ar.succeeded());\n    final String message = ar.cause().getMessage();\n    context.assertTrue(message.contains(\"lacks an executable arg[0]\") && message.contains(\"/some/executable/that/does/not/exist\"));\n    async.complete();\n  });\n}",
        "prediction": "@Test\npublic void changeReplicationFactor_missingExecutable(TestContext context) {\n  MockAdminClient adminClient = new MockAdminClient();\n  Vertx vertx = Vertx.vertx();\n  Topic topic = new Topic.Builder(\"changeReplicationFactor\", 2, (short)2, emptyMap()).build();\n  String[] partitions = new String[] {\"changeReplicationFactor-0\", \"changeReplicationFactor-1\"};\n  final String doesNotExist = \"/some/executable/that/does/not/exist\";\n  Subclass sub = new Subclass(adminClient, vertx, config, doesNotExist, asList(Subclass.generate(\"{\\\"version\\\":1,\\\"partitions\\\":[{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":0,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]},{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":1,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]}]}\", \"{\\\"version\\\":1,\\\"partitions\\\":[{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":0,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]},{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":1,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]}]}\"), Subclass.executeStarted(), Subclass.verifyInProgress(partitions), Subclass.verifySuccess(partitions)));\n  Async async = context.async();\n  sub.changeReplicationFactor(topic).setHandler(ar -> {\n    context.assertFalse(ar.succeeded());\n    final String message = ar.cause().getMessage();\n    context.assertTrue(message.contains(\"lacks an executable arg[0]\") && message.contains(\"/some/executable/that/does/not/exist\"));\n    async.complete();\n  });\n}",
        "reference": "@Test\npublic void changeReplicationFactor_missingExecutable(TestContext context) {\n  MockAdminClient adminClient = new MockAdminClient();\n  Vertx vertx = Vertx.vertx();\n  Topic topic = new Topic.Builder(\"changeReplicationFactor\", 2, (short)2, emptyMap()).build();\n  String[] partitions = new String[] {\"changeReplicationFactor-0\", \"changeReplicationFactor-1\"};\n  final String doesNotExist = \"/some/executable/that/does/not/exist\";\n  Subclass sub = new Subclass(adminClient, vertx, config, doesNotExist, asList(Subclass.generate(\"{\\\"version\\\":1,\\\"partitions\\\":[{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":0,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]},{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":1,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]}]}\", \"{\\\"version\\\":1,\\\"partitions\\\":[{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":0,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]},{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":1,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]}]}\"), Subclass.executeStarted(), Subclass.verifyInProgress(partitions), Subclass.verifySuccess(partitions)));\n  Async async = context.async();\n  sub.changeReplicationFactor(topic).setHandler(ar -> {\n    context.assertFalse(ar.succeeded());\n    final String message = ar.cause().getMessage();\n    context.assertTrue(message.contains(\"lacks an executable arg[0]\") && message.contains(\"/some/executable/that/does/not/exist\"));\n    async.complete();\n  });\n}"
    },
    {
        "id": 105,
        "original": "@Test\npublic void changeReplicationFactor(TestContext context) {\n  MockAdminClient adminClient = new MockAdminClient();\n  Vertx vertx = Vertx.vertx();\n  Topic topic = new Topic.Builder(\"changeReplicationFactor\", 2, (short)2, emptyMap()).build();\n  String[] partitions = new String[] {\"changeReplicationFactor-0\", \"changeReplicationFactor-1\"};\n  Subclass sub = new Subclass(adminClient, vertx, config, asList(Subclass.generate(\"{\\\"version\\\":1,\\\"partitions\\\":[{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":0,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]},{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":1,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]}]}\", \"{\\\"version\\\":1,\\\"partitions\\\":[{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":0,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]},{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":1,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]}]}\"), Subclass.executeStarted(), Subclass.verifyInProgress(partitions), Subclass.verifySuccess(partitions)));\n  Async async = context.async();\n  sub.changeReplicationFactor(topic, ar -> {\n    context.assertTrue(ar.succeeded());\n    async.complete();\n  });\n}",
        "prediction": "@Test\npublic void changeReplicationFactor(TestContext context) {\n  MockAdminClient adminClient = new MockAdminClient();\n  Vertx vertx = Vertx.vertx();\n  Topic topic = new Topic.Builder(\"changeReplicationFactor\", 2, (short)2, emptyMap()).build();\n  String[] partitions = new String[] {\"changeReplicationFactor-0\", \"changeReplicationFactor-1\"};\n  Subclass sub = new Subclass(adminClient, vertx, config, asList(Subclass.generate(\"{\\\"version\\\":1,\\\"partitions\\\":[{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":0,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]},{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":1,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]}]}\", \"{\\\"version\\\":1,\\\"partitions\\\":[{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":0,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]},{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":1,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]}]}\"), Subclass.executeStarted(), Subclass.verifyInProgress(partitions), Subclass.verifySuccess(partitions)));\n  Async async = context.async();\n  sub.changeReplicationFactor(topic).setHandler(ar -> {\n    context.assertTrue(ar.succeeded());\n    async.complete();\n  });\n}",
        "reference": "@Test\npublic void changeReplicationFactor(TestContext context) {\n  MockAdminClient adminClient = new MockAdminClient();\n  Vertx vertx = Vertx.vertx();\n  Topic topic = new Topic.Builder(\"changeReplicationFactor\", 2, (short)2, emptyMap()).build();\n  String[] partitions = new String[] {\"changeReplicationFactor-0\", \"changeReplicationFactor-1\"};\n  Subclass sub = new Subclass(adminClient, vertx, config, asList(Subclass.generate(\"{\\\"version\\\":1,\\\"partitions\\\":[{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":0,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]},{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":1,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]}]}\", \"{\\\"version\\\":1,\\\"partitions\\\":[{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":0,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]},{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":1,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]}]}\"), Subclass.executeStarted(), Subclass.verifyInProgress(partitions), Subclass.verifySuccess(partitions)));\n  Async async = context.async();\n  sub.changeReplicationFactor(topic).setHandler(ar -> {\n    context.assertTrue(ar.succeeded());\n    async.complete();\n  });\n}"
    },
    {
        "id": 106,
        "original": "@Test\npublic void changeReplicationFactor_ExecuteFail(TestContext context) {\n  MockAdminClient adminClient = new MockAdminClient();\n  Vertx vertx = Vertx.vertx();\n  Topic topic = new Topic.Builder(\"changeReplicationFactor\", 2, (short)2, emptyMap()).build();\n  String[] partitions = new String[] {\"changeReplicationFactor-0\", \"changeReplicationFactor-1\"};\n  Subclass sub = new Subclass(adminClient, vertx, config, asList(Subclass.generate(\"{\\\"version\\\":1,\\\"partitions\\\":[{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":0,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]},{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":1,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]}]}\", \"{\\\"version\\\":1,\\\"partitions\\\":[{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":0,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]},{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":1,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]}]}\"), Subclass.executeFail(\"Bang!\"), Subclass.executeStarted(), Subclass.verifyInProgress(partitions), Subclass.verifySuccess(partitions)));\n  Async async = context.async();\n  sub.changeReplicationFactor(topic, ar -> {\n    context.assertFalse(ar.succeeded());\n    context.assertTrue(ar.cause().getMessage().contains(\"Failed to reassign partitions\"));\n    async.complete();\n  });\n}",
        "prediction": "@Test\npublic void changeReplicationFactor_ExecuteFail(TestContext context) {\n  MockAdminClient adminClient = new MockAdminClient();\n  Vertx vertx = Vertx.vertx();\n  Topic topic = new Topic.Builder(\"changeReplicationFactor\", 2, (short)2, emptyMap()).build();\n  String[] partitions = new String[] {\"changeReplicationFactor-0\", \"changeReplicationFactor-1\"};\n  Subclass sub = new Subclass(adminClient, vertx, config, asList(Subclass.generate(\"{\\\"version\\\":1,\\\"partitions\\\":[{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":0,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]},{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":1,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]}]}\", \"{\\\"version\\\":1,\\\"partitions\\\":[{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":0,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]},{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":1,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]}]}\"), Subclass.executeFail(\"Bang!\"), Subclass.executeStarted(), Subclass.verifyInProgress(partitions), Subclass.verifySuccess(partitions)));\n  Async async = context.async();\n  sub.changeReplicationFactor(topic).setHandler(ar -> {\n    context.assertFalse(ar.succeeded());\n    context.assertTrue(ar.cause().getMessage().contains(\"Failed to reassign partitions\"));\n    async.complete();\n  });\n}",
        "reference": "@Test\npublic void changeReplicationFactor_ExecuteFail(TestContext context) {\n  MockAdminClient adminClient = new MockAdminClient();\n  Vertx vertx = Vertx.vertx();\n  Topic topic = new Topic.Builder(\"changeReplicationFactor\", 2, (short)2, emptyMap()).build();\n  String[] partitions = new String[] {\"changeReplicationFactor-0\", \"changeReplicationFactor-1\"};\n  Subclass sub = new Subclass(adminClient, vertx, config, asList(Subclass.generate(\"{\\\"version\\\":1,\\\"partitions\\\":[{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":0,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]},{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":1,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]}]}\", \"{\\\"version\\\":1,\\\"partitions\\\":[{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":0,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]},{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":1,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]}]}\"), Subclass.executeFail(\"Bang!\"), Subclass.executeStarted(), Subclass.verifyInProgress(partitions), Subclass.verifySuccess(partitions)));\n  Async async = context.async();\n  sub.changeReplicationFactor(topic).setHandler(ar -> {\n    context.assertFalse(ar.succeeded());\n    context.assertTrue(ar.cause().getMessage().contains(\"Failed to reassign partitions\"));\n    async.complete();\n  });\n}"
    },
    {
        "id": 107,
        "original": "@Test\npublic void testGetCpu() {\n  System.out.println(\"getCpu\");\n  prepareTestData(123);\n  double result = instance.getCpu();\n  System.out.println(result);\n  assertTrue(result >= 0);\n}",
        "prediction": "@Test\npublic void testGetCpu() throws PerfMonException {\n  System.out.println(\"getCpu\");\n  prepareTestData(123);\n  double result = instance.getCpu();\n  System.out.println(result);\n  assertTrue(result >= 0);\n}",
        "reference": "@Test\npublic void testGetCpu() throws PerfMonException {\n  System.out.println(\"getCpu\");\n  prepareTestData(123);\n  double result = instance.getCpu();\n  System.out.println(result);\n  assertTrue(result >= 0);\n}"
    },
    {
        "id": 108,
        "original": "@Test\npublic void testGetEnvMapForLog() {\n  LOGGER.debug(JsonUtil.format(SystemUtil.getEnvMapForLog()));\n}",
        "prediction": "@Test\npublic void testGetEnvMapForLog() {\n  LOGGER.debug(JsonUtil.format(SystemUtil.getEnvMap()));\n}",
        "reference": "@Test\npublic void testGetEnvMap() {\n  LOGGER.debug(JsonUtil.format(SystemUtil.getEnvMap()));\n}"
    },
    {
        "id": 109,
        "original": "@Test\npublic final void getResponseBodyAsString() {\n  String templateFile = \"http://10.8.25.80:6666/template.csv?sign=123456\";\n  HttpURLConnectionParam httpURLConnectionParam = new HttpURLConnectionParam();\n  httpURLConnectionParam.setContentCharset(CharsetType.GBK);\n  String responseBodyAsString = URLConnectionUtil.getResponseBodyAsString(templateFile, httpURLConnectionParam);\n  LOGGER.info(responseBodyAsString);\n}",
        "prediction": "@Test\npublic final void getResponseBodyAsString() {\n  String templateFile = \"http://10.8.25.80:6666/template.csv?sign=123456\";\n  ConnectionConfig connectionConfig = new ConnectionConfig();\n  connectionConfig.setContentCharset(CharsetType.GBK);\n  String responseBodyAsString = URLConnectionUtil.getResponseBodyAsString(templateFile, connectionConfig);\n  LOGGER.info(responseBodyAsString);\n}",
        "reference": "@Test\npublic final void getResponseBodyAsString() {\n  String templateFile = \"http://10.8.25.80:6666/template.csv?sign=123456\";\n  ConnectionConfig connectionConfig = new ConnectionConfig();\n  connectionConfig.setContentCharset(CharsetType.GBK);\n  String responseBodyAsString = URLConnectionUtil.getResponseBodyAsString(templateFile, connectionConfig);\n  LOGGER.info(responseBodyAsString);\n}"
    },
    {
        "id": 110,
        "original": "@Test\npublic void testJoinValues() {\n  String value = \"create_salesorder\";\n  String value2 = \"unionpay_mobile\";\n  Map<String, String> map = new HashMap<String, String>();\n  map.put(\"service\", value);\n  map.put(\"paymentType\", value2);\n  assertEquals(StringUtils.EMPTY, ParamUtil.joinValues(map, \"a\", \"b\"));\n  assertEquals(value, ParamUtil.joinValues(map, \"service\"));\n  assertEquals(value + value2, ParamUtil.joinValues(map, \"service\", \"paymentType\"));\n  assertEquals(value2 + value, ParamUtil.joinValues(map, \"paymentType\", \"service\"));\n}",
        "prediction": "@Test\npublic void testJoinValues() {\n  String value = \"create_salesorder\";\n  String value2 = \"unionpay_mobile\";\n  Map<String, String> map = new HashMap<String, String>();\n  map.put(\"service\", value);\n  map.put(\"paymentType\", value2);\n  assertEquals(StringUtils.EMPTY, ParamUtil.joinValuesOrderByIncludeKeys(map, \"a\", \"b\"));\n  assertEquals(value, ParamUtil.joinValuesOrderByIncludeKeys(map, \"service\"));\n  assertEquals(value + value2, ParamUtil.joinValuesOrderByIncludeKeys(map, \"service\", \"paymentType\"));\n  assertEquals(value2 + value, ParamUtil.joinValuesOrderByIncludeKeys(map, \"paymentType\", \"service\"));\n}",
        "reference": "@Test\npublic void testJoinValues() {\n  String value = \"create_salesorder\";\n  String value2 = \"unionpay_mobile\";\n  Map<String, String> map = new HashMap<String, String>();\n  map.put(\"service\", value);\n  map.put(\"paymentType\", value2);\n  assertEquals(StringUtils.EMPTY, ParamUtil.joinValuesOrderByIncludeKeys(map, \"a\", \"b\"));\n  assertEquals(value, ParamUtil.joinValuesOrderByIncludeKeys(map, \"service\"));\n  assertEquals(value + value2, ParamUtil.joinValuesOrderByIncludeKeys(map, \"service\", \"paymentType\"));\n  assertEquals(value2 + value, ParamUtil.joinValuesOrderByIncludeKeys(map, \"paymentType\", \"service\"));\n}"
    },
    {
        "id": 111,
        "original": "@Test\npublic void testCollectionToString() {\n  List<String> list = new ArrayList<String>();\n  list.add(\"2548\");\n  list.add(\"\");\n  ToStringConfig toStringConfig = new ToStringConfig(\",\");\n  toStringConfig.setIsJoinNullOrEmpty(false);\n  assertEquals(\"2548\", ConvertUtil.toString(list, toStringConfig));\n}",
        "prediction": "@Test\npublic void testCollectionToString() {\n  List<String> list = new ArrayList<String>();\n  list.add(\"2548\");\n  list.add(\"\");\n  ToStringConfig toStringConfig = new ToStringConfig(\",\");\n  toStringConfig.setIsJoinNullOrEmpty(false);\n  assertEquals(\"2548\", ConvertUtil.toString(toStringConfig, list));\n}",
        "reference": "@Test\npublic void testCollectionToString() {\n  List<String> list = new ArrayList<String>();\n  list.add(\"2548\");\n  list.add(\"\");\n  ToStringConfig toStringConfig = new ToStringConfig(\",\");\n  toStringConfig.setIsJoinNullOrEmpty(false);\n  assertEquals(\"2548\", ConvertUtil.toString(toStringConfig, list));\n}"
    },
    {
        "id": 112,
        "original": "@Test\npublic void testCollectionToString1() {\n  List<String> list = new ArrayList<String>();\n  list.add(\"2548\");\n  list.add(\"2548\");\n  list.add(\"2548\");\n  list.add(\"2548\");\n  list.add(\"2548\");\n  list.add(\"2548\");\n  ToStringConfig toStringConfig = new ToStringConfig(SystemUtils.LINE_SEPARATOR);\n  LOGGER.debug(ConvertUtil.toString(list, toStringConfig));\n}",
        "prediction": "@Test\npublic void testCollectionToString1() {\n  List<String> list = new ArrayList<String>();\n  list.add(\"2548\");\n  list.add(\"2548\");\n  list.add(\"2548\");\n  list.add(\"2548\");\n  list.add(\"2548\");\n  list.add(\"2548\");\n  ToStringConfig toStringConfig = new ToStringConfig(SystemUtils.LINE_SEPARATOR);\n  LOGGER.debug(ConvertUtil.toString(toStringConfig, list));\n}",
        "reference": "@Test\npublic void testCollectionToString1() {\n  List<String> list = new ArrayList<String>();\n  list.add(\"2548\");\n  list.add(\"2548\");\n  list.add(\"2548\");\n  list.add(\"2548\");\n  list.add(\"2548\");\n  list.add(\"2548\");\n  ToStringConfig toStringConfig = new ToStringConfig(SystemUtils.LINE_SEPARATOR);\n  LOGGER.debug(ConvertUtil.toString(toStringConfig, list));\n}"
    },
    {
        "id": 113,
        "original": "@Test\npublic void getConcreteMembers_isCorrect() throws Exception {\n  Element genericElement = Utils.getElementFromClass(DummyGenericClass.class);\n  assertNotNull(genericElement);\n  Map<Element, TypeMirror> genericMembers = new HashMap<>();\n  for (Element element : genericElement.getEnclosedElements()) {\n    if (element instanceof VariableElement) {\n      genericMembers.put(element, element.asType());\n    }\n  }\n  TypeMirror concreteType = TypeUtils.getInheritedType(Utils.getElementFromClass(DummyInheritedClass.class));\n  assertNotNull(concreteType);\n  TypeMirror genericType = Utils.getGenericVersionOfClass(DummyGenericClass.class);\n  assertNotNull(genericType);\n  LinkedHashMap<Element, TypeMirror> members = TypeUtils.getConcreteMembers(concreteType, types.asElement(genericType), genericMembers);\n  TypeMirror stringType = Utils.getTypeMirrorFromClass(String.class);\n  assertNotNull(stringType);\n  for (Entry<Element, TypeMirror> entry : members.entrySet()) {\n    if (entry.getKey().getSimpleName().contentEquals(\"testObject\")) {\n      assertTrue(entry.getValue().toString().equals(stringType.toString()));\n    } else if (entry.getKey().getSimpleName().contentEquals(\"testList\")) {\n      assertTrue(entry.getValue().toString().equals(types.getDeclaredType((TypeElement)Utils.getElementFromClass(ArrayList.class), stringType).toString()));\n    } else if (entry.getKey().getSimpleName().contentEquals(\"testMap\")) {\n      assertTrue(entry.getValue().toString().equals(types.getDeclaredType((TypeElement)Utils.getElementFromClass(HashMap.class), stringType, stringType).toString()));\n    } else if (entry.getKey().getSimpleName().contentEquals(\"testSet\")) {\n      assertTrue(entry.getValue().toString().equals(types.getDeclaredType((TypeElement)Utils.getElementFromClass(HashSet.class), stringType).toString()));\n    } else if (entry.getKey().getSimpleName().contentEquals(\"testArrayMap\")) {\n      TypeMirror listString = types.getDeclaredType((TypeElement)Utils.getElementFromClass(List.class), stringType);\n      assertTrue(entry.getValue().toString().equals(types.getDeclaredType((TypeElement)Utils.getElementFromClass(HashMap.class), stringType, listString).toString()));\n    } else if (entry.getKey().getSimpleName().contentEquals(\"testListMap\")) {\n      TypeMirror mapStringString = types.getDeclaredType((TypeElement)Utils.getElementFromClass(Map.class), stringType, stringType);\n      assertTrue(entry.getValue().toString().equals(types.getDeclaredType((TypeElement)Utils.getElementFromClass(ArrayList.class), mapStringString).toString()));\n    }\n  }\n}",
        "prediction": "@Test\npublic void getConcreteMembers_isCorrect() throws Exception {\n  TypeElement genericElement = (TypeElement) Utils.getElementFromClass(DummyGenericClass.class);\n  assertNotNull(genericElement);\n  Map<VariableElement, TypeMirror> genericMembers = new HashMap<>();\n  for (Element element : genericElement.getEnclosedElements()) {\n    if (element instanceof VariableElement) {\n      genericMembers.put((VariableElement)element, element.asType());\n    }\n  }\n  TypeMirror concreteType = TypeUtils.getInheritedType(Utils.getElementFromClass(DummyInheritedClass.class));\n  assertNotNull(concreteType);\n  TypeMirror genericType = Utils.getGenericVersionOfClass(DummyGenericClass.class);\n  assertNotNull(genericType);\n  LinkedHashMap<VariableElement, TypeMirror> members = TypeUtils.getConcreteMembers(concreteType, (TypeElement)types.asElement(genericType), genericMembers);\n  TypeMirror stringType = Utils.getTypeMirrorFromClass(String.class);\n  assertNotNull(stringType);\n  for (Entry<VariableElement, TypeMirror> entry : members.entrySet()) {\n    if (entry.getKey().getSimpleName().contentEquals(\"testObject\")) {\n      assertTrue(entry.getValue().toString().equals(stringType.toString()));\n    } else if (entry.getKey().getSimpleName().contentEquals(\"testList\")) {\n      assertTrue(entry.getValue().toString().equals(types.getDeclaredType((TypeElement)Utils.getElementFromClass(ArrayList.class), stringType).toString()));\n    } else if (entry.getKey().getSimpleName().contentEquals(\"testMap\")) {\n      assertTrue(entry.getValue().toString().equals(types.getDeclaredType((TypeElement)Utils.getElementFromClass(HashMap.class), stringType, stringType).toString()));\n    } else if (entry.getKey().getSimpleName().contentEquals(\"testSet\")) {\n      assertTrue(entry.getValue().toString().equals(types.getDeclaredType((TypeElement)Utils.getElementFromClass(HashSet.class), stringType).toString()));\n    } else if (entry.getKey().getSimpleName().contentEquals(\"testArrayMap\")) {\n      TypeMirror listString = types.getDeclaredType((TypeElement)Utils.getElementFromClass(List.class), stringType);\n      assertTrue(entry.getValue().toString().equals(types.getDeclaredType((TypeElement)Utils.getElementFromClass(HashMap.class), stringType, listString).toString()));\n    } else if (entry.getKey().getSimpleName().contentEquals(\"testListMap\")) {\n      TypeMirror mapStringString = types.getDeclaredType((TypeElement)Utils.getElementFromClass(Map.class), stringType, stringType);\n      assertTrue(entry.getValue().toString().equals(types.getDeclaredType((TypeElement)Utils.getElementFromClass(ArrayList.class), mapStringString).toString()));\n    }\n  }\n}",
        "reference": "@Test\npublic void getConcreteMembers_isCorrect() throws Exception {\n  Element genericElement = Utils.getElementFromClass(DummyGenericClass.class);\n  assertNotNull(genericElement);\n  Map<Element, TypeMirror> genericMembers = new HashMap<>();\n  for (Element element : genericElement.getEnclosedElements()) {\n    if (element instanceof VariableElement) {\n      genericMembers.put(element, element.asType());\n    }\n  }\n  TypeMirror concreteType = TypeUtils.getInheritedType(Utils.getElementFromClass(DummyInheritedClass.class));\n  assertNotNull(concreteType);\n  TypeMirror genericType = Utils.getGenericVersionOfClass(DummyGenericClass.class);\n  assertNotNull(genericType);\n  LinkedHashMap<Element, TypeMirror> members = TypeUtils.getConcreteMembers(concreteType, (TypeElement)types.asElement(genericType), genericMembers);\n  TypeMirror stringType = Utils.getTypeMirrorFromClass(String.class);\n  assertNotNull(stringType);\n  for (Entry<Element, TypeMirror> entry : members.entrySet()) {\n    if (entry.getKey().getSimpleName().contentEquals(\"testObject\")) {\n      assertTrue(entry.getValue().toString().equals(stringType.toString()));\n    } else if (entry.getKey().getSimpleName().contentEquals(\"testList\")) {\n      assertTrue(entry.getValue().toString().equals(types.getDeclaredType(Utils.getElementFromClass(ArrayList.class), stringType).toString()));\n    } else if (entry.getKey().getSimpleName().contentEquals(\"testMap\")) {\n      assertTrue(entry.getValue().toString().equals(types.getDeclaredType(Utils.getElementFromClass(HashMap.class), stringType, stringType).toString()));\n    } else if (entry.getKey().getSimpleName().contentEquals(\"testSet\")) {\n      assertTrue(entry.getValue().toString().equals(types.getDeclaredType(Utils.getElementFromClass(HashSet.class), stringType).toString()));\n    } else if (entry.getKey().getSimpleName().contentEquals(\"testArrayMap\")) {\n      TypeMirror listString = types.getDeclaredType(Utils.getElementFromClass(List.class), stringType);\n      assertTrue(entry.getValue().toString().equals(types.getDeclaredType(Utils.getElementFromClass(HashMap.class), stringType, listString).toString()));\n    } else if (entry.getKey().getSimpleName().contentEquals(\"testListMap\")) {\n      TypeMirror mapStringString = types.getDeclaredType(Utils.getElementFromClass(Map.class), stringType, stringType);\n      assertTrue(entry.getValue().toString().equals(types.getDeclaredType(Utils.getElementFromClass(ArrayList.class), mapStringString).toString()));\n    }\n  }\n}"
    },
    {
        "id": 114,
        "original": "@Test\npublic void testCreateClassifier() throws InterruptedException {\n  server.enqueue(jsonResponse(classifier));\n  final Classifier response = service.createClassifier(classifierId, \"en\", new File(\"src/test/resources/natural_language_classifier/weather_data_train.csv\")).execute();\n  final RecordedRequest request = server.takeRequest();\n  assertEquals(CLASSIFIERS_PATH, request.getPath());\n  assertEquals(classifier, response);\n}",
        "prediction": "@Test\npublic void testCreateClassifier() throws InterruptedException {\n  server.enqueue(jsonResponse(classifier));\n  CreateClassifierOptions createClassifierOptions = new CreateClassifierOptions.Builder()\n    .metadata(new File(\"src/test/resources/natural_language_classifier/metadata.json\"))\n    .trainingData(new File(\"src/test/resources/natural_language_classifier/weather_data_train.csv\"))\n    .build();\n  final Classifier response = service.createClassifier(createClassifierOptions).execute();\n  final RecordedRequest request = server.takeRequest();\n  assertEquals(CLASSIFIERS_PATH, request.getPath());\n  assertEquals(classifier, response);\n}",
        "reference": "@Test\npublic void testCreateClassifier() throws InterruptedException, FileNotFoundException {\n  server.enqueue(jsonResponse(classifier));\n  File metadata = new File(RESOURCE + \"metadata.json\");\n  File trainingData = new File(RESOURCE + \"weather_data_train.csv\");\n  CreateClassifierOptions createOptions = new CreateClassifierOptions.Builder().metadata(metadata).trainingData(trainingData).trainingDataFilename(\"weather_data_train.csv\").build();\n  final Classifier response = service.createClassifier(createOptions).execute();\n  final RecordedRequest request = server.takeRequest();\n  assertEquals(CLASSIFIERS_PATH, request.getPath());\n  assertEquals(classifier, response);\n}"
    },
    {
        "id": 115,
        "original": "@Test(expected = IllegalArgumentException.class)\npublic void testNullTrainingDataFile() {\n  service.createClassifier(null, null, new File(\"src/test/resources/notfound.txt\"));\n}",
        "prediction": "@Test(expected = IllegalArgumentException.class)\npublic void testNullTrainingDataFile() {\n  CreateClassifierOptions createClassifierOptions = new CreateClassifierOptions.Builder()\n      .metadata(new File(\"src/test/resources/notfound.txt\"))\n      .build();\n  service.createClassifier(createClassifierOptions);\n}",
        "reference": "@Test(expected = FileNotFoundException.class)\npublic void testNullTrainingDataFile() throws FileNotFoundException {\n  server.enqueue(jsonResponse(classifier));\n  File metadata = new File(RESOURCE + \"metadata.json\");\n  File trainingData = new File(RESOURCE + \"notfound.txt\");\n  CreateClassifierOptions createOptions = new CreateClassifierOptions.Builder().metadata(metadata).trainingData(trainingData).trainingDataFilename(\"notfound.txt\").build();\n  service.createClassifier(createOptions).execute();\n}"
    },
    {
        "id": 116,
        "original": "@Test(expected = IllegalArgumentException.class)\npublic void testNullClassifier() {\n  service.classify(\"\", \"test\");\n}",
        "prediction": "@Test(expected = IllegalArgumentException.class)\npublic void testNullClassifier() {\n  ClassifyOptions classifyOptions = new ClassifyOptions.Builder().classifierId(\"\").text(\"test\").build();\n  service.classify(classifyOptions);\n}",
        "reference": "@Test(expected = IllegalArgumentException.class)\npublic void testNullClassifier() {\n  ClassifyOptions classifyOptions = new ClassifyOptions.Builder().text(\"test\").build();\n  service.classify(classifyOptions);\n}"
    },
    {
        "id": 117,
        "original": "@Test(expected = IllegalArgumentException.class)\npublic void testNullText() {\n  service.classify(classifierId, null);\n}",
        "prediction": "@Test(expected = IllegalArgumentException.class)\npublic void testNullText() {\n  ClassifyOptions classifyOptions = new ClassifyOptions.Builder()\n    .classifierId(classifierId)\n    .text(null)\n    .build();\n  service.classify(classifyOptions);\n}",
        "reference": "@Test(expected = IllegalArgumentException.class)\npublic void testNullText() {\n  ClassifyOptions classifyOptions = new ClassifyOptions.Builder().classifierId(classifierId).build();\n  service.classify(classifyOptions);\n}"
    },
    {
        "id": 118,
        "original": "@Test(expected = IllegalArgumentException.class)\npublic void testNullDeleteClassifier() {\n  service.deleteClassifier(\"\");\n}",
        "prediction": "@Test(expected = IllegalArgumentException.class)\npublic void testNullDeleteClassifier() {\n  DeleteClassifierOptions deleteClassifierOptions = new DeleteClassifierOptions.Builder().build();\n  service.deleteClassifier(deleteClassifierOptions);\n}",
        "reference": "@Test(expected = IllegalArgumentException.class)\npublic void testNullDeleteClassifier() {\n  DeleteClassifierOptions deleteOptions = new DeleteClassifierOptions.Builder().build();\n  service.deleteClassifier(deleteOptions);\n}"
    },
    {
        "id": 119,
        "original": "@Test\npublic void testSynthesize() {\n  final File audio = new File(\"src/test/resources/speech_to_text/sample1.wav\");\n  try {\n    final List<Parameter> parameters = new ArrayList<Parameter>();\n    parameters.add(new Parameter(\"text\", text));\n    parameters.add(new Parameter(\"voice\", Voice.EN_LISA.getName()));\n    parameters.add(new Parameter(\"accept\", HttpMediaType.AUDIO_WAV));\n    mockServer.when(request().withQueryStringParameters(parameters).withPath(SYNTHESIZE_PATH)).respond(response().withHeaders(new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.AUDIO_WAV)).withBody(Files.toByteArray(audio)));\n    final InputStream in = service.synthesize(text, Voice.EN_LISA, HttpMediaType.AUDIO_WAV);\n    Assert.assertNotNull(in);\n    writeInputStreamToOutputStream(in, new FileOutputStream(\"target/output.wav\"));\n  } catch (final FileNotFoundException e) {\n    Assert.fail(e.getMessage());\n  } catch (final IOException e) {\n    Assert.fail(e.getMessage());\n  }\n}",
        "prediction": "@Test\npublic void testSynthesize() {\n  final File audio = new File(\"src/test/resources/speech_to_text/sample1.wav\");\n  try {\n    final List<Parameter> parameters = new ArrayList<Parameter>();\n    parameters.add(new Parameter(\"text\", text));\n    parameters.add(new Parameter(\"voice\", Voice.EN_LISA.getName()));\n    parameters.add(new Parameter(\"accept\", HttpMediaType.AUDIO_WAV));\n    mockServer.when(request().withQueryStringParameters(parameters).withPath(SYNTHESIZE_PATH)).respond(response().withHeaders(new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.AUDIO_WAV)).withBody(Files.toByteArray(audio)));\n    final InputStream in = service.synthesize(text, Voice.EN_LISA, HttpMediaType.AUDIO_WAV).execute();\n    Assert.assertNotNull(in);\n    writeInputStreamToOutputStream(in, new FileOutputStream(\"target/output.wav\"));\n  } catch (final FileNotFoundException e) {\n    Assert.fail(e.getMessage());\n  } catch (final IOException e) {\n    Assert.fail(e.getMessage());\n  }\n}",
        "reference": "@Test\npublic void testSynthesize() {\n  final File audio = new File(\"src/test/resources/speech_to_text/sample1.wav\");\n  try {\n    final List<Parameter> parameters = new ArrayList<Parameter>();\n    parameters.add(new Parameter(\"text\", text));\n    parameters.add(new Parameter(\"voice\", Voice.EN_LISA.getName()));\n    parameters.add(new Parameter(\"accept\", HttpMediaType.AUDIO_WAV));\n    mockServer.when(request().withQueryStringParameters(parameters).withPath(SYNTHESIZE_PATH)).respond(response().withHeaders(new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.AUDIO_WAV)).withBody(Files.toByteArray(audio)));\n    final InputStream in = service.synthesize(text, Voice.EN_LISA, HttpMediaType.AUDIO_WAV).execute();\n    Assert.assertNotNull(in);\n    writeInputStreamToOutputStream(in, new FileOutputStream(\"target/output.wav\"));\n  } catch (final FileNotFoundException e) {\n    Assert.fail(e.getMessage());\n  } catch (final IOException e) {\n    Assert.fail(e.getMessage());\n  }\n}"
    },
    {
        "id": 120,
        "original": "@Test\npublic void testGetModel() {\n  final SpeechModel speechModel = new SpeechModel(\"not-a-real-Model\");\n  speechModel.setRate(8000);\n  mockServer.when(request().withPath(GET_MODELS_PATH + \"/\" + speechModel.getName())).respond(response().withHeaders(new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.APPLICATION_JSON)).withBody(GsonSingleton.getGsonWithoutPrettyPrinting().toJson(speechModel)));\n  SpeechModel model = service.getModel(\"not-a-real-Model\");\n  Assert.assertNotNull(model);\n  Assert.assertEquals(model, speechModel);\n  model = service.getModel(speechModel.getName());\n  Assert.assertNotNull(model);\n  Assert.assertEquals(model, speechModel);\n  try {\n    TestUtils.assertNoExceptionsOnGetters(model);\n  } catch (final Exception e) {\n    Assert.fail(e.getMessage());\n  }\n}",
        "prediction": "@Test\npublic void testGetModel() {\n  final SpeechModel speechModel = new SpeechModel(\"not-a-real-Model\");\n  speechModel.setRate(8000);\n  mockServer.when(request().withPath(GET_MODELS_PATH + \"/\" + speechModel.getName())).respond(response().withHeaders(new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.APPLICATION_JSON)).withBody(GsonSingleton.getGsonWithoutPrettyPrinting().toJson(speechModel)));\n  ServiceCall<SpeechModel> serviceCall = service.getModel(\"not-a-real-Model\");\n  SpeechModel model = serviceCall.execute();\n  Assert.assertNotNull(model);\n  Assert.assertEquals(model, speechModel);\n  serviceCall = service.getModel(speechModel.getName());\n  model = serviceCall.execute();\n  Assert.assertNotNull(model);\n  Assert.assertEquals(model, speechModel);\n  try {\n    TestUtils.assertNoExceptionsOnGetters(model);\n  } catch (final Exception e) {\n    Assert.fail(e.getMessage());\n  }\n}",
        "reference": "@Test\npublic void testGetModel() {\n  final SpeechModel speechModel = new SpeechModel(\"not-a-real-Model\");\n  speechModel.setRate(8000);\n  mockServer.when(request().withPath(GET_MODELS_PATH + \"/\" + speechModel.getName())).respond(response().withHeaders(new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.APPLICATION_JSON)).withBody(GsonSingleton.getGsonWithoutPrettyPrinting().toJson(speechModel)));\n  SpeechModel model = service.getModel(\"not-a-real-Model\").execute();\n  Assert.assertNotNull(model);\n  Assert.assertEquals(model, speechModel);\n  model = service.getModel(speechModel.getName()).execute();\n  Assert.assertNotNull(model);\n  Assert.assertEquals(model, speechModel);\n  try {\n    TestUtils.assertNoExceptionsOnGetters(model);\n  } catch (final Exception e) {\n    Assert.fail(e.getMessage());\n  }\n}"
    },
    {
        "id": 121,
        "original": "@Test\npublic void testRecognizeMissingAudioFile() throws URISyntaxException {\n  final SpeechResults speechResults = new SpeechResults();\n  speechResults.setResultIndex(0);\n  final Transcript transcript = new Transcript();\n  transcript.setFinal(true);\n  final SpeechAlternative speechAlternative = new SpeechAlternative();\n  speechAlternative.setTranscript(\"thunderstorms could produce large hail isolated tornadoes and heavy rain\");\n  final List<SpeechAlternative> speechAlternatives = new ArrayList<SpeechAlternative>();\n  speechAlternatives.add(speechAlternative);\n  transcript.setAlternatives(speechAlternatives);\n  final List<Transcript> transcripts = new ArrayList<Transcript>();\n  transcripts.add(transcript);\n  speechResults.setResults(transcripts);\n  mockServer.when(request().withMethod(\"POST\").withPath(RECOGNIZE_PATH).withHeaders(new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.AUDIO_WAV))).respond(response().withHeader(APPLICATION_JSON).withBody(GsonSingleton.getGsonWithoutPrettyPrinting().toJson(speechResults)));\n  boolean didItHappen = false;\n  try {\n    service.recognize(null);\n  } catch (final IllegalArgumentException e) {\n    didItHappen = true;\n  }\n  Assert.assertTrue(\"Check that 'IllegalArgumentException' is thrown.\", didItHappen);\n}",
        "prediction": "@Test\npublic void testRecognizeMissingAudioFile() throws URISyntaxException {\n  final SpeechResults speechResults = new SpeechResults();\n  speechResults.setResultIndex(0);\n  final Transcript transcript = new Transcript();\n  transcript.setFinal(true);\n  final SpeechAlternative speechAlternative = new SpeechAlternative();\n  speechAlternative.setTranscript(\"thunderstorms could produce large hail isolated tornadoes and heavy rain\");\n  final List<SpeechAlternative> speechAlternatives = new ArrayList<SpeechAlternative>();\n  speechAlternatives.add(speechAlternative);\n  transcript.setAlternatives(speechAlternatives);\n  final List<Transcript> transcripts = new ArrayList<Transcript>();\n  transcripts.add(transcript);\n  speechResults.setResults(transcripts);\n  mockServer.when(request().withMethod(\"POST\").withPath(RECOGNIZE_PATH).withHeaders(new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.AUDIO_WAV))).respond(response().withHeader(APPLICATION_JSON).withBody(GsonSingleton.getGsonWithoutPrettyPrinting().toJson(speechResults)));\n  boolean didItHappen = false;\n  try {\n    service.recognize(null).execute();\n  } catch (final IllegalArgumentException e) {\n    didItHappen = true;\n  }\n  Assert.assertTrue(\"Check that 'IllegalArgumentException' is thrown.\", didItHappen);\n}",
        "reference": "@Test\npublic void testRecognizeMissingAudioFile() throws URISyntaxException {\n  final SpeechResults speechResults = new SpeechResults();\n  speechResults.setResultIndex(0);\n  final Transcript transcript = new Transcript();\n  transcript.setFinal(true);\n  final SpeechAlternative speechAlternative = new SpeechAlternative();\n  speechAlternative.setTranscript(\"thunderstorms could produce large hail isolated tornadoes and heavy rain\");\n  final List<SpeechAlternative> speechAlternatives = new ArrayList<SpeechAlternative>();\n  speechAlternatives.add(speechAlternative);\n  transcript.setAlternatives(speechAlternatives);\n  final List<Transcript> transcripts = new ArrayList<Transcript>();\n  transcripts.add(transcript);\n  speechResults.setResults(transcripts);\n  mockServer.when(request().withMethod(\"POST\").withPath(RECOGNIZE_PATH).withHeaders(new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.AUDIO_WAV))).respond(response().withHeader(APPLICATION_JSON).withBody(GsonSingleton.getGsonWithoutPrettyPrinting().toJson(speechResults)));\n  boolean didItHappen = false;\n  try {\n    service.recognize(null).execute();\n  } catch (final IllegalArgumentException e) {\n    didItHappen = true;\n  }\n  Assert.assertTrue(\"Check that 'IllegalArgumentException' is thrown.\", didItHappen);\n}"
    },
    {
        "id": 122,
        "original": "@Test\npublic void testGetVoices() {\n  final Map<String, Object> response = new HashMap<String, Object>();\n  final List<Voice> voices = new ArrayList<Voice>();\n  final Voice voice = new Voice();\n  voice.setUrl(\"http://ibm.watson.com/text-to-speech/voices/en-US_TestMaleVoice\");\n  voice.setName(\"en-US_TestMaleVoice\");\n  voice.setGender(\"male\");\n  voice.setLanguage(\"en-US\");\n  voice.setDescription(\"TestMale\");\n  final Voice voice1 = new Voice();\n  voice1.setUrl(\"http://ibm.watson.com/text-to-speech/voices/en-US_TestFemaleVoice\");\n  voice1.setName(\"en-US_TestFemaleVoice\");\n  voice1.setGender(\"female\");\n  voice1.setLanguage(\"en-US\");\n  voice1.setDescription(\"TestFemale\");\n  voices.add(voice);\n  voices.add(voice1);\n  response.put(\"voices\", voices);\n  mockServer.when(request().withPath(GET_VOICES_PATH)).respond(response().withHeaders(new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.APPLICATION_JSON)).withBody(GsonSingleton.getGsonWithoutPrettyPrinting().toJson(response)));\n  final List<Voice> result = service.getVoices();\n  Assert.assertNotNull(result);\n  Assert.assertFalse(result.isEmpty());\n  Assert.assertEquals(result, voices);\n}",
        "prediction": "@Test\npublic void testGetVoices() {\n  final Map<String, Object> response = new HashMap<String, Object>();\n  final List<Voice> voices = new ArrayList<Voice>();\n  final Voice voice = new Voice();\n  voice.setUrl(\"http://ibm.watson.com/text-to-speech/voices/en-US_TestMaleVoice\");\n  voice.setName(\"en-US_TestMaleVoice\");\n  voice.setGender(\"male\");\n  voice.setLanguage(\"en-US\");\n  voice.setDescription(\"TestMale\");\n  final Voice voice1 = new Voice();\n  voice1.setUrl(\"http://ibm.watson.com/text-to-speech/voices/en-US_TestFemaleVoice\");\n  voice1.setName(\"en-US_TestFemaleVoice\");\n  voice1.setGender(\"female\");\n  voice1.setLanguage(\"en-US\");\n  voice1.setDescription(\"TestFemale\");\n  voices.add(voice);\n  voices.add(voice1);\n  response.put(\"voices\", voices);\n  mockServer.when(request().withPath(GET_VOICES_PATH)).respond(response().withHeaders(new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.APPLICATION_JSON)).withBody(GsonSingleton.getGsonWithoutPrettyPrinting().toJson(response)));\n  final ServiceCall<List<Voice>> serviceCall = service.getVoices();\n  final List<Voice> result = serviceCall.execute();\n  Assert.assertNotNull(result);\n  Assert.assertFalse(result.isEmpty());\n  Assert.assertEquals(result, voices);\n}",
        "reference": "@Test\npublic void testGetVoices() {\n  final Map<String, Object> response = new HashMap<String, Object>();\n  final List<Voice> voices = new ArrayList<Voice>();\n  final Voice voice = new Voice();\n  voice.setUrl(\"http://ibm.watson.com/text-to-speech/voices/en-US_TestMaleVoice\");\n  voice.setName(\"en-US_TestMaleVoice\");\n  voice.setGender(\"male\");\n  voice.setLanguage(\"en-US\");\n  voice.setDescription(\"TestMale\");\n  final Voice voice1 = new Voice();\n  voice1.setUrl(\"http://ibm.watson.com/text-to-speech/voices/en-US_TestFemaleVoice\");\n  voice1.setName(\"en-US_TestFemaleVoice\");\n  voice1.setGender(\"female\");\n  voice1.setLanguage(\"en-US\");\n  voice1.setDescription(\"TestFemale\");\n  voices.add(voice);\n  voices.add(voice1);\n  response.put(\"voices\", voices);\n  mockServer.when(request().withPath(GET_VOICES_PATH)).respond(response().withHeaders(new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.APPLICATION_JSON)).withBody(GsonSingleton.getGsonWithoutPrettyPrinting().toJson(response)));\n  final List<Voice> result = service.getVoices().execute();\n  Assert.assertNotNull(result);\n  Assert.assertFalse(result.isEmpty());\n  Assert.assertEquals(result, voices);\n}"
    },
    {
        "id": 123,
        "original": "@Test\npublic void testDeleteCorpus() throws InterruptedException, FileNotFoundException {\n  String id = \"foo\";\n  String corpus = \"cName\";\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(\"{}\"));\n  service.deleteCorpus(id, corpus).execute();\n  final RecordedRequest request = server.takeRequest();\n  assertEquals(\"DELETE\", request.getMethod());\n  assertEquals(String.format(PATH_CORPUS, id, corpus), request.getPath());\n}",
        "prediction": "@Test\npublic void testDeleteCorpus() throws InterruptedException, FileNotFoundException {\n  String id = \"foo\";\n  String corpus = \"cName\";\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(\"{}\"));\n  DeleteCorpusOptions deleteCorpusOptions = new DeleteCorpusOptions.Builder().customizationId(id).corpusName(corpus).build();\n  service.deleteCorpus(deleteCorpusOptions).execute();\n  final RecordedRequest request = server.takeRequest();\n  assertEquals(\"DELETE\", request.getMethod());\n  assertEquals(String.format(\"/v1/customizations/%s/corpora/%s\", id, corpus), request.getPath());\n}",
        "reference": "@Test\npublic void testDeleteCorpus() throws InterruptedException, FileNotFoundException {\n  String id = \"foo\";\n  String corpus = \"cName\";\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(\"{}\"));\n  DeleteCorpusOptions deleteOptions = new DeleteCorpusOptions.Builder().customizationId(id).corpusName(corpus).build();\n  service.deleteCorpus(deleteOptions).execute();\n  final RecordedRequest request = server.takeRequest();\n  assertEquals(\"DELETE\", request.getMethod());\n  assertEquals(String.format(PATH_CORPUS, id, corpus), request.getPath());\n}"
    },
    {
        "id": 124,
        "original": "@Test\npublic void testGetModels() throws InterruptedException {\n  final SpeechModel speechModel = new SpeechModel(\"not-a-real-Model\");\n  speechModel.setRate(8000);\n  final SpeechModel speechModel1 = new SpeechModel(\"not-a-real-Model1\");\n  speechModel1.setRate(1600);\n  final SpeechModel speechModel2 = new SpeechModel(\"not-a-real-Model2\");\n  speechModel2.setRate(8000);\n  final List<SpeechModel> speechModels = ImmutableList.of(speechModel, speechModel1, speechModel2);\n  final Map<String, ?> response = ImmutableMap.of(\"models\", speechModels);\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(response)));\n  final List<SpeechModel> models = service.getModels().execute();\n  final RecordedRequest request = server.takeRequest();\n  assertNotNull(models);\n  assertFalse(models.isEmpty());\n  assertEquals(models, response.get(\"models\"));\n  assertEquals(PATH_MODELS, request.getPath());\n}",
        "prediction": "@Test\npublic void testListModels() throws InterruptedException {\n  final SpeechModel speechModel = new SpeechModel(\"not-a-real-Model\");\n  speechModel.setRate(8000);\n  final SpeechModel speechModel1 = new SpeechModel(\"not-a-real-Model1\");\n  speechModel1.setRate(1600);\n  final SpeechModel speechModel2 = new SpeechModel(\"not-a-real-Model2\");\n  speechModel2.setRate(8000);\n  final List<SpeechModel> speechModels = ImmutableList.of(speechModel, speechModel1, speechModel2);\n  final Map<String, ?> response = ImmutableMap.of(\"models\", speechModels);\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(response)));\n  final SpeechModels models = service.listModels().execute();\n  final RecordedRequest request = server.takeRequest();\n  assertNotNull(models);\n  assertFalse(models.getModels().isEmpty());\n  assertEquals(models.getModels(), response.get(\"models\"));\n  assertEquals(PATH_MODELS, request.getPath());\n}",
        "reference": "@Test\npublic void testGetModels() throws InterruptedException {\n  final SpeechModel speechModel = new SpeechModel();\n  speechModel.setName(\"not-a-real-Model\");\n  speechModel.setRate(8000);\n  final SpeechModel speechModel1 = new SpeechModel();\n  speechModel.setName(\"not-a-real-Model1\");\n  speechModel1.setRate(1600);\n  final SpeechModel speechModel2 = new SpeechModel();\n  speechModel.setName(\"not-a-real-Model2\");\n  speechModel2.setRate(8000);\n  final List<SpeechModel> speechModels = ImmutableList.of(speechModel, speechModel1, speechModel2);\n  final Map<String, ?> response = ImmutableMap.of(\"models\", speechModels);\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(response)));\n  final SpeechModels models = service.listModels().execute();\n  final RecordedRequest request = server.takeRequest();\n  assertNotNull(models);\n  assertFalse(models.getModels().isEmpty());\n  assertEquals(models.getModels(), response.get(\"models\"));\n  assertEquals(PATH_MODELS, request.getPath());\n}"
    },
    {
        "id": 125,
        "original": "@Test\npublic void testRecognize() throws URISyntaxException, InterruptedException {\n  final SpeechResults speechResults = new SpeechResults();\n  speechResults.setResultIndex(0);\n  final Transcript transcript = new Transcript();\n  transcript.setFinal(true);\n  final SpeechAlternative speechAlternative = new SpeechAlternative();\n  speechAlternative.setTranscript(\"thunderstorms could produce large hail isolated tornadoes and heavy rain\");\n  final List<SpeechAlternative> speechAlternatives = ImmutableList.of(speechAlternative);\n  transcript.setAlternatives(speechAlternatives);\n  final List<Transcript> transcripts = ImmutableList.of(transcript);\n  speechResults.setResults(transcripts);\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(speechResults)));\n  final SpeechResults result = service.recognize(SAMPLE_WAV).execute();\n  final RecordedRequest request = server.takeRequest();\n  assertNotNull(result);\n  assertEquals(result, speechResults);\n  assertEquals(\"POST\", request.getMethod());\n  assertEquals(PATH_RECOGNIZE, request.getPath());\n  assertEquals(HttpMediaType.AUDIO_WAV, request.getHeader(CONTENT_TYPE));\n}",
        "prediction": "@Test\npublic void testRecognize() throws URISyntaxException, InterruptedException {\n  final SpeechResults speechResults = new SpeechResults();\n  speechResults.setResultIndex(0);\n  final Transcript transcript = new Transcript();\n  transcript.setFinal(true);\n  final SpeechAlternative speechAlternative = new SpeechAlternative();\n  speechAlternative.setTranscript(\"thunderstorms could produce large hail isolated tornadoes and heavy rain\");\n  final List<SpeechAlternative> speechAlternatives = ImmutableList.of(speechAlternative);\n  transcript.setAlternatives(speechAlternatives);\n  final List<Transcript> transcripts = ImmutableList.of(transcript);\n  speechResults.setResults(transcripts);\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(speechResults)));\n  \n  RecognizeOptions recognizeOptions = new RecognizeOptions.Builder()\n    .audio(SAMPLE_WAV)\n    .contentType(HttpMediaType.AUDIO_WAV)\n    .build();\n  \n  final SpeechResults result = service.recognize(recognizeOptions).execute();\n  final RecordedRequest request = server.takeRequest();\n  assertNotNull(result);\n  assertEquals(result, speechResults);\n  assertEquals(\"POST\", request.getMethod());\n  assertEquals(PATH_RECOGNIZE, request.getPath());\n  assertEquals(HttpMediaType.AUDIO_WAV, request.getHeader(CONTENT_TYPE));\n}",
        "reference": "@Test\npublic void testRecognize() throws URISyntaxException, InterruptedException {\n  final SpeechRecognitionResults speechResults = new SpeechRecognitionResults();\n  speechResults.setResultIndex(0);\n  final SpeechRecognitionResult transcript = new SpeechRecognitionResult();\n  transcript.setFinal(true);\n  final SpeechRecognitionAlternative speechAlternative = new SpeechRecognitionAlternative();\n  speechAlternative.setTranscript(\"thunderstorms could produce large hail isolated tornadoes and heavy rain\");\n  final List<SpeechRecognitionAlternative> speechAlternatives = ImmutableList.of(speechAlternative);\n  transcript.setAlternatives(speechAlternatives);\n  final List<SpeechRecognitionResult> transcripts = ImmutableList.of(transcript);\n  speechResults.setResults(transcripts);\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(speechResults)));\n  RecognizeOptions recognizeOptions = new RecognizeOptions.Builder().audio(SAMPLE_WAV).contentType(RecognizeOptions.ContentType.AUDIO_WAV).build();\n  final SpeechRecognitionResults result = service.recognize(recognizeOptions).execute();\n  final RecordedRequest request = server.takeRequest();\n  assertNotNull(result);\n  assertEquals(result, speechResults);\n  assertEquals(\"POST\", request.getMethod());\n  assertEquals(PATH_RECOGNIZE, request.getPath());\n  assertEquals(HttpMediaType.AUDIO_WAV, request.getHeader(CONTENT_TYPE));\n}"
    },
    {
        "id": 126,
        "original": "@Test\npublic void testRecognizeWithCustomization() throws FileNotFoundException, InterruptedException {\n  String id = \"foo\";\n  String recString = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/recognition.json\"));\n  JsonObject recognition = new JsonParser().parse(recString).getAsJsonObject();\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(recString));\n  RecognizeOptions options = new RecognizeOptions.Builder().customizationId(id).build();\n  SpeechResults result = service.recognize(SAMPLE_WAV, options).execute();\n  final RecordedRequest request = server.takeRequest();\n  assertEquals(\"POST\", request.getMethod());\n  assertEquals(PATH_RECOGNIZE + \"?customization_id=\" + id, request.getPath());\n  assertEquals(recognition, GSON.toJsonTree(result));\n}",
        "prediction": "@Test\npublic void testRecognizeWithCustomization() throws FileNotFoundException, InterruptedException {\n  String id = \"foo\";\n  String recString = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/recognition.json\"));\n  JsonObject recognition = new JsonParser().parse(recString).getAsJsonObject();\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(recString));\n  RecognizeOptions options = new RecognizeOptions.Builder().customizationId(id).audio(SAMPLE_WAV).build();\n  SpeechRecognitionResults result = service.recognize(options).execute();\n  final RecordedRequest request = server.takeRequest();\n  assertEquals(\"POST\", request.getMethod());\n  assertEquals(PATH_RECOGNIZE + \"?customization_id=\" + id, request.getPath());\n  assertEquals(recognition, GSON.toJsonTree(result));\n}",
        "reference": "@Test\npublic void testRecognizeWithCustomization() throws FileNotFoundException, InterruptedException {\n  String id = \"foo\";\n  String recString = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/recognition.json\"));\n  JsonObject recognition = new JsonParser().parse(recString).getAsJsonObject();\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(recString));\n  RecognizeOptions recognizeOptions = new RecognizeOptions.Builder().audio(SAMPLE_WAV).contentType(RecognizeOptions.ContentType.AUDIO_WAV).customizationId(id).build();\n  SpeechRecognitionResults result = service.recognize(recognizeOptions).execute();\n  final RecordedRequest request = server.takeRequest();\n  assertEquals(\"POST\", request.getMethod());\n  assertEquals(PATH_RECOGNIZE + \"?customization_id=\" + id, request.getPath());\n  assertEquals(recognition, GSON.toJsonTree(result));\n}"
    },
    {
        "id": 127,
        "original": "@Test\npublic void testGetRecognitionJobs() throws InterruptedException, FileNotFoundException {\n  String jobsAsString = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/jobs.json\"));\n  JsonObject jobsAsJson = new JsonParser().parse(jobsAsString).getAsJsonObject();\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(jobsAsString));\n  List<RecognitionJob> result = service.getRecognitionJobs().execute();\n  final RecordedRequest request = server.takeRequest();\n  assertEquals(\"GET\", request.getMethod());\n  assertEquals(PATH_RECOGNITIONS, request.getPath());\n  assertEquals(jobsAsJson.get(\"recognitions\"), GSON.toJsonTree(result));\n}",
        "prediction": "@Test\npublic void testCheckJobs() throws InterruptedException, FileNotFoundException {\n  String jobsAsString = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/jobs.json\"));\n  JsonObject jobsAsJson = new JsonParser().parse(jobsAsString).getAsJsonObject();\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(jobsAsString));\n  CheckJobsOptions options = new CheckJobsOptions.Builder().build();\n  RecognitionJobs result = service.checkJobs(options).execute();\n  final RecordedRequest request = server.takeRequest();\n  assertEquals(\"GET\", request.getMethod());\n  assertEquals(\"/v1/recognitions\", request.getPath());\n  assertEquals(jobsAsJson.get(\"recognitions\"), GSON.toJsonTree(result));\n}",
        "reference": "@Test\npublic void testCheckJobs() throws InterruptedException, FileNotFoundException {\n  String jobsAsString = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/jobs.json\"));\n  JsonObject jobsAsJson = new JsonParser().parse(jobsAsString).getAsJsonObject();\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(jobsAsString));\n  RecognitionJobs result = service.checkJobs().execute();\n  final RecordedRequest request = server.takeRequest();\n  assertEquals(\"GET\", request.getMethod());\n  assertEquals(PATH_RECOGNITIONS, request.getPath());\n  assertEquals(jobsAsJson.get(\"recognitions\"), GSON.toJsonTree(result.getRecognitions()));\n}"
    },
    {
        "id": 128,
        "original": "@Test\npublic void testGetCustomizations() throws InterruptedException, FileNotFoundException {\n  String customizationsAsString = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/customizations.json\"));\n  JsonObject customizations = new JsonParser().parse(customizationsAsString).getAsJsonObject();\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(customizationsAsString));\n  List<Customization> result = service.getCustomizations(\"en-us\").execute();\n  final RecordedRequest request = server.takeRequest();\n  assertEquals(\"GET\", request.getMethod());\n  assertEquals(PATH_CUSTOMIZATIONS + \"?language=en-us\", request.getPath());\n  assertEquals(customizations.get(\"customizations\").getAsJsonArray().size(), result.size());\n  assertEquals(customizations.get(\"customizations\"), GSON.toJsonTree(result));\n}",
        "prediction": "@Test\npublic void testListLanguageModels() throws InterruptedException, FileNotFoundException {\n  String customizationsAsString = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/customizations.json\"));\n  JsonObject customizations = new JsonParser().parse(customizationsAsString).getAsJsonObject();\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(customizationsAsString));\n  ListLanguageModelsOptions options = new ListLanguageModelsOptions.Builder().language(\"en-us\").build();\n  LanguageModels result = service.listLanguageModels(options).execute();\n  final RecordedRequest request = server.takeRequest();\n  assertEquals(\"GET\", request.getMethod());\n  assertEquals(\"/v1/customizations?language=en-us\", request.getPath());\n  assertEquals(customizations.get(\"customizations\").getAsJsonArray().size(), result.getCustomizations().size());\n  assertEquals(customizations.get(\"customizations\"), GSON.toJsonTree(result.getCustomizations()));\n}",
        "reference": "@Test\npublic void testListLanguageModels() throws InterruptedException, FileNotFoundException {\n  String customizationsAsString = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/customizations.json\"));\n  JsonObject customizations = new JsonParser().parse(customizationsAsString).getAsJsonObject();\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(customizationsAsString));\n  ListLanguageModelsOptions listOptions = new ListLanguageModelsOptions.Builder().language(\"en-us\").build();\n  LanguageModels result = service.listLanguageModels(listOptions).execute();\n  final RecordedRequest request = server.takeRequest();\n  assertEquals(\"GET\", request.getMethod());\n  assertEquals(PATH_CUSTOMIZATIONS + \"?language=en-us\", request.getPath());\n  assertEquals(customizations.get(\"customizations\").getAsJsonArray().size(), result.getCustomizations().size());\n  assertEquals(customizations.get(\"customizations\"), GSON.toJsonTree(result.getCustomizations()));\n}"
    },
    {
        "id": 129,
        "original": "@Test\npublic void testGetCustomization() throws InterruptedException, FileNotFoundException {\n  String id = \"foo\";\n  Customization customization = loadFixture(\"src/test/resources/speech_to_text/customization.json\", Customization.class);\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(customization)));\n  Customization result = service.getCustomization(id).execute();\n  final RecordedRequest request = server.takeRequest();\n  assertEquals(\"GET\", request.getMethod());\n  assertEquals(String.format(PATH_CUSTOMIZATION, id), request.getPath());\n  assertEquals(result.toString(), customization.toString());\n}",
        "prediction": "@Test\npublic void testGetLanguageModel() throws InterruptedException, FileNotFoundException {\n  String id = \"foo\";\n  LanguageModel languageModel = loadFixture(\"src/test/resources/speech_to_text/language_model.json\", LanguageModel.class);\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(languageModel)));\n  GetLanguageModelOptions options = new GetLanguageModelOptions.Builder().customizationId(id).build();\n  LanguageModel result = service.getLanguageModel(options).execute();\n  final RecordedRequest request = server.takeRequest();\n  assertEquals(\"GET\", request.getMethod());\n  assertEquals(String.format(\"/v1/customizations/%s\", id), request.getPath());\n  assertEquals(result.toString(), languageModel.toString());\n}",
        "reference": "@Test\npublic void testGetLanguageModel() throws InterruptedException, FileNotFoundException {\n  String id = \"foo\";\n  LanguageModel model = loadFixture(\"src/test/resources/speech_to_text/customization.json\", LanguageModel.class);\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(model)));\n  GetLanguageModelOptions getOptions = new GetLanguageModelOptions.Builder().customizationId(id).build();\n  LanguageModel result = service.getLanguageModel(getOptions).execute();\n  final RecordedRequest request = server.takeRequest();\n  assertEquals(\"GET\", request.getMethod());\n  assertEquals(String.format(PATH_CUSTOMIZATION, id), request.getPath());\n  assertEquals(result.toString(), model.toString());\n}"
    },
    {
        "id": 130,
        "original": "@Test\npublic void testCreateCustomization() throws InterruptedException, FileNotFoundException {\n  Customization customization = loadFixture(\"src/test/resources/speech_to_text/customization.json\", Customization.class);\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(customization)));\n  Customization result = service.createCustomization(customization.getName(), SpeechModel.EN_GB_BROADBANDMODEL, customization.getDescription()).execute();\n  final RecordedRequest request = server.takeRequest();\n  assertEquals(\"POST\", request.getMethod());\n  assertEquals(PATH_CUSTOMIZATIONS, request.getPath());\n  assertEquals(result.toString(), customization.toString());\n}",
        "prediction": "@Test\npublic void testCreateCustomization() throws InterruptedException, FileNotFoundException {\n  Customization customization = loadFixture(\"src/test/resources/speech_to_text/customization.json\", Customization.class);\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(customization)));\n  \n  CreateLanguageModelOptions createLanguageModelOptions = new CreateLanguageModelOptions.Builder()\n    .name(customization.getName())\n    .baseModelName(SpeechModel.EN_GB_BROADBANDMODEL)\n    .description(customization.getDescription())\n    .contentType(HttpMediaType.APPLICATION_JSON)\n    .createLanguageModel(customization)\n    .build();\n  \n  LanguageModel result = service.createLanguageModel(createLanguageModelOptions).execute();\n  \n  final RecordedRequest request = server.takeRequest();\n  assertEquals(\"POST\", request.getMethod());\n  assertEquals(PATH_CUSTOMIZATIONS, request.getPath());\n  assertEquals(result.toString(), customization.toString());\n}",
        "reference": "@Test\npublic void testCreateLanguageModel() throws InterruptedException, FileNotFoundException {\n  LanguageModel model = loadFixture(\"src/test/resources/speech_to_text/customization.json\", LanguageModel.class);\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(model)));\n  CreateLanguageModel newModel = new CreateLanguageModel.Builder().name(model.getName()).baseModelName(\"en-GB_BroadbandModel\").description(model.getDescription()).build();\n  CreateLanguageModelOptions createOptions = new CreateLanguageModelOptions.Builder().createLanguageModel(newModel).build();\n  LanguageModel result = service.createLanguageModel(createOptions).execute();\n  final RecordedRequest request = server.takeRequest();\n  assertEquals(\"POST\", request.getMethod());\n  assertEquals(PATH_CUSTOMIZATIONS, request.getPath());\n  assertEquals(result.toString(), model.toString());\n}"
    },
    {
        "id": 131,
        "original": "@Test\npublic void testDeleteCustomization() throws InterruptedException {\n  String id = \"foo\";\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(\"{}\"));\n  service.deleteCustomization(id).execute();\n  final RecordedRequest request = server.takeRequest();\n  assertEquals(\"DELETE\", request.getMethod());\n  assertEquals(String.format(PATH_CUSTOMIZATION, id), request.getPath());\n}",
        "prediction": "@Test\npublic void testDeleteLanguageModel() throws InterruptedException {\n  String id = \"foo\";\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(\"{}\"));\n  DeleteLanguageModelOptions deleteLanguageModelOptions = new DeleteLanguageModelOptions.Builder().customizationId(id).build();\n  service.deleteLanguageModel(deleteLanguageModelOptions).execute();\n  final RecordedRequest request = server.takeRequest();\n  assertEquals(\"DELETE\", request.getMethod());\n  assertEquals(String.format(\"/v1/customizations/%s\", id), request.getPath());\n}",
        "reference": "@Test\npublic void testDeleteLanguageModel() throws InterruptedException {\n  String id = \"foo\";\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(\"{}\"));\n  DeleteLanguageModelOptions deleteOptions = new DeleteLanguageModelOptions.Builder().customizationId(id).build();\n  service.deleteLanguageModel(deleteOptions).execute();\n  final RecordedRequest request = server.takeRequest();\n  assertEquals(\"DELETE\", request.getMethod());\n  assertEquals(String.format(PATH_CUSTOMIZATION, id), request.getPath());\n}"
    },
    {
        "id": 132,
        "original": "@Test\npublic void testGetCorpora() throws InterruptedException, FileNotFoundException {\n  String id = \"foo\";\n  String corporaAsString = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/corpora.json\"));\n  JsonObject corpora = new JsonParser().parse(corporaAsString).getAsJsonObject();\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(corporaAsString));\n  List<Corpus> result = service.getCorpora(id).execute();\n  final RecordedRequest request = server.takeRequest();\n  assertEquals(\"GET\", request.getMethod());\n  assertEquals(String.format(PATH_CORPORA, id), request.getPath());\n  assertEquals(corpora.get(\"corpora\"), GSON.toJsonTree(result));\n}",
        "prediction": "@Test\npublic void testListCorpora() throws InterruptedException, FileNotFoundException {\n  String id = \"foo\";\n  String corporaAsString = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/corpora.json\"));\n  JsonObject corpora = new JsonParser().parse(corporaAsString).getAsJsonObject();\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(corporaAsString));\n  ListCorporaOptions options = new ListCorporaOptions.Builder().customizationId(id).build();\n  Corpora result = service.listCorpora(options).execute();\n  final RecordedRequest request = server.takeRequest();\n  assertEquals(\"GET\", request.getMethod());\n  assertEquals(String.format(\"/v1/customizations/%s/corpora\", id), request.getPath());\n  assertEquals(corpora.get(\"corpora\"), GSON.toJsonTree(result));\n}",
        "reference": "@Test\npublic void testListCorpora() throws InterruptedException, FileNotFoundException {\n  String id = \"foo\";\n  String corporaAsString = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/corpora.json\"));\n  JsonObject corpora = new JsonParser().parse(corporaAsString).getAsJsonObject();\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(corporaAsString));\n  ListCorporaOptions listOptions = new ListCorporaOptions.Builder().customizationId(id).build();\n  Corpora result = service.listCorpora(listOptions).execute();\n  final RecordedRequest request = server.takeRequest();\n  assertEquals(\"GET\", request.getMethod());\n  assertEquals(String.format(PATH_CORPORA, id), request.getPath());\n  assertEquals(corpora.get(\"corpora\"), GSON.toJsonTree(result.getCorpora()));\n}"
    },
    {
        "id": 133,
        "original": "@Test\npublic void testGetWords() throws InterruptedException, FileNotFoundException {\n  String id = \"foo\";\n  String wordsAsStr = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/words.json\"));\n  JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject();\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr));\n  List<WordData> result = service.getWords(id, null).execute();\n  final RecordedRequest request = server.takeRequest();\n  assertEquals(\"GET\", request.getMethod());\n  assertEquals(String.format(PATH_WORDS, id), request.getPath());\n  assertEquals(words.get(\"words\"), GSON.toJsonTree(result));\n}",
        "prediction": "@Test\npublic void testListWords() throws InterruptedException, FileNotFoundException {\n  String id = \"foo\";\n  String wordsAsStr = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/words.json\"));\n  JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject();\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr));\n  ListWordsOptions listWordsOptions = new ListWordsOptions.Builder().customizationId(id).build();\n  Words result = service.listWords(listWordsOptions).execute();\n  final RecordedRequest request = server.takeRequest();\n  assertEquals(\"GET\", request.getMethod());\n  assertEquals(String.format(\"/v1/customizations/%s/words\", id), request.getPath());\n  assertEquals(words.get(\"words\"), GSON.toJsonTree(result));\n}",
        "reference": "@Test\npublic void testListWords() throws InterruptedException, FileNotFoundException {\n  String id = \"foo\";\n  String wordsAsStr = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/words.json\"));\n  JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject();\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr));\n  ListWordsOptions listOptions = new ListWordsOptions.Builder().customizationId(id).build();\n  Words result = service.listWords(listOptions).execute();\n  final RecordedRequest request = server.takeRequest();\n  assertEquals(\"GET\", request.getMethod());\n  assertEquals(String.format(PATH_WORDS, id), request.getPath());\n  assertEquals(words.get(\"words\"), GSON.toJsonTree(result.getWords()));\n}"
    },
    {
        "id": 134,
        "original": "@Test\npublic void testGetWordsType() throws InterruptedException, FileNotFoundException {\n  String id = \"foo\";\n  String wordsAsStr = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/words.json\"));\n  JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject();\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr));\n  List<WordData> result = service.getWords(id, Type.ALL).execute();\n  final RecordedRequest request = server.takeRequest();\n  assertEquals(\"GET\", request.getMethod());\n  assertEquals(String.format(PATH_WORDS, id) + \"?word_type=all\", request.getPath());\n  assertEquals(words.get(\"words\"), GSON.toJsonTree(result));\n}",
        "prediction": "@Test\npublic void testGetWordsType() throws InterruptedException, FileNotFoundException {\n  String id = \"foo\";\n  String wordsAsStr = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/words.json\"));\n  JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject();\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr));\n  ListWordsOptions listWordsOptions = new ListWordsOptions.Builder().customizationId(id).wordType(\"all\").build();\n  Words result = service.listWords(listWordsOptions).execute();\n  final RecordedRequest request = server.takeRequest();\n  assertEquals(\"GET\", request.getMethod());\n  assertEquals(String.format(\"/v1/customizations/%s/words\", id) + \"?word_type=all\", request.getPath());\n  assertEquals(words.get(\"words\"), GSON.toJsonTree(result.getWords()));\n}",
        "reference": "@Test\npublic void testListWordsType() throws InterruptedException, FileNotFoundException {\n  String id = \"foo\";\n  String wordsAsStr = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/words.json\"));\n  JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject();\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr));\n  ListWordsOptions listOptions = new ListWordsOptions.Builder().customizationId(id).wordType(ListWordsOptions.WordType.ALL).build();\n  Words result = service.listWords(listOptions).execute();\n  final RecordedRequest request = server.takeRequest();\n  assertEquals(\"GET\", request.getMethod());\n  assertEquals(String.format(PATH_WORDS, id) + \"?word_type=all\", request.getPath());\n  assertEquals(words.get(\"words\"), GSON.toJsonTree(result.getWords()));\n}"
    },
    {
        "id": 135,
        "original": "@Test\npublic void testGetWordsSort() throws InterruptedException, FileNotFoundException {\n  String id = \"foo\";\n  String wordsAsStr = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/words.json\"));\n  JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject();\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr));\n  List<WordData> result = service.getWords(id, null, Sort.ALPHA).execute();\n  final RecordedRequest request = server.takeRequest();\n  assertEquals(\"GET\", request.getMethod());\n  assertEquals(String.format(PATH_WORDS, id) + \"?sort=alphabetical\", request.getPath());\n  assertEquals(words.get(\"words\"), GSON.toJsonTree(result));\n}",
        "prediction": "@Test\npublic void testGetWordsSort() throws InterruptedException, FileNotFoundException {\n  String id = \"foo\";\n  String wordsAsStr = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/words.json\"));\n  JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject();\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr));\n  ListWordsOptions options = new ListWordsOptions.Builder().customizationId(id).sort(\"alphabetical\").build();\n  Words result = service.listWords(options).execute();\n  final RecordedRequest request = server.takeRequest();\n  assertEquals(\"GET\", request.getMethod());\n  assertEquals(String.format(\"/v1/customizations/%s/words\", id) + \"?sort=alphabetical\", request.getPath());\n  assertEquals(words.get(\"words\"), GSON.toJsonTree(result));\n}",
        "reference": "@Test\npublic void testListWordsSort() throws InterruptedException, FileNotFoundException {\n  String id = \"foo\";\n  String wordsAsStr = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/words.json\"));\n  JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject();\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr));\n  ListWordsOptions listOptions = new ListWordsOptions.Builder().customizationId(id).sort(ListWordsOptions.Sort.ALPHABETICAL).build();\n  Words result = service.listWords(listOptions).execute();\n  final RecordedRequest request = server.takeRequest();\n  assertEquals(\"GET\", request.getMethod());\n  assertEquals(String.format(PATH_WORDS, id) + \"?sort=alphabetical\", request.getPath());\n  assertEquals(words.get(\"words\"), GSON.toJsonTree(result.getWords()));\n}"
    },
    {
        "id": 136,
        "original": "@Test\npublic void testGetWordsTypeSort() throws InterruptedException, FileNotFoundException {\n  String id = \"foo\";\n  String wordsAsStr = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/words.json\"));\n  JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject();\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr));\n  List<WordData> result = service.getWords(id, Type.ALL, Sort.ALPHA).execute();\n  final RecordedRequest request = server.takeRequest();\n  assertEquals(\"GET\", request.getMethod());\n  assertEquals(String.format(PATH_WORDS, id) + \"?word_type=all&sort=alphabetical\", request.getPath());\n  assertEquals(words.get(\"words\"), GSON.toJsonTree(result));\n}",
        "prediction": "@Test\npublic void testGetWordsTypeSort() throws InterruptedException, FileNotFoundException {\n  String id = \"foo\";\n  String wordsAsStr = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/words.json\"));\n  JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject();\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr));\n  ListWordsOptions listWordsOptions = new ListWordsOptions.Builder().customizationId(id).wordType(Type.ALL).sort(Sort.ALPHA).build();\n  Words result = service.listWords(listWordsOptions).execute();\n  final RecordedRequest request = server.takeRequest();\n  assertEquals(\"GET\", request.getMethod());\n  assertEquals(String.format(PATH_WORDS, id) + \"?word_type=all&sort=alphabetical\", request.getPath());\n  assertEquals(words.get(\"words\"), GSON.toJsonTree(result));\n}",
        "reference": "@Test\npublic void testListWordsTypeSort() throws InterruptedException, FileNotFoundException {\n  String id = \"foo\";\n  String wordsAsStr = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/words.json\"));\n  JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject();\n  server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr));\n  ListWordsOptions listOptions = new ListWordsOptions.Builder().customizationId(id).sort(ListWordsOptions.Sort.ALPHABETICAL).wordType(ListWordsOptions.WordType.ALL).build();\n  Words result = service.listWords(listOptions).execute();\n  final RecordedRequest request = server.takeRequest();\n  assertEquals(\"GET\", request.getMethod());\n  assertEquals(String.format(PATH_WORDS, id) + \"?word_type=all&sort=alphabetical\", request.getPath());\n  assertEquals(words.get(\"words\"), GSON.toJsonTree(result.getWords()));\n}"
    }
]