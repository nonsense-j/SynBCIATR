[
    {
        "id": 0,
        "original": "@Test public void getGroupFromGrpcClient() throws Exception { Configuration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.NOSASL.getAuthName()); Assert.assertEquals(\"\", SecurityUtils.getGroupFromGrpcClient()); Configuration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName()); Configuration.set(PropertyKey.SECURITY_GROUP_MAPPING_CLASS, IdentityUserGroupsMapping.class.getName()); AuthenticatedClientUser.set(\"test_client_user\"); Assert.assertEquals(\"test_client_user\", SecurityUtils.getGroupFromGrpcClient()); }",
        "prediction": "@Test public void getGroupFromGrpcClient()throws Exception { AlluxioConfiguration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.NOSASL.getAuthName()); Assert.assertEquals(\"\", SecurityUtils.getGroupFromGrpcClient(conf)); AlluxioConfiguration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName()); AlluxioConfiguration.set(PropertyKey.SECURITY_GROUP_MAPPING_CLASS, IdentityUserGroupsMapping.class.getName()); AuthenticatedClientUser.set(\"test_client_user\"); Assert.assertEquals(\"test_client_user\", SecurityUtils.getGroupFromGrpcClient()); }",
        "reference": "@Test public void getGroupFromGrpcClient() throws Exception { mConfiguration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.NOSASL.getAuthName()); Assert.assertEquals(\"\", SecurityUtils.getGroupFromGrpcClient(mConfiguration)); mConfiguration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName()); mConfiguration.set(PropertyKey.SECURITY_GROUP_MAPPING_CLASS, IdentityUserGroupsMapping.class.getName()); AuthenticatedClientUser.set(\"test_client_user\"); Assert.assertEquals(\"test_client_user\", SecurityUtils.getGroupFromGrpcClient(mConfiguration)); }"
    },
    {
        "id": 1,
        "original": "@Test public void getTmpDir() { String singleDir = \"/tmp\"; Whitebox.setInternalState(CommonUtils.class, \"TMP_DIRS\", Collections.singletonList(singleDir)); assertEquals(singleDir, CommonUtils.getTmpDir()); List<String> multiDirs = Arrays.asList(\"/tmp1\", \"/tmp2\", \"/tmp3\"); Whitebox.setInternalState(CommonUtils.class, \"TMP_DIRS\", multiDirs); Set<String> results = new HashSet<>(); for (int i = 0; i < 100 || results.size() != multiDirs.size(); i++) { results.add(CommonUtils.getTmpDir()); } assertEquals(new HashSet<>(multiDirs), results); Whitebox.setInternalState(CommonUtils.class, \"TMP_DIRS\", Configuration.getList(PropertyKey.TMP_DIRS, \",\")); }",
        "prediction": "@Test public void getTmpDir() { String singleDir = \"/tmp\"; Whitebox.setInternalState(CommonUtils.class, \"TMP_DIRS\", Collections.singletonList(singleDir)); assertEquals(singleDir, CommonUtils.getTmpDir()); List < String > multiDirs = Arrays.asList(\"/tmp1\", \"/tmp2\", \"/tmp3\"); Whitebox.setInternalState(CommonUtils.class, \"TMP_DIRS\", multiDirs); Set < String > results = new HashSet<>(); for (int i = 0; i < 100 || results.size()!= multiDirs.size(); i++) { results.add(CommonUtils.getTmpDir()); } assertEquals",
        "reference": "@Test public void getTmpDir() { String singleDir = \"/tmp\"; List<String> singleDirList = Arrays.asList(\"/tmp\"); assertEquals(singleDir, CommonUtils.getTmpDir(singleDirList)); List<String> multiDirs = Arrays.asList(\"/tmp1\", \"/tmp2\", \"/tmp3\"); Set<String> results = new HashSet<>(); for (int i = 0; i < 100 || results.size() != multiDirs.size(); i++) { results.add(CommonUtils.getTmpDir(multiDirs)); } assertEquals(new HashSet<>(multiDirs), results); }"
    },
    {
        "id": 2,
        "original": "@Test public void formatPermissionTest() { Assert.assertEquals(\"-rw-rw-rw-\", FormatUtils.formatPermission((short) 0666, false)); Assert.assertEquals(\"drw-rw-rw-\", FormatUtils.formatPermission((short) 0666, true)); Assert.assertEquals(\"-rwxrwxrwx\", FormatUtils.formatPermission((short) 0777, false)); Assert.assertEquals(\"drwxrwxrwx\", FormatUtils.formatPermission((short) 0777, true)); Assert.assertEquals(\"-r--r--r--\", FormatUtils.formatPermission((short) 0444, false)); Assert.assertEquals(\"dr--r--r--\", FormatUtils.formatPermission((short) 0444, true)); Assert.assertEquals(\"-r-xr-xr-x\", FormatUtils.formatPermission((short) 0555, false)); Assert.assertEquals(\"dr-xr-xr-x\", FormatUtils.formatPermission((short) 0555, true)); Assert.assertEquals(\"-rwxr-xr--\", FormatUtils.formatPermission((short) 0754, false)); Assert.assertEquals(\"drwxr-xr--\", FormatUtils.formatPermission((short) 0754, true)); }",
        "prediction": "@Test public void formatModeTest() { Assert.assertEquals(\"-rw-rw-rw-\", FormatUtils.formatMode((short) 0666, false)); Assert.assertEquals(\"drw-rw-rw-\", FormatUtils.formatMode((short) 0666, true)); Assert.assertEquals(\"-rwxrwxrwx\", FormatUtils.formatMode((short) 0777, false)); Assert.assertEquals(\"drwxrwxrwx\", FormatUtils.formatMode((short) 0777, true)); Assert.assertEquals(\"-r--r--r--\", FormatUtils.formatMode((short) 0444, false)); Assert.assertEquals(\"dr--r--r--",
        "reference": "@Test public void formatPermissionTest() { Assert.assertEquals(\"-rw-rw-rw-\", FormatUtils.formatMode((short) 0666, false)); Assert.assertEquals(\"drw-rw-rw-\", FormatUtils.formatMode((short) 0666, true)); Assert.assertEquals(\"-rwxrwxrwx\", FormatUtils.formatMode((short) 0777, false)); Assert.assertEquals(\"drwxrwxrwx\", FormatUtils.formatMode((short) 0777, true)); Assert.assertEquals(\"-r--r--r--\", FormatUtils.formatMode((short) 0444, false)); Assert.assertEquals(\"dr--r--r--\", FormatUtils.formatMode((short) 0444, true)); Assert.assertEquals(\"-r-xr-xr-x\", FormatUtils.formatMode((short) 0555, false)); Assert.assertEquals(\"dr-xr-xr-x\", FormatUtils.formatMode((short) 0555, true)); Assert.assertEquals(\"-rwxr-xr--\", FormatUtils.formatMode((short) 0754, false)); Assert.assertEquals(\"drwxr-xr--\", FormatUtils.formatMode((short) 0754, true)); }"
    },
    {
        "id": 3,
        "original": "@Test public void applyUMaskTest() { FileSystemPermission umaskPermission = new FileSystemPermission((short) 0022); PermissionStatus permissionStatus = new PermissionStatus(\"user1\", \"group1\", FileSystemPermission.getDefault()); Configuration conf = new Configuration(); conf.set(Constants.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName()); conf.set(Constants.SECURITY_AUTHORIZATION_PERMISSION_ENABLED, \"true\"); permissionStatus = permissionStatus.applyUMask(umaskPermission, conf); Assert.assertEquals(FileSystemAction.ALL, permissionStatus.getPermission().getUserAction()); Assert.assertEquals(FileSystemAction.READ_EXECUTE, permissionStatus.getPermission().getGroupAction()); Assert.assertEquals(FileSystemAction.READ_EXECUTE, permissionStatus.getPermission().getOtherAction()); Assert.assertEquals(0755, permissionStatus.getPermission().toShort()); }",
        "prediction": "@Test public void applyUMaskTest() { FileSystemPermission umaskPermission = new FileSystemPermission((short) 0022); PermissionStatus permissionStatus = new PermissionStatus(\"user1\", \"group1\", FileSystemPermission.getDefault()); Configuration conf = new Configuration(); conf.set(Constants.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName()); conf.set(Constants.SECURITY_AUTHORIZATION_PERMISSION_ENABLED, \"true\"); permissionStatus = permissionStatus.applyUMask(umaskPermission); Assert.assertEquals(FileSystemAction.ALL, permissionStatus.getPermission().getUserAction()); Assert.assertEquals(FileSystemAction.READ_EXECUTE, permissionStatus.getPermission().get",
        "reference": "@Test public void applyUMaskTest() { FileSystemPermission umaskPermission = new FileSystemPermission((short) 0022); PermissionStatus permissionStatus = new PermissionStatus(\"user1\", \"group1\", FileSystemPermission.getDefault()); permissionStatus = permissionStatus.applyUMask(umaskPermission); Assert.assertEquals(FileSystemAction.ALL, permissionStatus.getPermission().getUserAction()); Assert.assertEquals(FileSystemAction.READ_EXECUTE, permissionStatus.getPermission().getGroupAction()); Assert.assertEquals(FileSystemAction.READ_EXECUTE, permissionStatus.getPermission().getOtherAction()); Assert.assertEquals(0755, permissionStatus.getPermission().toShort()); }"
    },
    {
        "id": 4,
        "original": "@Test public void mount() throws Exception { AlluxioURI alluxioPath = new AlluxioURI(\"/t\"); AlluxioURI ufsPath = new AlluxioURI(\"/u\"); MountOptions mountOptions = MountOptions.defaults(); doNothing().when(mFileSystemMasterClient).mount(alluxioPath, ufsPath, mountOptions); mFileSystem.mount(alluxioPath, ufsPath, mountOptions); verify(mFileSystemMasterClient).mount(alluxioPath, ufsPath, mountOptions); verifyFilesystemContextAcquiredAndReleased(); }",
        "prediction": "@Test public void mount()throws Exception { AlluxioURI alluxioPath = new AlluxioURI(\"/t\"); AlluxioURI ufsPath = new AlluxioURI(\"/u\"); MountPOptions mountOptions = MountPOptions.defaults(); doNothing().when(mFileSystemMasterClient).mount(alluxioPath, ufsPath, mountOptions); mFileSystem.mount(alluxioPath, ufsPath, mountOptions); verify(mFileSystemMasterClient).mount(alluxioPath, ufsPath, mountOptions); verifyFilesystemContextAcquiredAndReleased(); }",
        "reference": "@Test public void mount() throws Exception { AlluxioURI alluxioPath = new AlluxioURI(\"/t\"); AlluxioURI ufsPath = new AlluxioURI(\"/u\"); MountPOptions mountOptions = MountPOptions.getDefaultInstance(); doNothing().when(mFileSystemMasterClient).mount(alluxioPath, ufsPath, mountOptions); mFileSystem.mount(alluxioPath, ufsPath, mountOptions); verify(mFileSystemMasterClient).mount(alluxioPath, ufsPath, mountOptions); verifyFilesystemContextAcquiredAndReleased(); }"
    },
    {
        "id": 5,
        "original": "@Test public void countBytes() throws Exception { long worker1 = mBlockMaster.getWorkerId(NET_ADDRESS_1); long worker2 = mBlockMaster.getWorkerId(NET_ADDRESS_2); List<String> tiers = Arrays.asList(\"MEM\", \"SSD\"); Map<String, Long> worker1TotalBytesOnTiers = ImmutableMap.of(\"MEM\", 10L, \"SSD\", 20L); Map<String, Long> worker2TotalBytesOnTiers = ImmutableMap.of(\"MEM\", 1000L, \"SSD\", 2000L); Map<String, Long> worker1UsedBytesOnTiers = ImmutableMap.of(\"MEM\", 1L, \"SSD\", 2L); Map<String, Long> worker2UsedBytesOnTiers = ImmutableMap.of(\"MEM\", 100L, \"SSD\", 200L); mBlockMaster.workerRegister(worker1, tiers, worker1TotalBytesOnTiers, worker1UsedBytesOnTiers, NO_BLOCKS_ON_TIERS, new RegisterWorkerTOptions()); mBlockMaster.workerRegister(worker2, tiers, worker2TotalBytesOnTiers, worker2UsedBytesOnTiers, NO_BLOCKS_ON_TIERS, new RegisterWorkerTOptions()); assertEquals(3030, mBlockMaster.getCapacityBytes()); assertEquals(303L, mBlockMaster.getUsedBytes()); assertEquals(ImmutableMap.of(\"MEM\", 1010L, \"SSD\", 2020L), mBlockMaster.getTotalBytesOnTiers()); assertEquals(ImmutableMap.of(\"MEM\", 101L, \"SSD\", 202L), mBlockMaster.getUsedBytesOnTiers()); }",
        "prediction": "@Test public void countBytes()throws Exception { long worker1 = mBlockMaster.getWorkerId(NET_ADDRESS_1); long worker2 = mBlockMaster.getWorkerId(NET_ADDRESS_2); List<String> tiers = Arrays.asList(\"MEM\", \"SSD\"); Map<String, Long> worker1TotalBytesOnTiers = ImmutableMap.of(\"MEM\", 10L, \"SSD\", 20L); Map<String, Long> worker2TotalBytesOnTiers = ImmutableMap.of(\"MEM\", 1000L, \"SSD\", 2000L); Map<String, Long> worker1UsedBytesOnTiers = ImmutableMap.of(\"MEM\", 1L, \"",
        "reference": "@Test public void countBytes() throws Exception { long worker1 = mBlockMaster.getWorkerId(NET_ADDRESS_1); long worker2 = mBlockMaster.getWorkerId(NET_ADDRESS_2); List<String> tiers = Arrays.asList(\"MEM\", \"SSD\"); Map<String, Long> worker1TotalBytesOnTiers = ImmutableMap.of(\"MEM\", 10L, \"SSD\", 20L); Map<String, Long> worker2TotalBytesOnTiers = ImmutableMap.of(\"MEM\", 1000L, \"SSD\", 2000L); Map<String, Long> worker1UsedBytesOnTiers = ImmutableMap.of(\"MEM\", 1L, \"SSD\", 2L); Map<String, Long> worker2UsedBytesOnTiers = ImmutableMap.of(\"MEM\", 100L, \"SSD\", 200L); mBlockMaster.workerRegister(worker1, tiers, worker1TotalBytesOnTiers, worker1UsedBytesOnTiers, NO_BLOCKS_ON_TIERS, RegisterWorkerPOptions.getDefaultInstance()); mBlockMaster.workerRegister(worker2, tiers, worker2TotalBytesOnTiers, worker2UsedBytesOnTiers, NO_BLOCKS_ON_TIERS, RegisterWorkerPOptions.getDefaultInstance()); assertEquals(3030, mBlockMaster.getCapacityBytes()); assertEquals(303L, mBlockMaster.getUsedBytes()); assertEquals(ImmutableMap.of(\"MEM\", 1010L, \"SSD\", 2020L), mBlockMaster.getTotalBytesOnTiers()); assertEquals(ImmutableMap.of(\"MEM\", 101L, \"SSD\", 202L), mBlockMaster.getUsedBytesOnTiers()); }"
    },
    {
        "id": 6,
        "original": "@Test public void setUserFromLoginModuleTest() throws Exception { Configuration conf = new Configuration(); Permission permission = Permission.defaults(); conf.set(Constants.SECURITY_AUTHENTICATION_TYPE, AuthType.NOSASL.getAuthName()); permission.setUserFromThriftClient(conf); verifyPermission(\"\", \"\", (short) 0777, permission); conf.set(Constants.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName()); conf.set(Constants.SECURITY_LOGIN_USERNAME, \"test_login_user\"); conf.set(Constants.SECURITY_GROUP_MAPPING, IdentityUserGroupsMapping.class.getName()); Whitebox.setInternalState(LoginUser.class, \"sLoginUser\", (String) null); permission.setUserFromLoginModule(conf); verifyPermission(\"test_login_user\", \"test_login_user\", (short) 0777, permission); }",
        "prediction": "@Test public void setUserFromLoginModuleTest()throws Exception { Configuration conf = new Configuration(); Permission permission = Permission.defaults(); conf.set(Constants.SECURITY_AUTHENTICATION_TYPE, AuthType.NOSASL.getAuthName()); permission.setUserFromThriftClient(conf); verifyPermission(\"\", \"\", (short) 0777, permission); conf.set(Constants.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName()); conf.set(Constants.SECURITY_LOGIN_USERNAME, \"test_login_user\"); conf.set(Constants.SECURITY_GROUP_MAPPING, IdentityUserGroupsMapping.class.getName()); Whitebox.setInternalState(LoginUser.class,",
        "reference": "@Test public void setUserFromLoginModuleTest() throws Exception { Configuration.defaultInit(); Permission permission = Permission.defaults(); Configuration.set(Constants.SECURITY_AUTHENTICATION_TYPE, AuthType.NOSASL.getAuthName()); permission.setUserFromThriftClient(); verifyPermission(\"\", \"\", (short) 0777, permission); Configuration.set(Constants.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName()); Configuration.set(Constants.SECURITY_LOGIN_USERNAME, \"test_login_user\"); Configuration.set(Constants.SECURITY_GROUP_MAPPING, IdentityUserGroupsMapping.class.getName()); Whitebox.setInternalState(LoginUser.class, \"sLoginUser\", (String) null); permission.setUserFromLoginModule(); verifyPermission(\"test_login_user\", \"test_login_user\", (short) 0777, permission); }"
    },
    {
        "id": 7,
        "original": "@Test public void createBlockPath() throws IOException { String absolutePath = PathUtils.concatPath(mTestFolder.getRoot(), \"tmp\", \"bar\"); File tempFile = new File(absolutePath); FileUtils.createBlockPath(tempFile.getAbsolutePath()); assertTrue(FileUtils.exists(tempFile.getParent())); }",
        "prediction": "@Test public void createBlockPath()throws IOException { String absolutePath = PathUtils.concatPath(mTestFolder.getRoot(), \"tmp\", \"bar\"); File tempFile = new File(absolutePath); FileUtils.createBlockPath(tempFile.getAbsolutePath(), \"workerDataFolderPermissions\"); assertTrue(FileUtils.exists(tempFile.getParent())); }",
        "reference": "@Test public void createBlockPath() throws IOException { String absolutePath = PathUtils.concatPath(mTestFolder.getRoot(), \"tmp\", \"bar\"); File tempFile = new File(absolutePath); FileUtils.createBlockPath(tempFile.getAbsolutePath(), mWorkerDataFolderPerms); assertTrue(FileUtils.exists(tempFile.getParent())); }"
    },
    {
        "id": 8,
        "original": "@Test public final void testToArray() { ItemList il = new ItemList(Itr.ZERO); for(int i = 0; i < CAP - 1; i++) { il.add(Itr.ZERO); } assertEquals(CAP, il.toArray().length); assertEquals(il.size(), il.toArray().length); }",
        "prediction": "@Test public final void testToArray() { ItemList il = new ItemList(Itr.ZERO, CAP); for(int i = 0; i < CAP - 1; i++) { il.add(Itr.ZERO); } assertEquals(CAP, il.finish().length); assertEquals(il.size(), il.finish().length); }",
        "reference": "@Test public final void testToArray() { ItemList il = new ItemList(Itr.ZERO); for(int i = 0; i < CAP - 1; i++) { il.add(Itr.ZERO); } assertEquals(CAP, il.finish().length); }"
    },
    {
        "id": 9,
        "original": "@Test public void handleFailure() throws Exception { Map map = new HashMap<String, Boolean>(); map.put(\"Key\", true); assertThat(client.handleFailure(map).get()).isEqualTo(true); }",
        "prediction": "@Test public void handleFailure()throws Exception { Set < String > set = new HashSet < String > (); set.add(\"Key\", true); assertThat(client.handleFailure(set).get()).isEqualTo(true); }",
        "reference": "@Test public void handleFailure() throws Exception { Set<String> set = new HashSet<>(); set.add(\"Key\"); assertThat(client.handleFailure(set).get()).isEqualTo(true); }"
    },
    {
        "id": 10,
        "original": "@Test public void successfulPolling() throws InterruptedException { for (int i = 0; i < PARAMETERS.CONCURRENCY_SOME; i++) { failureDetectorPolicy.executePolicy(layout, corfuRuntime); Thread.sleep(PARAMETERS.TIMEOUT_VERY_SHORT.toMillis()); } Thread.sleep(PARAMETERS.TIMEOUT_SHORT.toMillis()); Map<String, Boolean> result = failureDetectorPolicy.getServerStatus(); assertThat(result).isNull(); }",
        "prediction": "@Test public void successfulPolling()throws InterruptedException { for (int i = 0; i < PARAMETERS.CONCURRENCY_SOME; i++) { failureDetectorPolicy.executePolicy(layout, corfuRuntime); Thread.sleep(PARAMETERS.TIMEOUT_VERY_SHORT.toMillis()); } Thread.sleep(PARAMETERS.TIMEOUT_SHORT.toMillis()); PollReport result = failureDetectorPolicy.getServerStatus(); assertThat(result).isNull(); }",
        "reference": "@Test public void successfulPolling() throws InterruptedException { for (int i = 0; i < PARAMETERS.CONCURRENCY_SOME; i++) { failureDetectorPolicy.executePolicy(layout, corfuRuntime); Thread.sleep(PARAMETERS.TIMEOUT_VERY_SHORT.toMillis()); } Thread.sleep(PARAMETERS.TIMEOUT_SHORT.toMillis()); PollReport result = failureDetectorPolicy.getServerStatus(); assertThat(result.getIsFailurePresent()).isFalse(); }"
    },
    {
        "id": 11,
        "original": "@Test public void failedPolling() throws InterruptedException { addServerRule(SERVERS.PORT_0, new TestRule().always().drop()); addServerRule(SERVERS.PORT_1, new TestRule().always().drop()); addServerRule(SERVERS.PORT_2, new TestRule().always().drop()); Map<String, Boolean> expectedResult = new HashMap<>(); expectedResult.put(getEndpoint(SERVERS.PORT_0), false); expectedResult.put(getEndpoint(SERVERS.PORT_1), false); expectedResult.put(getEndpoint(SERVERS.PORT_2), false); pollAndMatchExpectedResult(expectedResult); clearServerRules(SERVERS.PORT_0); expectedResult.remove(getEndpoint(SERVERS.PORT_0)); pollAndMatchExpectedResult(expectedResult); }",
        "prediction": "@Test public void failedPolling()throws InterruptedException { addServerRule(SERVERS.PORT_0, new TestRule().always().drop()); addServerRule(SERVERS.PORT_1, new TestRule().always().drop()); addServerRule(SERVERS.PORT_2, new TestRule().always().drop()); Map<String, Boolean> expectedResult = new HashMap<>(); expectedResult.put(getEndpoint(SERVERS.PORT_0), false); expectedResult.put(getEndpoint(SERVERS.PORT_1), false); expectedResult.put(getEndpoint(SERVERS.PORT_2), false); pollAndMatchExpectedResult(expectedResult); clearServerRules(SERVERS.PORT",
        "reference": "@Test public void failedPolling() throws InterruptedException { addServerRule(SERVERS.PORT_0, new TestRule().always().drop()); addServerRule(SERVERS.PORT_1, new TestRule().always().drop()); addServerRule(SERVERS.PORT_2, new TestRule().always().drop()); Set<String> expectedResult = new HashSet<>(); expectedResult.add(getEndpoint(SERVERS.PORT_0)); expectedResult.add(getEndpoint(SERVERS.PORT_1)); expectedResult.add(getEndpoint(SERVERS.PORT_2)); pollAndMatchExpectedResult(expectedResult); clearServerRules(SERVERS.PORT_0); expectedResult.remove(getEndpoint(SERVERS.PORT_0)); pollAndMatchExpectedResult(expectedResult); }"
    },
    {
        "id": 12,
        "original": "@Test public void testGetItemId() { assertTrue(\"testGetItemId 0\", mv.getItemId() >= 0); }",
        "prediction": "@Test public void testGetItemId() { assertTrue(\"testGetItemId 0\", mv.getResourceId() >= 0); }",
        "reference": "@Test public void testGetItemId() { assertTrue(\"testGetItemId 0\", mv.getResourceId() >= 0); }"
    },
    {
        "id": 13,
        "original": "@Test public void testSetItemId() { int itemId = 55; mv.setItemId(itemId); assertThat(\"testSetItemId 0\", mv.getItemId(), equalTo(itemId)); }",
        "prediction": "@Test public void testSetItemId() { int itemId = 55; mv.setResourceId(itemId); assertThat(\"testSetItemId 0\", mv.getResourceId(), equalTo(itemId)); }",
        "reference": "@Test public void testSetItemId() { int itemId = 55; mv.setResourceId(itemId); mv.setResourceTypeId(Constants.ITEM); assertThat(\"testSetItemId 0\", mv.getResourceId(), equalTo(itemId)); }"
    },
    {
        "id": 14,
        "original": "@Test public void testGetFormat() throws SQLException { assertThat(\"testGetFormat 0\", bs.getFormat(), notNullValue()); assertThat(\"testGetFormat 1\", bs.getFormat(), equalTo(BitstreamFormat.findUnknown(context))); }",
        "prediction": "@Test public void testGetFormat()throws SQLException { assertThat(\"testGetFormat 0\", bs.getFormat(), notNullValue()); assertThat(\"testGetFormat 1\", bs.getFormat(), equalTo(BitstreamFormat.findUnknown(context))); }",
        "reference": "@Test public void testGetFormat() throws SQLException { assertThat(\"testGetFormat 0\", bs.getFormat(context), notNullValue()); assertThat(\"testGetFormat 1\", bs.getFormat(context), equalTo(bitstreamFormatService.findUnknown(context))); }"
    },
    {
        "id": 15,
        "original": "@Test public void testGetValueId() { assertThat(\"testGetValueId 0\",mv.getValueId(), notNullValue()); }",
        "prediction": "@Test public void testGetID() { assertThat(\"testGetID 0\",mv.getID(), notNullValue()); }",
        "reference": "@Test public void testGetValueId() { assertThat(\"testGetValueId 0\",mv.getID(), notNullValue()); }"
    },
    {
        "id": 16,
        "original": "@Test public void testGetErrorCode_invalidErrorObject() { Mockito.when(responseException.getContent()) .thenReturn(\"{\\\"type\\\":\\\"other\\\",\\\"message\\\":\\\"some other object\\\"}\"); try { ErrorResponseUtil.getErrorCode(responseException); Assert.fail(); } catch (HttpResponseException ex) { Assert.assertSame(responseException, ex); } }",
        "prediction": "@Test public void testGetErrorCode_invalidErrorObject() { Mockito.when(responseException.getContent()).thenReturn(\"{\\\\\"type\\\\\":\\\\\"other\\\\\",\\\\\"message\\\\\":\\\\\"some other object\\\\\"}\"); try { ErrorResponseUtil.getErrorCode(responseException); Assert.fail(); } catch (ResponseException ex) { Assert.assertSame(responseException, ex); } }",
        "reference": "@Test public void testGetErrorCode_invalidErrorObject() { Mockito.when(responseException.getContent()) .thenReturn(\"{\\\\\"type\\\\\":\\\\\"other\\\\\",\\\\\"message\\\\\":\\\\\"some other object\\\\\"}\"); try { ErrorResponseUtil.getErrorCode(responseException); Assert.fail(); } catch (ResponseException ex) { Assert.assertSame(responseException, ex); } }"
    },
    {
        "id": 17,
        "original": "@Test public void testGetErrorCode_knownErrorCode() throws HttpResponseException { Mockito.when(responseException.getContent()) .thenReturn( \"{\\\"errors\\\":[{\\\"code\\\":\\\"MANIFEST_INVALID\\\",\\\"message\\\":\\\"manifest invalid\\\",\\\"detail\\\":{}}]}\"); Assert.assertSame( ErrorCodes.MANIFEST_INVALID, ErrorResponseUtil.getErrorCode(responseException)); }",
        "prediction": "@Test public void testGetErrorCode_knownErrorCode()throws ResponseException { Mockito.when(responseException.getContent()).thenReturn( \"{\\\\\"errors\\\\\":[{\\\\\"code\\\\\":\\\\\"MANIFEST_INVALID\\\\\",\\\\\"message\\\\\":\\\\\"manifest invalid\\\\\",\\\\\"detail\\\\\":{}}]}\"); Assert.assertSame( ErrorCodes.MANIFEST_INVALID, ErrorResponseUtil.getErrorCode(responseException)); }",
        "reference": "@Test public void testGetErrorCode_knownErrorCode() throws ResponseException { Mockito.when(responseException.getContent()) .thenReturn( \"{\\\\\"errors\\\\\":[{\\\\\"code\\\\\":\\\\\"MANIFEST_INVALID\\\\\",\\\\\"message\\\\\":\\\\\"manifest invalid\\\\\",\\\\\"detail\\\\\":{}}]}\"); Assert.assertSame( ErrorCodes.MANIFEST_INVALID, ErrorResponseUtil.getErrorCode(responseException)); }"
    },
    {
        "id": 18,
        "original": "@Test public void testChangeProtectionKey() throws NoPeerConnectionException, IOException { KeyPair keypair1 = EncryptionUtil.generateRSAKeyPair(); KeyPair keypair2 = EncryptionUtil.generateRSAKeyPair(); Number160 locationKey = Number160.createHash(NetworkTestUtil.randomString()); Number160 domainKey = H2HConstants.TOMP2P_DEFAULT_KEY; Number160 contentKey = Number160.createHash(NetworkTestUtil.randomString()); NetworkManager node = network.get(random.nextInt(networkSize)); H2HTestData data1v0 = new H2HTestData(NetworkTestUtil.randomString()); data1v0.generateVersionKey(); data1v0.setBasedOnKey(Number160.ZERO); FuturePut putFuture1 = node.getDataManager().put(locationKey, domainKey, contentKey, data1v0, keypair1); putFuture1.awaitUninterruptibly(); Assert.assertTrue(putFuture1.isSuccess()); H2HTestData data1v1 = new H2HTestData(NetworkTestUtil.randomString()); data1v1.generateVersionKey(); data1v1.setBasedOnKey(data1v0.getVersionKey()); FuturePut putFuture2 = node.getDataManager().put(locationKey, domainKey, contentKey, data1v1, keypair1); putFuture2.awaitUninterruptibly(); Assert.assertTrue(putFuture2.isSuccess()); H2HTestData data1v2 = new H2HTestData(NetworkTestUtil.randomString()); data1v2.generateVersionKey(); data1v2.setBasedOnKey(data1v1.getVersionKey()); FuturePut changeFuture1 = node.getDataManager().changeProtectionKey(locationKey, domainKey, contentKey, data1v2.getTimeToLive(), keypair1, keypair2); changeFuture1.awaitUninterruptibly(); Assert.assertTrue(changeFuture1.isSuccess()); H2HTestData data1v3 = new H2HTestData(NetworkTestUtil.randomString()); data1v3.generateVersionKey(); data1v3.setBasedOnKey(data1v2.getVersionKey()); FuturePut changeFuture2 = node.getDataManager().put(locationKey, domainKey, contentKey, data1v3, keypair1); changeFuture2.awaitUninterruptibly(); Assert.assertFalse(changeFuture2.isSuccess()); }",
        "prediction": "@Test public void testChangeProtectionKey()throws NoPeerConnectionException, IOException { KeyPair keypair1 = EncryptionUtil.generateRSAKeyPair(); KeyPair keypair2 = EncryptionUtil.generateRSAKeyPair(); Number160 locationKey = Number160.createHash(NetworkTestUtil.randomString()); Number160 domainKey = H2HConstants.TOMP2P_DEFAULT_KEY; Number160 contentKey = Number160.createHash(NetworkTestUtil.randomString()); NetworkManager node = network.get(random.nextInt(networkSize)); H2HTestData data1v0 = new H2HTestData(NetworkTestUtil.randomString()); data1v0.generateVersionKey(); data1v0.",
        "reference": "@Test public void testChangeProtectionKey() throws NoPeerConnectionException, IOException, InvalidKeyException, SignatureException { KeyPair keypairOld = EncryptionUtil.generateRSAKeyPair(); KeyPair keypairNew = EncryptionUtil.generateRSAKeyPair(); Number160 locationKey = Number160.createHash(NetworkTestUtil.randomString()); Number160 domainKey = H2HConstants.TOMP2P_DEFAULT_KEY; Number160 contentKey = Number160.createHash(NetworkTestUtil.randomString()); NetworkManager node = network.get(random.nextInt(networkSize)); H2HSharableTestData data = new H2HSharableTestData(NetworkTestUtil.randomString()); data.generateVersionKey(); data.setBasedOnKey(Number160.ZERO); FuturePut putFuture1 = node.getDataManager() .put(locationKey, domainKey, contentKey, data, keypairOld); putFuture1.awaitUninterruptibly(); Assert.assertTrue(putFuture1.isSuccess()); FuturePut changeFuture = node.getDataManager().changeProtectionKey(locationKey, domainKey, contentKey, data.getVersionKey(), data.getBasedOnKey(), data.getTimeToLive(), keypairOld, keypairNew, data.getHash()); changeFuture.awaitUninterruptibly(); Assert.assertTrue(changeFuture.isSuccess()); Data resData = node.getDataManager().get(locationKey, domainKey, contentKey, data.getVersionKey()) .awaitUninterruptibly().getData(); Assert.assertTrue(resData.verify(keypairNew.getPublic(), new H2HSignatureFactory())); }"
    },
    {
        "id": 19,
        "original": "@Test public void testOnCreateOrUpdateCommand() throws GenieException { this.c = new Command(NAME, USER, CommandStatus.ACTIVE, EXECUTABLE, VERSION); this.c.onCreateOrUpdateCommand(); }",
        "prediction": "@Test public void testOnCreateOrUpdateCommand()throws GeniePreconditionException { this.c = new Command(NAME, USER, null, CommandStatus.ACTIVE, EXECUTABLE, VERSION); this.c.onCreateOrUpdateCommand(); Assert.assertEquals(2, this.c.getTags().size()); }",
        "reference": "@Test public void testOnCreateOrUpdateCommand() throws GeniePreconditionException { this.c = new Command(NAME, USER, CommandStatus.ACTIVE, EXECUTABLE, VERSION); this.c.onCreateOrUpdateCommand(); }"
    },
    {
        "id": 20,
        "original": "@Test public void testDeriveSecret() { String macAlgorithm = HKDFAlgorithm.TLS_HKDF_SHA256.getMacAlgorithm().getJavaName(); byte[] prk = ArrayConverter .hexStringToByteArray(\"31168cad69862a80c6f6bfd42897d0fe23c406a12e652a8d3ae4217694f49844\"); byte[] hashValue = ArrayConverter .hexStringToByteArray(\"52c04472bdfe929772c98b91cf425f78f47659be9d4a7d68b9e29d162935e9b9\"); String labelIn = \"client handshake traffic secret\"; byte[] result = HKDFunction.deriveSecret(macAlgorithm, prk, labelIn, hashValue); byte[] resultCorrect = ArrayConverter .hexStringToByteArray(\"6c6f274b1eae09b8bbd2039b7eb56147201a5e19288a3fd504fa52b1178a6e93\"); assertArrayEquals(result, resultCorrect); }",
        "prediction": "@Test public void testDeriveSecret() { String macAlgorithm = HKDFAlgorithm.TLS_HKDF_SHA256.getMacAlgorithm().getJavaName(); byte[] prk = ArrayConverter.hexStringToByteArray(\"31168cad69862a80c6f6bfd42897d0fe23c406a12e652a8d3ae4217694f49844\"); byte[] hashValue = ArrayConverter.hexStringToByteArray(\"52c04472bdfe929772c98b91cf425f78f47659be9d4a7d68b9e29d162935e9b9\");",
        "reference": "@Test public void testDeriveSecret() { String macAlgorithm = HKDFAlgorithm.TLS_HKDF_SHA256.getMacAlgorithm().getJavaName(); String hashAlgorithm = DigestAlgorithm.SHA256.getJavaName(); byte[] prk = ArrayConverter.hexStringToByteArray(\"33AD0A1C607EC03B09E6CD9893680CE210ADF300AA1F2660E1B22E10F170F92A\"); byte[] toHash = ArrayConverter.hexStringToByteArray(\"\"); String labelIn = HKDFunction.DERIVED; byte[] result = HKDFunction.deriveSecret(macAlgorithm, hashAlgorithm, prk, labelIn, toHash); byte[] resultCorrect = ArrayConverter.hexStringToByteArray(\"6F2615A108C702C5678F54FC9DBAB69716C076189C48250CEBEAC3576C3611BA\"); assertArrayEquals(result, resultCorrect); }"
    },
    {
        "id": 21,
        "original": "@Test(groups={\"tck\"}) public void test_next_serialization() throws IOException, ClassNotFoundException { DateTimeAdjuster next = DateTimeAdjusters.next(SUNDAY); assertTrue(next instanceof Serializable); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(next); oos.close(); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream( baos.toByteArray())); assertEquals(ois.readObject(), next); }",
        "prediction": "@Test(groups={\"tck\"}) public void test_next_serialization() throws IOException, ClassNotFoundException { WithAdjuster next = DateTimeAdjusters.next(SUNDAY); assertTrue(next instanceof Serializable); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(next); oos.close(); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())); assertEquals(ois.readObject(), next); }",
        "reference": "@Test(groups={\"tck\"}) public void test_next_serialization() throws IOException, ClassNotFoundException { WithAdjuster next = DateTimeAdjusters.next(SUNDAY); assertTrue(next instanceof Serializable); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(next); oos.close(); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream( baos.toByteArray())); assertEquals(ois.readObject(), next); }"
    },
    {
        "id": 22,
        "original": "@Test(groups={\"tck\"}) public void test_parseToEngine_String() throws Exception { DateTimeFormatter test = new DateTimeFormatter(Locale.ENGLISH, DateTimeFormatSymbols.STANDARD, compPP); CalendricalEngine result = test.parseToEngine(\"ONE30\"); assertEquals(result.getInput().size(), 1); assertEquals(result.getInput().get(0), DAY_OF_MONTH.field(30L)); }",
        "prediction": "@Test(groups={\"tck\"}) public void test_parseToBuilder_String()throws Exception { DateTimeFormatter test = new DateTimeFormatter(Locale.ENGLISH, DateTimeFormatSymbols.STANDARD, compPP); DateTimeBuilder result = test.parseToBuilder(\"ONE30\"); assertEquals(result.getInput().size(), 1); assertEquals(result.getInput().get(0), DAY_OF_MONTH.field(30L)); }",
        "reference": "@Test(groups={\"tck\"}) public void test_parseToEngine_String() throws Exception { DateTimeFormatter test = new DateTimeFormatter(Locale.ENGLISH, DateTimeFormatSymbols.STANDARD, compPP); CalendricalEngine result = test.parseToBuilder(\"ONE30\"); assertEquals(result.getInput().size(), 1); assertEquals(result.getInput().get(0), DAY_OF_MONTH.field(30L)); }"
    },
    {
        "id": 23,
        "original": "@Test(groups={\"tck\"}) public void test_firstDayOfMonth_serialization() throws IOException, ClassNotFoundException { DateTimeAdjuster firstDayOfMonth = DateTimeAdjusters.firstDayOfMonth(); assertTrue(firstDayOfMonth instanceof Serializable); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(firstDayOfMonth); oos.close(); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())); assertSame(ois.readObject(), firstDayOfMonth); }",
        "prediction": "@Test(groups={\"tck\"}) public void test_firstDayOfMonth_serialization() throws IOException, ClassNotFoundException { WithAdjuster firstDayOfMonth = DateTimeAdjusters.firstDayOfMonth(); assertTrue(firstDayOfMonth instanceof Serializable); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(firstDayOfMonth); oos.close(); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())); assertSame(ois.readObject(), firstDayOfMonth); }",
        "reference": "@Test(groups={\"tck\"}) public void test_firstDayOfMonth_serialization() throws IOException, ClassNotFoundException { WithAdjuster firstDayOfMonth = DateTimeAdjusters.firstDayOfMonth(); assertTrue(firstDayOfMonth instanceof Serializable); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(firstDayOfMonth); oos.close(); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())); assertSame(ois.readObject(), firstDayOfMonth); }"
    },
    {
        "id": 24,
        "original": "@Test(expectedExceptions=NullPointerException.class, groups={\"tck\"}) public void test_print_Calendrical_null() throws Exception { DateTimeFormatter test = fmt.withLocale(Locale.ENGLISH).withSymbols(DateTimeFormatSymbols.STANDARD); test.print((DateTimeAccessor) null); }",
        "prediction": "@Test(expectedExceptions=NullPointerException.class, groups={\"tck\"}) public void test_print_Calendrical_null()throws Exception { DateTimeFormatter test = fmt.withLocale(Locale.ENGLISH).withSymbols(DateTimeFormatSymbols.STANDARD); test.print((TemporalAccessor) null); }",
        "reference": "@Test(expectedExceptions=NullPointerException.class, groups={\"tck\"}) public void test_print_Calendrical_null() throws Exception { DateTimeFormatter test = fmt.withLocale(Locale.ENGLISH).withSymbols(DateTimeFormatSymbols.STANDARD); test.print((TemporalAccessor) null); }"
    },
    {
        "id": 25,
        "original": "@Test(groups={\"tck\"}) public void test_print_Calendrical() throws Exception { DateTimeFormatter test = fmt.withLocale(Locale.ENGLISH).withSymbols(DateTimeFormatSymbols.STANDARD); String result = test.print(LocalDate.of(2008, 6, 30)); assertEquals(result, \"ONE30\"); }",
        "prediction": "@Test(groups={\"tck\"}) public void test_print_Calendrical()throws Exception { DateTimeFormatter test = fmt.withLocale(Locale.ENGLISH).withSymbols(DateTimeFormatSymbols.STANDARD); String result = test.print(LocalDate.of(2008, 6, 30)); assertEquals(result, \"ONE30\"); }",
        "reference": "@Test(groups={\"tck\"}) public void test_print_Calendrical() throws Exception { DateTimeFormatter test = fmt.withLocale(Locale.ENGLISH).withSymbols(DateTimeFormatSymbols.STANDARD); String result = test.print(LocalDate.of(2008, 6, 30)); assertEquals(result, \"ONE30\"); }"
    },
    {
        "id": 26,
        "original": "@Test(groups={\"tck\"}) public void test_parseBest_firstOption() throws Exception { DateTimeFormatter test = DateTimeFormatters.pattern(\"yyyy-MM-dd[ZZZ]\"); DateTimeAccessor result = test.parseBest(\"2011-06-30+03:00\", OffsetDate.class, LocalDate.class); assertEquals(result, OffsetDate.of(2011, 6, 30, ZoneOffset.ofHours(3))); }",
        "prediction": "@Test(groups={\"tck\"}) public void test_parseBest_firstOption()throws Exception { DateTimeFormatter test = DateTimeFormatters.pattern(\"yyyy-MM-dd[ZZZ]\"); TemporalAccessor result = test.parseBest(\"2011-06-30+03:00\", OffsetDate.class, LocalDate.class); assertEquals(result, OffsetDate.of(2011, 6, 30, ZoneOffset.ofHours(3))); }",
        "reference": "@Test(groups={\"tck\"}) public void test_parseBest_firstOption() throws Exception { DateTimeFormatter test = DateTimeFormatters.pattern(\"yyyy-MM-dd[ZZZ]\"); TemporalAccessor result = test.parseBest(\"2011-06-30+03:00\", OffsetDate.class, LocalDate.class); assertEquals(result, OffsetDate.of(2011, 6, 30, ZoneOffset.ofHours(3))); }"
    },
    {
        "id": 27,
        "original": "@Test(groups={\"tck\"}) public void test_matchesCalendrical_ymd_date() { LocalDate date = LocalDate.of(2008, 6, 30); assertEquals(DateTimeField.of(YEAR, 2008).matchesCalendrical(date), true); assertEquals(DateTimeField.of(YEAR, 2006).matchesCalendrical(date), false); assertEquals(DateTimeField.of(MONTH_OF_YEAR, 6).matchesCalendrical(date), true); assertEquals(DateTimeField.of(MONTH_OF_YEAR, 7).matchesCalendrical(date), false); assertEquals(DateTimeField.of(MONTH_OF_YEAR, -1).matchesCalendrical(date), false); assertEquals(DateTimeField.of(DAY_OF_MONTH, 30).matchesCalendrical(date), true); assertEquals(DateTimeField.of(DAY_OF_MONTH, 12).matchesCalendrical(date), false); assertEquals(DateTimeField.of(DAY_OF_WEEK, 1).matchesCalendrical(date), true); assertEquals(DateTimeField.of(DAY_OF_WEEK, 2).matchesCalendrical(date), false); assertEquals(DateTimeField.of(HOUR_OF_DAY, 2).matchesCalendrical(date), false); }",
        "prediction": "@Test(groups = \"tck\"}) public void test_matchesCalendrical_ymd_date() { LocalDate date = LocalDate.of(2008, 6, 30); assertEquals(DateTimeField.of(YEAR, 2008).matches(date), true); assertEquals(DateTimeField.of(YEAR, 2006).matches(date), false); assertEquals(DateTimeField.of(MONTH_OF_YEAR, 6).matches(date), true); assertEquals(DateTimeField.of(MONTH_OF_YEAR, 7).matches(date), false); assertEquals(DateTimeField.of(MONTH_OF_YEAR, 12).matches(date), false); assertEquals(DateTimeField",
        "reference": "@Test(groups={\"tck\"}) public void test_matches() { LocalDate date = LocalDate.of(2008, 6, 30); assertEquals(DateTimeField.of(YEAR, 2008).matches(DateTimeField.of(YEAR, 2008)), true); assertEquals(DateTimeField.of(YEAR, 2008).matches(DateTimeField.of(YEAR, 2012)), false); assertEquals(DateTimeField.of(YEAR, 2008).matches(DateTimeField.of(MONTH_OF_YEAR, 2008)), false); assertEquals(DateTimeField.of(YEAR, 2008).matches(date), true); assertEquals(DateTimeField.of(YEAR, 2012).matches(date), false); assertEquals(DateTimeField.of(MONTH_OF_YEAR, 6).matches(date), true); assertEquals(DateTimeField.of(MONTH_OF_YEAR, 7).matches(date), false); assertEquals(DateTimeField.of(MONTH_OF_YEAR, -1).matches(date), false); assertEquals(DateTimeField.of(DAY_OF_MONTH, 30).matches(date), true); assertEquals(DateTimeField.of(DAY_OF_MONTH, 12).matches(date), false); assertEquals(DateTimeField.of(DAY_OF_WEEK, 1).matches(date), true); assertEquals(DateTimeField.of(DAY_OF_WEEK, 2).matches(date), false); assertEquals(DateTimeField.of(HOUR_OF_DAY, 2).matches(date), false); }"
    },
    {
        "id": 28,
        "original": "@Test(expectedExceptions=NullPointerException.class) public void test_appendValueReduced_null() throws Exception { builder.appendValueReduced(null, 2, 2000); }",
        "prediction": "@Test(expectedExceptions=NullPointerException.class) public void test_appendValueReduced_null()throws Exception { builder.appendValueReduced(null, 2, 2000, null); }",
        "reference": "@Test(expectedExceptions=NullPointerException.class) public void test_appendValueReduced_null() throws Exception { builder.appendValueReduced(null, 2, 2, 2000); }"
    },
    {
        "id": 29,
        "original": "@Test public void test_appendValueReduced() throws Exception { builder.appendValueReduced(YEAR, 2, 2000); DateTimeFormatter f = builder.toFormatter(); assertEquals(f.toString(), \"ReducedValue(Year,2,2000)\"); TemporalAccessor cal = f.parseUnresolved(\"12\", new ParsePosition(0)); assertEquals(cal.get(YEAR), 2012); }",
        "prediction": "@Test public void test_appendValueReduced()throws Exception { builder.appendValueReduced(YEAR, 2, 2000, 2); DateTimeFormatter f = builder.toFormatter(); assertEquals(f.toString(), \"ReducedValue(Year,2,2000, 2)\"); TemporalAccessor cal = f.parseUnresolved(\"12\", new ParsePosition(0)); assertEquals(cal.get(YEAR), 2012); }",
        "reference": "@Test public void test_appendValueReduced() throws Exception { builder.appendValueReduced(YEAR, 2, 2, 2000); DateTimeFormatter f = builder.toFormatter(); assertEquals(f.toString(), \"ReducedValue(Year,2,2000)\"); TemporalAccessor cal = f.parseUnresolved(\"12\", new ParsePosition(0)); assertEquals(cal.get(YEAR), 2012); }"
    },
    {
        "id": 30,
        "original": "@Test(groups={\"tck\"}) public void test_getAvailableGroupIds() { Set<String> groups = ZoneRulesProvider.getAvailableGroupIds(); assertEquals(groups.contains(\"TZDB\"), true); groups.clear(); assertEquals(groups.size(), 0); Set<String> groups2 = ZoneRulesProvider.getAvailableGroupIds(); assertEquals(groups2.contains(\"TZDB\"), true); }",
        "prediction": "@Test(groups={\"tck\"}) public void test_getAvailableZoneIds() { Set < String > groups = ZoneRulesProvider.getAvailableZoneIds(); assertEquals(groups.contains(\"TZDB\"), true); groups.clear(); assertEquals(groups.size(), 0); Set < String > groups2 = ZoneRulesProvider.getAvailableZoneIds(); assertEquals(groups2.contains(\"TZDB\"), true); }",
        "reference": "@Test(groups={\"tck\"}) public void test_getAvailableGroupIds() { Set<String> zoneIds = ZoneRulesProvider.getAvailableZoneIds(); assertEquals(zoneIds.contains(\"Europe/London\"), true); zoneIds.clear(); assertEquals(zoneIds.size(), 0); Set<String> zoneIds2 = ZoneRulesProvider.getAvailableZoneIds(); assertEquals(zoneIds2.contains(\"Europe/London\"), true); }"
    },
    {
        "id": 31,
        "original": "@Test public void testIsSPNegoMessage() { final SimpleHttpRequest request = new SimpleHttpRequest(); final AuthorizationHeader header = new AuthorizationHeader(request); Assert.assertFalse(header.isSPNegoMessage()); request.addHeader(\"Authorization\", \"\"); Assert.assertFalse(header.isSPNegoMessage()); request.addHeader( \"Authorization\", \"Negotiate YHYGBisGAQUFAqBsMGqgMDAuBgorBgEEAYI3AgIKBgkqhkiC9xIBAgIGCSqGSIb3EgECAgYKKwYBBAGCNwICHqI2BDROVExNU1NQAAEAAACXsgjiAwADADEAAAAJAAkAKAAAAAYBsR0AAAAPR0xZQ0VSSU5FU0FE\"); Assert.assertTrue(header.isSPNegoMessage()); }",
        "prediction": "@Test public void testIsSPNegoTokenInitMessage() { final SimpleHttpRequest request = new SimpleHttpRequest(); final AuthorizationHeader header = new AuthorizationHeader(request); Assert.assertFalse(header.isSPNegoTokenInit()); request.addHeader(\"Authorization\", \"\"); Assert.assertFalse(header.isSPNegoTokenInit()); request.addHeader( \"Authorization\", \"Negotiate YHYGBisGAQUFAqBsMGqgMDAuBgorBgEEAYI3AgIKBgkqhkiC9xIBAgIGCSqGSIb3EgECAgYKKwYBBAGCNwICHqI2BDROVEx",
        "reference": "@Test public void testIsSPNegTokenInitMessage() { final SimpleHttpRequest request = new SimpleHttpRequest(); final AuthorizationHeader header = new AuthorizationHeader(request); Assert.assertFalse(header.isSPNegTokenInitMessage()); request.addHeader(\"Authorization\", \"\"); Assert.assertFalse(header.isSPNegTokenInitMessage()); request.addHeader( \"Authorization\", \"Negotiate YHYGBisGAQUFAqBsMGqgMDAuBgorBgEEAYI3AgIKBgkqhkiC9xIBAgIGCSqGSIb3EgECAgYKKwYBBAGCNwICHqI2BDROVExNU1NQAAEAAACXsgjiAwADADEAAAAJAAkAKAAAAAYBsR0AAAAPR0xZQ0VSSU5FU0FE\"); Assert.assertTrue(header.isSPNegTokenInitMessage()); }"
    },
    {
        "id": 32,
        "original": "@Test public void testFindByClusterStackAndVersion() { Assert.assertEquals(3, hostVersionDAO.findByClusterStackAndVersion(\"test_cluster1\", \"HDP-2.2\", \"2.2.0.0-995\").size()); Assert.assertEquals(3, hostVersionDAO.findAll().size()); addMoreVersions(); Assert.assertEquals(3, hostVersionDAO.findByClusterStackAndVersion(\"test_cluster1\", \"HDP-2.2\", \"2.2.0.1-996\").size()); Assert.assertEquals(3, hostVersionDAO.findByClusterStackAndVersion(\"test_cluster1\", \"HDP-2.2\", \"2.2.1.0-500\").size()); Assert.assertEquals(9, hostVersionDAO.findAll().size()); }",
        "prediction": "@Test public void testFindByClusterStackAndVersion() { Assert.assertEquals(3, hostVersionDAO.findByClusterStackAndVersion(\"test_cluster1\", \"HDP-2.2\", \"2.2.0.0-995\").size()); Assert.assertEquals(3, hostVersionDAO.findAll().size()); addMoreVersions(); Assert.assertEquals(3, hostVersionDAO.findByClusterStackAndVersion(\"test_cluster1\", \"HDP-2.2\", \"2.2.0.1-996\").size()); Assert.assertEquals(3, hostVersionDAO.findByClusterStackAndVersion(\"test_cluster1\", \"H",
        "reference": "@Test public void testFindByClusterStackAndVersion() { Assert.assertEquals(3, hostVersionDAO.findByClusterStackAndVersion(\"test_cluster1\", HDP_22_STACK, \"2.2.0.0-995\").size()); Assert.assertEquals(3, hostVersionDAO.findAll().size()); addMoreVersions(); Assert.assertEquals(3, hostVersionDAO.findByClusterStackAndVersion(\"test_cluster1\", HDP_22_STACK, \"2.2.0.1-996\").size()); Assert.assertEquals(3, hostVersionDAO.findByClusterStackAndVersion(\"test_cluster1\", HDP_22_STACK, \"2.2.1.0-500\").size()); Assert.assertEquals(9, hostVersionDAO.findAll().size()); }"
    },
    {
        "id": 33,
        "original": "@Test public void testFindByStack() { createSingleRecord(); Assert.assertEquals(0, repositoryVersionDAO.findByStack(\"non existing\").size()); Assert.assertEquals(1, repositoryVersionDAO.findByStack(\"stack\").size()); }",
        "prediction": "@Test public void testFindByStack() { createSingleRecord(); Assert.assertEquals(0, repositoryVersionDAO.findByStack(\"non existing\").size()); Assert.assertEquals(1, repositoryVersionDAO.findByStack(\"stack\").size()); }",
        "reference": "@Test public void testFindByStack() { createSingleRecord(); Assert.assertEquals(0, repositoryVersionDAO.findByStack(BAD_STACK).size()); Assert.assertEquals(1, repositoryVersionDAO.findByStack(HDP_206).size()); }"
    },
    {
        "id": 34,
        "original": "@Test public void testHexDigitToBoolArray() { assertBoolArrayEquals( new boolean[]{false, false, false, false}, Conversion.hexDigitToBoolArray('0')); assertBoolArrayEquals( new boolean[]{true, false, false, false}, Conversion.hexDigitToBoolArray('1')); assertBoolArrayEquals( new boolean[]{false, true, false, false}, Conversion.hexDigitToBoolArray('2')); assertBoolArrayEquals( new boolean[]{true, true, false, false}, Conversion.hexDigitToBoolArray('3')); assertBoolArrayEquals( new boolean[]{false, false, true, false}, Conversion.hexDigitToBoolArray('4')); assertBoolArrayEquals( new boolean[]{true, false, true, false}, Conversion.hexDigitToBoolArray('5')); assertBoolArrayEquals( new boolean[]{false, true, true, false}, Conversion.hexDigitToBoolArray('6')); assertBoolArrayEquals( new boolean[]{true, true, true, false}, Conversion.hexDigitToBoolArray('7')); assertBoolArrayEquals( new boolean[]{false, false, false, true}, Conversion.hexDigitToBoolArray('8')); assertBoolArrayEquals( new boolean[]{true, false, false, true}, Conversion.hexDigitToBoolArray('9')); assertBoolArrayEquals( new boolean[]{false, true, false, true}, Conversion.hexDigitToBoolArray('A')); assertBoolArrayEquals( new boolean[]{false, true, false, true}, Conversion.hexDigitToBoolArray('a')); assertBoolArrayEquals( new boolean[]{true, true, false, true}, Conversion.hexDigitToBoolArray('B')); assertBoolArrayEquals( new boolean[]{true, true, false, true}, Conversion.hexDigitToBoolArray('b')); assertBoolArrayEquals( new boolean[]{false, false, true, true}, Conversion.hexDigitToBoolArray('C')); assertBoolArrayEquals( new boolean[]{false, false, true, true}, Conversion.hexDigitToBoolArray('c')); assertBoolArrayEquals( new boolean[]{true, false, true, true}, Conversion.hexDigitToBoolArray('D')); assertBoolArrayEquals( new boolean[]{true, false, true, true}, Conversion.hexDigitToBoolArray('d')); assertBoolArrayEquals( new boolean[]{false, true, true, true}, Conversion.hexDigitToBoolArray('E')); assertBoolArrayEquals( new boolean[]{false, true, true, true}, Conversion.hexDigitToBoolArray('e')); assertBoolArrayEquals( new boolean[]{true, true, true, true}, Conversion.hexDigitToBoolArray('F')); assertBoolArrayEquals( new boolean[]{true, true, true, true}, Conversion.hexDigitToBoolArray('f')); try { Conversion.hexDigitToBoolArray('G'); fail(\"Thrown \" + IllegalArgumentException.class.getName() + \" expected\"); } catch (final IllegalArgumentException e) { } }",
        "prediction": "@Test public void testHexDigitToBinary() { assertBinaryEquals( new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary(\\'0\\')); assertBinaryEquals( new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary(\\'1\\')); assertBinaryEquals( new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary(\\'2\\')); assertBinaryEquals( new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary(\\'3\\')); assertBinaryEquals( new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary(\\'4\\')); assertBinaryEquals( new boolean[",
        "reference": "@Test public void testHexDigitToBinary() { assertBinaryEquals( new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary(\\'0\\')); assertBinaryEquals( new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary(\\'1\\')); assertBinaryEquals( new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary(\\'2\\')); assertBinaryEquals( new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary(\\'3\\')); assertBinaryEquals( new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary(\\'4\\')); assertBinaryEquals( new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary(\\'5\\')); assertBinaryEquals( new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary(\\'6\\')); assertBinaryEquals( new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary(\\'7\\')); assertBinaryEquals( new boolean[]{false, false, false, true}, Conversion.hexDigitToBinary(\\'8\\')); assertBinaryEquals( new boolean[]{true, false, false, true}, Conversion.hexDigitToBinary(\\'9\\')); assertBinaryEquals( new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary(\\'A\\')); assertBinaryEquals( new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary(\\'a\\')); assertBinaryEquals( new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary(\\'B\\')); assertBinaryEquals( new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary(\\'b\\')); assertBinaryEquals( new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary(\\'C\\')); assertBinaryEquals( new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary(\\'c\\')); assertBinaryEquals( new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary(\\'D\\')); assertBinaryEquals( new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary(\\'d\\')); assertBinaryEquals( new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary(\\'E\\')); assertBinaryEquals( new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary(\\'e\\')); assertBinaryEquals( new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary(\\'F\\')); assertBinaryEquals( new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary(\\'f\\')); try { Conversion.hexDigitToBinary(\\'G\\'); fail(\"Thrown \" + IllegalArgumentException.class.getName() + \" expected\"); } catch (final IllegalArgumentException e) { } }"
    },
    {
        "id": 35,
        "original": "@Test public void testCreateSSLEngineFactory() throws Exception { Configuration serverConfig = new Configuration(); serverConfig.setBoolean(SecurityOptions.SSL_ENABLED, true); serverConfig.setString(SecurityOptions.SSL_KEYSTORE, \"src/test/resources/local127.keystore\"); serverConfig.setString(SecurityOptions.SSL_KEYSTORE_PASSWORD, \"password\"); serverConfig.setString(SecurityOptions.SSL_KEY_PASSWORD, \"password\"); serverConfig.setString(SecurityOptions.SSL_PROTOCOL, \"TLSv1\"); serverConfig.setString(SecurityOptions.SSL_ALGORITHMS, \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA,TLS_DHE_RSA_WITH_AES_128_CBC_SHA256\"); final SSLEngineFactory serverSSLEngineFactory = SSLUtils.createServerSSLEngineFactory(serverConfig); final SSLEngine sslEngine = serverSSLEngineFactory.createSSLEngine(); assertThat( Arrays.asList(sslEngine.getEnabledProtocols()), contains(\"TLSv1\")); assertThat( Arrays.asList(sslEngine.getEnabledCipherSuites()), containsInAnyOrder(\"TLS_DHE_RSA_WITH_AES_128_CBC_SHA\", \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA256\")); }",
        "prediction": "@Test public void testCreateSSLEngineFactory()throws Exception { Configuration serverConfig = new Configuration(); serverConfig.setBoolean(SecurityOptions.SSL_ENABLED, true); serverConfig.setString(SecurityOptions.SSL_KEYSTORE, \"src/test/resources/local127.keystore\"); serverConfig.setString(SecurityOptions.SSL_KEYSTORE_PASSWORD, \"password\"); serverConfig.setString(SecurityOptions.SSL_KEY_PASSWORD, \"password\"); serverConfig.setString(SecurityOptions.SSL_PROTOCOL, \"TLSv1\"); serverConfig.setString(SecurityOptions.SSL_ALGORITHMS, \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA,TLS_DHE_",
        "reference": "@Test public void testCreateSSLEngineFactory() throws Exception { Configuration serverConfig = createInternalSslConfigWithKeyAndTrustStores(); serverConfig.setString(SecurityOptions.SSL_PROTOCOL, \"TLSv1\"); serverConfig.setString(SecurityOptions.SSL_ALGORITHMS, \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA,TLS_DHE_RSA_WITH_AES_128_CBC_SHA256\"); final SSLEngineFactory serverSSLEngineFactory = SSLUtils.createInternalServerSSLEngineFactory(serverConfig); final SSLEngine sslEngine = serverSSLEngineFactory.createSSLEngine(); assertEquals(1, sslEngine.getEnabledProtocols().length); assertEquals(\"TLSv1\", sslEngine.getEnabledProtocols()[0]); assertEquals(2, sslEngine.getEnabledCipherSuites().length); assertThat(sslEngine.getEnabledCipherSuites(), arrayContainingInAnyOrder( \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA\", \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA256\")); }"
    },
    {
        "id": 36,
        "original": "@Test public void testGetSnapshottingSettings() throws Exception { ExecutionJobVertex jobVertex = mock(ExecutionJobVertex.class); when(jobVertex.getJobVertexId()).thenReturn(new JobVertexID()); when(jobVertex.getParallelism()).thenReturn(1); JobSnapshottingSettings snapshottingSettings = new JobSnapshottingSettings( Collections.singletonList(new JobVertexID()), Collections.singletonList(new JobVertexID()), Collections.singletonList(new JobVertexID()), 181238123L, 19191992L, 191929L, 123, ExternalizedCheckpointSettings.none(), null, false); CheckpointStatsTracker tracker = new CheckpointStatsTracker( 0, Collections.singletonList(jobVertex), snapshottingSettings, new UnregisteredMetricsGroup()); assertEquals(snapshottingSettings, tracker.getSnapshottingSettings()); }",
        "prediction": "@Test public void testGetSnapshottingSettings()throws Exception { ExecutionJobVertex jobVertex = mock(ExecutionJobVertex.class); when(jobVertex.getJobVertexId()).thenReturn(new JobVertexID()); when(jobVertex.getParallelism()).thenReturn(1); JobSnapshottingSettings snapshottingSettings = new JobSnapshottingSettings( Collections.singletonList(new JobVertexID()), Collections.singletonList(new JobVertexID()), Collections.singletonList(new JobVertexID()), 181238123L, 19191992L, 191929L, 123, ExternalizedCheckpointSettings.none(), null, false); CheckpointStatsTracker tracker = new CheckpointStatsTracker( 0",
        "reference": "@Test public void testGetSnapshottingSettings() throws Exception { ExecutionJobVertex jobVertex = mock(ExecutionJobVertex.class); when(jobVertex.getJobVertexId()).thenReturn(new JobVertexID()); when(jobVertex.getParallelism()).thenReturn(1); JobCheckpointingSettings snapshottingSettings = new JobCheckpointingSettings( Collections.singletonList(new JobVertexID()), Collections.singletonList(new JobVertexID()), Collections.singletonList(new JobVertexID()), 181238123L, 19191992L, 191929L, 123, ExternalizedCheckpointSettings.none(), null, false); CheckpointStatsTracker tracker = new CheckpointStatsTracker( 0, Collections.singletonList(jobVertex), snapshottingSettings, new UnregisteredMetricsGroup()); assertEquals(snapshottingSettings, tracker.getSnapshottingSettings()); }"
    },
    {
        "id": 37,
        "original": "@Test public void testGetInputs() { final Operator input1 = new OpImpl(0); final Operator input2 = new OpImpl(1); final Operator fixture = new OpImpl(0).withInputs(input1, input2); final List<Operator.Output> result = fixture.getInputs(); assertNotNull(result); assertEquals(2, result.size()); assertEquals(Arrays.asList(input1.getOutput(0), input2.getOutput(0)), result); }",
        "prediction": "@Test public void testGetInputs() { final Operator input1 = new OpImpl(0); final Operator input2 = new OpImpl(1); final Operator fixture = new OpImpl(0).withInputs(input1, input2); final List < Operator.Output > result = fixture.getInputs(); assertNotNull(result); assertEquals(2, result.size()); assertEquals(Arrays.asList(input1.getOutput(0), input2.getOutput(0)), result); }",
        "reference": "@Test public void testGetInputs() { final Operator<?> input1 = new OpImpl(0); final Operator<?> input2 = new OpImpl(1); final Operator<?> fixture = new OpImpl(0).withInputs(input1, input2); final List<Operator<?>.Output> result = fixture.getInputs(); assertNotNull(result); assertEquals(2, result.size()); assertEquals(Arrays.asList(input1.getOutput(0), input2.getOutput(0)), result); }"
    },
    {
        "id": 38,
        "original": "@Test public void testClearAndPut() { for (int i = 0; i < CAPACITY; ++i) { Assert.assertTrue(mailbox.tryPutMail(() -> {})); } mailbox.clearAndPut(POISON_LETTER); Assert.assertTrue(mailbox.hasMail()); Assert.assertEquals(POISON_LETTER, mailbox.tryTakeMail().get()); Assert.assertFalse(mailbox.hasMail()); }",
        "prediction": "@Test public void testClearAndPut() { for (int i = 0; i < CAPACITY; ++i) { Assert.assertTrue(mailbox.tryPutMail(() -> {})); } mailbox.clearAndPut(POISON_LETTER); Assert.assertTrue(mailbox.hasMail()); Assert.assertEquals(POISON_LETTER, mailbox.tryTakeMail().get()); Assert.assertFalse(mailbox.hasMail()); }",
        "reference": "@Test public void testClearAndPut() throws Exception { Runnable letterInstance = () -> {}; for (int i = 0; i < CAPACITY; ++i) { Assert.assertTrue(mailbox.tryPutMail(letterInstance)); } List<Runnable> droppedLetters = mailbox.clearAndPut(POISON_LETTER); Assert.assertTrue(mailbox.hasMail()); Assert.assertEquals(POISON_LETTER, mailbox.tryTakeMail().get()); Assert.assertFalse(mailbox.hasMail()); Assert.assertEquals(CAPACITY, droppedLetters.size()); }"
    },
    {
        "id": 39,
        "original": "@Test public void testSleep() throws Exception { for (int i = 0; i < NUM_ATTEMPTS; i++) { long expectedSleepTimeMs = new Random().nextInt(100); long start = System.currentTimeMillis(); SysUtils.sleep(expectedSleepTimeMs); long end = System.currentTimeMillis(); Assert.assertTrue((end - start) >= expectedSleepTimeMs); } }",
        "prediction": "@Test public void testSleep()throws Exception { for (int i = 0; i < NUM_ATTEMPTS; i++) { Duration expectedSleepTimeMs = Duration.ofMillis(100); long start = System.currentTimeMillis(); SysUtils.sleep(expectedSleepTimeMs); long end = System.currentTimeMillis(); Assert.assertTrue((end - start) >= expectedSleepTimeMs); } }",
        "reference": "@Test public void testSleep() throws Exception { for (int i = 0; i < NUM_ATTEMPTS; i++) { Duration expectedSleepTime = Duration.ofMillis(new Random().nextInt(100)); long start = System.currentTimeMillis(); SysUtils.sleep(expectedSleepTime); long end = System.currentTimeMillis(); Assert.assertTrue((end - start) >= expectedSleepTime.toMillis()); } }"
    },
    {
        "id": 40,
        "original": "@Test public void testGetContainers() throws ResourceExceededException { int paddingPercentage = 10; Map<Integer, List<InstanceId>> packing = new HashMap<>(); packing.put(7, Arrays.asList( new InstanceId(\"spout\", 1, 0), new InstanceId(\"bolt\", 2, 0))); packing.put(3, Arrays.asList( new InstanceId(\"spout\", 3, 0), new InstanceId(\"bolt\", 4, 0))); PackingPlan packingPlan = generatePacking(packing); Map<Integer, Container> containers = PackingPlanBuilder.getContainers( packingPlan, paddingPercentage, new HashMap<String, TreeSet<Integer>>(), new TreeSet<Integer>()); assertEquals(packing.size(), containers.size()); for (Integer containerId : packing.keySet()) { Container foundContainer = containers.get(containerId); assertEquals(paddingPercentage, foundContainer.getPaddingPercentage()); assertEquals(packingPlan.getMaxContainerResources(), foundContainer.getCapacity()); assertEquals(2, foundContainer.getInstances().size()); } }",
        "prediction": "@Test public void testGetContainers() { int paddingPercentage = 10; Map<Integer, List<InstanceId>> packing = new HashMap<>(); packing.put(7, Arrays.asList( new InstanceId(\"spout\", 1, 0), new InstanceId(\"bolt\", 2, 0))); packing.put(3, Arrays.asList( new InstanceId(\"spout\", 3, 0), new InstanceId(\"bolt\", 4, 0))); PackingPlan packingPlan = generatePacking(packing); Map<Integer, Container> containers = PackingPlanBuilder.getContainers( packingPlan, paddingPercentage, new HashMap<String, TreeSet<Integer>>(), new TreeSet<Integer>",
        "reference": "@Test public void testGetContainers() { Resource padding = new Resource(1.0, ByteAmount.fromGigabytes(1), ByteAmount.fromGigabytes(1)); Map<Integer, List<InstanceId>> packing = new HashMap<>(); packing.put(7, Arrays.asList( new InstanceId(\"spout\", 1, 0), new InstanceId(\"bolt\", 2, 0))); packing.put(3, Arrays.asList( new InstanceId(\"spout\", 3, 0), new InstanceId(\"bolt\", 4, 0))); PackingPlan packingPlan = generatePacking(packing); Map<Integer, Container> containers = PackingPlanBuilder.getContainers( packingPlan, packingPlan.getMaxContainerResources(), padding, new HashMap<String, TreeSet<Integer>>(), new TreeSet<Integer>()); assertEquals(packing.size(), containers.size()); for (Integer containerId : packing.keySet()) { Container foundContainer = containers.get(containerId); assertEquals(padding, foundContainer.getPadding()); assertEquals(packingPlan.getMaxContainerResources(), foundContainer.getCapacity()); assertEquals(2, foundContainer.getInstances().size()); } }"
    },
    {
        "id": 41,
        "original": "@Test public void testAssign() { executor.assign(\"foo\", \"2\", message); Object var = executor.getState().get(\"foo\"); assertThat(var, instanceOf(Integer.class)); assertThat(var, equalTo(2)); }",
        "prediction": "@Test public void testAssign() { executor.assign(\"foo\", \"2\", message, null); Object var = executor.getState().get(\"foo\"); assertThat(var, instanceOf(Integer.class)); assertThat(var, equalTo(2)); }",
        "reference": "@Test public void testAssign() { executor.assign(\"foo\", \"2\", message, Context.EMPTY_CONTEXT()); Object var = executor.getState().get(\"foo\"); assertThat(var, instanceOf(Integer.class)); assertThat(var, equalTo(2)); }"
    },
    {
        "id": 42,
        "original": "@Test public void testExecuteTransformation() { String actual = executor.execute(\"TO_UPPER('lowercase')\", message, String.class); assertThat(actual, equalTo(\"LOWERCASE\")); }",
        "prediction": "@Test public void testExecuteTransformation() { String actual = executor.execute(\"TO_UPPER(\\'lowercase\\')\", message, Context.class); assertThat(actual, equalTo(\"LOWERCASE\")); }",
        "reference": "@Test public void testExecuteTransformation() { String actual = executor.execute(\"TO_UPPER(\\'lowercase\\')\", message, String.class, Context.EMPTY_CONTEXT()); assertThat(actual, equalTo(\"LOWERCASE\")); }"
    },
    {
        "id": 43,
        "original": "@Test public void testRemovePartition() throws MetadataServiceException, URISyntaxException { Services services = Services.get(); PartitionDependencyManagerService pdms = services.get(PartitionDependencyManagerService.class); String newHCatDependency = \"hcat://hcat.yahoo.com:5080/mydb/clicks/?datastamp=12&region=us\"; String actionId = \"myAction\"; pdms.addMissingPartition(newHCatDependency, actionId); HCatURI hcatUri = new HCatURI(newHCatDependency); Map<String, PartitionsGroup> tablePartitionsMap = pdms.getHCatMap().get(hcatUri.getServerEndPoint() + \"#\" + hcatUri.getDb()); assertNotNull(tablePartitionsMap); assertTrue(tablePartitionsMap.containsKey(\"clicks\")); PartitionsGroup missingPartitions = tablePartitionsMap.get(hcatUri.getTable()); assertNotNull(missingPartitions); pdms.removePartition(newHCatDependency, false); assertFalse(missingPartitions.getPartitionsMap().containsKey(hcatUri.getPartitionMap())); pdms.addMissingPartition(newHCatDependency, actionId); assertNotNull(missingPartitions); pdms.removePartition(newHCatDependency); assertFalse(pdms.getHCatMap().containsKey(hcatUri.getTable())); }",
        "prediction": "@Test public void testRemovePartition()throws MetadataServiceException, URISyntaxException { Services services = Services.get(); PartitionDependencyManagerService pdms = services.get(PartitionDependencyManagerService.class); String newHCatDependency = \"hcat://hcat.yahoo.com:5080/mydb/clicks/?datastamp=12&region=us\"; String actionId = \"myAction\"; pdms.addMissingPartition(newHCatDependency, actionId); HCatURI hcatUri = new HCatURI(newHCatDependency); Map<String, PartitionsGroup> tablePartitionsMap = pdms.getHCatMap().get(hcatUri.getServerEndPoint() + \"#\"",
        "reference": "@Test public void testRemovePartition() throws Exception { Services services = Services.get(); PartitionDependencyManagerService pdms = services.get(PartitionDependencyManagerService.class); String newHCatDependency = \"hcat://hcat.yahoo.com:5080/database/mydb/table/clicks/partition/datastamp=12,region=us\"; String actionId = \"myAction\"; pdms.addMissingPartition(newHCatDependency, actionId); HCatURI hcatUri = new HCatURI(newHCatDependency); Map<String, PartitionsGroup> tablePartitionsMap = pdms.getHCatMap().get(hcatUri.getServerEndPoint() + \"#\" + hcatUri.getDb()); assertNotNull(tablePartitionsMap); assertTrue(tablePartitionsMap.containsKey(\"clicks\")); PartitionsGroup missingPartitions = tablePartitionsMap.get(hcatUri.getTable()); assertNotNull(missingPartitions); pdms.removePartition(newHCatDependency, false); assertFalse(missingPartitions.getPartitionsMap().containsKey(hcatUri.getPartitionMap())); pdms.addMissingPartition(newHCatDependency, actionId); assertNotNull(missingPartitions); pdms.removePartition(newHCatDependency); assertFalse(pdms.getHCatMap().containsKey(hcatUri.getTable())); }"
    },
    {
        "id": 44,
        "original": "@Test public void testParseServiceRequestPath() { ServiceRequestPathInfo info = GatewayServlet.parseServiceRequestPath(null); info = GatewayServlet.parseServiceRequestPath(\"/invalidpath\"); Assert.assertNull(info.orgId); Assert.assertNull(info.serviceId); Assert.assertNull(info.serviceVersion); Assert.assertNull(info.resource); info = GatewayServlet.parseServiceRequestPath(\"/invalid/path\"); Assert.assertNull(info.orgId); Assert.assertNull(info.serviceId); Assert.assertNull(info.serviceVersion); Assert.assertNull(info.resource); info = GatewayServlet.parseServiceRequestPath(\"/Org1/Service1/1.0\"); Assert.assertEquals(\"Org1\", info.orgId); Assert.assertEquals(\"Service1\", info.serviceId); Assert.assertEquals(\"1.0\", info.serviceVersion); Assert.assertNull(info.resource); info = GatewayServlet.parseServiceRequestPath(\"/MyOrg/Service-99/2.7\"); Assert.assertEquals(\"MyOrg\", info.orgId); Assert.assertEquals(\"Service-99\", info.serviceId); Assert.assertEquals(\"2.7\", info.serviceVersion); Assert.assertNull(info.resource); info = GatewayServlet.parseServiceRequestPath(\"/MyOrg/Service-99/2.7/resource\"); Assert.assertEquals(\"MyOrg\", info.orgId); Assert.assertEquals(\"Service-99\", info.serviceId); Assert.assertEquals(\"2.7\", info.serviceVersion); Assert.assertEquals(\"/resource\", info.resource); info = GatewayServlet.parseServiceRequestPath(\"/MyOrg/Service-99/2.7/path/to/resource\"); Assert.assertEquals(\"MyOrg\", info.orgId); Assert.assertEquals(\"Service-99\", info.serviceId); Assert.assertEquals(\"2.7\", info.serviceVersion); Assert.assertEquals(\"/path/to/resource\", info.resource); info = GatewayServlet.parseServiceRequestPath(\"/MyOrg/Service-99/2.7/path/to/resource?query=1234\"); Assert.assertEquals(\"MyOrg\", info.orgId); Assert.assertEquals(\"Service-99\", info.serviceId); Assert.assertEquals(\"2.7\", info.serviceVersion); Assert.assertEquals(\"/path/to/resource?query=1234\", info.resource); }",
        "prediction": "@Test public void testParseServiceRequestPath() { ServiceRequestPathInfo info = GatewayServlet.parseServiceRequestPath(HttpServletRequest.getPathInfo()); info = GatewayServlet.parseServiceRequestPath(\"/invalidpath\"); Assert.assertNull(info.orgId); Assert.assertNull(info.serviceId); Assert.assertNull(info.serviceVersion); Assert.assertNull(info.resource); info = GatewayServlet.parseServiceRequestPath(\"/invalid/path\"); Assert.assertNull(info.orgId); Assert.assertNull(info.serviceId); Assert.assertNull(info.serviceVersion); Assert.assertNull(info.resource); info = GatewayServlet.parseServiceRequestPath",
        "reference": "@Test public void testParseServiceRequestPath() { ServiceRequestPathInfo info = parseServiceRequestPath(null); info = parseServiceRequestPath(\"/invalidpath\"); Assert.assertNull(info.orgId); Assert.assertNull(info.serviceId); Assert.assertNull(info.serviceVersion); Assert.assertNull(info.resource); info = parseServiceRequestPath(\"/invalid/path\"); Assert.assertNull(info.orgId); Assert.assertNull(info.serviceId); Assert.assertNull(info.serviceVersion); Assert.assertNull(info.resource); info = parseServiceRequestPath(\"/Org1/Service1/1.0\"); Assert.assertEquals(\"Org1\", info.orgId); Assert.assertEquals(\"Service1\", info.serviceId); Assert.assertEquals(\"1.0\", info.serviceVersion); Assert.assertNull(info.resource); info = parseServiceRequestPath(\"/MyOrg/Service-99/2.7\"); Assert.assertEquals(\"MyOrg\", info.orgId); Assert.assertEquals(\"Service-99\", info.serviceId); Assert.assertEquals(\"2.7\", info.serviceVersion); Assert.assertNull(info.resource); info = parseServiceRequestPath(\"/MyOrg/Service-99/2.7/resource\"); Assert.assertEquals(\"MyOrg\", info.orgId); Assert.assertEquals(\"Service-99\", info.serviceId); Assert.assertEquals(\"2.7\", info.serviceVersion); Assert.assertEquals(\"/resource\", info.resource); info = parseServiceRequestPath(\"/MyOrg/Service-99/2.7/path/to/resource\"); Assert.assertEquals(\"MyOrg\", info.orgId); Assert.assertEquals(\"Service-99\", info.serviceId); Assert.assertEquals(\"2.7\", info.serviceVersion); Assert.assertEquals(\"/path/to/resource\", info.resource); info = parseServiceRequestPath(\"/MyOrg/Service-99/2.7/path/to/resource?query=1234\"); Assert.assertEquals(\"MyOrg\", info.orgId); Assert.assertEquals(\"Service-99\", info.serviceId); Assert.assertEquals(\"2.7\", info.serviceVersion); Assert.assertEquals(\"/path/to/resource?query=1234\", info.resource); info = parseServiceRequestPath(\"/MyOrg/Service-99/path/to/resource?query=1234\", null, \"2.7\"); Assert.assertEquals(\"MyOrg\", info.orgId); Assert.assertEquals(\"Service-99\", info.serviceId); Assert.assertEquals(\"2.7\", info.serviceVersion); Assert.assertEquals(\"/path/to/resource?query=1234\", info.resource); info = parseServiceRequestPath(\"/MyOrg/Service-99/path/to/resource?query=1234\", \"application/apiman.2.7+json\", null); Assert.assertEquals(\"MyOrg\", info.orgId); Assert.assertEquals(\"Service-99\", info.serviceId); Assert.assertEquals(\"2.7\", info.serviceVersion); Assert.assertEquals(\"/path/to/resource?query=1234\", info.resource); }"
    },
    {
        "id": 45,
        "original": "@Test public void testVisitation() throws Exception { VisitationRecorder recorder = new VisitationRecorder(\"srcs\"); mapper.visitLabels(recorder); assertThat(recorder.labelsVisited).containsExactly(\"//p:a\", \"//p:b\", \"//p:c\"); }",
        "prediction": "@Test public void testVisitation()throws Exception { VisitationRecorder recorder = new VisitationRecorder(\"srcs\"); mapper.visitLabels(recorder); assertThat(recorder.labelsVisited).containsExactly(\"//p:a\", \"//p:b\", \"//p:c\"); }",
        "reference": "@Test public void testVisitation() throws Exception { assertThat(getLabelsForAttribute(mapper, \"srcs\")).containsExactly(\"//p:a\", \"//p:b\", \"//p:c\"); }"
    },
    {
        "id": 46,
        "original": "@Test public void testVisitationConfigurableAttribute() throws Exception { Rule rule = scratchRule(\"a\", \"myrule\", \"sh_binary(name = 'myrule',\", \" srcs = select({\", \" '//conditions:a': ['a.sh'],\", \" '//conditions:b': ['b.sh'],\", \" '\" + BuildType.Selector.DEFAULT_CONDITION_KEY + \"': ['default.sh'],\", \" }))\"); VisitationRecorder recorder = new VisitationRecorder(\"srcs\"); AggregatingAttributeMapper.of(rule).visitLabels(recorder); assertThat(recorder.labelsVisited) .containsExactlyElementsIn( ImmutableList.of( \"//a:a.sh\", \"//a:b.sh\", \"//a:default.sh\", \"//conditions:a\", \"//conditions:b\")); }",
        "prediction": "@Test public void testVisitationConfigurableAttribute()throws Exception { Rule rule = scratchRule(\"a\", \"myrule\", \"sh_binary(name = \\'myrule\\',\", \" srcs = select({\", \" \\'//conditions:a\\': [\\'a.sh\\'],\", \" \\'//conditions:b\\': [\\'b.sh\\'],\", \" \\'\" + BuildType.Selector.DEFAULT_CONDITION_KEY + \"\\': [\\'default.sh\\'],\", \" }))\"); VisitationRecorder recorder = new VisitationRecorder(\"srcs\"); AggregatingAttributeMapper.of(rule).visitLabels(recorder); assertThat(recorder.labelsVisited).containsExactlyElementsIn(",
        "reference": "@Test public void testVisitationConfigurableAttribute() throws Exception { Rule rule = scratchRule(\"a\", \"myrule\", \"sh_binary(name = \\'myrule\\',\", \" srcs = select({\", \" \\'//conditions:a\\': [\\'a.sh\\'],\", \" \\'//conditions:b\\': [\\'b.sh\\'],\", \" \\'\" + BuildType.Selector.DEFAULT_CONDITION_KEY + \"\\': [\\'default.sh\\'],\", \" }))\"); assertThat(getLabelsForAttribute(AggregatingAttributeMapper.of(rule), \"srcs\")) .containsExactlyElementsIn( ImmutableList.of( \"//a:a.sh\", \"//a:b.sh\", \"//a:default.sh\", \"//conditions:a\", \"//conditions:b\")); }"
    },
    {
        "id": 47,
        "original": "@Test public void testDivideInternally() throws StructureException, IOException { Structure s = StructureIO.getStructure(\"4e3e\"); SubunitCluster sc1 = new SubunitCluster( new Subunit(StructureTools.getRepresentativeAtomArray(s .getChainByIndex(0)), \"chain 0\", null, s)); boolean divided = sc1.divideInternally(0.8, 3.0, 20); assertTrue(divided); assertEquals(sc1.size(), 2); assertTrue(sc1.length() < 178); assertEquals(sc1.getAlignedAtomsSubunit(0).length, sc1.getAlignedAtomsSubunit(1).length); }",
        "prediction": "@Test public void testDivideInternally()throws StructureException, IOException { Structure s = StructureIO.getStructure(\"4e3e\"); SubunitCluster sc1 = new SubunitCluster( new Subunit(StructureTools.getRepresentativeAtomArray(s.getChainByIndex(0)), \"chain 0\", null, s)); boolean divided = sc1.divideInternally(new SubunitClustererParameters(new SubunitClustererParameters(null, null, s)); boolean divided = sc1.divideInternally(0.8, 3.0, 20); assertTrue(divided); assertEquals(sc1.size(), 2); assertTrue(sc1.length() <",
        "reference": "@Test public void testDivideInternally() throws StructureException, IOException { Structure s = StructureIO.getStructure(\"4e3e\"); SubunitCluster sc1 = new SubunitCluster( new Subunit(StructureTools.getRepresentativeAtomArray(s .getChainByIndex(0)), \"chain 0\", null, s)); SubunitClustererParameters clustererParameters = new SubunitClustererParameters(); clustererParameters.setStructureCoverageThreshold(0.8); clustererParameters.setRMSDThreshold(3.0); clustererParameters.setMinimumSequenceLength(20); boolean divided = sc1.divideInternally(clustererParameters); assertTrue(divided); assertEquals(sc1.size(), 2); assertTrue(sc1.length() < 178); assertEquals(sc1.getAlignedAtomsSubunit(0).length, sc1.getAlignedAtomsSubunit(1).length); }"
    },
    {
        "id": 48,
        "original": "@Test public void testMergeStructure() throws StructureException, IOException { Structure s = StructureIO.getStructure(\"4hhb\"); SubunitCluster sc1 = new SubunitCluster( new Subunit(StructureTools.getRepresentativeAtomArray(s .getChainByIndex(0)), \"chain 0\", null, s)); SubunitCluster sc2 = new SubunitCluster( new Subunit(StructureTools.getRepresentativeAtomArray(s .getChainByIndex(1)), \"chain 1\", null, s)); SubunitCluster sc3 = new SubunitCluster( new Subunit(StructureTools.getRepresentativeAtomArray(s .getChainByIndex(2)), \"chain 2\", null, s)); SubunitCluster sc4 = new SubunitCluster( new Subunit(StructureTools.getRepresentativeAtomArray(s .getChainByIndex(3)), \"chain 3\", null, s)); boolean merged13 = sc1.mergeStructure(sc3, 3.0, 0.9); boolean merged24 = sc2.mergeStructure(sc4, 3.0, 0.9); assertTrue(merged13); assertTrue(merged24); assertEquals(sc1.size(), 2); assertEquals(sc2.size(), 2); assertEquals(sc1.length(), 141); assertEquals(sc2.length(), 146); assertEquals(sc1.getAlignedAtomsSubunit(0).length, sc1.getAlignedAtomsSubunit(1).length); assertEquals(sc2.getAlignedAtomsSubunit(0).length, sc2.getAlignedAtomsSubunit(1).length); boolean merged = sc1.mergeStructure(sc2, 3.0, 0.9); assertTrue(merged); assertEquals(sc1.size(), 4); assertEquals(sc1.length(), 140, 2); assertEquals(sc1.getAlignedAtomsSubunit(0).length, sc1.getAlignedAtomsSubunit(2).length); }",
        "prediction": "@Test public void testMergeStructure()throws StructureException, IOException { Structure s = StructureIO.getStructure(\"4hhb\"); SubunitCluster sc1 = new SubunitCluster( new Subunit(StructureTools.getRepresentativeAtomArray(s.getChainByIndex(0)), \"chain 0\", null, s)); SubunitCluster sc2 = new SubunitCluster( new Subunit(StructureTools.getRepresentativeAtomArray(s.getChainByIndex(1)), \"chain 1\", null, s)); SubunitCluster sc3 = new SubunitCluster( new Subunit(StructureTools.getRepresentativeAtomArray(s.getChainByIndex(2)), \"chain 2\", null,",
        "reference": "@Test public void testMergeStructure() throws StructureException, IOException { Structure s = StructureIO.getStructure(\"4hhb\"); SubunitCluster sc1 = new SubunitCluster( new Subunit(StructureTools.getRepresentativeAtomArray(s .getChainByIndex(0)), \"chain 0\", null, s)); SubunitCluster sc2 = new SubunitCluster( new Subunit(StructureTools.getRepresentativeAtomArray(s .getChainByIndex(1)), \"chain 1\", null, s)); SubunitCluster sc3 = new SubunitCluster( new Subunit(StructureTools.getRepresentativeAtomArray(s .getChainByIndex(2)), \"chain 2\", null, s)); SubunitCluster sc4 = new SubunitCluster( new Subunit(StructureTools.getRepresentativeAtomArray(s .getChainByIndex(3)), \"chain 3\", null, s)); SubunitClustererParameters clustererParameters = new SubunitClustererParameters(); clustererParameters.setRMSDThreshold(3.0); clustererParameters.setStructureCoverageThreshold(0.9); boolean merged13 = sc1.mergeStructure(sc3,clustererParameters); boolean merged24 = sc2.mergeStructure(sc4,clustererParameters); assertTrue(merged13); assertTrue(merged24); assertEquals(sc1.size(), 2); assertEquals(sc2.size(), 2); assertEquals(sc1.length(), 141); assertEquals(sc2.length(), 146); assertEquals(sc1.getAlignedAtomsSubunit(0).length, sc1.getAlignedAtomsSubunit(1).length); assertEquals(sc2.getAlignedAtomsSubunit(0).length, sc2.getAlignedAtomsSubunit(1).length); boolean merged = sc1.mergeStructure(sc2, clustererParameters); assertTrue(merged); assertEquals(sc1.size(), 4); assertEquals(sc1.length(), 140, 2); assertEquals(sc1.getAlignedAtomsSubunit(0).length, sc1.getAlignedAtomsSubunit(2).length); }"
    },
    {
        "id": 49,
        "original": "@Test public void testGetPercentageOfIdentity() { assertEquals(global.getPercentageOfIdentity(), 1.0, 0.01); assertEquals(local.getPercentageOfIdentity(), 1.0, 0.01); }",
        "prediction": "@Test public void testGetPercentageOfIdentity() { assertEquals(global.getPercentageOfIdentity(), 1.0, 0.01); assertEquals(local.getPercentageOfIdentity(), 1.0, 0.01); assertEquals(global.getPercentageOfIdentity(false), 1.0, 0.01); }",
        "reference": "@Test public void testGetPercentageOfIdentity() { assertEquals(global.getPercentageOfIdentity(false), 1.0, 0.01); assertEquals(local.getPercentageOfIdentity(false), 1.0, 0.01); }"
    },
    {
        "id": 50,
        "original": "@Test public void testDeploy() throws Exception { HttpResponse response = deploy(\"WordCount.jar\"); Assert.assertEquals(200, response.getStatusLine().getStatusCode()); }",
        "prediction": "@Test public void testDeploy()throws Exception { HttpResponse response = deploy(Application.class); Assert.assertEquals(200, response.getStatusLine().getStatusCode()); Assert.assertEquals(404, response.getStatusLine().getReasonPhrase()); Assert.assertEquals(404, response.getStatusLine().getReasonPhrase()); }",
        "reference": "@Test public void testDeploy() throws Exception { HttpResponse response = deploy(WordCount.class); Assert.assertEquals(200, response.getStatusLine().getStatusCode()); }"
    },
    {
        "id": 51,
        "original": "@Test public void testHypergeometricCdf() { logger.info(\"HypergeometricCdf\"); int k = 3; int n = 10; int Kp = 30; int Np = 100; double expResult = 0.65401998866081; double result = DiscreteDistributions.HypergeometricCdf(k, n, Kp, Np); assertEquals(expResult, result, TestConfiguration.DOUBLE_ACCURACY_HIGH); }",
        "prediction": "@Test public void testHypergeometricCdf() { logger.info(\"HypergeometricCdf\"); int k = 3; int n = 10; int Kp = 30; int Np = 100; double expResult = 0.65401998866081; double result = DiscreteDistributions.hypergeometricCdf(k, n, Kp, Np); assertEquals(expResult, result, TestConfiguration.DOUBLE_ACCURACY_HIGH); }",
        "reference": "@Test public void testHypergeometricCdf() { logger.info(\"HypergeometricCdf\"); int k = 3; int n = 10; int Kp = 30; int Np = 100; double expResult = 0.65401998866081; double result = DiscreteDistributions.hypergeometricCdf(k, n, Kp, Np); assertEquals(expResult, result, TestConfiguration.DOUBLE_ACCURACY_HIGH); }"
    },
    {
        "id": 52,
        "original": "@Test public void testGetColumns() { TestUtils.log(this.getClass(), \"getColumns\"); RandomSingleton.getInstance().setSeed(TestConfiguration.RANDOM_SEED); DatabaseConfiguration dbConf = TestUtils.getDBConfig(); Dataset instance = new Dataset(dbConf); AssociativeArray xData1 = new AssociativeArray(); xData1.put(\"1\", true); instance.add(new Record(xData1, null)); AssociativeArray xData2 = new AssociativeArray(); xData2.put(\"2\", 1.0); instance.add(new Record(xData2, null)); AssociativeArray xData3 = new AssociativeArray(); xData3.put(\"3\", (short)1); instance.add(new Record(xData3, null)); AssociativeArray xData4 = new AssociativeArray(); xData4.put(\"4\", \"s\"); instance.add(new Record(xData4, null)); Map<Object, Dataset.ColumnType> expResult = new LinkedHashMap<>(); expResult.put(\"1\", Dataset.ColumnType.DUMMYVAR); expResult.put(\"2\", Dataset.ColumnType.NUMERICAL); expResult.put(\"3\", Dataset.ColumnType.ORDINAL); expResult.put(\"4\", Dataset.ColumnType.CATEGORICAL); Map<Object, Dataset.ColumnType> result = instance.getColumns(); assertEquals(expResult, result); }",
        "prediction": "@Test public void testGetColumns() { TestUtils.log(this.getClass(), \"getColumns\"); RandomSingleton.getInstance().setSeed(TestConfiguration.RANDOM_SEED); DatabaseConfiguration dbConf = TestUtils.getDBConfig(); Dataset instance = new Dataset(dbConf); AssociativeArray xData1 = new AssociativeArray(); xData1.put(\"1\", true); instance.add(new Record(xData1, null)); AssociativeArray xData2 = new AssociativeArray(); xData2.put(\"2\", 1.0); instance.add(new Record(xData2, null)); AssociativeArray xData3 = new AssociativeArray(); xData",
        "reference": "@Test public void testGetColumns() { TestUtils.log(this.getClass(), \"getColumns\"); RandomSingleton.getInstance().setSeed(TestConfiguration.RANDOM_SEED); DatabaseConfiguration dbConf = TestUtils.getDBConfig(); Dataset instance = new Dataset(dbConf); AssociativeArray xData1 = new AssociativeArray(); xData1.put(\"1\", true); instance.add(new Record(xData1, null)); AssociativeArray xData2 = new AssociativeArray(); xData2.put(\"2\", 1.0); instance.add(new Record(xData2, null)); AssociativeArray xData3 = new AssociativeArray(); xData3.put(\"3\", (short)1); instance.add(new Record(xData3, null)); AssociativeArray xData4 = new AssociativeArray(); xData4.put(\"4\", \"s\"); instance.add(new Record(xData4, null)); Map<Object, TypeInference.DataType> expResult = new LinkedHashMap<>(); expResult.put(\"1\", TypeInference.DataType.BOOLEAN); expResult.put(\"2\", TypeInference.DataType.NUMERICAL); expResult.put(\"3\", TypeInference.DataType.ORDINAL); expResult.put(\"4\", TypeInference.DataType.CATEGORICAL); Map<Object, TypeInference.DataType> result = instance.getXDataTypes(); assertEquals(expResult, result); }"
    },
    {
        "id": 53,
        "original": "@Test public void testAllStoredEventsSince() { System.out.println(\"allStoredEventsSince\"); Date occurredFrom = null; HibernateEventStore instance = new HibernateEventStore(); List<StoredEvent> expResult = null; List<StoredEvent> result = instance.allStoredEventsSince(occurredFrom); assertEquals(expResult, result); fail(\"The test case is a prototype.\"); }",
        "prediction": "@Test public void testFindStoredEventsSince() { System.out.println(\"findStoredEventsSince\"); Date occurredFrom = null; HibernateEventStore instance = new HibernateEventStore(); List < StoredEvent > expResult = null; List < StoredEvent > result = instance.findStoredEventsSince(occurredFrom); assertEquals(expResult, result); fail(\"The test case is a prototype.\"); }",
        "reference": "@Test public void testFindStoredEventsSince() { System.out.println(\"findStoredEventsSince\"); Date occurredFrom = null; HibernateEventStore instance = new HibernateEventStore(); List<StoredEvent> expResult = null; List<StoredEvent> result = instance.findStoredEventsSince(occurredFrom); assertEquals(expResult, result); fail(\"The test case is a prototype.\"); }"
    },
    {
        "id": 54,
        "original": "@Test public void testPutAll_MultiMap_Simple() { MultiMap<String> mm = new MultiMap<String>(); assertMapSize(mm,0); MultiMap<String> input = new MultiMap<String>(); input.put(\"food\",\"apple\"); input.put(\"color\",\"red\"); input.put(\"amount\",\"bushel\"); mm.putAll(input); assertMapSize(mm,3); assertValues(mm,\"food\",\"apple\"); assertValues(mm,\"color\",\"red\"); assertValues(mm,\"amount\",\"bushel\"); }",
        "prediction": "@Test public void testPutAll_MultiMap_Simple() { MultiMap < String > mm = new MultiMap < String > (); assertMapSize(mm,0); MultiMap < String > input = new MultiMap < String > (); input.put(\"food\",\"apple\"); input.put(\"color\",\"red\"); input.put(\"amount\",\"bushel\"); mm.putAll(input); assertMapSize(mm,3); assertValues(mm,\"food\",\"apple\"); assertValues(mm,\"color\",\"red\"); assertValues(mm,\"amount\",\"bushel\"); }",
        "reference": "@Test public void testPutAll_MultiMap_Simple() { MultiMap mm = new MultiMap(); assertMapSize(mm,0); MultiMap input = new MultiMap(); input.put(\"food\",\"apple\"); input.put(\"color\",\"red\"); input.put(\"amount\",\"bushel\"); mm.putAll(input); assertMapSize(mm,3); assertValues(mm,\"food\",\"apple\"); assertValues(mm,\"color\",\"red\"); assertValues(mm,\"amount\",\"bushel\"); }"
    },
    {
        "id": 55,
        "original": "@Test public void testTransact_getsNewTimestampOnEachTry() { ofy().transact(new VoidWork() { DateTime firstAttemptTime; @Override public void vrun() { if (firstAttemptTime == null) { firstAttemptTime = ofy().getTransactionTime(); sleepUninterruptibly(10, MILLISECONDS); throw new ConcurrentModificationException(); } assertThat(ofy().getTransactionTime()).isGreaterThan(firstAttemptTime); }}); }",
        "prediction": "@Test public void testTransact_getsNewTimestampOnEachTry() { ofy().transact(new VoidWork() { DateTime firstAttemptTime; @Override public void vrun() { if (firstAttemptTime == null) { firstAttemptTime = ofy().getTransactionTime(); sleepUninterruptibly(10, MILLISECONDS); throw new ConcurrentModificationException(); } assertThat(ofy().getTransactionTime()).isGreaterThan(firstAttemptTime); }}); }",
        "reference": "@Test public void testTransact_getsNewTimestampOnEachTry() { tm().transact(new Runnable() { DateTime firstAttemptTime; @Override public void run() { if (firstAttemptTime == null) { firstAttemptTime = tm().getTransactionTime(); sleepUninterruptibly(10, MILLISECONDS); throw new ConcurrentModificationException(); } assertThat(tm().getTransactionTime()).isGreaterThan(firstAttemptTime); }}); }"
    },
    {
        "id": 56,
        "original": "@Test public void testPromote_shouldPromoteKey() throws Exception { int primaryKeyId = 42; int newPrimaryKeyId = 43; KeysetHandle handle = KeysetHandle.fromKeyset( TestUtil.createKeyset( createEnabledKey(primaryKeyId), createEnabledKey(newPrimaryKeyId))); Keyset keyset = KeysetManager .withKeysetHandle(handle) .promote(newPrimaryKeyId) .getKeysetHandle() .getKeyset(); assertThat(keyset.getKeyCount()).isEqualTo(2); assertThat(keyset.getPrimaryKeyId()).isEqualTo(newPrimaryKeyId); }",
        "prediction": "@Test public void testPromote_shouldSetPrimaryKey()throws Exception { int primaryKeyId = 42; int newPrimaryKeyId = 43; KeysetHandle handle = KeysetHandle.fromKeyset(TestUtil.createKeyset( createEnabledKey(primaryKeyId), createEnabledKey(newPrimaryKeyId))); Keyset keyset = KeysetManager.withKeysetHandle(handle).setPrimary(newPrimaryKeyId).getKeysetHandle().getKeyset(); assertThat(keyset.getKeyCount()).isEqualTo(2); assertThat(keyset.getPrimaryKeyId()).isEqualTo(newPrimaryKeyId); assertThat(keyset.getStatus()).equals(",
        "reference": "@Test public void testSetPrimary_shouldSetPrimary() throws Exception { int primaryKeyId = 42; int newPrimaryKeyId = 43; KeysetHandle handle = KeysetHandle.fromKeyset( TestUtil.createKeyset( createEnabledKey(primaryKeyId), createEnabledKey(newPrimaryKeyId))); Keyset keyset = KeysetManager .withKeysetHandle(handle) .setPrimary(newPrimaryKeyId) .getKeysetHandle() .getKeyset(); assertThat(keyset.getKeyCount()).isEqualTo(2); assertThat(keyset.getPrimaryKeyId()).isEqualTo(newPrimaryKeyId); }"
    },
    {
        "id": 57,
        "original": "@Test public void testCurrentlyPreparedTxs() { txPrepare(1); txKeyWrite(1, 10); txKeyWrite(1, 11); txPrepare(2); txKeyWrite(2, 20); txKeyWrite(2, 21); txKeyWrite(2, 22); txPrepare(3); txKeyWrite(3, 30); txCommit(2); tracker.writeLockState(); try { Map<GridCacheVersion, WALPointer> currentlyPreparedTxs = tracker.currentlyPreparedTxs(); assertEquals(2, currentlyPreparedTxs.size()); assertTrue(currentlyPreparedTxs.containsKey(nearXidVersion(1))); assertTrue(currentlyPreparedTxs.containsKey(nearXidVersion(3))); } finally { tracker.writeUnlockState(); } txKeyWrite(3, 31); txCommit(3); tracker.writeLockState(); try { Map<GridCacheVersion, WALPointer> currentlyPreparedTxs = tracker.currentlyPreparedTxs(); assertEquals(1, currentlyPreparedTxs.size()); assertTrue(currentlyPreparedTxs.containsKey(nearXidVersion(1))); } finally { tracker.writeUnlockState(); } }",
        "prediction": "@Test public void testCurrentlyPreparedTxs() { txPrepare(1); txKeyWrite(1, 10); txKeyWrite(1, 11); txPrepare(2); txKeyWrite(2, 20); txKeyWrite(2, 21); txKeyWrite(2, 22); txPrepare(3); txKeyWrite(3, 30); txCommit(2); tracker.writeLockState(); try { Set<GridCacheVersion> currentlyPreparedTxs = tracker.currentlyPreparedTxs(); assertEquals(2, currentlyPreparedTxs.size()); assertTrue(currentlyPreparedTxs.containsKey(nearXidVersion(1))); assertTrue(currentlyPreparedTxs.containsKey(nearXid",
        "reference": "@Test public void testCurrentlyPreparedTxs() { txPrepare(1); txKeyWrite(1, 10); txKeyWrite(1, 11); txPrepare(2); txKeyWrite(2, 20); txKeyWrite(2, 21); txKeyWrite(2, 22); txPrepare(3); txKeyWrite(3, 30); txCommit(2); tracker.writeLockState(); try { Set<GridCacheVersion> currentlyPreparedTxs = tracker.currentlyPreparedTxs(); assertEquals(2, currentlyPreparedTxs.size()); assertTrue(currentlyPreparedTxs.contains(nearXidVersion(1))); assertTrue(currentlyPreparedTxs.contains(nearXidVersion(3))); } finally { tracker.writeUnlockState(); } txKeyWrite(3, 31); txCommit(3); tracker.writeLockState(); try { Set<GridCacheVersion> currentlyPreparedTxs = tracker.currentlyPreparedTxs(); assertEquals(1, currentlyPreparedTxs.size()); assertTrue(currentlyPreparedTxs.contains(nearXidVersion(1))); } finally { tracker.writeUnlockState(); } }"
    },
    {
        "id": 58,
        "original": "@Test public void testSolve_doubleArrArr_doubleArrArr() { System.out.println(\"solve\"); double[][] A = { {0.9000, 0.4000, 0.7000}, {0.4000, 0.5000, 0.3000}, {0.7000, 0.3000, 0.8000} }; double[][] B2 = { {0.5, 0.2}, {0.5, 0.8}, {0.5, 0.3} }; double[][] X2 = { {-0.2027027, -1.2837838}, {0.8783784, 2.2297297}, {0.4729730, 0.6621622} }; double[][] x = Math.solve(A, B2); assertEquals(X2.length, x.length); assertEquals(X2[0].length, x[0].length); for (int i = 0; i < X2.length; i++) { for (int j = 0; j < X2[i].length; j++) { assertEquals(X2[i][j], x[i][j], 1E-7); } } }",
        "prediction": "@Test public void testSolve_doubleArrArr_doubleArrArr() { System.out.println(\"solve\"); double[][] A = { {0.9000, 0.4000, 0.7000}, {0.4000, 0.5000, 0.3000}, {0.7000, 0.3000, 0.8000} }; double[][] B2 = { {0.5, 0.2}, {0.5, 0.8}, {0.5, 0.3} }; double[][] X2 = { {-0.2027027, -1.2837838}, {0.878",
        "reference": "@Test public void testSolve_doubleArrArr_doubleArrArr() { System.out.println(\"solve\"); double[][] A = { {0.9000, 0.4000, 0.7000}, {0.4000, 0.5000, 0.3000}, {0.7000, 0.3000, 0.8000} }; double[][] B2 = { {0.5, 0.2}, {0.5, 0.8}, {0.5, 0.3} }; double[][] X2 = { {-0.2027027, -1.2837838}, {0.8783784, 2.2297297}, {0.4729730, 0.6621622} }; DenseMatrix x = Math.solve(A, B2); assertEquals(X2.length, x.nrows()); assertEquals(X2[0].length, x.ncols()); for (int i = 0; i < X2.length; i++) { for (int j = 0; j < X2[i].length; j++) { assertEquals(X2[i][j], x.get(i, j), 1E-7); } } }"
    },
    {
        "id": 59,
        "original": "@Test public void testColSum() { System.out.println(\"colSum\"); double[][] A = { {0.7220180, 0.07121225, 0.6881997}, {-0.2648886, -0.89044952, 0.3700456}, {-0.6391588, 0.44947578, 0.6240573} }; double[] r = {-0.1820294, -0.3697615, 1.6823026}; double[] result = Math.colSum(A); for (int i = 0; i < r.length; i++) { assertEquals(result[i], r[i], 1E-7); } }",
        "prediction": "@Test public void testColSum() { System.out.println(\"colSum\"); double[][] A = { {0.7220180, 0.07121225, 0.6881997}, {-0.2648886, -0.89044952, 0.3700456}, {-0.6391588, 0.44947578, 0.6240573} }; double[] r = {-0.1820294, -0.3697615, 1.6823026}; double[] result = Math.colSums(A); for (int i = 0; i < r.length; i++) {",
        "reference": "@Test public void testColSums() { System.out.println(\"colSums\"); double[][] A = { {0.7220180, 0.07121225, 0.6881997}, {-0.2648886, -0.89044952, 0.3700456}, {-0.6391588, 0.44947578, 0.6240573} }; double[] r = {-0.1820294, -0.3697615, 1.6823026}; double[] result = Math.colSums(A); for (int i = 0; i < r.length; i++) { assertEquals(result[i], r[i], 1E-7); } }"
    },
    {
        "id": 60,
        "original": "@Test public void addAllAsync_manyTimesRoundTheRing() throws Exception { RingbufferConfig c = config.getRingbufferConfig(ringbuffer.getName()); Random random = new Random(); for (int iteration = 0; iteration < 1000; iteration++) { List<String> items = randomList(max(1, random.nextInt(c.getCapacity()))); long previousTailSeq = ringbuffer.tailSequence(); long result = ringbuffer.addAllAsync(items, OVERWRITE).get(); assertEquals(previousTailSeq + items.size(), ringbuffer.tailSequence()); if (ringbuffer.tailSequence() < c.getCapacity()) { assertEquals(0, ringbuffer.headSequence()); } else { assertEquals(ringbuffer.tailSequence() - c.getCapacity() + 1, ringbuffer.headSequence()); } assertEquals(ringbuffer.tailSequence(), result); long startSequence = previousTailSeq + 1; for (int k = 0; k < items.size(); k++) { assertEquals(items.get(k), ringbuffer.readOne(startSequence + k)); } } }",
        "prediction": "@Test public void addAllAsync_manyTimesRoundTheRing()throws Exception { RingbufferConfig c = config.getRingbufferConfig(ringbuffer.getName()); Random random = new Random(); for (int iteration = 0; iteration < 1000; iteration++) { List<String> items = randomList(max(1, random.nextInt(c.getCapacity()))); long previousTailSeq = ringbuffer.tailSequence(); long result = ringbuffer.addAllAsync(items, OVERWRITE).get(); assertEquals(previousTailSeq + items.size(), ringbuffer.tailSequence()); if (ringbuffer.tailSequence() < c.getCapacity()) { assertEquals(0, ringbuffer.headSequence",
        "reference": "@Test public void addAllAsync_manyTimesRoundTheRing() throws Exception { RingbufferConfig c = config.getRingbufferConfig(ringbuffer.getName()); Random random = new Random(); for (int iteration = 0; iteration < 1000; iteration++) { List<String> items = randomList(max(1, random.nextInt(c.getCapacity()))); long previousTailSeq = ringbuffer.tailSequence(); long result = ringbuffer.addAllAsync(items, OVERWRITE).toCompletableFuture().get(); assertEquals(previousTailSeq + items.size(), ringbuffer.tailSequence()); if (ringbuffer.tailSequence() < c.getCapacity()) { assertEquals(0, ringbuffer.headSequence()); } else { assertEquals(ringbuffer.tailSequence() - c.getCapacity() + 1, ringbuffer.headSequence()); } assertEquals(ringbuffer.tailSequence(), result); long startSequence = previousTailSeq + 1; for (int k = 0; k < items.size(); k++) { assertEquals(items.get(k), ringbuffer.readOne(startSequence + k)); } } }"
    },
    {
        "id": 61,
        "original": "@Test public void testGetUntaggedName() throws VersioningSyntaxException { VersioningService instance = new VersioningService(); String expression = APPLICATION_NAME + VersioningService.EXPRESSION_SEPARATOR + \"RC-\" + VersioningService.EXPRESSION_WILDCARD; String result = instance.getUntaggedName(expression); assertEquals(APPLICATION_NAME, result); expression = APPLICATION_NAME + VersioningService.EXPRESSION_SEPARATOR + \"RC-1.0.0\"; result = instance.getUntaggedName(expression); assertEquals(APPLICATION_NAME, result); expression = APPLICATION_NAME; result = instance.getUntaggedName(expression); assertEquals(APPLICATION_NAME, result); expression = APPLICATION_NAME + VersioningService.EXPRESSION_SEPARATOR; try { result = instance.getUntaggedName(expression); fail(\"the getUntagged method did not throw a VersioningSyntaxException\"); } catch(VersioningSyntaxException e){} }",
        "prediction": "@Test public void testGetUntaggedName()throws VersioningSyntaxException { VersioningService instance = new VersioningService(); String expression = APPLICATION_NAME + VersioningService.EXPRESSION_SEPARATOR + \"RC-\" + VersioningService.EXPRESSION_WILDCARD; String result = instance.getUntaggedName(expression); assertEquals(APPLICATION_NAME, result); expression = APPLICATION_NAME + VersioningService.EXPRESSION_SEPARATOR + \"RC-1.0.0\"; result = instance.getUntaggedName(expression); assertEquals(APPLICATION_NAME, result); expression = APPLICATION_NAME; result = instance.getUntaggedName(expression); assertEquals(APPLICATION_NAME",
        "reference": "@Test public void testGetUntaggedName() throws VersioningSyntaxException { String expression = APPLICATION_NAME + VersioningService.EXPRESSION_SEPARATOR + \"RC-\" + VersioningService.EXPRESSION_WILDCARD; String result = VersioningService.getUntaggedName(expression); assertEquals(APPLICATION_NAME, result); expression = APPLICATION_NAME + VersioningService.EXPRESSION_SEPARATOR + \"RC-1.0.0\"; result = VersioningService.getUntaggedName(expression); assertEquals(APPLICATION_NAME, result); expression = APPLICATION_NAME; result = VersioningService.getUntaggedName(expression); assertEquals(APPLICATION_NAME, result); expression = APPLICATION_NAME + VersioningService.EXPRESSION_SEPARATOR; try { result = VersioningService.getUntaggedName(expression); fail(\"the getUntagged method did not throw a VersioningSyntaxException\"); } catch(VersioningSyntaxException e){} }"
    },
    {
        "id": 62,
        "original": "@Test(description = \"PUT /vApp/{id}\", dependsOnMethods = { \"testGetVApp\" }) public void testModifyVApp() { VApp newVApp = VApp.builder() .name(name(\"new-name-\")) .description(\"New Description\") .build(); vAppNames.add(newVApp.getName()); Task modifyVApp = vAppApi.modifyVApp(vApp.getHref(), newVApp); assertTrue(retryTaskSuccess.apply(modifyVApp), String.format(TASK_COMPLETE_TIMELY, \"modifyVApp\")); vApp = vAppApi.getVApp(vApp.getHref()); assertEquals(vApp.getName(), newVApp.getName(), String.format(OBJ_FIELD_EQ, VAPP, \"Name\", newVApp.getName(), vApp.getName())); assertEquals(vApp.getDescription(), newVApp.getDescription(), String.format(OBJ_FIELD_EQ, VAPP, \"Description\", newVApp.getDescription(), vApp.getDescription())); }",
        "prediction": "@Test(description = \"PUT /vApp/{id}\", dependsOnMethods = { \"testGetVApp\" }) public void testEditVApp() { VApp newVApp = VApp.builder().name(name(\"new-name-\")).description(\"New Description\").build(); vAppNames.add(newVApp.getName()); VApp editVApp = vAppApi.editVApp(vApp.getHref(), newVApp); assertTrue(retryTaskSuccess.apply(editVApp), String.format(TASK_COMPLETE_TIMELY, \"editVApp\")); vApp = vAppApi.getVApp(vApp.getHref());",
        "reference": "@Test(description = \"PUT /vApp/{id}\", dependsOnMethods = { \"testGetVApp\" }) public void testEditVApp() { VApp newVApp = VApp.builder().name(name(\"new-name-\")).description(\"New Description\").build(); vAppNames.add(newVApp.getName()); Task editVApp = vAppApi.editVApp(vApp.getHref(), newVApp); assertTrue(retryTaskSuccess.apply(editVApp), String.format(TASK_COMPLETE_TIMELY, \"editVApp\")); vApp = vAppApi.getVApp(vApp.getHref()); assertEquals(vApp.getName(), newVApp.getName(), String.format(OBJ_FIELD_EQ, VAPP, \"Name\", newVApp.getName(), vApp.getName())); assertEquals(vApp.getDescription(), newVApp.getDescription(), String.format(OBJ_FIELD_EQ, VAPP, \"Description\", newVApp.getDescription(), vApp.getDescription())); }"
    },
    {
        "id": 63,
        "original": "@Test(description = \"GET /v${apiVersion}/{tenantId}/flavors/detail\") public void testListFlavorsInDetail() throws Exception { for (String zoneId : zones) { FlavorApi api = novaContext.getApi().getFlavorApiForZone(zoneId); Set<? extends Flavor> response = api.listFlavorsInDetail(); assertNotNull(response); assertFalse(response.isEmpty()); for (Flavor flavor : response) { assertNotNull(flavor.getId()); assertNotNull(flavor.getName()); assertNotNull(flavor.getLinks()); assertTrue(flavor.getRam() > 0); assertTrue(flavor.getDisk() > 0); assertTrue(flavor.getVcpus() > 0); } } }",
        "prediction": "@Test(description = \"GET /v${apiVersion}/{tenantId}/flavors/detail\") public void testListFlavorsInDetail()throws Exception { for (String zoneId : zones) { FlavorApi api = novaContext.getApi().getFlavorApiForZone(zoneId); Set<? extends Flavor> response = api.listInDetail(); assertNotNull(response); assertFalse(response.isEmpty()); for (Flavor flavor : response) { assertNotNull(flavor.getId()); assertNotNull(flavor.getName()); assertNotNull(flavor.getLinks()); assertTrue(flavor.getRam() > 0); assertTrue(flavor.getDisk() > 0); } }",
        "reference": "@Test(description = \"GET /v${apiVersion}/{tenantId}/flavors/detail\") public void testListFlavorsInDetail() throws Exception { for (String zoneId : zones) { FlavorApi api = novaContext.getApi().getFlavorApiForZone(zoneId); Set<? extends Flavor> response = api.listInDetail().concat().toImmutableSet(); assertNotNull(response); assertFalse(response.isEmpty()); for (Flavor flavor : response) { assertNotNull(flavor.getId()); assertNotNull(flavor.getName()); assertNotNull(flavor.getLinks()); assertTrue(flavor.getRam() > 0); assertTrue(flavor.getDisk() > 0); assertTrue(flavor.getVcpus() > 0); } } }"
    },
    {
        "id": 64,
        "original": "@Test(description = \"GET /v${apiVersion}/{tenantId}/flavors\") public void testListFlavors() throws Exception { for (String zoneId : zones) { FlavorApi api = novaContext.getApi().getFlavorApiForZone(zoneId); Set<? extends Resource> response = api.listFlavors(); assertNotNull(response); assertFalse(response.isEmpty()); for (Resource flavor : response) { assertNotNull(flavor.getId()); assertNotNull(flavor.getName()); assertNotNull(flavor.getLinks()); } } }",
        "prediction": "@Test(description = \"GET /v${apiVersion}/{tenantId}/flavors\") public void testListFlavors()throws Exception { for (String zoneId : zones) { FlavorApi api = novaContext.getApi().getFlavorApiForZone(zoneId); Set <? extends Resource > response = api.list(); assertNotNull(response); assertFalse(response.isEmpty()); for (Resource flavor : response) { assertNotNull(flavor.getId()); assertNotNull(flavor.getName()); assertNotNull(flavor.getLinks()); } } }",
        "reference": "@Test(description = \"GET /v${apiVersion}/{tenantId}/flavors\") public void testListFlavors() throws Exception { for (String zoneId : zones) { FlavorApi api = novaContext.getApi().getFlavorApiForZone(zoneId); Set<? extends Resource> response = api.list().concat().toImmutableSet(); assertNotNull(response); assertFalse(response.isEmpty()); for (Resource flavor : response) { assertNotNull(flavor.getId()); assertNotNull(flavor.getName()); assertNotNull(flavor.getLinks()); } } }"
    },
    {
        "id": 65,
        "original": "@Test public void testGetChecksum_FileNotFound() throws Exception { System.out.println(\"getChecksum (invalid path)\"); String algorithm = \"MD5\"; File file = new File(\"not a valid file\"); boolean exceptionThrown = false; try { byte[] result = Checksum.getChecksum(algorithm, file); } catch (FileNotFoundException ex) { exceptionThrown = true; } assertTrue(exceptionThrown); }",
        "prediction": "@Test public void testGetChecksum_FileNotFound()throws Exception { System.out.println(\"getChecksum (invalid path)\"); String algorithm = \"MD5\"; File file = new File(\"not a valid file\"); boolean exceptionThrown = false; try { byte[] result = Checksum.getChecksum(algorithm, file); } catch (FileNotFoundException ex) { exceptionThrown = true; } assertTrue(exceptionThrown); }",
        "reference": "@Test public void testGetChecksum_FileNotFound() throws Exception { System.out.println(\"getChecksum (invalid path)\"); String algorithm = \"MD5\"; File file = new File(\"not a valid file\"); boolean exceptionThrown = false; try { byte[] result = Checksum.getChecksum(algorithm, file); } catch (IOException ex) { exceptionThrown = true; } assertTrue(exceptionThrown); }"
    },
    {
        "id": 66,
        "original": "@Test public void testAnalyze() throws Exception { System.out.println(\"analyze\"); File file = new File(this.getClass().getClassLoader().getResource(\"struts2-core-2.1.2.jar\").getPath()); Dependency result = new Dependency(file); FileNameAnalyzer instance = new FileNameAnalyzer(); instance.analyze(result); assertTrue(result.getVendorEvidence().toString().toLowerCase().contains(\"struts\")); }",
        "prediction": "@Test public void testAnalyze()throws Exception { System.out.println(\"analyze\"); File file = new File(this.getClass().getClassLoader().getResource(\"struts2-core-2.1.2.jar\").getPath()); Engine result = new Engine(file); FileNameAnalyzer instance = new FileNameAnalyzer(); instance.analyze(result, null); assertTrue(result.getVendorEvidence().toString().toLowerCase().contains(\"struts\")); }",
        "reference": "@Test public void testAnalyze() throws Exception { System.out.println(\"analyze\"); File file = new File(this.getClass().getClassLoader().getResource(\"struts2-core-2.1.2.jar\").getPath()); Dependency result = new Dependency(file); FileNameAnalyzer instance = new FileNameAnalyzer(); instance.analyze(result, null); assertTrue(result.getVendorEvidence().toString().toLowerCase().contains(\"struts\")); }"
    },
    {
        "id": 67,
        "original": "@Test public void testRemoveProperty() { String key = \"SomeKey\"; String value = \"value\"; String dfault = \"default\"; Settings.setString(key, value); String ret = Settings.getString(key); Assert.assertEquals(value, ret); Settings.removeProperty(key); ret = Settings.getString(key, dfault); Assert.assertEquals(dfault, ret); }",
        "prediction": "@Test public void testRemoveProperty() { String key = \"SomeKey\"; String value = \"value\"; String dfault = \"default\"; getSettings().setString(key, value); String ret = getSettings().getString(key); Assert.assertEquals(value, ret); getSettings().removeProperty(key); ret = getSettings().getString(key, dfault); Assert.assertEquals(dfault, ret); }",
        "reference": "@Test public void testRemoveProperty() { String key = \"SomeKey\"; String value = \"value\"; String dfault = \"default\"; getSettings().setString(key, value); String ret = getSettings().getString(key); Assert.assertEquals(value, ret); getSettings().removeProperty(key); ret = getSettings().getString(key, dfault); Assert.assertEquals(dfault, ret); }"
    },
    {
        "id": 68,
        "original": "@Test public void testInAbbrevJournalNames_case1() throws Exception { String input = \"Nature\"; List<OffsetPosition> journalsPositions = target.inAbbrevJournalNames(input); assertNotNull(journalsPositions); assertThat(journalsPositions, hasSize(1)); assertThat(journalsPositions.get(0).start, is(0)); }",
        "prediction": "@Test public void testTokenPositionsAbbrevJournalNames_case1()throws Exception { String input = \"Nature\"; List<OffsetPosition> journalsPositions = target.tokenPositionsAbbrevJournalNames(input); assertNotNull(journalsPositions); assertThat(journalsPositions, hasSize(1)); assertThat(journalsPositions.get(0).start, is(0)); }",
        "reference": "@Test public void testInAbbrevJournalNames_case1() throws Exception { String input = \"Nature\"; List<OffsetPosition> journalsPositions = target.tokenPositionsAbbrevJournalNames(input); assertNotNull(journalsPositions); assertThat(journalsPositions, hasSize(1)); assertThat(journalsPositions.get(0).start, is(0)); }"
    },
    {
        "id": 69,
        "original": "@Test public void testMatcherList_location() throws Exception { target = new FastMatcher(this.getClass().getResourceAsStream(\"location.txt\")); final List<OffsetPosition> offsetPositions = target.matcher(Arrays.asList(\"I\", \"m\", \"walking\", \"in\", \"The\", \"Bronx\")); assertThat(offsetPositions, hasSize(2)); assertThat(offsetPositions.get(0).start, is(4)); assertThat(offsetPositions.get(0).end, is(5)); assertThat(offsetPositions.get(1).start, is(5)); assertThat(offsetPositions.get(1).end, is(5)); }",
        "prediction": "@Test public void testMatcherList_location()throws Exception { target = new FastMatcher(this.getClass().getResourceAsStream(\"location.txt\")); final List <OffsetPosition > offsetPositions = target.matchLayoutToken(Arrays.asList(\"I\", \"m\", \"walking\", \"in\", \"The\", \"Bronx\")); assertThat(offsetPositions, hasSize(2)); assertThat(offsetPositions.get(0).start, is(4)); assertThat(offsetPositions.get(0).end, is(5)); assertThat(offsetPositions.get(1).start, is(5)); assertThat(offsetPositions.get(1).end, is(5",
        "reference": "@Test public void testMatcherList_location() throws Exception { target = new FastMatcher(this.getClass().getResourceAsStream(\"location.txt\")); final String input = \"I\\'m walking in The Bronx\"; List<LayoutToken> tokenisedInput = GrobidAnalyzer.getInstance().tokenizeWithLayoutToken(input); final List<OffsetPosition> offsetPositions = target.matchLayoutToken(tokenisedInput); assertThat(offsetPositions, hasSize(2)); assertThat(offsetPositions.get(0).start, is(8)); assertThat(offsetPositions.get(0).end, is(10)); assertThat(offsetPositions.get(1).start, is(10)); assertThat(offsetPositions.get(1).end, is(10)); }"
    },
    {
        "id": 70,
        "original": "@Test public void testMatchString_location() throws Exception { target = new FastMatcher(this.getClass().getResourceAsStream(\"location.txt\")); final String input = \"I'm walking in The Bronx\"; final List<OffsetPosition> positions = target.match(input); assertThat(positions, hasSize(2)); assertThat(positions.get(0).start, is(15)); assertThat(positions.get(0).end, is(24)); assertThat(positions.get(1).start, is(19)); assertThat(positions.get(1).end, is(24)); }",
        "prediction": "@Test public void testMatchString_location()throws Exception { target = new FastMatcher(this.getClass().getResourceAsStream(\"location.txt\")); final String input = \"I\\'m walking in The Bronx\"; final List<OffsetPosition> positions = target.matchCharacter(input); assertThat(positions, hasSize(2)); assertThat(positions.get(0).start, is(15)); assertThat(positions.get(0).end, is(24)); assertThat(positions.get(1).start, is(19)); assertThat(positions.get(1).end, is(24)); }",
        "reference": "@Test public void testMatchString_location() throws Exception { target = new FastMatcher(this.getClass().getResourceAsStream(\"location.txt\")); final String input = \"I\\'m walking in The Bronx\"; final List<OffsetPosition> positions = target.matchCharacter(input); assertThat(positions, hasSize(2)); assertThat(positions.get(0).start, is(15)); assertThat(positions.get(0).end, is(24)); assertThat(positions.get(1).start, is(19)); assertThat(positions.get(1).end, is(24)); }"
    },
    {
        "id": 71,
        "original": "@Test public void testMatchList_location_1Match() throws Exception { target = new FastMatcher(this.getClass().getResourceAsStream(\"location.txt\")); final String input = \"This is Bronx\"; final List<OffsetPosition> offsetPositions = target.match(Arrays.asList(input.split(\" \"))); assertThat(offsetPositions, hasSize(1)); assertThat(offsetPositions.get(0).start, is(2)); assertThat(offsetPositions.get(0).end, is(2)); }",
        "prediction": "@Test public void testMatchList_location_1Match()throws Exception { target = new FastMatcher(this.getClass().getResourceAsStream(\"location.txt\")); final String input = \"This is Bronx\"; final List<OffsetPosition> offsetPositions = target.matchCharacterLayoutToken(Arrays.asList(input.split(\" \"))); assertThat(offsetPositions, hasSize(1)); assertThat(offsetPositions.get(0).start, is(2)); assertThat(offsetPositions.get(0).end, is(2)); }",
        "reference": "@Test public void testMatchList_location_1Match() throws Exception { target = new FastMatcher(this.getClass().getResourceAsStream(\"location.txt\")); final String input = \"This is Bronx\"; List<LayoutToken> tokenisedInput = GrobidAnalyzer.getInstance().tokenizeWithLayoutToken(input); final List<OffsetPosition> offsetPositions = target.matchCharacterLayoutToken(tokenisedInput); assertThat(offsetPositions, hasSize(1)); assertThat(offsetPositions.get(0).start, is(4)); assertThat(offsetPositions.get(0).end, is(4)); }"
    },
    {
        "id": 72,
        "original": "@Test public void testDownloadFileFromServer() throws Exception { final RestfulMgr restfulMgr = new RestfulMgrMock().getMockInstance(); FetcherMgr fetcherMgr = new FetcherMgrImpl(restfulMgr, 3, 5, true, \"\", new ArrayList<String>()); try { String valueString = fetcherMgr.downloadFileFromServer(requestUrl, RestfulMgrMock.defaultFileName); Assert.assertEquals(RestfulMgrMock.defaultFileName, valueString); } catch (Exception e) { e.printStackTrace(); Assert.assertTrue(false); } }",
        "prediction": "@Test public void testDownloadFileFromServer()throws Exception { final RestfulMgr restfulMgr = new RestfulMgrMock().getMockInstance(); FetcherMgr fetcherMgr = new FetcherMgrImpl(restfulMgr, 3, 5, true, \"\", new ArrayList<String>()); try { String valueString = fetcherMgr.downloadFileFromServer(requestUrl, RestfulMgrMock.defaultFileName, RestfulMgrMock.defaultTargetDir); Assert.assertEquals(RestfulMgrMock.defaultTargetDir, valueString); } catch(Exception e) { e.printStackTrace(); Assert.assertTrue(false); } }",
        "reference": "@Test public void testDownloadFileFromServer() throws Exception { final RestfulMgr restfulMgr = new RestfulMgrMock().getMockInstance(); FetcherMgr fetcherMgr = new FetcherMgrImpl(restfulMgr, 3, 5, true, \"\", new ArrayList<String>()); try { String valueString = fetcherMgr.downloadFileFromServer(requestUrl, RestfulMgrMock.defaultFileName, \"./disconf\"); Assert.assertEquals(RestfulMgrMock.defaultFileName, valueString); } catch (Exception e) { e.printStackTrace(); Assert.assertTrue(false); } }"
    },
    {
        "id": 73,
        "original": "@Test public void setImage() { ImageFloat32 image = new ImageFloat32(640,480); GImageMiscOps.fillUniform(image,rand,0,200); UnrollSiftScaleSpaceGradient alg = new UnrollSiftScaleSpaceGradient(new SiftScaleSpace(-1,3,3,2)); alg.setImage(image); SiftScaleSpace ss = new SiftScaleSpace(-1,3,3,2); ss.initialize(image); ImageFloat32 derivX = new ImageFloat32(640,480); ImageFloat32 derivY = new ImageFloat32(640,480); int total = 0; do { for (int i = 0; i < ss.getNumScales(); i++, total++ ) { ImageFloat32 scaleImage = ss.getImageScale(i); derivX.reshape(scaleImage.width,scaleImage.height); derivY.reshape(scaleImage.width,scaleImage.height); GImageDerivativeOps.gradient(DerivativeType.THREE,scaleImage,derivX,derivY, BorderType.EXTENDED); UnrollSiftScaleSpaceGradient.ImageScale found = alg.usedScales.get(total); BoofTesting.assertEquals(derivX,found.derivX,1e-4); BoofTesting.assertEquals(derivY,found.derivY,1e-4); assertEquals(ss.computeSigmaScale(i),found.sigma,1e-4); assertEquals(image.width/(double)scaleImage.width,found.imageToInput,1e-4); } } while( ss.computeNextOctave() ); }",
        "prediction": "@Test public void setImage() { GrayF32 image = new GrayF32(640,480); GImageMiscOps.fillUniform(image,rand,0,200); UnrollSiftScaleSpaceGradient alg = new UnrollSiftScaleSpaceGradient(new SiftScaleSpace(-1,3,3,2)); alg.setImage(image); SiftScaleSpace ss = new SiftScaleSpace(-1,3,3,2); ss.initialize(image); GrayF32 derivX = new GrayF32(640,480); GrayF32 derivY = new GrayF32(640,480); int total = 0; do { for (int i = 0; i",
        "reference": "@Test public void setImage() { GrayF32 image = new GrayF32(640,480); GImageMiscOps.fillUniform(image,rand,0,200); UnrollSiftScaleSpaceGradient alg = new UnrollSiftScaleSpaceGradient(new SiftScaleSpace(-1,3,3,2)); alg.setImage(image); SiftScaleSpace ss = new SiftScaleSpace(-1,3,3,2); ss.initialize(image); GrayF32 derivX = new GrayF32(640,480); GrayF32 derivY = new GrayF32(640,480); int total = 0; do { for (int i = 0; i < ss.getNumScales(); i++, total++ ) { GrayF32 scaleImage = ss.getImageScale(i); derivX.reshape(scaleImage.width,scaleImage.height); derivY.reshape(scaleImage.width,scaleImage.height); GImageDerivativeOps.gradient(DerivativeType.THREE,scaleImage,derivX,derivY, BorderType.EXTENDED); UnrollSiftScaleSpaceGradient.ImageScale found = alg.usedScales.get(total); BoofTesting.assertEquals(derivX,found.derivX,1e-4); BoofTesting.assertEquals(derivY,found.derivY,1e-4); assertEquals(ss.computeSigmaScale(i),found.sigma,1e-4); assertEquals(image.width/(double)scaleImage.width,found.imageToInput,1e-4); } } while( ss.computeNextOctave() ); }"
    },
    {
        "id": 74,
        "original": "@Test public void fit_obvious() { List<Point2D_I32> contours = createSquare(10,12,20,30); GrowQueue_I32 corners = createSquareCorners(10, 12, 20, 30); corners.add(corners.get(3)+4); MinimizeEnergyPrune alg = new MinimizeEnergyPrune(1); GrowQueue_I32 output = new GrowQueue_I32(); alg.fit(contours,corners,output); assertEquals(4, output.size()); for (int i = 0; i < 4; i++) { assertEquals(corners.get(i),output.get(i)); } }",
        "prediction": "@Test public void fit_obvious() { List<Point2D_I32> contours = createSquare(10,12,20,30); GrowQueue_I32 corners = createSquareCorners(10, 12, 20, 30); corners.add(corners.get(3)+4); MinimizeEnergyPrune alg = new MinimizeEnergyPrune(1); GrowQueue_I32 output = new GrowQueue_I32(); alg.prune(contours,corners,output); assertEquals(4, output.size()); for (int i = 0; i < 4; i++) { assertEquals(corners.get(i),output.get(i",
        "reference": "@Test public void prune_obvious() { List<Point2D_I32> contours = createSquare(10,12,20,30); GrowQueue_I32 corners = createSquareCorners(10, 12, 20, 30); corners.add(corners.get(3)+4); MinimizeEnergyPrune alg = new MinimizeEnergyPrune(1); GrowQueue_I32 output = new GrowQueue_I32(); alg.prune(contours, corners, output); assertEquals(4, output.size()); checkMatched(corners, output); }"
    },
    {
        "id": 75,
        "original": "@Test void computeCostInnerD() { Planar<GrayU16> costYXD = new Planar<>(GrayU16.class,rangeD,width,height); GImageMiscOps.fillUniform(costYXD,rand,0,SgmDisparityCost.MAX_COST); SgmCostAggregation alg = new SgmCostAggregation(); alg.init(costYXD); for (int i = 0; i < alg.workCostLr.length; i++) { alg.workCostLr[i] = (short)rand.nextInt(SgmDisparityCost.MAX_COST); } GrayU16 costXD = costYXD.getBand(2); int x = rangeD + 2; int pathI = 3; int idxCost = costXD.getIndex(0,x); int idxWork = alg.lengthD*pathI; alg.computeCostInnerD(costXD,idxCost,idxWork, rangeD); for (int d = 1; d < rangeD-1; d++) { int cost_p_d = costXD.get(d,x); int l0 = workArray(alg,pathI,d); int l1 = workArray(alg,pathI,d-1) + alg.penalty1; int l2 = workArray(alg,pathI,d+1) + alg.penalty1; int l3 = alg.penalty2; int v = min(min(min(l0,l1),l2),l3); int expected = cost_p_d + v; int found = workArray(alg,pathI+1,d); assertEquals(expected,found); } }",
        "prediction": "@Test void computeCostInnerD() { Planar<GrayU16> costYXD = new Planar<>(GrayU16.class,rangeD,width,height); GImageMiscOps.fillUniform(costYXD,rand,0,SgmDisparityCost.MAX_COST); SgmCostAggregation alg = new SgmCostAggregation(); alg.init(costYXD); for(int i = 0; i < alg.workCostLr.length; i++) { alg.workCostLr[i] = (short)rand.nextInt(SgmDisparityCost.MAX_COST); } GrayU16 costXD = costYXD.getBand(2",
        "reference": "@Test void computeCostInnerD() { Planar<GrayU16> costYXD = new Planar<>(GrayU16.class,rangeD,width,height); GImageMiscOps.fillUniform(costYXD,rand,0,SgmDisparityCost.MAX_COST); SgmCostAggregation alg = new SgmCostAggregation(); alg.init(costYXD); short[] workCostLr = alg.workspace.get(0).workCostLr; for (int i = 0; i < workCostLr.length; i++) { workCostLr[i] = (short)rand.nextInt(SgmDisparityCost.MAX_COST); } GrayU16 costXD = costYXD.getBand(2); int x = rangeD + 2; int pathI = 3; int idxCost = costXD.getIndex(0,x); int idxWork = alg.lengthD*pathI; alg.computeCostInnerD(costXD,idxCost,idxWork, rangeD, workCostLr); for (int d = 1; d < rangeD-1; d++) { int cost_p_d = costXD.get(d,x); int l0 = workArray(alg,pathI,d); int l1 = workArray(alg,pathI,d-1) + alg.penalty1; int l2 = workArray(alg,pathI,d+1) + alg.penalty1; int l3 = alg.penalty2; int v = min(min(min(l0,l1),l2),l3); int expected = cost_p_d + v; int found = workArray(alg,pathI+1,d); assertEquals(expected,found); } }"
    },
    {
        "id": 76,
        "original": "@Test public void gaussian() { for( int totalOrder = 1; totalOrder <= 4; totalOrder++ ) { for( int orderX = 0; orderX<= totalOrder; orderX++ ) { int orderY = totalOrder-orderX; SteerableKernel<Kernel2D_F32> alg = FactorySteerable.gaussian(Kernel2D_F32.class,orderX,orderY,10); Kernel2D_F32 k = alg.compute(0.1); boolean notZero = false; for( int y = 0; y < k.width; y++ ) { for( int x = 0; x < k.width; x++ ) { if( k.get(x,y) != 0 ) notZero=true; } } assertTrue(notZero); } } }",
        "prediction": "@Test public void gaussian() { for( int totalOrder = 1; totalOrder <= 4; totalOrder++ ) { for( int orderX = 0; orderX<= totalOrder; orderX++ ) { int orderY = totalOrder-orderX; SteerableKernel<Kernel2D_F32> alg = FactorySteerable.gaussian(Kernel2D_F32.class,orderX, orderY, 10, 0); Kernel2D_F32 k = alg.compute(0.1); boolean notZero = false; for( int y = 0; y < k.width; y++ ) { for( int x = 0; x < k.width; x",
        "reference": "@Test public void gaussian() { for( int totalOrder = 1; totalOrder <= 4; totalOrder++ ) { for( int orderX = 0; orderX<= totalOrder; orderX++ ) { int orderY = totalOrder-orderX; SteerableKernel<Kernel2D_F32> alg = FactorySteerable.gaussian(Kernel2D_F32.class,orderX,orderY, -1, 10); Kernel2D_F32 k = alg.compute(0.1); boolean notZero = false; for( int y = 0; y < k.width; y++ ) { for( int x = 0; x < k.width; x++ ) { if( k.get(x,y) != 0 ) notZero=true; } } assertTrue(notZero); } } }"
    },
    {
        "id": 77,
        "original": "@Test public void fullView_Transform() { IntrinsicParameters param = new IntrinsicParameters(). fsetK(300, 320, 0, 150, 130, width, height).fsetRadial(0.1, 0.05); PointTransform_F32 adjToDist = LensDistortionOps.fullView(param, null, true); PointTransform_F32 distToAdj = LensDistortionOps.fullView(param, null, false); checkBorderOutside(adjToDist,distToAdj); param = new IntrinsicParameters(). fsetK(300, 320, 0, 150, 130, width, height).fsetRadial(-0.1,-0.05); adjToDist = LensDistortionOps.fullView(param, null, true); distToAdj = LensDistortionOps.fullView(param, null, false); checkBorderOutside(adjToDist,distToAdj); }",
        "prediction": "@Test public void transform_F32() { IntrinsicParameters param = new IntrinsicParameters(). fsetK(300, 320, 0, 150, 130, width, height).fsetRadial(0.1, 0.05); PointTransform_F32 adjToDist = LensDistortionOps.transform_F32(AdjustmentType.FULL_VIEW, param, null, true); PointTransform_F32 distToAdj = LensDistortionOps.transform_F32(AdjustmentType.SHRINK, param, null, false); checkBorderOutside(adjToDist,distToAdj); param = new IntrinsicParameters(). fsetK(300, 320, 0, 150,",
        "reference": "@Test public void transform_F32_fullView() { IntrinsicParameters param = new IntrinsicParameters(). fsetK(300, 320, 0, 150, 130, width, height).fsetRadial(0.1, 0.05); PointTransform_F32 adjToDist = LensDistortionOps.transform_F32(AdjustmentType.FULL_VIEW, param, null, true); PointTransform_F32 distToAdj = LensDistortionOps.transform_F32(AdjustmentType.FULL_VIEW, param, null, false); checkBorderOutside(adjToDist,distToAdj); param = new IntrinsicParameters(). fsetK(300, 320, 0, 150, 130, width, height).fsetRadial(-0.1,-0.05); adjToDist = LensDistortionOps.transform_F32(AdjustmentType.FULL_VIEW, param, null, true); distToAdj = LensDistortionOps.transform_F32(AdjustmentType.FULL_VIEW, param, null, false); checkBorderOutside(adjToDist,distToAdj); }"
    },
    {
        "id": 78,
        "original": "@Test public void allInside_Transform() { IntrinsicParameters param = new IntrinsicParameters().fsetK(300, 320, 0, 150, 130, width, height).fsetRadial(0.1, 1e-4); PointTransform_F32 adjToDist = LensDistortionOps.allInside(param, null, true); PointTransform_F32 distToAdj = LensDistortionOps.allInside(param, null, false); checkInside(adjToDist, distToAdj); param = new IntrinsicParameters().fsetK(300, 320, 0, 150, 130, width, height).fsetRadial(-0.1,-1e-4); adjToDist = LensDistortionOps.allInside(param, null, true); distToAdj = LensDistortionOps.allInside(param, null, false); checkInside(adjToDist, distToAdj); }",
        "prediction": "@Test public void transform_F32_Transform() { IntrinsicParameters param = new IntrinsicParameters().fsetK(300, 320, 0, 150, 130, width, height).fsetRadial(0.1, 1e-4); PointTransform_F32 adjToDist = LensDistortionOps.transform_F32(AdjustmentType.FULL_VIEW, param, null, false); PointTransform_F32 distToAdj = LensDistortionOps.transform_F32(AdjustmentType.SHRINK, param, null, true); checkInside(adjToDist, distToAdj); param = new IntrinsicParameters().fsetK(300, 320, 0,",
        "reference": "@Test public void transform_F32_shrink() { IntrinsicParameters param = new IntrinsicParameters().fsetK(300, 320, 0, 150, 130, width, height).fsetRadial(0.1, 1e-4); PointTransform_F32 adjToDist = LensDistortionOps.transform_F32(AdjustmentType.SHRINK, param, null, true); PointTransform_F32 distToAdj = LensDistortionOps.transform_F32(AdjustmentType.SHRINK, param, null, false); checkInside(adjToDist, distToAdj); param = new IntrinsicParameters().fsetK(300, 320, 0, 150, 130, width, height).fsetRadial(-0.1,-1e-4); adjToDist = LensDistortionOps.transform_F32(AdjustmentType.SHRINK, param, null, true); distToAdj = LensDistortionOps.transform_F32(AdjustmentType.SHRINK, param, null, false); checkInside(adjToDist, distToAdj); }"
    },
    {
        "id": 79,
        "original": "@Test public void hessian_F32() { ImageFloat32 original = new ImageFloat32(width,height); ImageFloat32 integral = new ImageFloat32(width,height); ImageFloat32 found = new ImageFloat32(width,height); ImageFloat32 expected = new ImageFloat32(width,height); GImageMiscOps.fillUniform(original, rand, 0, 50); IntegralImageOps.transform(original,integral); int size = 9; for( int skip = 1; skip <= 4; skip++ ) { found.reshape(width/skip,height/skip); expected.reshape(width/skip,height/skip); ImplIntegralImageFeatureIntensity.hessianNaive(integral,skip,size,expected); IntegralImageFeatureIntensity.hessian(integral,skip,size,found); BoofTesting.assertEquals(expected,found, 1e-4f); } }",
        "prediction": "@Test public void hessian_F32() { GrayF32 original = new GrayF32(width,height); GrayF32 integral = new GrayF32(width,height); GrayF32 found = new GrayF32(width,height); GrayF32 expected = new GrayF32(width,height); GImageMiscOps.fillUniform(original, rand, 0, 50); IntegralImageOps.transform(original,integral); int size = 9; for( int skip = 1; skip <= 4; skip++ ) { found.reshape(width/skip,height/skip); expected.reshape(width/skip,height/skip); ImplIntegralImageFeatureIntensity.hessian(found, expected,",
        "reference": "@Test public void hessian_F32() { GrayF32 original = new GrayF32(width,height); GrayF32 integral = new GrayF32(width,height); GrayF32 found = new GrayF32(width,height); GrayF32 expected = new GrayF32(width,height); GImageMiscOps.fillUniform(original, rand, 0, 50); IntegralImageOps.transform(original,integral); int size = 9; for( int skip = 1; skip <= 4; skip++ ) { found.reshape(width/skip,height/skip); expected.reshape(width/skip,height/skip); ImplIntegralImageFeatureIntensity.hessianNaive(integral,skip,size,expected); IntegralImageFeatureIntensity.hessian(integral,skip,size,found); BoofTesting.assertEquals(expected,found, 1e-4f); } }"
    },
    {
        "id": 80,
        "original": "@Test public void findErrorLocatorBM() { GrowQueue_I8 message = GrowQueue_I8.parseHex( \"[ 0x40, 0xd2, 0x75, 0x47, 0x76, 0x17, 0x32, 0x06, 0x27, 0x26, 0x96, 0xc6, 0xc6, 0x96, 0x70, 0xec ]\"); GrowQueue_I8 ecc = new GrowQueue_I8(); int nsyn = 10; int syndromes[] = new int[nsyn]; ReidSolomonCodes alg = new ReidSolomonCodes(8,primitive8); alg.generator(nsyn); alg.computeECC(message,ecc); message.data[0] = 0; alg.computeSyndromes(message,ecc,syndromes); GrowQueue_I8 errorLocator = new GrowQueue_I8(); alg.findErrorLocatorBM(syndromes,nsyn,errorLocator); assertEquals(2,errorLocator.size); assertEquals(3,errorLocator.get(0)); assertEquals(1,errorLocator.get(1)); message.data[6] = 10; alg.computeSyndromes(message,ecc,syndromes); alg.findErrorLocatorBM(syndromes,nsyn,errorLocator); assertEquals(3,errorLocator.size); assertEquals(238,errorLocator.get(0)&0xFF); assertEquals(89,errorLocator.get(1)); assertEquals(1,errorLocator.get(2)); }",
        "prediction": "@Test public void findErrorLocatorPolynomialBM() { GrowQueue_I8 message = GrowQueue_I8.parseHex( \"[ 0x40, 0xd2, 0x75, 0x47, 0x76, 0x17, 0x32, 0x06, 0x27, 0x26, 0x96, 0xc6, 0xc6, 0x96, 0x70, 0xec ]\"); GrowQueue_I8 ecc = new GrowQueue_I8(); int nsyn = 10; int syndromes[] = new int[nsyn]; ReidSolomonCodes alg = new ReidSolomonCodes(",
        "reference": "@Test public void findErrorLocatorPolynomialBM() { GrowQueue_I8 message = GrowQueue_I8.parseHex( \"[ 0x40, 0xd2, 0x75, 0x47, 0x76, 0x17, 0x32, 0x06, 0x27, 0x26, 0x96, 0xc6, 0xc6, 0x96, 0x70, 0xec ]\"); GrowQueue_I8 ecc = new GrowQueue_I8(); int nsyn = 10; int syndromes[] = new int[nsyn]; ReidSolomonCodes alg = new ReidSolomonCodes(8,primitive8); alg.generator(nsyn); alg.computeECC(message,ecc); message.data[0] = 0; alg.computeSyndromes(message,ecc,syndromes); GrowQueue_I8 errorLocator = new GrowQueue_I8(); alg.findErrorLocatorPolynomialBM(syndromes,nsyn,errorLocator); assertEquals(2,errorLocator.size); assertEquals(3,errorLocator.get(0)); assertEquals(1,errorLocator.get(1)); message.data[6] = 10; alg.computeSyndromes(message,ecc,syndromes); alg.findErrorLocatorPolynomialBM(syndromes,nsyn,errorLocator); assertEquals(3,errorLocator.size); assertEquals(238,errorLocator.get(0)&0xFF); assertEquals(89,errorLocator.get(1)); assertEquals(1,errorLocator.get(2)); }"
    },
    {
        "id": 81,
        "original": "@Test public void scaleSpace() { double ss[] = new double[]{1,2,4,6,8,10}; PyramidFloat<ImageFloat32> pyramid = FactoryPyramid.scaleSpacePyramid(ss, ImageFloat32.class); for( int i = 0; i < ss.length; i++ ) { assertEquals(ss[i],pyramid.getSigma(i),1e-8); assertEquals(ss[i],pyramid.getScale(i),1e-8); if( i > 1) assertTrue(Math.abs(ss[i] - ((PyramidFloatGaussianScale)pyramid).getSigmaLayers()[i])>0.1); } }",
        "prediction": "@Test public void scaleSpace() { double ss[] = new double[]{1,2,4,6,8,10}; PyramidFloat<ImageFloat32> pyramid = FactoryPyramid.scaleSpacePyramid(ss, ImageFloat32.class); for( int i = 0; i < ss.length; i++ ) { assertEquals(ss[i], pyramid.getSigma(i),1e-8); assertEquals(ss[i], pyramid.getScale(i),1e-8); if( i > 1) assertTrue(Math.abs(ss[i] - ((PyramidFloatGaussianScale)pyramid).getSigmaLayers()[i",
        "reference": "@Test public void scaleSpace() { double ss[] = new double[]{1,2,4,6,8,10}; PyramidFloat<GrayF32> pyramid = FactoryPyramid.scaleSpacePyramid(ss, GrayF32.class); for( int i = 0; i < ss.length; i++ ) { assertEquals(ss[i],pyramid.getSigma(i),1e-8); assertEquals(ss[i],pyramid.getScale(i),1e-8); if( i > 1) assertTrue(Math.abs(ss[i] - ((PyramidFloatGaussianScale)pyramid).getSigmaLayers()[i])>0.1); } }"
    },
    {
        "id": 82,
        "original": "@Test public void copyTest() throws IOException, StoreException { storeCopier.copy(new StoreFindTokenFactory(STORE_KEY_FACTORY).getNewFindToken()); storeCopier.close(); StoreMetrics storeMetrics = new StoreMetrics(new MetricRegistry()); Files.copy(new File(srcDir, StoreDescriptor.STORE_DESCRIPTOR_FILENAME).toPath(), new File(tgtDir, StoreDescriptor.STORE_DESCRIPTOR_FILENAME).toPath(), StandardCopyOption.REPLACE_EXISTING); BlobStore tgt = new BlobStore(STORE_ID, storeConfig, null, null, DISK_IO_SCHEDULER, StoreTestUtils.DEFAULT_DISK_SPACE_ALLOCATOR, storeMetrics, storeMetrics, tgtDir.getAbsolutePath(), STORE_CAPACITY, STORE_KEY_FACTORY, null, null, time); tgt.start(); try { StoreKey[] failKeys = {expiredId, deletedId}; for (StoreKey key : failKeys) { try { tgt.get(Collections.singletonList(key), EnumSet.allOf(StoreGetOptions.class)); fail(\"Should have failed to get \" + key); } catch (StoreException e) { assertEquals(\"Unexpected StoreErrorCode\", StoreErrorCodes.ID_Not_Found, e.getErrorCode()); } } StoreInfo storeInfo = tgt.get(Collections.singletonList(putId), EnumSet.noneOf(StoreGetOptions.class)); MessageInfo messageInfo = storeInfo.getMessageReadSetInfo().get(0); assertEquals(\"Size does not match\", putData.length, messageInfo.getSize()); assertEquals(\"Size does not match\", putData.length, storeInfo.getMessageReadSet().sizeInBytes(0)); assertFalse(\"Should not be deleted or expired\", messageInfo.isDeleted() || messageInfo.isExpired()); ByteBufferChannel channel = new ByteBufferChannel(ByteBuffer.allocate(putData.length)); storeInfo.getMessageReadSet().writeTo(0, channel, 0, putData.length); assertArrayEquals(\"Data put does not match data copied\", putData, channel.getBuffer().array()); } finally { tgt.shutdown(); } }",
        "prediction": "@Test public void copyTest()throws Exception { storeCopier.copy(new StoreFindTokenFactory(STORE_KEY_FACTORY).getNewFindToken()); storeCopier.close(); StoreMetrics storeMetrics = new StoreMetrics(new MetricRegistry()); Files.copy(new File(srcDir, StoreDescriptor.STORE_DESCRIPTOR_FILENAME).toPath(), new File(tgtDir, StoreDescriptor.STORE_DESCRIPTOR_FILENAME).toPath(), StandardCopyOption.REPLACE_EXISTING); BlobStore tgt = new BlobStore(STORE_ID, storeConfig, null, null, DISK_IO_SCHEDULER, StoreTestUtils.DEFAULT_DISK_SPACE_ALLOC",
        "reference": "@Test public void copyTest() throws Exception { storeCopier.copy(new StoreFindTokenFactory(STORE_KEY_FACTORY).getNewFindToken()); storeCopier.close(); StoreMetrics storeMetrics = new StoreMetrics(new MetricRegistry()); Files.copy(new File(srcDir, StoreDescriptor.STORE_DESCRIPTOR_FILENAME).toPath(), new File(tgtDir, StoreDescriptor.STORE_DESCRIPTOR_FILENAME).toPath(), StandardCopyOption.REPLACE_EXISTING); BlobStore tgt = new BlobStore(STORE_ID, storeConfig, null, null, DISK_IO_SCHEDULER, StoreTestUtils.DEFAULT_DISK_SPACE_ALLOCATOR, storeMetrics, storeMetrics, tgtDir.getAbsolutePath(), STORE_CAPACITY, STORE_KEY_FACTORY, null, null, time); tgt.start(); try { StoreKey[] failKeys = {expiredId, deletedId}; for (StoreKey key : failKeys) { try { tgt.get(Collections.singletonList(key), EnumSet.allOf(StoreGetOptions.class)); fail(\"Should have failed to get \" + key); } catch (StoreException e) { assertEquals(\"Unexpected StoreErrorCode\", StoreErrorCodes.ID_Not_Found, e.getErrorCode()); } } StoreInfo storeInfo = tgt.get(Collections.singletonList(putId), EnumSet.noneOf(StoreGetOptions.class)); MessageInfo messageInfo = storeInfo.getMessageReadSetInfo().get(0); assertEquals(\"Size does not match\", putData.length, messageInfo.getSize()); assertEquals(\"Size does not match\", putData.length, storeInfo.getMessageReadSet().sizeInBytes(0)); assertFalse(\"Should not be deleted or expired\", messageInfo.isDeleted() || messageInfo.isExpired()); ByteBufferChannel channel = new ByteBufferChannel(ByteBuffer.allocate(putData.length)); storeInfo.getMessageReadSet().writeTo(0, channel, 0, putData.length); assertArrayEquals(\"Data put does not match data copied\", putData, channel.getBuffer().array()); } finally { tgt.shutdown(); } }"
    },
    {
        "id": 83,
        "original": "@Test public void testReplenishConnections() { connectionTracker = new ConnectionTracker(routerConfig.routerScalingUnitMaxConnectionsPerPortPlainText, routerConfig.routerScalingUnitMaxConnectionsPerPortSsl); int minActiveConnectionsCount = 0; int totalConnectionsCount = 0; int availableCount = 0; MockDataNodeId dataNodeId1 = new MockDataNodeId(\"host1\", Collections.singletonList(plainTextPort), Collections.emptyList(), \"DC1\"); MockDataNodeId dataNodeId2 = new MockDataNodeId(\"host2\", Arrays.asList(plainTextPort, sslPort), Collections.emptyList(), \"DC1\"); dataNodeId2.setSslEnabledDataCenters(Collections.singletonList(\"DC1\")); connectionTracker.setMinimumActiveConnectionsPercentage(dataNodeId1, 50); minActiveConnectionsCount += 50 * routerConfig.routerScalingUnitMaxConnectionsPerPortPlainText / 100; connectionTracker.setMinimumActiveConnectionsPercentage(dataNodeId2, 200); minActiveConnectionsCount += routerConfig.routerScalingUnitMaxConnectionsPerPortSsl; assertCounts(totalConnectionsCount, availableCount); connectionTracker.replenishConnections(this::mockNewConnection); totalConnectionsCount += minActiveConnectionsCount; assertCounts(totalConnectionsCount, availableCount); List<String> newConnections = getNewlyEstablishedConnections(); newConnections.forEach(connectionTracker::checkInConnection); availableCount += minActiveConnectionsCount; assertCounts(totalConnectionsCount, availableCount); Assert.assertTrue(connectionTracker.mayCreateNewConnection(\"host1\", plainTextPort, dataNodeId1)); Assert.assertFalse(connectionTracker.mayCreateNewConnection(\"host2\", sslPort, dataNodeId2)); newConnections.stream().limit(2).forEach(connectionTracker::removeConnection); totalConnectionsCount -= 2; availableCount -= 2; assertCounts(totalConnectionsCount, availableCount); connectionTracker.replenishConnections(this::mockNewConnection); totalConnectionsCount += 2; assertCounts(totalConnectionsCount, availableCount); newConnections = getNewlyEstablishedConnections(); newConnections.forEach(connectionTracker::checkInConnection); availableCount += 2; assertCounts(totalConnectionsCount, availableCount); String conn1 = connectionTracker.checkOutConnection(\"host1\", plainTextPort, dataNodeId1); Assert.assertNotNull(conn1); String conn2 = connectionTracker.checkOutConnection(\"host2\", sslPort, dataNodeId2); Assert.assertNotNull(conn2); availableCount -= 2; assertCounts(totalConnectionsCount, availableCount); connectionTracker.removeConnection(conn1); connectionTracker.checkInConnection(conn2); totalConnectionsCount -= 1; availableCount += 1; assertCounts(totalConnectionsCount, availableCount); connectionTracker.replenishConnections(this::mockNewConnection); totalConnectionsCount += 1; assertCounts(totalConnectionsCount, availableCount); }",
        "prediction": "@Test public void testReplenishConnections() { connectionTracker = new ConnectionTracker(routerConfig.routerScalingUnitMaxConnectionsPerPortPlainText, routerConfig.routerScalingUnitMaxConnectionsPerPortSsl); int minActiveConnectionsCount = 0; int totalConnectionsCount = 0; int availableCount = 0; MockDataNodeId dataNodeId1 = new MockDataNodeId(\"host1\", Collections.singletonList(plainTextPort), Collections.emptyList(), \"DC1\"); MockDataNodeId dataNodeId2 = new MockDataNodeId(\"host2\", Arrays.asList(plainTextPort, sslPort), Collections.emptyList(), \"DC1\"); dataNodeId2.setSslEnabledDataCenters(Collections.singletonList",
        "reference": "@Test public void testReplenishConnections() { connectionTracker = new ConnectionTracker(routerConfig.routerScalingUnitMaxConnectionsPerPortPlainText, routerConfig.routerScalingUnitMaxConnectionsPerPortSsl); int minActiveConnectionsCount = 0; int totalConnectionsCount = 0; int availableCount = 0; MockDataNodeId dataNodeId1 = new MockDataNodeId(\"host1\", Collections.singletonList(plainTextPort), Collections.emptyList(), \"DC1\"); MockDataNodeId dataNodeId2 = new MockDataNodeId(\"host2\", Arrays.asList(plainTextPort, sslPort), Collections.emptyList(), \"DC1\"); dataNodeId2.setSslEnabledDataCenters(Collections.singletonList(\"DC1\")); connectionTracker.setMinimumActiveConnectionsPercentage(dataNodeId1, 50); minActiveConnectionsCount += 50 * routerConfig.routerScalingUnitMaxConnectionsPerPortPlainText / 100; connectionTracker.setMinimumActiveConnectionsPercentage(dataNodeId2, 200); minActiveConnectionsCount += routerConfig.routerScalingUnitMaxConnectionsPerPortSsl; assertCounts(totalConnectionsCount, availableCount); connectionTracker.replenishConnections(this::mockNewConnection, Integer.MAX_VALUE); totalConnectionsCount += minActiveConnectionsCount; assertCounts(totalConnectionsCount, availableCount); List<String> newConnections = getNewlyEstablishedConnections(); newConnections.forEach(connectionTracker::checkInConnection); availableCount += minActiveConnectionsCount; assertCounts(totalConnectionsCount, availableCount); Assert.assertTrue(connectionTracker.mayCreateNewConnection(\"host1\", plainTextPort, dataNodeId1)); Assert.assertFalse(connectionTracker.mayCreateNewConnection(\"host2\", sslPort, dataNodeId2)); newConnections.stream().limit(2).forEach(connectionTracker::removeConnection); totalConnectionsCount -= 2; availableCount -= 2; assertCounts(totalConnectionsCount, availableCount); connectionTracker.replenishConnections(this::mockNewConnection, Integer.MAX_VALUE); totalConnectionsCount += 2; assertCounts(totalConnectionsCount, availableCount); newConnections = getNewlyEstablishedConnections(); newConnections.forEach(connectionTracker::checkInConnection); availableCount += 2; assertCounts(totalConnectionsCount, availableCount); String conn1 = connectionTracker.checkOutConnection(\"host1\", plainTextPort, dataNodeId1); Assert.assertNotNull(conn1); String conn2 = connectionTracker.checkOutConnection(\"host2\", sslPort, dataNodeId2); Assert.assertNotNull(conn2); availableCount -= 2; assertCounts(totalConnectionsCount, availableCount); connectionTracker.removeConnection(conn1); connectionTracker.checkInConnection(conn2); totalConnectionsCount -= 1; availableCount += 1; assertCounts(totalConnectionsCount, availableCount); connectionTracker.replenishConnections(this::mockNewConnection, Integer.MAX_VALUE); totalConnectionsCount += 1; assertCounts(totalConnectionsCount, availableCount); String connId; while ((connId = connectionTracker.checkOutConnection(\"host2\", sslPort, dataNodeId2)) != null) { connectionTracker.removeConnection(connId); } totalConnectionsCount -= 2; availableCount -= 2; assertCounts(totalConnectionsCount, availableCount); connectionTracker.replenishConnections(this::mockNewConnection, 1); totalConnectionsCount += 1; assertCounts(totalConnectionsCount, availableCount); connectionTracker.replenishConnections(this::mockNewConnection, 1); totalConnectionsCount += 1; assertCounts(totalConnectionsCount, availableCount); }"
    },
    {
        "id": 84,
        "original": "@Test public void testGetMuleHomeFile() { File muleHome = MuleContainerBootstrapUtils.getMuleHomeFile(); assertNotNull(muleHome.getAbsolutePath()); }",
        "prediction": "@Test public void testGetMuleHomeFile() { File muleHome = MuleContainerBootstrapUtils.getMuleHome(); assertNotNull(muleHome.getAbsolutePath()); }",
        "reference": "@Test public void testGetMuleHomeFile() { File muleHome = MuleContainerBootstrapUtils.getMuleHome(); assertNotNull(muleHome.getAbsolutePath()); }"
    },
    {
        "id": 85,
        "original": "@Test public void testSaveOrUpdateUserDetail() { ModelMap model = new ModelMap(); User currUser = getTestUser(); currUser.setUserName(\"new name\"); userController.saveOrUpdateUserDetail(currUser, model, currUser, null); userController.getUserDetail(getTestUser(), model, currUser.getUserId()); User user = (User) model.get(\"user\"); assertThat(user.getUserName(), is(\"new name\")); assertThat(user.getPassword(), is(currUser.getPassword())); User admin = getAdminUser(); User temp = new User(\"temp1\", \"temp1\", \"temp1\", \"temp@nhn.com\", Role.USER); userController.saveOrUpdateUserDetail(admin, model, temp, null); temp = new User(\"temp2\", \"temp2\", \"temp2\", \"temp@nhn.com\", Role.USER); userController.saveOrUpdateUserDetail(admin, model, temp, null); model.clear(); userController.saveOrUpdateUserDetail(currUser, model, currUser, \"temp1, temp2\"); userController.getUserDetail(getTestUser(), model, currUser.getUserId()); user = (User) model.get(\"user\"); assertThat(user.getFollowers().size(), is(2)); assertThat(user.getFollowers().get(0).getUserId(), is(\"temp1\")); }",
        "prediction": "@Test public void testSaveOrUpdateUserDetail() { ModelMap model = new ModelMap(); User currUser = getTestUser(); currUser.setUserName(\"new name\"); userController.saveUser(currUser, model, currUser, null); userController.getUserDetail(getTestUser(), model, currUser.getUserId()); User user = (User) model.get(\"user\"); assertThat(user.getUserName(), is(\"new name\")); assertThat(user.getPassword(), is(currUser.getPassword())); User admin = getAdminUser(); User temp = new User(\"temp1\", \"temp1\", \"temp1\", \"temp@nhn.com\", Role.USER",
        "reference": "@Test public void testSaveOrUpdateUserDetail() { ModelMap model = new ModelMap(); User currUser = getTestUser(); currUser.setUserName(\"new name\"); userController.saveUser(currUser, model, currUser); userController.getUserDetail(getTestUser(), model, currUser.getUserId()); User user = (User) model.get(\"user\"); assertThat(user.getUserName(), is(\"new name\")); assertThat(user.getPassword(), is(currUser.getPassword())); User admin = getAdminUser(); User temp = new User(\"temp1\", \"temp1\", \"temp1\", \"temp@nhn.com\", Role.USER); userController.saveUser(admin, model, temp); temp = new User(\"temp2\", \"temp2\", \"temp2\", \"temp@nhn.com\", Role.USER); userController.saveUser(admin, model, temp); model.clear(); currUser.setFollowersStr(\"temp1, temp2\"); userController.saveUser(currUser, model, currUser); userController.getUserDetail(getTestUser(), model, currUser.getUserId()); user = (User) model.get(\"user\"); assertThat(user.getFollowers().size(), is(2)); assertThat(user.getFollowers().get(0).getUserId(), is(\"temp1\")); }"
    },
    {
        "id": 86,
        "original": "@Test public void testBoolean() { Buffer buffer = new FixedBuffer(16); buffer.put(true); buffer.put(false); Buffer read = new FixedBuffer(buffer.getBuffer()); boolean b = read.readBoolean(); Assert.assertEquals(true, b); boolean c = read.readBoolean(); Assert.assertEquals(false, c); }",
        "prediction": "@Test public void testBoolean() { Buffer buffer = new FixedBuffer(16); buffer.put(true); buffer.put(false); Buffer read = new FixedBuffer(buffer.getBuffer()); boolean b = read.readBoolean(); Assert.assertEquals(true, b); boolean c = read.readBoolean(); Assert.assertEquals(false, c); }",
        "reference": "@Test public void testBoolean() { Buffer buffer = new FixedBuffer(16); buffer.putBoolean(true); buffer.putBoolean(false); Buffer read = new FixedBuffer(buffer.getBuffer()); boolean b = read.readBoolean(); Assert.assertEquals(true, b); boolean c = read.readBoolean(); Assert.assertEquals(false, c); }"
    },
    {
        "id": 87,
        "original": "@Test @Verifies(value = \"set this care setting to new order\", method = \"cloneForDiscontinuing(Order)\") public void cloneForDiscontinuing_shouldSetThisCareSettingToNewOrder() { Order anOrder = new Order(); CareSetting careSetting = new CareSetting(); anOrder.setCareSetting(careSetting); Order orderThatCanDiscontinueTheOrder = anOrder.cloneForDiscontinuing(); assertEquals(anOrder.getCareSetting(), orderThatCanDiscontinueTheOrder.getCareSetting()); }",
        "prediction": "@Test public void cloneForDiscontinuing_shouldSetThisCareSettingToNewOrder()throws IllegalAccessException, InstantiationException { Order anOrder = new Order(); CareSetting careSetting = new CareSetting(); anOrder.setCareSetting(careSetting); anOrder.setConcept(careSetting); Order orderThatCanDiscontinueTheOrder = anOrder.cloneForDiscontinuing(); assertEquals(anOrder.getConcept(), orderThatCanDiscontinueTheOrder.getConcept()); assertEquals(anOrder.getConcept(), orderThatCanDiscontinueTheOrder.getConcept()); }",
        "reference": "@Test @Verifies(value = \"set this care setting to new order\", method = \"cloneForDiscontinuing(Order)\") public void cloneForDiscontinuing_shouldSetThisCareSettingToNewOrder() throws Exception { Order anOrder = new Order(); CareSetting careSetting = new CareSetting(); anOrder.setCareSetting(careSetting); Order orderThatCanDiscontinueTheOrder = anOrder.cloneForDiscontinuing(); assertEquals(anOrder.getCareSetting(), orderThatCanDiscontinueTheOrder.getCareSetting()); }"
    },
    {
        "id": 88,
        "original": "@Test public void getConstructorTest() { JavaAttributeInfo testAttr = getTestAttribute(); String method = getConstructor(CLASS_NAME, testAttr, GENERATE_SERVICE_AND_MANAGER); assertThat(true, is(method.contains(THIS + PERIOD + CLASS_NAME + SPACE + EQUAL + SPACE + \"builder\" + OBJECT + PERIOD + GET_METHOD_PREFIX + \"Testname\" + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN))); }",
        "prediction": "@Test public void getConstructorTest() { JavaAttributeInfo testAttr = getTestAttribute(); String method = getConstructor(CLASS_NAME, testAttr, GENERATE_SERVICE_AND_MANAGER, YangPluginConfig.getConflictResolver()); assertThat(true, is(method.contains(THIS + PERIOD + CLASS_NAME + SPACE + EQUAL + SPACE + \"builder\" + OBJECT + PERIOD + GET_METHOD_PREFIX + \"Testname\" + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN))); }",
        "reference": "@Test public void getConstructorTest() { JavaAttributeInfo testAttr = getTestAttribute(); YangPluginConfig pluginConfig = new YangPluginConfig(); String method = getConstructor(CLASS_NAME, testAttr, GENERATE_SERVICE_AND_MANAGER, pluginConfig); assertThat(true, is(method.contains(THIS + PERIOD + CLASS_NAME + SPACE + EQUAL + SPACE + \"builder\" + OBJECT + PERIOD + GET_METHOD_PREFIX + \"Testname\" + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN))); }"
    },
    {
        "id": 89,
        "original": "@Test public void testGetTunnelInfos() { testAddTunnelInfo(); Map<TunnelId, PceccTunnelInfo> tunnelInfoMap = distrPceStore.getTunnelInfos(); assertThat(tunnelInfoMap, is(notNullValue())); assertThat(tunnelInfoMap.isEmpty(), is(false)); assertThat(tunnelInfoMap.size(), is(2)); }",
        "prediction": "@Test public void testGetTunnelInfos() { testAddTunnelInfo(); Map<TunnelId, ResourceConsumer> tunnelInfoMap = distrPceStore.getTunnelInfos(); assertThat(tunnelInfoMap, is(notNullValue())); assertThat(tunnelInfoMap.isEmpty(), is(false)); assertThat(tunnelInfoMap.size(), is(2)); }",
        "reference": "@Test public void testGetTunnelInfos() { testAddTunnelInfo(); Map<TunnelId, ResourceConsumer> tunnelInfoMap = distrPceStore.getTunnelInfos(); assertThat(tunnelInfoMap, is(notNullValue())); assertThat(tunnelInfoMap.isEmpty(), is(false)); assertThat(tunnelInfoMap.size(), is(2)); }"
    },
    {
        "id": 90,
        "original": "@Test public void testGetTunnelInfo() { testAddTunnelInfo(); assertThat(tunnelId1, is(notNullValue())); assertThat(distrPceStore.getTunnelInfo(tunnelId1), is(pceccTunnelInfo1)); assertThat(tunnelId2, is(notNullValue())); assertThat(distrPceStore.getTunnelInfo(tunnelId2), is(pceccTunnelInfo2)); }",
        "prediction": "@Test public void testGetTunnelInfo() { testAddTunnelInfo(); assertThat(tunnelId1, is(notNullValue())); assertThat(distrPceStore.getTunnelInfo(tunnelId1), is(pceccTunnelInfo1)); assertThat(tunnelId2, is(notNullValue())); assertThat(distrPceStore.getTunnelInfo(tunnelId2), is(resourceConsumerTunnelInfo2)); }",
        "reference": "@Test public void testGetTunnelInfo() { testAddTunnelInfo(); assertThat(tunnelId1, is(notNullValue())); assertThat(distrPceStore.getTunnelInfo(tunnelId1), is(tunnelConsumerId1)); assertThat(tunnelId2, is(notNullValue())); assertThat(distrPceStore.getTunnelInfo(tunnelId2), is(tunnelConsumerId2)); }"
    },
    {
        "id": 91,
        "original": "@Test public void testAddTunnelInfo() { distrPceStore.storageService = new TestStorageService(); distrPceStore.activate(); distrPceStore.addTunnelInfo(tunnelId1, pceccTunnelInfo1); assertThat(distrPceStore.existsTunnelInfo(tunnelId1), is(true)); assertThat(distrPceStore.getTunnelInfo(tunnelId1), is(pceccTunnelInfo1)); distrPceStore.addTunnelInfo(tunnelId2, pceccTunnelInfo2); assertThat(distrPceStore.existsTunnelInfo(tunnelId2), is(true)); assertThat(distrPceStore.getTunnelInfo(tunnelId2), is(pceccTunnelInfo2)); }",
        "prediction": "@Test public void testAddTunnelInfo() { distrPceStore.storageService = new TestStorageService(); distrPceStore.activate(); distrPceStore.addTunnelInfo(tunnelId1, tunnelConsumerId1); assertThat(distrPceStore.existsTunnelInfo(tunnelId1), is(true)); assertThat(distrPceStore.getTunnelInfo(tunnelId1), is(tunnelConsumerId1)); distrPceStore.addTunnelInfo(tunnelId2, tunnelConsumerId2); assertThat(distrPceStore.existsTunnelInfo(tunnelId2), is(true)); assertThat(distrPceStore.getTunnelInfo",
        "reference": "@Test public void testAddTunnelInfo() { distrPceStore.storageService = new TestStorageService(); distrPceStore.activate(); distrPceStore.addTunnelInfo(tunnelId1, tunnelConsumerId1); assertThat(distrPceStore.existsTunnelInfo(tunnelId1), is(true)); assertThat(distrPceStore.getTunnelInfo(tunnelId1), is(tunnelConsumerId1)); distrPceStore.addTunnelInfo(tunnelId2, tunnelConsumerId2); assertThat(distrPceStore.existsTunnelInfo(tunnelId2), is(true)); assertThat(distrPceStore.getTunnelInfo(tunnelId2), is(tunnelConsumerId2)); }"
    },
    {
        "id": 92,
        "original": "@Test public void testBuildNdpSolicit() throws Exception { Ethernet ethPacket = NeighborSolicitation.buildNdpSolicit(TARGET_IP.toOctets(), SRC_IP.toOctets(), DST_IP.toOctets(), SRC_MAC.toBytes(), DST_MAC.toBytes(), VLAN_ID); IPv6 ipPacket = (IPv6) ethPacket.getPayload(); ICMP6 icmp6Packet = (ICMP6) ipPacket.getPayload(); NeighborSolicitation nsPacket = (NeighborSolicitation) icmp6Packet.getPayload(); assertEquals(\"Non-DAD NS should have 1 option\", 1, nsPacket.getOptions().size()); assertEquals(\"The option should be SRC_LL_ADDR type\", TYPE_SOURCE_LL_ADDRESS, nsPacket.getOptions().stream().findFirst().get().type()); }",
        "prediction": "@Test public void testBuildNdpSolicit()throws Exception { Ethernet ethPacket = NeighborSolicitation.buildNdpSolicit(TARGET_IP.toOctets(), SRC_IP.toOctets(), DST_IP.toOctets(), SRC_MAC.toBytes(), DST_MAC.toBytes(), VLAN_ID); IPv6 ipPacket = (IPv6) ethPacket.getPayload(); ICMP6 icmp6Packet = (ICMP6) ipPacket.getPayload(); NeighborSolicitation nsPacket = (NeighborSolicitation) icmp6Packet.getPayload(); assertEquals(\"Non-DAD NS should have 1 option\",",
        "reference": "@Test public void testBuildNdpSolicit() throws Exception { final Ethernet ethPacket = NeighborSolicitation.buildNdpSolicit(TARGET_IP, SRC_IP, DST_IP, SRC_MAC, DST_MAC, VLAN_ID); assertTrue(ethPacket.getDestinationMAC().equals(DST_MAC)); assertTrue(ethPacket.getSourceMAC().equals(SRC_MAC)); assertTrue(ethPacket.getEtherType() == Ethernet.TYPE_IPV6); assertTrue(ethPacket.getVlanID() == VLAN_ID.id()); final IPv6 ipPacket = (IPv6) ethPacket.getPayload(); assertArrayEquals(ipPacket.getSourceAddress(), SRC_IP.toOctets()); assertArrayEquals(ipPacket.getDestinationAddress(), DST_IP.toOctets()); final ICMP6 icmp6Packet = (ICMP6) ipPacket.getPayload(); final NeighborSolicitation nsPacket = (NeighborSolicitation) icmp6Packet.getPayload(); assertArrayEquals(nsPacket.getTargetAddress(), TARGET_IP.toOctets()); assertEquals(\"Non-DAD NS should have 1 option\", 1, nsPacket.getOptions().size()); assertEquals(\"The option should be SRC_LL_ADDR type\", TYPE_SOURCE_LL_ADDRESS, nsPacket.getOptions().stream().findFirst().get().type()); }"
    },
    {
        "id": 93,
        "original": "@Test public void testBuildNdpSolicitDad() throws Exception { Ethernet ethPacket = NeighborSolicitation.buildNdpSolicit(TARGET_IP.toOctets(), Ip6Address.ZERO.toOctets(), DST_IP.toOctets(), SRC_MAC.toBytes(), DST_MAC.toBytes(), VLAN_ID); IPv6 ipPacket = (IPv6) ethPacket.getPayload(); ICMP6 icmp6Packet = (ICMP6) ipPacket.getPayload(); NeighborSolicitation nsPacket = (NeighborSolicitation) icmp6Packet.getPayload(); assertEquals(\"DAD NS should have no option\", 0, nsPacket.getOptions().size()); }",
        "prediction": "@Test public void testBuildNdpSolicitDad()throws Exception { Ethernet ethPacket = NeighborSolicitation.buildNdpSolicit(TARGET_IP.toOctets(), Ip6Address.ZERO.toOctets(), DST_IP.toOctets(), SRC_MAC.toBytes(), DST_MAC.toBytes(), VLAN_ID); IPv6 ipPacket = (IPv6) ethPacket.getPayload(); ICMP6 icmp6Packet = (ICMP6) ipPacket.getPayload(); NeighborSolicitation nsPacket = (NeighborSolicitation) icmp6Packet.getPayload(); assertEquals(\"DAD NS should have no option",
        "reference": "@Test public void testBuildNdpSolicitDad() throws Exception { Ethernet ethPacket = NeighborSolicitation.buildNdpSolicit(TARGET_IP, Ip6Address.ZERO, DST_IP, SRC_MAC, DST_MAC, VLAN_ID); IPv6 ipPacket = (IPv6) ethPacket.getPayload(); ICMP6 icmp6Packet = (ICMP6) ipPacket.getPayload(); NeighborSolicitation nsPacket = (NeighborSolicitation) icmp6Packet.getPayload(); assertEquals(\"DAD NS should have no option\", 0, nsPacket.getOptions().size()); }"
    },
    {
        "id": 94,
        "original": "@Test public void getRootPackageTest() { conflictResolver.setPrefixForIdentifier(null); String rootPackage = getRootPackage((byte) 1, CHILD_PACKAGE, DATE1, conflictResolver); assertThat(rootPackage.equals(DEFAULT_BASE_PKG + PERIOD + VERSION_NUMBER + PERIOD + CHILD_WITH_PERIOD + PERIOD + DATE_WITH_REV1), is(true)); }",
        "prediction": "@Test public void getRootPackageTest() { conflictResolver.setPrefixForIdentifier(null); String rootPackage = getRootPackage((byte) 1, CHILD_PACKAGE, DATE1, conflictResolver); assertThat(rootPackage.equals(DEFAULT_BASE_PKG + PERIOD + VERSION_NUMBER + PERIOD + CHILD_WITH_PERIOD + PERIOD + DATE_WITH_REV1), is(true)); }",
        "reference": "@Test public void getRootPackageTest() throws ParseException { conflictResolver.setPrefixForIdentifier(null); Date date = simpleDateFormat.parse(DATE1); String rootPackage = getRootPackage((byte) 1, CHILD_PACKAGE, date, conflictResolver); assertThat(rootPackage.equals(DEFAULT_BASE_PKG + PERIOD + VERSION_NUMBER + PERIOD + CHILD_WITH_PERIOD + PERIOD + DATE_WITH_REV1), is(true)); }"
    },
    {
        "id": 95,
        "original": "@Test public void getRootPackageWithRevTest() { String rootPkgWithRev = getRootPackage((byte) 1, CHILD_PACKAGE, DATE2, null); assertThat(rootPkgWithRev.equals( DEFAULT_BASE_PKG + PERIOD + VERSION_NUMBER + PERIOD + CHILD_WITH_PERIOD + PERIOD + DATE_WITH_REV2), is(true)); }",
        "prediction": "@Test public void getRootPackageWithRevTest() { String rootPkgWithRev = getRootPackage((byte) 1, CHILD_PACKAGE, DATE2, null); assertThat(rootPkgWithRev.equals( DEFAULT_BASE_PKG + PERIOD + VERSION_NUMBER + PERIOD + CHILD_WITH_PERIOD + PERIOD + DATE_WITH_REV2), is(true)); }",
        "reference": "@Test public void getRootPackageWithRevTest() throws ParseException { Date date = simpleDateFormat.parse(DATE2); String rootPkgWithRev = getRootPackage((byte) 1, CHILD_PACKAGE, date, null); assertThat(rootPkgWithRev.equals( DEFAULT_BASE_PKG + PERIOD + VERSION_NUMBER + PERIOD + CHILD_WITH_PERIOD + PERIOD + DATE_WITH_REV2), is(true)); }"
    },
    {
        "id": 96,
        "original": "@Test public void addPackageInfoTest() throws IOException { File dirPath = new File(CREATE_PATH); dirPath.mkdirs(); addPackageInfo(dirPath, CHECK1, CREATE_PATH, false); File filePath = new File(dirPath + File.separator + PKG_INFO); assertThat(filePath.isFile(), is(true)); }",
        "prediction": "@Test public void addPackageInfoTest()throws IOException { File dirPath = new File(CREATE_PATH); dirPath.mkdirs(); addPackageInfo(dirPath, CHECK1, CREATE_PATH, false, null); File filePath = new File(dirPath + File.separator + PKG_INFO); assertThat(filePath.isFile(), is(true)); }",
        "reference": "@Test public void addPackageInfoTest() throws IOException { File dirPath = new File(CREATE_PATH); dirPath.mkdirs(); addPackageInfo(dirPath, CHECK1, CREATE_PATH, false, getStubPluginConfig()); File filePath = new File(dirPath + File.separator + PKG_INFO); assertThat(filePath.isFile(), is(true)); }"
    },
    {
        "id": 97,
        "original": "@Test public void addPackageInfoTest() throws IOException { File dirPath = new File(CREATE_PATH); dirPath.mkdirs(); addPackageInfo(dirPath, \"check1\", CREATE_PATH); File filePath = new File(dirPath + File.separator + \"package-info.java\"); assertThat(filePath.isFile(), is(true)); }",
        "prediction": "@Test public void addPackageInfoTest()throws IOException { File dirPath = new File(CREATE_PATH); dirPath.mkdirs(); addPackageInfo(dirPath, \"check1\", CREATE_PATH, false); File filePath = new File(dirPath + File.separator + \"package-info.java\"); assertThat(filePath.isFile(), is(true)); }",
        "reference": "@Test public void addPackageInfoTest() throws IOException { File dirPath = new File(CREATE_PATH); dirPath.mkdirs(); addPackageInfo(dirPath, CHECK1, CREATE_PATH, false); File filePath = new File(dirPath + File.separator + PKG_INFO); assertThat(filePath.isFile(), is(true)); }"
    },
    {
        "id": 98,
        "original": "@Test public void testSetExcludePorts() throws Exception { ImmutableSet.Builder<String> builder = ImmutableSet.builder(); builder.add(PORT_NAME_3); config.setExcludePorts(builder.build()); Set<String> excludePorts = config.excludePorts(); assertThat(excludePorts.size(), is(1)); assertTrue(excludePorts.contains(PORT_NAME_3)); }",
        "prediction": "@Test public void testSetSuppressHost()throws Exception { Set<ConnectPoint> suppressHost = ImmutableSet.builder(); suppressHost.add(PORT_NAME_3); config.setSuppressHost(suppressHost); Set < String > excludePorts = config.excludePorts(); assertThat(excludePorts.size(), is(1)); assertTrue(excludePorts.contains(PORT_NAME_3)); }",
        "reference": "@Test public void testSetSuppressHost() throws Exception { ImmutableSet.Builder<ConnectPoint> builder = ImmutableSet.builder(); builder.add(PORT_3); config.setSuppressHost(builder.build()); Set<ConnectPoint> suppressHost = config.suppressHost(); assertNotNull(\"suppressHost should not be null\", suppressHost); assertThat(suppressHost.size(), is(1)); assertTrue(suppressHost.contains(PORT_3)); }"
    },
    {
        "id": 99,
        "original": "@Test public void setSelectedDatabaseConnection() { AbstractSqoopJobEntryController controller = new TestSqoopJobEntryController(); String database = \"testing\"; controller.setSelectedDatabaseConnection(database); assertNull(\"Setting a database to one that doesn't exist in the JobMeta should not work\", controller.getConfig().getDatabase()); controller.getJobMeta().addDatabase(new DatabaseMeta(database, \"MYSQL\", null, null, null, null, null, null)); controller.setSelectedDatabaseConnection(database); assertEquals(database, controller.getConfig().getDatabase()); }",
        "prediction": "@Test public void setSelectedDatabaseConnection() { AbstractSqoopJobEntryController controller = new TestSqoopJobEntryController(); String database = \"testing\"; controller.setSelectedDatabaseConnection(database); assertNull(\"Setting a database to one that doesn\\'t exist in the JobMeta should not work\", controller.getConfig().getDatabase()); controller.getJobMeta().addDatabase(new DatabaseMeta(database, \"MYSQL\", null, null, null, null, null)); controller.setSelectedDatabaseConnection(database); assertEquals(database, controller.getConfig().getDatabase()); assertEquals(database, controller.getConfig().getDatabase()); assertEquals(database, controller.getConfig().getDatabase",
        "reference": "@Test public void setSelectedDatabaseConnection() throws KettleDatabaseException { AbstractSqoopJobEntryController controller = new TestSqoopJobEntryController(); String connect = \"jdbc:bogus://bogus\"; String username = \"username\"; String password = \"password\"; controller.getConfig().setConnect(connect); controller.getConfig().setUsername(username); controller.getConfig().setPassword(password); String connectAdvanced = \"jdbc:advanced://bogus\"; String usernameAdvanced = \"advanced_user\"; String passwordAdvanced = \"super password!\"; controller.getConfig().setConnectFromAdvanced(connectAdvanced); controller.getConfig().setUsernameFromAdvanced(usernameAdvanced); controller.getConfig().setPasswordFromAdvanced(passwordAdvanced); DatabaseItem test = new DatabaseItem(\"test\"); DatabaseMeta database = new DatabaseMeta(test.getName(), \"MYSQL\", null, null, null, null, null, null); controller.getJobMeta().addDatabase(database); controller.setSelectedDatabaseConnection(test); assertEquals(test, controller.getSelectedDatabaseConnection()); assertEquals(test.getName(), controller.getConfig().getDatabase()); assertEquals(database.getURL(), controller.getConfig().getConnect()); assertEquals(database.getUsername(), controller.getConfig().getUsername()); assertEquals(database.getPassword(), controller.getConfig().getPassword()); assertEquals(connectAdvanced, controller.getConfig().getConnectFromAdvanced()); assertEquals(usernameAdvanced, controller.getConfig().getUsernameFromAdvanced()); assertEquals(passwordAdvanced, controller.getConfig().getPasswordFromAdvanced()); controller.setSelectedDatabaseConnection(controller.USE_ADVANCED_OPTIONS); assertEquals(controller.USE_ADVANCED_OPTIONS, controller.getSelectedDatabaseConnection()); assertNull(controller.getConfig().getDatabase()); assertEquals(connectAdvanced, controller.getConfig().getConnect()); assertEquals(usernameAdvanced, controller.getConfig().getUsername()); assertEquals(passwordAdvanced, controller.getConfig().getPassword()); assertEquals(connectAdvanced, controller.getConfig().getConnectFromAdvanced()); assertEquals(usernameAdvanced, controller.getConfig().getUsernameFromAdvanced()); assertEquals(passwordAdvanced, controller.getConfig().getPasswordFromAdvanced()); controller.setSelectedDatabaseConnection(test); assertEquals(test, controller.getSelectedDatabaseConnection()); assertEquals(test.getName(), controller.getConfig().getDatabase()); assertEquals(database.getURL(), controller.getConfig().getConnect()); assertEquals(database.getUsername(), controller.getConfig().getUsername()); assertEquals(database.getPassword(), controller.getConfig().getPassword()); assertEquals(connectAdvanced, controller.getConfig().getConnectFromAdvanced()); assertEquals(usernameAdvanced, controller.getConfig().getUsernameFromAdvanced()); assertEquals(passwordAdvanced, controller.getConfig().getPasswordFromAdvanced()); }"
    },
    {
        "id": 100,
        "original": "@Test public void testConcat() throws Exception { final String context = \"Concat\"; try (Storage s = createStorage()) { s.initialize(0); HashMap<String, ByteArrayOutputStream> appendData = populate(s, context); val firstSegmentName = getSegmentName(0, context); val firstSegmentHandle = s.openWrite(firstSegmentName).join(); AtomicLong firstSegmentLength = new AtomicLong(s.getStreamSegmentInfo(firstSegmentName, TIMEOUT).join().getLength()); assertThrows(\"concat() did not throw for non-existent target segment name.\", () -> s.concat(createHandle(\"foo1\", false), 0, firstSegmentHandle, TIMEOUT), ex -> ex instanceof StreamSegmentNotExistsException); assertThrows(\"concat() did not throw for invalid source StreamSegment name.\", () -> s.concat(firstSegmentHandle, firstSegmentLength.get(), createHandle(\"foo2\", false), TIMEOUT), ex -> ex instanceof StreamSegmentNotExistsException); ArrayList<String> concatOrder = new ArrayList<>(); concatOrder.add(firstSegmentName); for (String sourceSegment : appendData.keySet()) { if (sourceSegment.equals(firstSegmentName)) { continue; } val sourceWriteHandle = s.openWrite(sourceSegment).join(); assertThrows(\"Concat allowed when source segment is not sealed.\", () -> s.concat(firstSegmentHandle, firstSegmentLength.get(), sourceWriteHandle, TIMEOUT), ex -> ex instanceof IllegalStateException); s.seal(sourceWriteHandle, TIMEOUT).join(); SegmentProperties preConcatTargetProps = s.getStreamSegmentInfo(firstSegmentName, TIMEOUT).join(); SegmentProperties sourceProps = s.getStreamSegmentInfo(sourceSegment, TIMEOUT).join(); s.concat(firstSegmentHandle, firstSegmentLength.get(), sourceWriteHandle, TIMEOUT).join(); concatOrder.add(sourceSegment); SegmentProperties postConcatTargetProps = s.getStreamSegmentInfo(firstSegmentName, TIMEOUT).join(); Assert.assertFalse(\"concat() did not delete source segment\", s.exists(sourceSegment, TIMEOUT).join()); Assert.assertEquals(\"Unexpected target StreamSegment.length after concatenation.\", preConcatTargetProps.getLength() + sourceProps.getLength(), postConcatTargetProps.getLength()); firstSegmentLength.set(postConcatTargetProps.getLength()); } SegmentProperties segmentProperties = s.getStreamSegmentInfo(firstSegmentName, TIMEOUT).join(); byte[] readBuffer = new byte[(int) segmentProperties.getLength()]; int bytesRead = s.read(firstSegmentHandle, 0, readBuffer, 0, readBuffer.length, TIMEOUT).join(); Assert.assertEquals(\"Unexpected number of bytes read.\", readBuffer.length, bytesRead); int offset = 0; for (String segmentName : concatOrder) { byte[] concatData = appendData.get(segmentName).toByteArray(); AssertExtensions.assertArrayEquals(\"Unexpected concat data.\", concatData, 0, readBuffer, offset, concatData.length); offset += concatData.length; } Assert.assertEquals(\"Concat included more bytes than expected.\", offset, readBuffer.length); } }",
        "prediction": "@Test public void testConcat()throws Exception { final String context = \"Concat\"; try (Storage s = createStorage()) { s.initialize(0); HashMap<String, ByteArrayOutputStream> appendData = populate(s, context); val firstSegmentName = getSegmentName(0, context); val firstSegmentHandle = s.openWrite(firstSegmentName).join(); AtomicLong firstSegmentLength = new AtomicLong(s.getStreamSegmentInfo(firstSegmentName, TIMEOUT).join().getLength()); assertThrows(\"concat() did not throw for non-existent target segment name.\", () -> s.concat(createHandle(\"foo1\", false), 0, firstSegmentHandle, TIMEOUT), ex -> ex instanceof StreamSegment",
        "reference": "@Test public void testConcat() throws Exception { final String context = \"Concat\"; try (Storage s = createStorage()) { s.initialize(DEFAULT_EPOCH); HashMap<String, ByteArrayOutputStream> appendData = populate(s, context); val firstSegmentName = getSegmentName(0, context); val firstSegmentHandle = s.openWrite(firstSegmentName).join(); AtomicLong firstSegmentLength = new AtomicLong(s.getStreamSegmentInfo(firstSegmentName, TIMEOUT).join().getLength()); assertThrows(\"concat() did not throw for non-existent target segment name.\", () -> s.concat(createHandle(\"foo1\", false, DEFAULT_EPOCH), 0, firstSegmentName, TIMEOUT), ex -> ex instanceof StreamSegmentNotExistsException); assertThrows(\"concat() did not throw for invalid source StreamSegment name.\", () -> s.concat(firstSegmentHandle, firstSegmentLength.get(), \"foo2\", TIMEOUT), ex -> ex instanceof StreamSegmentNotExistsException); ArrayList<String> concatOrder = new ArrayList<>(); concatOrder.add(firstSegmentName); for (String sourceSegment : appendData.keySet()) { if (sourceSegment.equals(firstSegmentName)) { continue; } assertThrows(\"Concat allowed when source segment is not sealed.\", () -> s.concat(firstSegmentHandle, firstSegmentLength.get(), sourceSegment, TIMEOUT), ex -> ex instanceof IllegalStateException); val sourceWriteHandle = s.openWrite(sourceSegment).join(); s.seal(sourceWriteHandle, TIMEOUT).join(); SegmentProperties preConcatTargetProps = s.getStreamSegmentInfo(firstSegmentName, TIMEOUT).join(); SegmentProperties sourceProps = s.getStreamSegmentInfo(sourceSegment, TIMEOUT).join(); s.concat(firstSegmentHandle, firstSegmentLength.get(), sourceSegment, TIMEOUT).join(); concatOrder.add(sourceSegment); SegmentProperties postConcatTargetProps = s.getStreamSegmentInfo(firstSegmentName, TIMEOUT).join(); Assert.assertFalse(\"concat() did not delete source segment\", s.exists(sourceSegment, TIMEOUT).join()); Assert.assertEquals(\"Unexpected target StreamSegment.length after concatenation.\", preConcatTargetProps.getLength() + sourceProps.getLength(), postConcatTargetProps.getLength()); firstSegmentLength.set(postConcatTargetProps.getLength()); } SegmentProperties segmentProperties = s.getStreamSegmentInfo(firstSegmentName, TIMEOUT).join(); byte[] readBuffer = new byte[(int) segmentProperties.getLength()]; int bytesRead = s.read(firstSegmentHandle, 0, readBuffer, 0, readBuffer.length, TIMEOUT).join(); Assert.assertEquals(\"Unexpected number of bytes read.\", readBuffer.length, bytesRead); int offset = 0; for (String segmentName : concatOrder) { byte[] concatData = appendData.get(segmentName).toByteArray(); AssertExtensions.assertArrayEquals(\"Unexpected concat data.\", concatData, 0, readBuffer, offset, concatData.length); offset += concatData.length; } Assert.assertEquals(\"Concat included more bytes than expected.\", offset, readBuffer.length); } }"
    },
    {
        "id": 101,
        "original": "@Test public void testRemoveFinishedWrites() { final int timeIncrement = 1234 * 1000; AtomicLong time = new AtomicLong(); val q = new WriteQueue(MAX_PARALLELISM, time::get); val writes = new ArrayDeque<Write>(); for (int i = 0; i < ITEM_COUNT; i++) { time.addAndGet(timeIncrement); val w = new Write(new ByteArraySegment(new byte[i]), new TestWriteLedger(i), new CompletableFuture<>()); if (i % 2 == 0) { w.complete(new TestLogAddress(i)); } q.add(w); writes.addLast(w); } while (!writes.isEmpty()) { val write = writes.pollFirst(); if (!write.isDone()) { boolean result1 = q.removeFinishedWrites(); Assert.assertTrue(\"Unexpected value from removeFinishedWrites when there were writes left in the queue.\", result1); val stats1 = q.getStatistics(); Assert.assertEquals(\"Unexpected size after removeFinishedWrites with no effect.\", writes.size() + 1, stats1.getSize()); write.complete(new TestLogAddress(time.get())); } long expectedElapsed = write.getTimestamp(); int removed = 1; while (!writes.isEmpty() && writes.peekFirst().isDone()) { expectedElapsed += writes.pollFirst().getTimestamp(); removed++; } expectedElapsed = (time.get() * removed - expectedElapsed) / AbstractTimer.NANOS_TO_MILLIS / removed; boolean result2 = q.removeFinishedWrites(); Assert.assertEquals(\"Unexpected result from removeFinishedWrites.\", !writes.isEmpty(), result2); val stats2 = q.getStatistics(); Assert.assertEquals(\"Unexpected size after removeFinishedWrites.\", writes.size(), stats2.getSize()); Assert.assertEquals(\"Unexpected getExpectedProcessingTimeMillis after clear.\", expectedElapsed, stats2.getExpectedProcessingTimeMillis()); } }",
        "prediction": "@Test public void testRemoveFinishedWrites() { final int timeIncrement = 1234 * 1000; AtomicLong time = new AtomicLong(); val q = new WriteQueue(MAX_PARALLELISM, time::get); val writes = new ArrayDeque<Write>(); for (int i = 0; i < ITEM_COUNT; i++) { time.addAndGet(timeIncrement); val w = new Write(new ByteArraySegment(new byte[i]), new TestWriteLedger(i), new CompletableFuture<>()); if (i % 2 == 0) { w.complete(new TestLogAddress(i)); } q.add(w); writes.addLast(w); } while (!writes.isEmpty",
        "reference": "@Test public void testRemoveFinishedWrites() { final int timeIncrement = 1234 * 1000; AtomicLong time = new AtomicLong(); val q = new WriteQueue(MAX_PARALLELISM, time::get); val writes = new ArrayDeque<Write>(); for (int i = 0; i < ITEM_COUNT; i++) { time.addAndGet(timeIncrement); val w = new Write(new ByteArraySegment(new byte[i]), new TestWriteLedger(i), new CompletableFuture<>()); if (i % 2 == 0) { w.setEntryId(i); w.complete(); } q.add(w); writes.addLast(w); } while (!writes.isEmpty()) { val write = writes.pollFirst(); if (!write.isDone()) { val result1 = q.removeFinishedWrites(); AssertExtensions.assertContainsSameElements(\"Unexpected value from removeFinishedWrites when there were writes left in the queue.\", EnumSet.of(WriteQueue.CleanupStatus.QueueNotEmpty), result1); val stats1 = q.getStatistics(); Assert.assertEquals(\"Unexpected size after removeFinishedWrites with no effect.\", writes.size() + 1, stats1.getSize()); write.setEntryId(time.get()); write.complete(); } long expectedElapsed = write.getTimestamp(); int removed = 1; while (!writes.isEmpty() && writes.peekFirst().isDone()) { expectedElapsed += writes.pollFirst().getTimestamp(); removed++; } expectedElapsed = (time.get() * removed - expectedElapsed) / AbstractTimer.NANOS_TO_MILLIS / removed; val result2 = q.removeFinishedWrites(); val expectedResult = EnumSet.of(writes.isEmpty() ? WriteQueue.CleanupStatus.QueueEmpty : WriteQueue.CleanupStatus.QueueNotEmpty); AssertExtensions.assertContainsSameElements(\"Unexpected result from removeFinishedWrites.\", expectedResult, result2); val stats2 = q.getStatistics(); Assert.assertEquals(\"Unexpected size after removeFinishedWrites.\", writes.size(), stats2.getSize()); Assert.assertEquals(\"Unexpected getExpectedProcessingTimeMillis after clear.\", expectedElapsed, stats2.getExpectedProcessingTimeMillis()); } val w3 = new Write(new ByteArraySegment(new byte[1]), new TestWriteLedger(0), new CompletableFuture<>()); q.add(w3); w3.fail(new IntentionalException(), true); val result3 = q.removeFinishedWrites(); AssertExtensions.assertContainsSameElements(\"Unexpected value from removeFinishedWrites when there were failed writes.\", EnumSet.of(WriteQueue.CleanupStatus.QueueEmpty, WriteQueue.CleanupStatus.WriteFailed), result3); }"
    },
    {
        "id": 102,
        "original": "@Test public void createUserWithInvalidLoginName() { User user = UserData.randomUser(); UserDTO userDTO = BeanMapper.map(user, UserDTO.class); userDTO.setLoginName(null); IdResponse response = accountWebServiceClient.createUser(userDTO); assertEquals(WSResponse.PARAMETER_ERROR, response.getCode()); userDTO.setLoginName(\"user\"); response = accountWebServiceClient.createUser(userDTO); assertEquals(WSResponse.PARAMETER_ERROR, response.getCode()); }",
        "prediction": "@Test public void createUserWithInvalidLoginName() { User user = UserData.randomUser(); UserDTO userDTO = BeanMapper.map(user, UserDTO.class); userDTO.setLoginName(null); IdResult response = accountWebServiceClient.createUser(userDTO); assertEquals(WSResponse.PARAMETER_ERROR, response.getCode()); userDTO.setLoginName(\"user\"); response = accountWebServiceClient.createUser(userDTO); assertEquals(WSResponse.PARAMETER_ERROR, response.getCode()); userDTO.setLoginName(\"user\"); response = accountWebServiceClient.createUser(userDTO); assertEquals(WSResponse.PARAMETER_ERROR, response.getCode()); userDTO",
        "reference": "@Test public void createUserWithInvalidLoginName() { User user = UserData.randomUser(); UserDTO userDTO = BeanMapper.map(user, UserDTO.class); userDTO.setLoginName(null); IdResult response = accountWebServiceClient.createUser(userDTO); assertEquals(WSResult.PARAMETER_ERROR, response.getCode()); userDTO.setLoginName(\"user\"); response = accountWebServiceClient.createUser(userDTO); assertEquals(WSResult.PARAMETER_ERROR, response.getCode()); }"
    },
    {
        "id": 103,
        "original": "@Test @Category(Smoke.class) public void getUser() { GetUserResponse response = accountWebServiceClient.getUser(1L); assertEquals(\"admin\", response.getUser().getLoginName()); }",
        "prediction": "@Test public void getUser() { GetUserResult response = accountWebServiceClient.getUser(1L); assertEquals(\"admin\", response.getUser().getLoginName()); }",
        "reference": "@Test @Category(Smoke.class) public void getUser() { GetUserResult response = accountWebServiceClient.getUser(1L); assertEquals(\"admin\", response.getUser().getLoginName()); }"
    },
    {
        "id": 104,
        "original": "@Test public void changeReplicationFactor_missingExecutable(TestContext context) { MockAdminClient adminClient = new MockAdminClient(); Vertx vertx = Vertx.vertx(); Topic topic = new Topic.Builder(\"changeReplicationFactor\", 2, (short) 2, emptyMap()).build(); String[] partitions = new String[]{\"changeReplicationFactor-0\", \"changeReplicationFactor-1\"}; final String doesNotExist = \"/some/executable/that/does/not/exist\"; Subclass sub = new Subclass(adminClient, vertx, config, doesNotExist, asList( Subclass.generate(\"{\\\"version\\\":1,\\\"partitions\\\":[{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":0,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]},{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":1,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]}]}\", \"{\\\"version\\\":1,\\\"partitions\\\":[{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":0,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]},{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":1,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]}]}\"), Subclass.executeStarted(), Subclass.verifyInProgress(partitions), Subclass.verifySuccess(partitions))); Async async = context.async(); sub.changeReplicationFactor(topic, ar -> { context.assertFalse(ar.succeeded()); final String message = ar.cause().getMessage(); context.assertTrue(message.contains(\"lacks an executable arg[0]\") && message.contains(\"/some/executable/that/does/not/exist\")); async.complete(); }); }",
        "prediction": "@Test public void changeReplicationFactor_missingExecutable(TestContext context) { MockAdminClient adminClient = new MockAdminClient(); Vertx vertx = Vertx.vertx(); Topic topic = new Topic.Builder(\"changeReplicationFactor\", 2, (short) 2, emptyMap()).build(); String[] partitions = new String[]{\"changeReplicationFactor-0\", \"changeReplicationFactor-1\"}; final String doesNotExist = \"/some/executable/that/does/not/exist\"; Subclass sub = new Subclass(adminClient, vertx, config, doesNotExist, asList(Subclass.generate(\"{\\\\\"version\\\\\":1,\\\\\"partitions\\\\\":[{\\\\\"topic\\\\\":\\\\\"test",
        "reference": "@Test public void changeReplicationFactor_missingExecutable(TestContext context) { MockAdminClient adminClient = new MockAdminClient(); Vertx vertx = Vertx.vertx(); Topic topic = new Topic.Builder(\"changeReplicationFactor\", 2, (short) 2, emptyMap()).build(); String[] partitions = new String[]{\"changeReplicationFactor-0\", \"changeReplicationFactor-1\"}; final String doesNotExist = \"/some/executable/that/does/not/exist\"; Subclass sub = new Subclass(adminClient, vertx, config, doesNotExist, asList( Subclass.generate(\"{\\\\\"version\\\\\":1,\\\\\"partitions\\\\\":[{\\\\\"topic\\\\\":\\\\\"test-topic\\\\\",\\\\\"partition\\\\\":0,\\\\\"replicas\\\\\":[0],\\\\\"log_dirs\\\\\":[\\\\\"any\\\\\"]},{\\\\\"topic\\\\\":\\\\\"test-topic\\\\\",\\\\\"partition\\\\\":1,\\\\\"replicas\\\\\":[0],\\\\\"log_dirs\\\\\":[\\\\\"any\\\\\"]}]}\", \"{\\\\\"version\\\\\":1,\\\\\"partitions\\\\\":[{\\\\\"topic\\\\\":\\\\\"test-topic\\\\\",\\\\\"partition\\\\\":0,\\\\\"replicas\\\\\":[0],\\\\\"log_dirs\\\\\":[\\\\\"any\\\\\"]},{\\\\\"topic\\\\\":\\\\\"test-topic\\\\\",\\\\\"partition\\\\\":1,\\\\\"replicas\\\\\":[0],\\\\\"log_dirs\\\\\":[\\\\\"any\\\\\"]}]}\"), Subclass.executeStarted(), Subclass.verifyInProgress(partitions), Subclass.verifySuccess(partitions))); Async async = context.async(); sub.changeReplicationFactor(topic).setHandler(ar -> { context.assertFalse(ar.succeeded()); final String message = ar.cause().getMessage(); context.assertTrue(message.contains(\"lacks an executable arg[0]\") && message.contains(\"/some/executable/that/does/not/exist\")); async.complete(); }); }"
    },
    {
        "id": 105,
        "original": "@Test public void changeReplicationFactor(TestContext context) { MockAdminClient adminClient = new MockAdminClient(); Vertx vertx = Vertx.vertx(); Topic topic = new Topic.Builder(\"changeReplicationFactor\", 2, (short) 2, emptyMap()).build(); String[] partitions = new String[]{\"changeReplicationFactor-0\", \"changeReplicationFactor-1\"}; Subclass sub = new Subclass(adminClient, vertx, config, asList( Subclass.generate(\"{\\\"version\\\":1,\\\"partitions\\\":[{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":0,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]},{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":1,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]}]}\", \"{\\\"version\\\":1,\\\"partitions\\\":[{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":0,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]},{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":1,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]}]}\"), Subclass.executeStarted(), Subclass.verifyInProgress(partitions), Subclass.verifySuccess(partitions))); Async async = context.async(); sub.changeReplicationFactor(topic, ar -> { context.assertTrue(ar.succeeded()); async.complete(); }); }",
        "prediction": "@Test public void changeReplicationFactor(TestContext context) { MockAdminClient adminClient = new MockAdminClient(); Vertx vertx = Vertx.vertx(); Topic topic = new Topic.Builder(\"changeReplicationFactor\", 2, (short) 2, emptyMap()).build(); String[] partitions = new String[]{\"changeReplicationFactor-0\", \"changeReplicationFactor-1\"}; Subclass sub = new Subclass(adminClient, vertx, config, asList(Subclass.generate(\"{\\\\\"version\\\\\":1,\\\\\"partitions\\\\\":[{\\\\\"topic\\\\\":\\\\\"test-topic\\\\\",\\\\\"partition\\\\\":0,\\\\\"replicas\\\\\":[0],\\\\\"log_dirs\\\\\":",
        "reference": "@Test public void changeReplicationFactor(TestContext context) { MockAdminClient adminClient = new MockAdminClient(); Vertx vertx = Vertx.vertx(); Topic topic = new Topic.Builder(\"changeReplicationFactor\", 2, (short) 2, emptyMap()).build(); String[] partitions = new String[]{\"changeReplicationFactor-0\", \"changeReplicationFactor-1\"}; Subclass sub = new Subclass(adminClient, vertx, config, asList( Subclass.generate(\"{\\\\\"version\\\\\":1,\\\\\"partitions\\\\\":[{\\\\\"topic\\\\\":\\\\\"test-topic\\\\\",\\\\\"partition\\\\\":0,\\\\\"replicas\\\\\":[0],\\\\\"log_dirs\\\\\":[\\\\\"any\\\\\"]},{\\\\\"topic\\\\\":\\\\\"test-topic\\\\\",\\\\\"partition\\\\\":1,\\\\\"replicas\\\\\":[0],\\\\\"log_dirs\\\\\":[\\\\\"any\\\\\"]}]}\", \"{\\\\\"version\\\\\":1,\\\\\"partitions\\\\\":[{\\\\\"topic\\\\\":\\\\\"test-topic\\\\\",\\\\\"partition\\\\\":0,\\\\\"replicas\\\\\":[0],\\\\\"log_dirs\\\\\":[\\\\\"any\\\\\"]},{\\\\\"topic\\\\\":\\\\\"test-topic\\\\\",\\\\\"partition\\\\\":1,\\\\\"replicas\\\\\":[0],\\\\\"log_dirs\\\\\":[\\\\\"any\\\\\"]}]}\"), Subclass.executeStarted(), Subclass.verifyInProgress(partitions), Subclass.verifySuccess(partitions))); Async async = context.async(); sub.changeReplicationFactor(topic).setHandler(ar -> { context.assertTrue(ar.succeeded()); async.complete(); }); }"
    },
    {
        "id": 106,
        "original": "@Test public void changeReplicationFactor_ExecuteFail(TestContext context) { MockAdminClient adminClient = new MockAdminClient(); Vertx vertx = Vertx.vertx(); Topic topic = new Topic.Builder(\"changeReplicationFactor\", 2, (short) 2, emptyMap()).build(); String[] partitions = new String[]{\"changeReplicationFactor-0\", \"changeReplicationFactor-1\"}; Subclass sub = new Subclass(adminClient, vertx, config, asList( Subclass.generate(\"{\\\"version\\\":1,\\\"partitions\\\":[{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":0,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]},{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":1,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]}]}\", \"{\\\"version\\\":1,\\\"partitions\\\":[{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":0,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]},{\\\"topic\\\":\\\"test-topic\\\",\\\"partition\\\":1,\\\"replicas\\\":[0],\\\"log_dirs\\\":[\\\"any\\\"]}]}\"), Subclass.executeFail(\"Bang!\"), Subclass.executeStarted(), Subclass.verifyInProgress(partitions), Subclass.verifySuccess(partitions))); Async async = context.async(); sub.changeReplicationFactor(topic, ar -> { context.assertFalse(ar.succeeded()); context.assertTrue(ar.cause().getMessage().contains(\"Failed to reassign partitions\")); async.complete(); }); }",
        "prediction": "@Test public void changeReplicationFactor_ExecuteFail(TestContext context) { MockAdminClient adminClient = new MockAdminClient(); Vertx vertx = Vertx.vertx(); Topic topic = new Topic.Builder(\"changeReplicationFactor\", 2, (short) 2, emptyMap()).build(); String[] partitions = new String[]{\"changeReplicationFactor-0\", \"changeReplicationFactor-1\"}; Subclass sub = new Subclass(adminClient, vertx, config, asList(Subclass.generate(\"{\\\\\"version\\\\\":1,\\\\\"partitions\\\\\":[{\\\\\"topic\\\\\":\\\\\"test-topic\\\\\",\\\\\"partition\\\\\":0,\\\\\"replicas\\\\\":[0],\\\\\"log_",
        "reference": "@Test public void changeReplicationFactor_ExecuteFail(TestContext context) { MockAdminClient adminClient = new MockAdminClient(); Vertx vertx = Vertx.vertx(); Topic topic = new Topic.Builder(\"changeReplicationFactor\", 2, (short) 2, emptyMap()).build(); String[] partitions = new String[]{\"changeReplicationFactor-0\", \"changeReplicationFactor-1\"}; Subclass sub = new Subclass(adminClient, vertx, config, asList( Subclass.generate(\"{\\\\\"version\\\\\":1,\\\\\"partitions\\\\\":[{\\\\\"topic\\\\\":\\\\\"test-topic\\\\\",\\\\\"partition\\\\\":0,\\\\\"replicas\\\\\":[0],\\\\\"log_dirs\\\\\":[\\\\\"any\\\\\"]},{\\\\\"topic\\\\\":\\\\\"test-topic\\\\\",\\\\\"partition\\\\\":1,\\\\\"replicas\\\\\":[0],\\\\\"log_dirs\\\\\":[\\\\\"any\\\\\"]}]}\", \"{\\\\\"version\\\\\":1,\\\\\"partitions\\\\\":[{\\\\\"topic\\\\\":\\\\\"test-topic\\\\\",\\\\\"partition\\\\\":0,\\\\\"replicas\\\\\":[0],\\\\\"log_dirs\\\\\":[\\\\\"any\\\\\"]},{\\\\\"topic\\\\\":\\\\\"test-topic\\\\\",\\\\\"partition\\\\\":1,\\\\\"replicas\\\\\":[0],\\\\\"log_dirs\\\\\":[\\\\\"any\\\\\"]}]}\"), Subclass.executeFail(\"Bang!\"), Subclass.executeStarted(), Subclass.verifyInProgress(partitions), Subclass.verifySuccess(partitions))); Async async = context.async(); sub.changeReplicationFactor(topic).setHandler(ar -> { context.assertFalse(ar.succeeded()); context.assertTrue(ar.cause().getMessage().contains(\"Failed to reassign partitions\")); async.complete(); }); }"
    },
    {
        "id": 107,
        "original": "@Test public void testGetCpu() { System.out.println(\"getCpu\"); prepareTestData(123); double result = instance.getCpu(); System.out.println(result); assertTrue(result >= 0); }",
        "prediction": "@Test public void testGetCpu()throws PerfMonException { System.out.println(\"getCpu\"); prepareTestData(123); double result = instance.getCpu(); System.out.println(result); assertTrue(result >= 0); }",
        "reference": "@Test public void testGetCpu() throws PerfMonException { System.out.println(\"getCpu\"); prepareTestData(123); double result = instance.getCpu(); System.out.println(result); assertTrue(result >= 0); }"
    },
    {
        "id": 108,
        "original": "@Test public void testGetEnvMapForLog(){ LOGGER.debug(JsonUtil.format(SystemUtil.getEnvMapForLog())); }",
        "prediction": "@Test public void testGetEnvMap() { LOGGER.debug(JsonUtil.format(SystemUtil.getEnvMap())); }",
        "reference": "@Test public void testGetEnvMap(){ LOGGER.debug(JsonUtil.format(SystemUtil.getEnvMap())); }"
    },
    {
        "id": 109,
        "original": "@Test public final void getResponseBodyAsString(){ String templateFile = \"http://10.8.25.80:6666/template.csv?sign=123456\"; HttpURLConnectionParam httpURLConnectionParam = new HttpURLConnectionParam(); httpURLConnectionParam.setContentCharset(CharsetType.GBK); String responseBodyAsString = URLConnectionUtil.getResponseBodyAsString(templateFile, httpURLConnectionParam); LOGGER.info(responseBodyAsString); }",
        "prediction": "@Test public final void getResponseBodyAsString()throws IOException { String templateFile = \"http://10.8.25.80:6666/template.csv?sign=123456\"; ConnectionConfig connectionConfig = new ConnectionConfig(); connectionConfig.setContentCharset(CharsetType.GBK); String responseBodyAsString = URLConnectionUtil.getResponseBodyAsString(templateFile, connectionConfig); LOGGER.info(responseBodyAsString); }",
        "reference": "@Test public final void getResponseBodyAsString(){ String templateFile = \"http://10.8.25.80:6666/template.csv?sign=123456\"; ConnectionConfig connectionConfig = new ConnectionConfig(); connectionConfig.setContentCharset(CharsetType.GBK); String responseBodyAsString = URLConnectionUtil.getResponseBodyAsString(templateFile, connectionConfig); LOGGER.info(responseBodyAsString); }"
    },
    {
        "id": 110,
        "original": "@Test public void testJoinValues(){ String value = \"create_salesorder\"; String value2 = \"unionpay_mobile\"; Map<String, String> map = new HashMap<String, String>(); map.put(\"service\", value); map.put(\"paymentType\", value2); assertEquals(StringUtils.EMPTY, ParamUtil.joinValues(map, \"a\", \"b\")); assertEquals(value, ParamUtil.joinValues(map, \"service\")); assertEquals(value + value2, ParamUtil.joinValues(map, \"service\", \"paymentType\")); assertEquals(value2 + value, ParamUtil.joinValues(map, \"paymentType\", \"service\")); }",
        "prediction": "@Test public void testJoinValues() { String value = \"create_salesorder\"; String value2 = \"unionpay_mobile\"; Map<String, String> map = new HashMap<String, String>(); map.put(\"service\", value); map.put(\"paymentType\", value2); assertEquals(StringUtils.EMPTY, ParamUtil.joinValuesOrderByIncludeKeys(map, \"a\", \"b\")); assertEquals(value, ParamUtil.joinValues(map, \"service\")); assertEquals(value + value2, ParamUtil.joinValues(map, \"service\", \"paymentType\")); assertEquals(value2 + value, ParamUtil.joinValuesOrderByIncludeKeys(map",
        "reference": "@Test public void testJoinValues(){ String value = \"create_salesorder\"; String value2 = \"unionpay_mobile\"; Map<String, String> map = new HashMap<String, String>(); map.put(\"service\", value); map.put(\"paymentType\", value2); assertEquals(StringUtils.EMPTY, ParamUtil.joinValuesOrderByIncludeKeys(map, \"a\", \"b\")); assertEquals(value, ParamUtil.joinValuesOrderByIncludeKeys(map, \"service\")); assertEquals(value + value2, ParamUtil.joinValuesOrderByIncludeKeys(map, \"service\", \"paymentType\")); assertEquals(value2 + value, ParamUtil.joinValuesOrderByIncludeKeys(map, \"paymentType\", \"service\")); }"
    },
    {
        "id": 111,
        "original": "@Test public void testCollectionToString(){ List<String> list = new ArrayList<String>(); list.add(\"2548\"); list.add(\"\"); ToStringConfig toStringConfig = new ToStringConfig(\",\"); toStringConfig.setIsJoinNullOrEmpty(false); assertEquals(\"2548\", ConvertUtil.toString(list, toStringConfig)); }",
        "prediction": "@Test public void testCollectionToString(){ final List < String > list = new ArrayList<String>(); list.add(\"2548\"); list.add(\"\"); ToStringConfig toStringConfig = new ToStringConfig(\",\"); toStringConfig.setIsJoinNullOrEmpty(false); assertEquals(\"2548\", ConvertUtil.toString(list, toStringConfig)); }",
        "reference": "@Test public void testCollectionToString(){ List<String> list = new ArrayList<String>(); list.add(\"2548\"); list.add(\"\"); ToStringConfig toStringConfig = new ToStringConfig(\",\"); toStringConfig.setIsJoinNullOrEmpty(false); assertEquals(\"2548\", ConvertUtil.toString(toStringConfig, list)); }"
    },
    {
        "id": 112,
        "original": "@Test public void testCollectionToString1(){ List<String> list = new ArrayList<String>(); list.add(\"2548\"); list.add(\"2548\"); list.add(\"2548\"); list.add(\"2548\"); list.add(\"2548\"); list.add(\"2548\"); ToStringConfig toStringConfig = new ToStringConfig(SystemUtils.LINE_SEPARATOR); LOGGER.debug(ConvertUtil.toString(list, toStringConfig)); }",
        "prediction": "@Test public void testCollectionToString1() { final List < String > list = new ArrayList<String>(); list.add(\"2548\"); list.add(\"2548\"); list.add(\"2548\"); list.add(\"2548\"); list.add(\"2548\"); list.add(\"2548\"); list.add(\"2548\"); LOGGER.debug(ConvertUtil.toString(list, toStringConfig)); }",
        "reference": "@Test public void testCollectionToString1(){ List<String> list = new ArrayList<String>(); list.add(\"2548\"); list.add(\"2548\"); list.add(\"2548\"); list.add(\"2548\"); list.add(\"2548\"); list.add(\"2548\"); ToStringConfig toStringConfig = new ToStringConfig(SystemUtils.LINE_SEPARATOR); LOGGER.debug(ConvertUtil.toString(toStringConfig, list)); }"
    },
    {
        "id": 113,
        "original": "@Test public void getConcreteMembers_isCorrect() throws Exception { Element genericElement = Utils.getElementFromClass(DummyGenericClass.class); assertNotNull(genericElement); Map<Element, TypeMirror> genericMembers = new HashMap<>(); for (Element element : genericElement.getEnclosedElements()) { if (element instanceof VariableElement) { genericMembers.put(element, element.asType()); } } TypeMirror concreteType = TypeUtils.getInheritedType(Utils.getElementFromClass(DummyInheritedClass.class)); assertNotNull(concreteType); TypeMirror genericType = Utils.getGenericVersionOfClass(DummyGenericClass.class); assertNotNull(genericType); LinkedHashMap<Element, TypeMirror> members = TypeUtils.getConcreteMembers(concreteType, types.asElement(genericType), genericMembers); TypeMirror stringType = Utils.getTypeMirrorFromClass(String.class); assertNotNull(stringType); for (Entry<Element, TypeMirror> entry : members.entrySet()) { if (entry.getKey().getSimpleName().contentEquals(\"testObject\")) { assertTrue(entry.getValue().toString().equals(stringType.toString())); } else if (entry.getKey().getSimpleName().contentEquals(\"testList\")) { assertTrue(entry.getValue() .toString() .equals(types.getDeclaredType( (TypeElement) Utils.getElementFromClass(ArrayList.class), stringType).toString())); } else if (entry.getKey().getSimpleName().contentEquals(\"testMap\")) { assertTrue(entry.getValue() .toString() .equals(types.getDeclaredType( (TypeElement) Utils.getElementFromClass(HashMap.class), stringType, stringType).toString())); } else if (entry.getKey().getSimpleName().contentEquals(\"testSet\")) { assertTrue(entry.getValue() .toString() .equals(types.getDeclaredType( (TypeElement) Utils.getElementFromClass(HashSet.class), stringType) .toString())); } else if (entry.getKey().getSimpleName().contentEquals(\"testArrayMap\")) { TypeMirror listString = types.getDeclaredType((TypeElement) Utils.getElementFromClass(List.class), stringType); assertTrue(entry.getValue() .toString() .equals(types.getDeclaredType( (TypeElement) Utils.getElementFromClass(HashMap.class), stringType, listString) .toString())); } else if (entry.getKey().getSimpleName().contentEquals(\"testListMap\")) { TypeMirror mapStringString = types.getDeclaredType((TypeElement) Utils.getElementFromClass(Map.class), stringType, stringType); assertTrue(entry.getValue() .toString() .equals(types.getDeclaredType( (TypeElement) Utils.getElementFromClass(ArrayList.class), mapStringString) .toString())); } } }",
        "prediction": "@Test public void getConcreteMembers_isCorrect()throws Exception { TypeElement genericElement = Utils.getElementFromClass(DummyGenericClass.class); assertNotNull(genericElement); Map<VariableElement, TypeMirror> genericMembers = new HashMap<>(); for(VariableElement element : genericElement.getEnclosedElements()) { if(element instanceof VariableElement) { genericMembers.put(element, element.asType()); } } TypeMirror concreteType = TypeUtils.getInheritedType(Utils.getElementFromClass(DummyInheritedClass.class)); assertNotNull(concreteType); TypeMirror genericType = Utils.getGenericVersionOfClass(DummyGenericClass.class); assertNotNull(genericType); LinkedHashMap<Element, TypeMirror> members = TypeUtils.get",
        "reference": "@Test public void getConcreteMembers_isCorrect() throws Exception { Element genericElement = Utils.getElementFromClass(DummyGenericClass.class); assertNotNull(genericElement); Map<Element, TypeMirror> genericMembers = new HashMap<>(); for (Element element : genericElement.getEnclosedElements()) { if (element instanceof VariableElement) { genericMembers.put(element, element.asType()); } } TypeMirror concreteType = TypeUtils.getInheritedType(Utils.getElementFromClass(DummyInheritedClass.class)); assertNotNull(concreteType); TypeMirror genericType = Utils.getGenericVersionOfClass(DummyGenericClass.class); assertNotNull(genericType); LinkedHashMap<Element, TypeMirror> members = TypeUtils.getConcreteMembers(concreteType, (TypeElement) types.asElement(genericType), genericMembers); TypeMirror stringType = Utils.getTypeMirrorFromClass(String.class); assertNotNull(stringType); for (Entry<Element, TypeMirror> entry : members.entrySet()) { if (entry.getKey().getSimpleName().contentEquals(\"testObject\")) { assertTrue(entry.getValue().toString().equals(stringType.toString())); } else if (entry.getKey().getSimpleName().contentEquals(\"testList\")) { assertTrue(entry.getValue() .toString() .equals(types.getDeclaredType(Utils.getElementFromClass(ArrayList.class), stringType).toString())); } else if (entry.getKey().getSimpleName().contentEquals(\"testMap\")) { assertTrue(entry.getValue() .toString() .equals(types.getDeclaredType(Utils.getElementFromClass(HashMap.class), stringType, stringType).toString())); } else if (entry.getKey().getSimpleName().contentEquals(\"testSet\")) { assertTrue(entry.getValue() .toString() .equals(types.getDeclaredType(Utils.getElementFromClass(HashSet.class), stringType) .toString())); } else if (entry.getKey().getSimpleName().contentEquals(\"testArrayMap\")) { TypeMirror listString = types.getDeclaredType(Utils.getElementFromClass(List.class), stringType); assertTrue(entry.getValue() .toString() .equals(types.getDeclaredType(Utils.getElementFromClass(HashMap.class), stringType, listString) .toString())); } else if (entry.getKey().getSimpleName().contentEquals(\"testListMap\")) { TypeMirror mapStringString = types.getDeclaredType(Utils.getElementFromClass(Map.class), stringType, stringType); assertTrue(entry.getValue() .toString() .equals(types.getDeclaredType(Utils.getElementFromClass(ArrayList.class), mapStringString) .toString())); } } }"
    },
    {
        "id": 114,
        "original": "@Test public void testCreateClassifier() throws InterruptedException { server.enqueue(jsonResponse(classifier)); final Classifier response = service.createClassifier(classifierId, \"en\", new File(\"src/test/resources/natural_language_classifier/weather_data_train.csv\")).execute(); final RecordedRequest request = server.takeRequest(); assertEquals(CLASSIFIERS_PATH, request.getPath()); assertEquals(classifier, response); }",
        "prediction": "@Test public void testCreateClassifier()throws InterruptedException { server.enqueue(jsonResponse(classifier)); final Classifier response = service.createClassifier(CreateClassifierOptions.builder().name(\"en\")).execute(); final RecordedRequest request = server.takeRequest(); assertEquals(CLASSIFIERS_PATH, request.getPath()); assertEquals(classifier, response); }",
        "reference": "@Test public void testCreateClassifier() throws InterruptedException, FileNotFoundException { server.enqueue(jsonResponse(classifier)); File metadata = new File(RESOURCE + \"metadata.json\"); File trainingData = new File(RESOURCE + \"weather_data_train.csv\"); CreateClassifierOptions createOptions = new CreateClassifierOptions.Builder() .metadata(metadata) .trainingData(trainingData) .trainingDataFilename(\"weather_data_train.csv\") .build(); final Classifier response = service.createClassifier(createOptions).execute(); final RecordedRequest request = server.takeRequest(); assertEquals(CLASSIFIERS_PATH, request.getPath()); assertEquals(classifier, response); }"
    },
    {
        "id": 115,
        "original": "@Test(expected = IllegalArgumentException.class) public void testNullTrainingDataFile() { service.createClassifier(null, null, new File(\"src/test/resources/notfound.txt\")); }",
        "prediction": "@Test(expected = IllegalArgumentException.class)public void testNullTrainingDataFile() { service.createClassifier(CreateClassifierOptions.builder().build()); }",
        "reference": "@Test(expected = FileNotFoundException.class) public void testNullTrainingDataFile() throws FileNotFoundException { server.enqueue(jsonResponse(classifier)); File metadata = new File(RESOURCE + \"metadata.json\"); File trainingData = new File(RESOURCE + \"notfound.txt\"); CreateClassifierOptions createOptions = new CreateClassifierOptions.Builder() .metadata(metadata) .trainingData(trainingData) .trainingDataFilename(\"notfound.txt\") .build(); service.createClassifier(createOptions).execute(); }"
    },
    {
        "id": 116,
        "original": "@Test(expected = IllegalArgumentException.class) public void testNullClassifier() { service.classify(\"\", \"test\"); }",
        "prediction": "@Test(expected = IllegalArgumentException.class)public void testNullClassifier() { service.classify(\"\", \"test\"); }",
        "reference": "@Test(expected = IllegalArgumentException.class) public void testNullClassifier() { ClassifyOptions classifyOptions = new ClassifyOptions.Builder() .text(\"test\") .build(); service.classify(classifyOptions); }"
    },
    {
        "id": 117,
        "original": "@Test(expected = IllegalArgumentException.class) public void testNullText() { service.classify(classifierId, null); }",
        "prediction": "@Test(expected = IllegalArgumentException.class)public void testNullText() { service.classify(classifierId, null); }",
        "reference": "@Test(expected = IllegalArgumentException.class) public void testNullText() { ClassifyOptions classifyOptions = new ClassifyOptions.Builder() .classifierId(classifierId) .build(); service.classify(classifyOptions); }"
    },
    {
        "id": 118,
        "original": "@Test(expected = IllegalArgumentException.class) public void testNullDeleteClassifier() { service.deleteClassifier(\"\"); }",
        "prediction": "@Test(expected = IllegalArgumentException.class)public void testNullDeleteClassifier() { service.deleteClassifier(DeleteClassifierOptions.newBuilder().classifierId(deleteClassifierOptions.classifierId()).build()); }",
        "reference": "@Test(expected = IllegalArgumentException.class) public void testNullDeleteClassifier() { DeleteClassifierOptions deleteOptions = new DeleteClassifierOptions.Builder() .build(); service.deleteClassifier(deleteOptions); }"
    },
    {
        "id": 119,
        "original": "@Test public void testSynthesize() { final File audio = new File(\"src/test/resources/speech_to_text/sample1.wav\"); try { final List<Parameter> parameters = new ArrayList<Parameter>(); parameters.add(new Parameter(\"text\", text)); parameters.add(new Parameter(\"voice\", Voice.EN_LISA.getName())); parameters.add(new Parameter(\"accept\", HttpMediaType.AUDIO_WAV)); mockServer.when(request().withQueryStringParameters(parameters).withPath(SYNTHESIZE_PATH)) .respond( response().withHeaders( new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.AUDIO_WAV)).withBody( Files.toByteArray(audio))); final InputStream in = service.synthesize(text, Voice.EN_LISA, HttpMediaType.AUDIO_WAV); Assert.assertNotNull(in); writeInputStreamToOutputStream(in, new FileOutputStream(\"target/output.wav\")); } catch (final FileNotFoundException e) { Assert.fail(e.getMessage()); } catch (final IOException e) { Assert.fail(e.getMessage()); } }",
        "prediction": "@Test public void testSynthesize() { final File audio = new File(\"src/test/resources/speech_to_text/sample1.wav\"); try { final List<Parameter> parameters = new ArrayList<Parameter>(); parameters.add(new Parameter(\"text\", text)); parameters.add(new Parameter(\"voice\", Voice.EN_LISA.getName())); parameters.add(new Parameter(\"accept\", HttpMediaType.AUDIO_WAV)); mockServer.when(request().withQueryStringParameters(parameters).withPath(SYNTHESIZE_PATH)).respond( response().withHeaders( new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.AUDIO",
        "reference": "@Test public void testSynthesize() { final File audio = new File(\"src/test/resources/speech_to_text/sample1.wav\"); try { final List<Parameter> parameters = new ArrayList<Parameter>(); parameters.add(new Parameter(\"text\", text)); parameters.add(new Parameter(\"voice\", Voice.EN_LISA.getName())); parameters.add(new Parameter(\"accept\", HttpMediaType.AUDIO_WAV)); mockServer.when(request().withQueryStringParameters(parameters).withPath(SYNTHESIZE_PATH)) .respond( response().withHeaders( new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.AUDIO_WAV)).withBody( Files.toByteArray(audio))); final InputStream in = service.synthesize(text, Voice.EN_LISA, HttpMediaType.AUDIO_WAV).execute(); Assert.assertNotNull(in); writeInputStreamToOutputStream(in, new FileOutputStream(\"target/output.wav\")); } catch (final FileNotFoundException e) { Assert.fail(e.getMessage()); } catch (final IOException e) { Assert.fail(e.getMessage()); } }"
    },
    {
        "id": 120,
        "original": "@Test public void testGetModel() { final SpeechModel speechModel = new SpeechModel(\"not-a-real-Model\"); speechModel.setRate(8000); mockServer.when(request().withPath(GET_MODELS_PATH + \"/\" + speechModel.getName())).respond( response().withHeaders( new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.APPLICATION_JSON)).withBody( GsonSingleton.getGsonWithoutPrettyPrinting().toJson(speechModel))); SpeechModel model = service.getModel(\"not-a-real-Model\"); Assert.assertNotNull(model); Assert.assertEquals(model, speechModel); model = service.getModel(speechModel.getName()); Assert.assertNotNull(model); Assert.assertEquals(model, speechModel); try { TestUtils.assertNoExceptionsOnGetters(model); } catch (final Exception e) { Assert.fail(e.getMessage()); } }",
        "prediction": "@Test public void testGetModel() { final SpeechModel speechModel = new SpeechModel(\"not-a-real-Model\"); speechModel.setRate(8000); mockServer.when(request().withPath(GET_MODELS_PATH + \"/\" + speechModel.getName())).respond( response().withHeaders( new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.APPLICATION_JSON)).withBody( GsonSingleton.getGsonWithoutPrettyPrinting().toJson(speechModel))); SpeechModel model = service.getModel(\"not-a-real-Model\"); Assert.assertNotNull(model); Assert.assertEquals(model, speechModel); model =",
        "reference": "@Test public void testGetModel() { final SpeechModel speechModel = new SpeechModel(\"not-a-real-Model\"); speechModel.setRate(8000); mockServer.when(request().withPath(GET_MODELS_PATH + \"/\" + speechModel.getName())).respond( response().withHeaders( new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.APPLICATION_JSON)).withBody( GsonSingleton.getGsonWithoutPrettyPrinting().toJson(speechModel))); SpeechModel model = service.getModel(\"not-a-real-Model\").execute(); Assert.assertNotNull(model); Assert.assertEquals(model, speechModel); model = service.getModel(speechModel.getName()).execute(); Assert.assertNotNull(model); Assert.assertEquals(model, speechModel); try { TestUtils.assertNoExceptionsOnGetters(model); } catch (final Exception e) { Assert.fail(e.getMessage()); } }"
    },
    {
        "id": 121,
        "original": "@Test public void testRecognizeMissingAudioFile() throws URISyntaxException { final SpeechResults speechResults = new SpeechResults(); speechResults.setResultIndex(0); final Transcript transcript = new Transcript(); transcript.setFinal(true); final SpeechAlternative speechAlternative = new SpeechAlternative(); speechAlternative .setTranscript(\"thunderstorms could produce large hail isolated tornadoes and heavy rain\"); final List<SpeechAlternative> speechAlternatives = new ArrayList<SpeechAlternative>(); speechAlternatives.add(speechAlternative); transcript.setAlternatives(speechAlternatives); final List<Transcript> transcripts = new ArrayList<Transcript>(); transcripts.add(transcript); speechResults.setResults(transcripts); mockServer.when( request().withMethod(\"POST\").withPath(RECOGNIZE_PATH) .withHeaders(new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.AUDIO_WAV))) .respond( response().withHeader(APPLICATION_JSON).withBody( GsonSingleton.getGsonWithoutPrettyPrinting().toJson(speechResults))); boolean didItHappen = false; try { service.recognize(null); } catch (final IllegalArgumentException e) { didItHappen = true; } Assert.assertTrue(\"Check that 'IllegalArgumentException' is thrown.\", didItHappen); }",
        "prediction": "@Test public void testRecognizeMissingAudioFile()throws URISyntaxException { final SpeechResults speechResults = new SpeechResults(); speechResults.setResultIndex(0); final Transcript transcript = new Transcript(); transcript.setFinal(true); final SpeechAlternative speechAlternative = new SpeechAlternative(); speechAlternative.setTranscript(\"thunderstorms could produce large hail isolated tornadoes and heavy rain\"); final List<SpeechAlternative> speechAlternatives = new ArrayList<SpeechAlternative>(); speechAlternatives.add(speechAlternative); transcript.setAlternatives(speechAlternatives); final List<Transcript> transcripts = new ArrayList<Transcript>(); transcripts.add(transcript); speechResults.",
        "reference": "@Test public void testRecognizeMissingAudioFile() throws URISyntaxException { final SpeechResults speechResults = new SpeechResults(); speechResults.setResultIndex(0); final Transcript transcript = new Transcript(); transcript.setFinal(true); final SpeechAlternative speechAlternative = new SpeechAlternative(); speechAlternative .setTranscript(\"thunderstorms could produce large hail isolated tornadoes and heavy rain\"); final List<SpeechAlternative> speechAlternatives = new ArrayList<SpeechAlternative>(); speechAlternatives.add(speechAlternative); transcript.setAlternatives(speechAlternatives); final List<Transcript> transcripts = new ArrayList<Transcript>(); transcripts.add(transcript); speechResults.setResults(transcripts); mockServer.when( request().withMethod(\"POST\").withPath(RECOGNIZE_PATH) .withHeaders(new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.AUDIO_WAV))) .respond( response().withHeader(APPLICATION_JSON).withBody( GsonSingleton.getGsonWithoutPrettyPrinting().toJson(speechResults))); boolean didItHappen = false; try { service.recognize(null).execute(); } catch (final IllegalArgumentException e) { didItHappen = true; } Assert.assertTrue(\"Check that \\'IllegalArgumentException\\' is thrown.\", didItHappen); }"
    },
    {
        "id": 122,
        "original": "@Test public void testGetVoices() { final Map<String, Object> response = new HashMap<String, Object>(); final List<Voice> voices = new ArrayList<Voice>(); final Voice voice = new Voice(); voice.setUrl(\"http://ibm.watson.com/text-to-speech/voices/en-US_TestMaleVoice\"); voice.setName(\"en-US_TestMaleVoice\"); voice.setGender(\"male\"); voice.setLanguage(\"en-US\"); voice.setDescription(\"TestMale\"); final Voice voice1 = new Voice(); voice1.setUrl(\"http://ibm.watson.com/text-to-speech/voices/en-US_TestFemaleVoice\"); voice1.setName(\"en-US_TestFemaleVoice\"); voice1.setGender(\"female\"); voice1.setLanguage(\"en-US\"); voice1.setDescription(\"TestFemale\"); voices.add(voice); voices.add(voice1); response.put(\"voices\", voices); mockServer.when(request().withPath(GET_VOICES_PATH)).respond( response().withHeaders( new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.APPLICATION_JSON)).withBody( GsonSingleton.getGsonWithoutPrettyPrinting().toJson(response))); final List<Voice> result = service.getVoices(); Assert.assertNotNull(result); Assert.assertFalse(result.isEmpty()); Assert.assertEquals(result, voices); }",
        "prediction": "@Test public void testGetVoices() { final Map<String, Object> response = new HashMap<String, Object>(); final List < Voice > voices = new ArrayList<Voice>(); final Voice voice = new Voice(); voice.setUrl(\"http://ibm.watson.com/text-to-speech/voices/en-US_TestMaleVoice\"); voice.setName(\"en-US_TestMaleVoice\"); voice.setGender(\"male\"); voice.setLanguage(\"en-US\"); voice.setDescription(\"TestMale\"); final Voice voice1 = new Voice(); voice1.setUrl(\"http://ibm.watson.com/text",
        "reference": "@Test public void testGetVoices() { final Map<String, Object> response = new HashMap<String, Object>(); final List<Voice> voices = new ArrayList<Voice>(); final Voice voice = new Voice(); voice.setUrl(\"http://ibm.watson.com/text-to-speech/voices/en-US_TestMaleVoice\"); voice.setName(\"en-US_TestMaleVoice\"); voice.setGender(\"male\"); voice.setLanguage(\"en-US\"); voice.setDescription(\"TestMale\"); final Voice voice1 = new Voice(); voice1.setUrl(\"http://ibm.watson.com/text-to-speech/voices/en-US_TestFemaleVoice\"); voice1.setName(\"en-US_TestFemaleVoice\"); voice1.setGender(\"female\"); voice1.setLanguage(\"en-US\"); voice1.setDescription(\"TestFemale\"); voices.add(voice); voices.add(voice1); response.put(\"voices\", voices); mockServer.when(request().withPath(GET_VOICES_PATH)).respond( response().withHeaders( new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.APPLICATION_JSON)).withBody( GsonSingleton.getGsonWithoutPrettyPrinting().toJson(response))); final List<Voice> result = service.getVoices().execute(); Assert.assertNotNull(result); Assert.assertFalse(result.isEmpty()); Assert.assertEquals(result, voices); }"
    },
    {
        "id": 123,
        "original": "@Test public void testDeleteCorpus() throws InterruptedException, FileNotFoundException { String id = \"foo\"; String corpus = \"cName\"; server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(\"{}\")); service.deleteCorpus(id, corpus).execute(); final RecordedRequest request = server.takeRequest(); assertEquals(\"DELETE\", request.getMethod()); assertEquals(String.format(PATH_CORPUS, id, corpus), request.getPath()); }",
        "prediction": "@Test public void testDeleteCorpus()throws InterruptedException, FileNotFoundException { String id = \"foo\"; String corpus = \"cName\"; server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(\"{}\")); DeleteCorpusOptions deleteOptions = new DeleteCorpusOptions.Builder().customizationId(id).corpusName(corpus).build(); service.deleteCorpus(deleteOptions).execute(); final RecordedRequest request = server.takeRequest(); assertEquals(\"DELETE\", request.getMethod()); assertEquals(String.format(PATH_CORPUS, id, corpus), request.getPath()); }",
        "reference": "@Test public void testDeleteCorpus() throws InterruptedException, FileNotFoundException { String id = \"foo\"; String corpus = \"cName\"; server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(\"{}\")); DeleteCorpusOptions deleteOptions = new DeleteCorpusOptions.Builder() .customizationId(id) .corpusName(corpus) .build(); service.deleteCorpus(deleteOptions).execute(); final RecordedRequest request = server.takeRequest(); assertEquals(\"DELETE\", request.getMethod()); assertEquals(String.format(PATH_CORPUS, id, corpus), request.getPath()); }"
    },
    {
        "id": 124,
        "original": "@Test public void testGetModels() throws InterruptedException { final SpeechModel speechModel = new SpeechModel(\"not-a-real-Model\"); speechModel.setRate(8000); final SpeechModel speechModel1 = new SpeechModel(\"not-a-real-Model1\"); speechModel1.setRate(1600); final SpeechModel speechModel2 = new SpeechModel(\"not-a-real-Model2\"); speechModel2.setRate(8000); final List<SpeechModel> speechModels = ImmutableList.of(speechModel, speechModel1, speechModel2); final Map<String, ?> response = ImmutableMap.of(\"models\", speechModels); server.enqueue( new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(response))); final List<SpeechModel> models = service.getModels().execute(); final RecordedRequest request = server.takeRequest(); assertNotNull(models); assertFalse(models.isEmpty()); assertEquals(models, response.get(\"models\")); assertEquals(PATH_MODELS, request.getPath()); }",
        "prediction": "@Test public void testGetModels()throws InterruptedException { final SpeechModel speechModel = new SpeechModel(\"not-a-real-Model\"); speechModel.setRate(8000); final SpeechModel speechModel1 = new SpeechModel(\"not-a-real-Model1\"); speechModel1.setRate(1600); final SpeechModel speechModel2 = new SpeechModel(\"not-a-real-Model2\"); speechModel2.setRate(8000); final List < SpeechModels > speechModels = ImmutableList.of(speechModel, speechModel1, speechModel2); final Map<String,?> response = ImmutableMap.of(\"models\", speechModels); server.enqueue",
        "reference": "@Test public void testGetModels() throws InterruptedException { final SpeechModel speechModel = new SpeechModel(); speechModel.setName(\"not-a-real-Model\"); speechModel.setRate(8000); final SpeechModel speechModel1 = new SpeechModel(); speechModel.setName(\"not-a-real-Model1\"); speechModel1.setRate(1600); final SpeechModel speechModel2 = new SpeechModel(); speechModel.setName(\"not-a-real-Model2\"); speechModel2.setRate(8000); final List<SpeechModel> speechModels = ImmutableList.of(speechModel, speechModel1, speechModel2); final Map<String, ?> response = ImmutableMap.of(\"models\", speechModels); server.enqueue( new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(response))); final SpeechModels models = service.listModels().execute(); final RecordedRequest request = server.takeRequest(); assertNotNull(models); assertFalse(models.getModels().isEmpty()); assertEquals(models.getModels(), response.get(\"models\")); assertEquals(PATH_MODELS, request.getPath()); }"
    },
    {
        "id": 125,
        "original": "@Test public void testRecognize() throws URISyntaxException, InterruptedException { final SpeechResults speechResults = new SpeechResults(); speechResults.setResultIndex(0); final Transcript transcript = new Transcript(); transcript.setFinal(true); final SpeechAlternative speechAlternative = new SpeechAlternative(); speechAlternative.setTranscript(\"thunderstorms could produce large hail isolated tornadoes and heavy rain\"); final List<SpeechAlternative> speechAlternatives = ImmutableList.of(speechAlternative); transcript.setAlternatives(speechAlternatives); final List<Transcript> transcripts = ImmutableList.of(transcript); speechResults.setResults(transcripts); server.enqueue( new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(speechResults))); final SpeechResults result = service.recognize(SAMPLE_WAV).execute(); final RecordedRequest request = server.takeRequest(); assertNotNull(result); assertEquals(result, speechResults); assertEquals(\"POST\", request.getMethod()); assertEquals(PATH_RECOGNIZE, request.getPath()); assertEquals(HttpMediaType.AUDIO_WAV, request.getHeader(CONTENT_TYPE)); }",
        "prediction": "@Test public void testRecognize()throws URISyntaxException, InterruptedException { final SpeechResults speechResults = new SpeechResults(); speechResults.setResultIndex(0); final Transcript transcript = new Transcript(); transcript.setFinal(true); final SpeechAlternative speechAlternative = new SpeechAlternative(); speechAlternative.setTranscript(\"thunderstorms could produce large hail isolated tornadoes and heavy rain\"); final List<SpeechAlternative> speechAlternatives = ImmutableList.of(speechAlternative); transcript.setAlternatives(speechAlternatives); final List<Transcript> transcripts = ImmutableList.of(transcript); speechResults.setResults(transcripts); server.enqueue( new MockResponse().addHeader(",
        "reference": "@Test public void testRecognize() throws URISyntaxException, InterruptedException { final SpeechRecognitionResults speechResults = new SpeechRecognitionResults(); speechResults.setResultIndex(0); final SpeechRecognitionResult transcript = new SpeechRecognitionResult(); transcript.setFinal(true); final SpeechRecognitionAlternative speechAlternative = new SpeechRecognitionAlternative(); speechAlternative.setTranscript(\"thunderstorms could produce large hail isolated tornadoes and heavy rain\"); final List<SpeechRecognitionAlternative> speechAlternatives = ImmutableList.of(speechAlternative); transcript.setAlternatives(speechAlternatives); final List<SpeechRecognitionResult> transcripts = ImmutableList.of(transcript); speechResults.setResults(transcripts); server.enqueue( new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(speechResults))); RecognizeOptions recognizeOptions = new RecognizeOptions.Builder() .audio(SAMPLE_WAV) .contentType(RecognizeOptions.ContentType.AUDIO_WAV) .build(); final SpeechRecognitionResults result = service.recognize(recognizeOptions).execute(); final RecordedRequest request = server.takeRequest(); assertNotNull(result); assertEquals(result, speechResults); assertEquals(\"POST\", request.getMethod()); assertEquals(PATH_RECOGNIZE, request.getPath()); assertEquals(HttpMediaType.AUDIO_WAV, request.getHeader(CONTENT_TYPE)); }"
    },
    {
        "id": 126,
        "original": "@Test public void testRecognizeWithCustomization() throws FileNotFoundException, InterruptedException { String id = \"foo\"; String recString = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/recognition.json\")); JsonObject recognition = new JsonParser().parse(recString).getAsJsonObject(); server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(recString)); RecognizeOptions options = new RecognizeOptions.Builder().customizationId(id).build(); SpeechResults result = service.recognize(SAMPLE_WAV, options).execute(); final RecordedRequest request = server.takeRequest(); assertEquals(\"POST\", request.getMethod()); assertEquals(PATH_RECOGNIZE + \"?customization_id=\" + id, request.getPath()); assertEquals(recognition, GSON.toJsonTree(result)); }",
        "prediction": "@Test public void testRecognizeWithCustomization()throws FileNotFoundException, InterruptedException { String id = \"foo\"; String recString = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/recognition.json\")); JsonObject recognition = new JsonParser().parse(recString).getAsJsonObject(); server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(recString)); RecognizeOptions options = new RecognizeOptions.Builder().customizationId(id).build(); SpeechRecognitionResults result = service.recognize(SAMPLE_WAV, options).execute(); final RecordedRequest request",
        "reference": "@Test public void testRecognizeWithCustomization() throws FileNotFoundException, InterruptedException { String id = \"foo\"; String recString = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/recognition.json\")); JsonObject recognition = new JsonParser().parse(recString).getAsJsonObject(); server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(recString)); RecognizeOptions recognizeOptions = new RecognizeOptions.Builder() .audio(SAMPLE_WAV) .contentType(RecognizeOptions.ContentType.AUDIO_WAV) .customizationId(id) .build(); SpeechRecognitionResults result = service.recognize(recognizeOptions).execute(); final RecordedRequest request = server.takeRequest(); assertEquals(\"POST\", request.getMethod()); assertEquals(PATH_RECOGNIZE + \"?customization_id=\" + id, request.getPath()); assertEquals(recognition, GSON.toJsonTree(result)); }"
    },
    {
        "id": 127,
        "original": "@Test public void testGetCustomizations() throws InterruptedException, FileNotFoundException { String customizationsAsString = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/customizations.json\")); JsonObject customizations = new JsonParser().parse(customizationsAsString).getAsJsonObject(); server.enqueue( new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(customizationsAsString)); List<Customization> result = service.getCustomizations(\"en-us\").execute(); final RecordedRequest request = server.takeRequest(); assertEquals(\"GET\", request.getMethod()); assertEquals(PATH_CUSTOMIZATIONS + \"?language=en-us\", request.getPath()); assertEquals(customizations.get(\"customizations\").getAsJsonArray().size(), result.size()); assertEquals(customizations.get(\"customizations\"), GSON.toJsonTree(result)); }",
        "prediction": "@Test public void testGetCustomizations()throws InterruptedException, FileNotFoundException { String customizationsAsString = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/customizations.json\")); JsonObject customizations = new JsonParser().parse(customizationsAsString).getAsJsonObject(); server.enqueue( new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(customizationsAsString)); ListLanguageModelsOptions listLanguageModelsOptions = new ListLanguageModelsOptions.Builder().language(Language.en-us).build(); service.listLanguageModels(listLanguageModelsOptions).execute(); final RecordedRequest request = server.takeRequest(); assertEquals(\"GET",
        "reference": "@Test public void testListLanguageModels() throws InterruptedException, FileNotFoundException { String customizationsAsString = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/customizations.json\")); JsonObject customizations = new JsonParser().parse(customizationsAsString).getAsJsonObject(); server.enqueue( new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(customizationsAsString)); ListLanguageModelsOptions listOptions = new ListLanguageModelsOptions.Builder() .language(\"en-us\") .build(); LanguageModels result = service.listLanguageModels(listOptions).execute(); final RecordedRequest request = server.takeRequest(); assertEquals(\"GET\", request.getMethod()); assertEquals(PATH_CUSTOMIZATIONS + \"?language=en-us\", request.getPath()); assertEquals(customizations.get(\"customizations\").getAsJsonArray().size(), result.getCustomizations().size()); assertEquals(customizations.get(\"customizations\"), GSON.toJsonTree(result.getCustomizations())); }"
    },
    {
        "id": 128,
        "original": "@Test public void testGetCustomization() throws InterruptedException, FileNotFoundException { String id = \"foo\"; Customization customization = loadFixture(\"src/test/resources/speech_to_text/customization.json\", Customization.class); server.enqueue( new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(customization))); Customization result = service.getCustomization(id).execute(); final RecordedRequest request = server.takeRequest(); assertEquals(\"GET\", request.getMethod()); assertEquals(String.format(PATH_CUSTOMIZATION, id), request.getPath()); assertEquals(result.toString(), customization.toString()); }",
        "prediction": "@Test public void testGetCustomization()throws InterruptedException, FileNotFoundException { String id = \"foo\"; GetLanguageModelOptions getLanguageModelOptions = new GetLanguageModelOptions.Builder().customizationId(id).build(); server.enqueue( new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(getLanguageModelOptions))); LanguageModel result = service.getLanguageModel(getLanguageModelOptions).execute(); final RecordedRequest request = server.takeRequest(); assertEquals(\"GET\", request.getMethod()); assertEquals(String.format(PATH_CUSTOMIZATION, id), request.getPath()); assertEquals(result.toString(), \"custom",
        "reference": "@Test public void testGetLanguageModel() throws InterruptedException, FileNotFoundException { String id = \"foo\"; LanguageModel model = loadFixture(\"src/test/resources/speech_to_text/customization.json\", LanguageModel.class); server.enqueue( new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(model))); GetLanguageModelOptions getOptions = new GetLanguageModelOptions.Builder() .customizationId(id) .build(); LanguageModel result = service.getLanguageModel(getOptions).execute(); final RecordedRequest request = server.takeRequest(); assertEquals(\"GET\", request.getMethod()); assertEquals(String.format(PATH_CUSTOMIZATION, id), request.getPath()); assertEquals(result.toString(), model.toString()); }"
    },
    {
        "id": 129,
        "original": "@Test public void testCreateCustomization() throws InterruptedException, FileNotFoundException { Customization customization = loadFixture(\"src/test/resources/speech_to_text/customization.json\", Customization.class); server.enqueue( new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(customization))); Customization result = service .createCustomization(customization.getName(), SpeechModel.EN_GB_BROADBANDMODEL, customization.getDescription()) .execute(); final RecordedRequest request = server.takeRequest(); assertEquals(\"POST\", request.getMethod()); assertEquals(PATH_CUSTOMIZATIONS, request.getPath()); assertEquals(result.toString(), customization.toString()); }",
        "prediction": "@Test public void testCreateCustomization()throws InterruptedException, FileNotFoundException { LanguageModel customization = loadFixture(\"src/test/resources/speech_to_text/customization.json\", LanguageModel.class); server.enqueue( new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(customization))); LanguageModel result = service.createLanguageModel(customization.getName(), SpeechModel.EN_GB_BROADBANDMODEL, customization.getDescription()).execute(); final RecordedRequest request = server.takeRequest(); assertEquals(\"POST\", request.getMethod()); assertEquals(PATH_CUSTOMIZ",
        "reference": "@Test public void testCreateLanguageModel() throws InterruptedException, FileNotFoundException { LanguageModel model = loadFixture(\"src/test/resources/speech_to_text/customization.json\", LanguageModel.class); server.enqueue( new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(model))); CreateLanguageModel newModel = new CreateLanguageModel.Builder() .name(model.getName()) .baseModelName(\"en-GB_BroadbandModel\") .description(model.getDescription()) .build(); CreateLanguageModelOptions createOptions = new CreateLanguageModelOptions.Builder() .createLanguageModel(newModel) .build(); LanguageModel result = service.createLanguageModel(createOptions).execute(); final RecordedRequest request = server.takeRequest(); assertEquals(\"POST\", request.getMethod()); assertEquals(PATH_CUSTOMIZATIONS, request.getPath()); assertEquals(result.toString(), model.toString()); }"
    },
    {
        "id": 130,
        "original": "@Test public void testDeleteCustomization() throws InterruptedException { String id = \"foo\"; server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(\"{}\")); service.deleteCustomization(id).execute(); final RecordedRequest request = server.takeRequest(); assertEquals(\"DELETE\", request.getMethod()); assertEquals(String.format(PATH_CUSTOMIZATION, id), request.getPath()); }",
        "prediction": "@Test public void testDeleteLanguageModel()throws InterruptedException { String id = \"foo\"; server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(\"{}\")); DeleteLanguageModelOptions deleteLanguageModelOptions = new DeleteLanguageModelOptions.Builder().customizationId(id).build(); service.deleteLanguageModel(deleteLanguageModelOptions).execute(); final RecordedRequest request = server.takeRequest(); assertEquals(\"DELETE\", request.getMethod()); assertEquals(String.format(PATH_CUSTOMIZATION, id), request.getPath()); }",
        "reference": "@Test public void testDeleteLanguageModel() throws InterruptedException { String id = \"foo\"; server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(\"{}\")); DeleteLanguageModelOptions deleteOptions = new DeleteLanguageModelOptions.Builder() .customizationId(id) .build(); service.deleteLanguageModel(deleteOptions).execute(); final RecordedRequest request = server.takeRequest(); assertEquals(\"DELETE\", request.getMethod()); assertEquals(String.format(PATH_CUSTOMIZATION, id), request.getPath()); }"
    },
    {
        "id": 131,
        "original": "@Test public void testGetCorpora() throws InterruptedException, FileNotFoundException { String id = \"foo\"; String corporaAsString = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/corpora.json\")); JsonObject corpora = new JsonParser().parse(corporaAsString).getAsJsonObject(); server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(corporaAsString)); List<Corpus> result = service.getCorpora(id).execute(); final RecordedRequest request = server.takeRequest(); assertEquals(\"GET\", request.getMethod()); assertEquals(String.format(PATH_CORPORA, id), request.getPath()); assertEquals(corpora.get(\"corpora\"), GSON.toJsonTree(result)); }",
        "prediction": "@Test public void testGetCorpora()throws InterruptedException, FileNotFoundException { String id = \"foo\"; String corporaAsString = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/corpora.json\")); JsonObject corpora = new JsonParser().parse(corporaAsString).getAsJsonObject(); server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(corporaAsString)); ListCorporaOptions listOptions = new ListCorporaOptions.Builder().customizationId(id).build(); service.listCorpora(listOptions).execute(); final RecordedRequest request =",
        "reference": "@Test public void testListCorpora() throws InterruptedException, FileNotFoundException { String id = \"foo\"; String corporaAsString = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/corpora.json\")); JsonObject corpora = new JsonParser().parse(corporaAsString).getAsJsonObject(); server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(corporaAsString)); ListCorporaOptions listOptions = new ListCorporaOptions.Builder() .customizationId(id) .build(); Corpora result = service.listCorpora(listOptions).execute(); final RecordedRequest request = server.takeRequest(); assertEquals(\"GET\", request.getMethod()); assertEquals(String.format(PATH_CORPORA, id), request.getPath()); assertEquals(corpora.get(\"corpora\"), GSON.toJsonTree(result.getCorpora())); }"
    },
    {
        "id": 132,
        "original": "@Test public void testGetWords() throws InterruptedException, FileNotFoundException { String id = \"foo\"; String wordsAsStr = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/words.json\")); JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject(); server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr)); List<WordData> result = service.getWords(id, null).execute(); final RecordedRequest request = server.takeRequest(); assertEquals(\"GET\", request.getMethod()); assertEquals(String.format(PATH_WORDS, id), request.getPath()); assertEquals(words.get(\"words\"), GSON.toJsonTree(result)); }",
        "prediction": "@Test public void testGetWords()throws InterruptedException, FileNotFoundException { String id = \"foo\"; String wordsAsStr = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/words.json\")); JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject(); server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr)); ListWordsOptions options = new ListWordsOptions.Builder().customizationId(id).wordType(Word.Type.AUDIO).sort(1).build(); service.listWords(options).execute(); final RecordedRequest request = server.",
        "reference": "@Test public void testListWords() throws InterruptedException, FileNotFoundException { String id = \"foo\"; String wordsAsStr = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/words.json\")); JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject(); server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr)); ListWordsOptions listOptions = new ListWordsOptions.Builder() .customizationId(id) .build(); Words result = service.listWords(listOptions).execute(); final RecordedRequest request = server.takeRequest(); assertEquals(\"GET\", request.getMethod()); assertEquals(String.format(PATH_WORDS, id), request.getPath()); assertEquals(words.get(\"words\"), GSON.toJsonTree(result.getWords())); }"
    },
    {
        "id": 133,
        "original": "@Test public void testGetWordsType() throws InterruptedException, FileNotFoundException { String id = \"foo\"; String wordsAsStr = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/words.json\")); JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject(); server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr)); List<WordData> result = service.getWords(id, Type.ALL).execute(); final RecordedRequest request = server.takeRequest(); assertEquals(\"GET\", request.getMethod()); assertEquals(String.format(PATH_WORDS, id) + \"?word_type=all\", request.getPath()); assertEquals(words.get(\"words\"), GSON.toJsonTree(result)); }",
        "prediction": "@Test public void testGetWordsType()throws InterruptedException, FileNotFoundException { String id = \"foo\"; String wordsAsStr = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/words.json\")); JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject(); server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr)); ListWordsOptions options = new ListWordsOptions.Builder().customizationId(id).wordType(Word.Type.ALL).sort(options.sort().asc()).build(); service.listWords(options).execute(); final RecordedRequest",
        "reference": "@Test public void testListWordsType() throws InterruptedException, FileNotFoundException { String id = \"foo\"; String wordsAsStr = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/words.json\")); JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject(); server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr)); ListWordsOptions listOptions = new ListWordsOptions.Builder() .customizationId(id) .wordType(ListWordsOptions.WordType.ALL) .build(); Words result = service.listWords(listOptions).execute(); final RecordedRequest request = server.takeRequest(); assertEquals(\"GET\", request.getMethod()); assertEquals(String.format(PATH_WORDS, id) + \"?word_type=all\", request.getPath()); assertEquals(words.get(\"words\"), GSON.toJsonTree(result.getWords())); }"
    },
    {
        "id": 134,
        "original": "@Test public void testGetWordsSort() throws InterruptedException, FileNotFoundException { String id = \"foo\"; String wordsAsStr = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/words.json\")); JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject(); server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr)); List<WordData> result = service.getWords(id, null, Sort.ALPHA).execute(); final RecordedRequest request = server.takeRequest(); assertEquals(\"GET\", request.getMethod()); assertEquals(String.format(PATH_WORDS, id) + \"?sort=alphabetical\", request.getPath()); assertEquals(words.get(\"words\"), GSON.toJsonTree(result)); }",
        "prediction": "@Test public void testGetWordsSort()throws InterruptedException, FileNotFoundException { String id = \"foo\"; String wordsAsStr = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/words.json\")); JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject(); server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr)); ListWordsOptions listOptions = new ListWordsOptions.Builder().customizationId(id).wordType(Word.Type.ALPHA).build(); service.listWords(listOptions).execute(); final RecordedRequest request = server.takeRequest();",
        "reference": "@Test public void testListWordsSort() throws InterruptedException, FileNotFoundException { String id = \"foo\"; String wordsAsStr = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/words.json\")); JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject(); server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr)); ListWordsOptions listOptions = new ListWordsOptions.Builder() .customizationId(id) .sort(ListWordsOptions.Sort.ALPHABETICAL) .build(); Words result = service.listWords(listOptions).execute(); final RecordedRequest request = server.takeRequest(); assertEquals(\"GET\", request.getMethod()); assertEquals(String.format(PATH_WORDS, id) + \"?sort=alphabetical\", request.getPath()); assertEquals(words.get(\"words\"), GSON.toJsonTree(result.getWords())); }"
    },
    {
        "id": 135,
        "original": "@Test public void testGetWordsTypeSort() throws InterruptedException, FileNotFoundException { String id = \"foo\"; String wordsAsStr = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/words.json\")); JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject(); server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr)); List<WordData> result = service.getWords(id, Type.ALL, Sort.ALPHA).execute(); final RecordedRequest request = server.takeRequest(); assertEquals(\"GET\", request.getMethod()); assertEquals(String.format(PATH_WORDS, id) + \"?word_type=all&sort=alphabetical\", request.getPath()); assertEquals(words.get(\"words\"), GSON.toJsonTree(result)); }",
        "prediction": "@Test public void testGetWordsTypeSort()throws InterruptedException, FileNotFoundException { String id = \"foo\"; String wordsAsStr = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/words.json\")); JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject(); server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr)); ListWordsOptions listOptions = new ListWordsOptions.Builder().wordType(Word.Type.ALL).build(); service.listWords(listOptions).execute(); final RecordedRequest request = server.takeRequest(); assertEquals(\"GET\",",
        "reference": "@Test public void testListWordsTypeSort() throws InterruptedException, FileNotFoundException { String id = \"foo\"; String wordsAsStr = getStringFromInputStream(new FileInputStream(\"src/test/resources/speech_to_text/words.json\")); JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject(); server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr)); ListWordsOptions listOptions = new ListWordsOptions.Builder() .customizationId(id) .sort(ListWordsOptions.Sort.ALPHABETICAL) .wordType(ListWordsOptions.WordType.ALL) .build(); Words result = service.listWords(listOptions).execute(); final RecordedRequest request = server.takeRequest(); assertEquals(\"GET\", request.getMethod()); assertEquals(String.format(PATH_WORDS, id) + \"?word_type=all&sort=alphabetical\", request.getPath()); assertEquals(words.get(\"words\"), GSON.toJsonTree(result.getWords())); }"
    }
]