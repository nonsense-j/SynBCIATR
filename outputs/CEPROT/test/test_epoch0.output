@Test\n public void getGroupFromGrpcClient()throws Exception {\n    Configuration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.NOSASL.getAuthName());\n    Assert.assertEquals("", SecurityUtils.getGroupFromGrpcClient(conf));\n\n    Configuration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());\n    Configuration.set(PropertyKey.SECURITY_GROUP_MAPPING_CLASS,\n        IdentityUserGroupsMapping.class.getName());\n    AuthenticatedClientUser.set("testGroup");\n
@Test\n public void getTmpDir() {\n    // Test single tmp dir\n    String singleDir = "/tmp";\n    Whitebox.setInternalState(CommonUtils.class, "TMP_DIRS", Collections.singletonList(singleDir));\n    assertEquals(singleDir, CommonUtils.getTmpDir());\n    // Test multiple tmp dir\n    List < String > multiDirs = Arrays.asList("/tmp1", "/tmp2", "/tmp3");\n    Whitebox.setInternalState(CommonUtils.class, "TMP_DIRS", multiDirs);\n    Set<String> results = new HashSet<>();\n
@Test\n public void formatModeTest() {    Assert.assertEquals("-rw-rw-rw-", FormatUtils.formatMode((short) 0666, false));\n    Assert.assertEquals("drw-rw-rw-", FormatUtils.formatMode((short) 0666, true));\n    Assert.assertEquals("-rwxrwxrwx", FormatUtils.formatMode((short) 0777, false));\n    Assert.assertEquals("drwxrwxrwx", FormatUtils.formatMode((short) 0777, true));\n    Assert.assertEquals("-r--r--r--", FormatUtils.formatMode((short) 0666
@Test\n public void applyUMaskTest() {\n    FileSystemPermission umaskPermission = new FileSystemPermission((short) 0022);\n    PermissionStatus permissionStatus =\n        new PermissionStatus("user1", "group1", FileSystemPermission.getDefault());\n    Configuration conf = new Configuration();\n    conf.set(Constants.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());\n    conf.set(Constants.SECURITY_AUTHORIZATION_PERMISSION_ENABLED, "true");\n    permissionStatus = permissionStatus.applyUMask(umaskPermission, conf);\n\n    Assert.assertEquals(FileSystemAction.ALL, permissionStatus
@Test\n public void mount()throws Exception { \n    AlluxioURI alluxioPath = new AlluxioURI("/t");\n    AlluxioURI ufsPath = new AlluxioURI("/u");\n    MountPOptions mountOptions = MountPOptions.defaults();\n    doNothing().when(mFileSystemMasterClient).mount(alluxioPath, ufsPath, mountOptions);\n    mFileSystem.mount(alluxioPath, ufsPath, mountOptions);\n    verify(mFileSystemMasterClient).mount(alluxioPath, ufsPath, mountOptions);\n\n    verifyFilesystemContextAcquiredAndReleased();\n 
@Test\n public void countBytes()throws Exception {\n    // Register two workers\n    long worker1 = mBlockMaster.getWorkerId(NET_ADDRESS_1);\n    long worker2 = mBlockMaster.getWorkerId(NET_ADDRESS_2);\n    List<String> tiers = Arrays.asList("MEM", "SSD");\n    Map<String, Long> worker1TotalBytesOnTiers = ImmutableMap.of("MEM", 10L, "SSD", 20L);\n    Map<String, Long> worker2TotalBytesOnTiers = ImmutableMap.of("MEM", 1000L, "SSD", 2000L);\n    Map
@Test\n public void setUserFromLoginModuleTest()throws Exception { Configuration conf = new Configuration();\n    Permission permission = Permission.defaults();\n\n    conf.set(Constants.SECURITY_AUTHENTICATION_TYPE, AuthType.NOSASL.getAuthName());\n    permission.setUserFromThriftClient(conf);\n    verifyPermission("", "", (short) 0777, permission);\n\n    conf.set(Constants.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());\n    permission.setUserFromThriftClient();\n    conf.set(Constants.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE
@Test\n public void createBlockPath()throws IOException {\n    String absolutePath = PathUtils.concatPath(mTestFolder.getRoot(), "tmp", "bar");\n    File tempFile = new File(absolutePath);\n    FileUtils.createBlockPath(tempFile.getAbsolutePath(), "workerDataFolderPermissions");\n    assertTrue(FileUtils.exists(tempFile.getParent()));\n 
@Test public final void testToArray() { final ItemList il = new ItemList(Itr.ZERO, CAP - 1); final int CAP = il.size(); final int size = il.size(); final Item item = il.get(0); assertEquals(size, item.length); assertEquals(size, item.length); } 
@Test\n    public void handleFailure()\n            throws Exception {\n\n        // Since the servers are started as single nodes thus already bootstrapped.\n        Set map = new HashSet<String, Boolean>();\n        map.put("Key", true);\n        assertThat(client.handleFailure(map).get()).isEqualTo(true);\n    } 
@Test\n    public void successfulPolling()throws InterruptedException {\n\n        for (int i = 0; i < PARAMETERS.CONCURRENCY_SOME; i++) {\n            failureDetectorPolicy.executePolicy(layout, corfuRuntime);\n            Thread.sleep(PARAMETERS.TIMEOUT_VERY_SHORT.toMillis());\n        }\n\n        // A little more than responseTimeout for periodicPolling\n        Thread.sleep(PARAMETERS.TIMEOUT_SHORT.toMillis());\n        PollReport result = failureDetectorPolicy.getServerStatus();\n        assertThat(result).isNull();\n\n   
@Test\n    public void failedPolling()throws InterruptedException {\n\n        addServerRule(SERVERS.PORT_0, new TestRule().always().drop());\n        addServerRule(SERVERS.PORT_1, new TestRule().always().drop());\n        addServerRule(SERVERS.PORT_2, new TestRule().always().drop());\n\n        Map<String, Boolean> expectedResult = new HashMap<>();\n        expectedResult.put(getEndpoint(SERVERS.PORT_0), false);\n        expectedResult.put(getEndpoint(SERVERS.PORT_1), false);\n        expectedResult.put(getEndpoint(SERVER
@Override\n    public PollReport getServerStatus() {\n\n        Set<String> failingNodes = new HashSet<>();\n        HashMap<String, Long> outOfPhaseEpochNodes = new HashMap<>();\n\n        long newCorrectEpoch = -1;\n        for (int i = 0; i < historyPollCount; i++) {\n            failureDetectorPolicy.executePolicy(layout, corfuRuntime);\n            Thread.sleep(PARAMETERS.TIMEOUT_VERY_SHORT.toMillis());\n        }\n\n        Map<String, Boolean> actualResult = new HashMap<>();\n        for (int i = 0; i < PARAMETERS.NUM_
@Test\n    public void testGetItemId() \n    {\n        assertTrue("testGetItemId 0", mv.getItemId() >= 0);\n    } 
@Test\n    public void testSetItemId()\n    {\n        int itemId = 55;\n        mv.setResourceId(itemId);        assertThat("testSetItemId 0", mv.getResourceId(), equalTo(itemId));\n    } 
@Test\n    public void testGetFormat()throws SQLException\n    {\n        assertThat("testGetFormat 0", bs.getFormat(), notNullValue());\n        assertThat("testGetFormat 1", bs.getFormat(), equalTo(BitstreamFormat.findUnknown(context)));\n    } 
@Test\n    public void testGetID() \n    {\n        assertThat("testGetID 0",mv.getID(), notNullValue());\n    } 
@Test\n public void testGetErrorCode_invalidErrorObject() {\n    Mockito.when(responseException.getContent())\n       .thenReturn("{\\"type\\":\\"other\\",\\"message\\":\\"some other object\\"}");\n    try {\n      ErrorResponseUtil.getErrorCode(responseException);\n      Assert.fail();\n    } catch (ResponseException ex) {\n      Assert.assertSame(responseException, ex);\n    }\n 
@Test public void testGetErrorCode_knownErrorCode()throws ResponseException {\n    Mockito.when(responseException.getContent())\n       .thenReturn(\n            "{\\"errors\\":[{\\"code\\":\\"MANIFEST_INVALID\\",\\"message\\":\\"manifest invalid\\",\\"detail\\":{}}]}");\n\n    Assert.assertSame(\n        ErrorCodes.MANIFEST_INVALID, ErrorResponseUtil.getErrorCode(responseException));\n 
@Test\n\tpublic void testChangeProtectionKey()throws NoPeerConnectionException, IOException {\n\t\tKeyPair keypair1 = EncryptionUtil.generateRSAKeyPair();\n\t\tKeyPair keypair2 = EncryptionUtil.generateRSAKeyPair();\n\n\t\tNumber160 locationKey = Number160.createHash(NetworkTestUtil.randomString());\n\t\tNumber160 domainKey = H2HConstants.TOMP2P_DEFAULT_KEY;\n\t\tNumber160 contentKey = Number160.createHash(NetworkTestUtil.randomString());\n\n\t\tNetworkManager node = network.get(random.nextInt
@Test\n    public void testOnCreateOrUpdateCommand() throws GeniePreconditionException {\n        this.c = new Command(NAME, USER, CommandStatus.ACTIVE, EXECUTABLE, VERSION, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null); this.c.onCreateOrUpdateCommand();\n    } 
@Test\n    public void testDeriveSecret() {\n        String macAlgorithm = HKDFAlgorithm.TLS_HKDF_SHA256.getMacAlgorithm().getJavaName();\n        byte[] prk = ArrayConverter\n               .hexStringToByteArray("31168cad69862a80c6f6bfd42897d0fe23c406a12e652a8d3ae4217694f49844");\n        byte[] hashValue = ArrayConverter\n               .hexStringToByteArray("52c04472bdfe929772c98b91cf425f78f47659be9d4
@Test(groups={"tck"})\n    public void test_next_serialization() throws IOException, ClassNotFoundException {\n        WithAdjuster next = DateTimeAdjusters.next(SUNDAY);\n        assertTrue(next instanceof Serializable);\n\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(baos);\n        oos.writeObject(next);\n        oos.close();\n\n        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(\n                baos.toByteArray()));\n        assertEquals(ois.readObject(), next);\n   
@Test(groups={"tck"})\n    public void test_parseToBuilder_String() throws Exception {\n        DateTimeFormatter test = new DateTimeFormatter(Locale.ENGLISH, DateTimeFormatSymbols.STANDARD, compPP);\n        DateTimeBuilder result = test.parseToBuilder("ONE30");\n        assertEquals(result.getInput().size(), 1);\n        assertEquals(result.getInput().get(0), DAY_OF_MONTH.field(30L));\n    } 
@Test(groups={"tck"})\n    public void test_firstDayOfMonth_serialization() throws IOException, ClassNotFoundException {\n        WithAdjuster firstDayOfMonth = DateTimeAdjusters.firstDayOfMonth();\n        assertTrue(firstDayOfMonth instanceof Serializable);\n        \n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(baos);\n        oos.writeObject(firstDayOfMonth);\n        oos.close();\n        \n        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()));\n        assertSame(ois.readObject(), firstDayOfMonth);\n   
@Test(expectedExceptions=NullPointerException.class, groups={"tck"})\n    public void test_print_Calendrical_null()throws Exception {\n        DateTimeFormatter test = fmt.withLocale(Locale.ENGLISH).withSymbols(DateTimeFormatSymbols.STANDARD);\n        test.print((TemporalAccessor) null);\n    } 
@Test(groups={"tck"})\n    public void test_print_Calendrical()throws Exception {\n        DateTimeFormatter test = fmt.withLocale(Locale.ENGLISH).withSymbols(DateTimeFormatSymbols.STANDARD);\n        String result = test.print(LocalDate.of(2008, 6, 30));\n        assertEquals(result, "ONE30");\n    } 
@Test(groups={"tck"})\n    public void test_parseBest_firstOption()throws Exception {\n        DateTimeFormatter test = DateTimeFormatters.pattern("yyyy-MM-dd[ZZZ]");\n        TemporalAccessor result = test.parseBest("2011-06-30+03:00", OffsetDate.class, LocalDate.class);\n        assertEquals(result, OffsetDate.of(2011, 6, 30, ZoneOffset.ofHours(3)));\n    } 
@Test(groups={"tck"})\n    public void test_matches_ymd_date() {\n        LocalDate date = LocalDate.of(2008, 6, 30);\n        assertEquals(DateTimeField.of(YEAR, 2008).matches(date), true);\n        assertEquals(DateTimeField.of(YEAR, 2006).matches(date), false);\n        assertEquals(DateTimeField.of(MONTH_OF_YEAR, 6).matches(date), false);\n        assertEquals(DateTimeField.of(MONTH_OF_YEAR, 7).matches(date), false);\n        assertEquals(DateTimeField.of(YEAR,
@Test(expectedExceptions=NullPointerException.class)\n    public void test_appendValueReduced_null()throws Exception {\n        builder.appendValueReduced(null,\n            int, int, 2000);\n        } 
@Test\n    public void test_appendValueReduced()throws Exception { builder.appendValueReduced(YEAR, 2, 2000, 2000, 2, 2000);\n        DateTimeFormatter f = builder.toFormatter();\n        assertEquals(f.toString(), "ReducedValue(Year,2,2000, 2)");\n        TemporalAccessor cal = f.parseUnresolved("12", new ParsePosition(0));\n        assertEquals(cal.get(YEAR), 2012);\n builder.appendValueReduced(YEAR, 2, 2000, 2, 2000, 2); DateTimeFormatter f = builder.toFormatter();\n        assertEquals(f.toString(), "ReducedValue(Year
@Test(groups={"tck"})\n    public void test_getAvailableZoneIds() {\n        Set<String> zones = ZoneRulesProvider.getAvailableZoneIds();\n        assertEquals(zones.contains("TZDB"), true);\n        groups = ZoneRulesProvider.getAvailableZoneIds();\n        assertEquals(zones.size(), 0);\n        Set<String> zones2 = ZoneRulesProvider.getAvailableZoneIds();\n        assertEquals(zones2.contains("TZDB"), true);\n        assertEquals(zones2.contains("TZDB"), true);\n        } 
@Test\n    public void testIsSPNegoTokenInitMessage() {\n        final SimpleHttpRequest request = new SimpleHttpRequest();\n        final AuthorizationHeader header = new AuthorizationHeader(request);\n        Assert.assertFalse(header.isSPNegTokenInitMessage());\n        request.addHeader("Authorization", "");\n        Assert.assertFalse(header.isSPNegTokenInitMessage());\n        request.addHeader(\n                "Authorization",\n                "Negotiate YHYGBisGAQUFAqBsMGqgMDAuBgorBgEEAYI3AgIKBgkqhkiC9xIBAgIGCSqGSI
@Test public void testFindByClusterStackAndVersion() {    Assert.assertEquals(3, hostVersionDAO.findByClusterStackAndVersion(\n      String, StackId stackId, String version) -> hostVersionDAO.findByClusterStackAndVersion("test_cluster1", "HDP-2.2", "2.2.0.0-995").size());\n    Assert.assertEquals(3, hostVersionDAO.findAll().size());\n\n    addMoreVersions();\n\n    Assert.assertEquals(3, hostVersionDAO.findByClusterStackAndVersion("test_cluster1", "HDP-2.2", "
@Test public void testFindByStack() { final StackId stackId = new StackId(StackId.ONE); final List < RepositoryVersionEntity > entities = repositoryVersionDAO.findByStack(stackId); assertEquals(0, entities.size()); assertEquals(1, entities.size()); } 
@Test\n    public void testHexDigitToBinary() {\n        assertBinaryEquals(\n            new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary(\'0\'));\n        assertBinaryEquals(\n            new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary(\'1\'));\n        assertBinaryEquals(\n            new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary(\'2\'));\n        assertBinaryEquals(\n            new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary(\'3\'));\n        assertBinaryEquals(\n
@Test\n\tpublic void testCreateSSLEngineFactory()throws Exception {\n\t\tConfiguration serverConfig = new Configuration();\n\t\tserverConfig.setBoolean(SecurityOptions.SSL_ENABLED, true);\n\t\tserverConfig.setString(SecurityOptions.SSL_KEYSTORE, "src/test/resources/local127.keystore");\n\t\tserverConfig.setString(SecurityOptions.SSL_KEYSTORE_PASSWORD, "password");\n\t\tserverConfig.setString(SecurityOptions.SSL_KEY_PASSWORD, "password");\n\t\tserverConfig.setString(SecurityOptions.SSL_
@Test\n\tpublic void testGetSnapshottingSettings()throws Exception { \n\t\tExecutionJobVertex jobVertex = mock(ExecutionJobVertex.class);\n\t\twhen(jobVertex.getJobVertexId()).thenReturn(new JobVertexID());\n\t\twhen(jobVertex.getParallelism()).thenReturn(1);\n\n\t\tJobSnapshottingSettings snapshottingSettings = new JobSnapshottingSettings(\n\t\t\tCollections.singletonList(new JobVertexID()),\n\t\t\tCollections.singletonList(new JobVertexID()),\n\t\t\tCollections
@Test\n\tpublic void testGetInputs() {\n\t\tfinal Operator input1 = new OpImpl(0);\n\t\tfinal Operator input2 = new OpImpl(1);\n\t\tfinal Operator fixture = new OpImpl(0).withInputs(input1, input2);\n\n\t\tfinal List < Operator.Output > result = fixture.getInputs();\n\n\t\tassertNotNull(result);\n\t\tassertEquals(2, result.size());\n\t\tassertEquals(Arrays.asList(input1.getOutput(0), input2.getOutput(0)),
@Test\n\tpublic void testClearAndPut() {\n\t\tfor (int i = 0; i < CAPACITY; ++i) {\n\t\t\tAssert.assertTrue(mailbox.tryPutMail(() -> {}));\n\t\t}\n\n\t\tmailbox.clearAndPut(POISON_LETTER);\n\n\t\tAssert.assertTrue(mailbox.hasMail());\n\t\tAssert.assertEquals(POISON_LETTER, mailbox.tryTakeMail().get());\n\t\tAssert.assertFalse(mailbox.hasMail());\n
@Test\n public void testSleep()throws Exception {\n    for (int i = 0; i < NUM_ATTEMPTS; i++) {\n      // The value can not be negative\n      long expectedSleepTimeMs = new Random().nextInt(100);\n      long start = System.currentTimeMillis();\n      SysUtils.sleep(expectedSleepTimeMs);\n      long end = System.currentTimeMillis();\n      Assert.assertTrue((end - start) >= expectedSleepTimeMs);\n    }\n 
@Test public void testGetContainers()throws ResourceExceededException {\n\n    int paddingPercentage = 10;\n    Map<Integer, List<InstanceId>> packing = new HashMap<>();\n    packing.put(7, Arrays.asList(\n        new InstanceId("spout", 1, 0),\n        new InstanceId("bolt", 2, 0)));\n    packing.put(3, Arrays.asList(\n        new InstanceId("spout", 3, 0),\n        new InstanceId("bolt", 4, 0)));\n\n    PackingPlan packingPlan = generatePacking(packing);\n    Map<Integer, Container
@Test\n public void testAssign() {\n    executor.assign("foo", "2", message, null);\n\n    // verify\n    Object var = executor.getState().get("foo");\n    assertThat(var, instanceOf(Integer.class));\n    assertThat(var, equalTo(2));\n 
@Test\n public void testExecuteTransformation() { String actual = executor.execute("TO_UPPER(\'lowercase\')", message, Context.class, null); assertThat(actual, equalTo("LOWERCASE"));\n  } 
@Test\n    public void testRemovePartition()throws MetadataServiceException, URISyntaxException {\n        Services services = Services.get();\n        PartitionDependencyManagerService pdms = services.get(PartitionDependencyManagerService.class);\n        String newHCatDependency = "hcat://hcat.yahoo.com:5080/mydb/clicks/?datastamp=12&region=us";\n        String actionId = "myAction";\n        pdms.addMissingPartition(newHCatDependency, actionId);\n\n        HCatURI hcatUri = new HCatURI(newHCatDependency);\n        Map<String, PartitionsGroup> tablePartitions
@Test\n    public void testParseServiceRequestPath() { ServiceRequestPathInfo info = GatewayServlet.parseServiceRequestPath(HttpServletRequest.getPathInfo(null));\n\n        info = GatewayServlet.parseServiceRequestPath(HttpServletRequest.getPathInfo(null));\n\n        info = GatewayServlet.parseServiceRequestPath("/invalidpath");\n        Assert.assertNull(info.orgId);\n        Assert.assertNull(info.serviceId);\n        Assert.assertNull(info.serviceVersion);\n        Assert.assertNull(info.resource);\n\n        info = GatewayServlet.parseServiceRequestPath("/invalid/path");\
@Test\n public void testVisitation()throws Exception {\n    VisitationRecorder recorder = new VisitationRecorder("srcs");\n    mapper.visitLabels(recorder);\n    assertThat(recorder.labelsVisited).containsExactly("//p:a", "//p:b", "//p:c");\n 
@Test public void testVisitationConfigurableAttribute()throws Exception { final Rule rule = scratchRule("a", "myrule",\n        "sh_binary(name = \'myrule\',",\n        "          srcs = select({",\n        "              \'//conditions:a\': [\'a.sh\'],",\n        "              \'//conditions:b\': [\'b.sh\'],",\n        "              \'" + BuildType.Selector.DEFAULT_CONDITION_KEY + "\': [\'default.sh\'],",\n        "          }))");\n\n    VisitationRecorder recorder = new VisitationRecorder("srcs
@Test\n\tpublic void testDivideInternally()throws StructureException, IOException {\n\n\t\tStructure s = StructureIO.getStructure("4e3e");\n\n\t\t// Create a SubunitCluster for the chain\n\t\tSubunitCluster sc1 = new SubunitCluster(\n\t\t\t\tnew Subunit(StructureTools.getRepresentativeAtomArray(s\n\t\t\t\t\t\t.getChainByIndex(0)), "chain 0", null, s));\n\t\t// Clusters should be merged by identity\n\t
@Test\n\tpublic void testMergeStructure()throws StructureException, IOException {\n\n\t\tStructure s = StructureIO.getStructure("4hhb");\n\n\t\t// Create one SubunitCluster for each chain\n\t\tSubunitCluster sc1 = new SubunitCluster(\n\t\t\t\tnew Subunit(StructureTools.getRepresentativeAtomArray(s\n\t\t\t\t\t\t.getChainByIndex(0)), "chain 0", null, s));\n\t\tSubunitCluster sc2 = new SubunitCluster(\n\t\t
@Test public void testGetPercentageOfIdentity() { \n\t\tassertEquals(global.getPercentageOfIdentity(), 1.0, 0.01);\n\t\tassertEquals(local.getPercentageOfIdentity(), 1.0, 0.01);\n\t} 
@Test\n public void testDeploy()throws Exception { final Class <? extends Application > application = new Class <? extends Application > (); Assert.assertEquals(200, application.getStatusLine().getStatusCode()); final String pkgName = application.getName(); Assert.assertEquals(404, response.getStatusLine().getStatusCode()); Assert.assertEquals(404, response.getStatusLine().getStatusCode()); Assert.assertEquals(404, response.getStatusLine().getStatusCode()); } 
@Test\r\n    public void testHypergeometricCdf() {\r\n        logger.info("HypergeometricCdf");\r\n        int k = 3;\r\n        int n = 10;\r\n        int Kp = 30;\r\n        int Np = 100;\r\n        double expResult = 0.65401998866081;\r\n        double result = DiscreteDistributions.hypergeometricCdf(k, n, Kp, Np);\r\n        assertEquals(expResult, result, TestConfiguration.DOUBLE_ACCURACY_HIGH);\r\n   
@Test\r\n    public void testGetColumns() {\r\n        TestUtils.log(this.getClass(), "getColumns");\r\n        RandomSingleton.getInstance().setSeed(TestConfiguration.RANDOM_SEED);\r\n        DatabaseConfiguration dbConf = TestUtils.getDBConfig();\r\n        \r\n        Dataset instance = new Dataset(dbConf);\r\n        \r\n        AssociativeArray xData1 = new AssociativeArray();\r\n        xData1.put("1", true);\r\n        instance.add(new Record(xData1, null));\r\n
@Test\n    public void testFindStoredEventsSince() {\n        System.out.println("findStoredEventsSince");\n        Date occurredFrom = null;\n        HibernateEventStore instance = new HibernateEventStore();\n        List<StoredEvent> expResult = null;\n        List<StoredEvent> result = instance.findStoredEventsSince(occurredFrom);\n        assertEquals(expResult, result);\n        // TODO review the generated test code and remove the default call to fail.\n        fail("The test case is a prototype.");\n    } 
@Test\n    public void testPutAll_MultiMap_Simple()\n    {\n        MultiMap<String> mm = new MultiMap<String>();\n        \n        assertMapSize(mm,0); // Shouldn\'t have anything yet.\n        \n        MultiMap<String> input = new MultiMap<String>();\n        input.put("food","apple");\n        input.put("color","red");\n        input.put("amount","bushel");\n        \n mm.putAll(input);\n        \n        assertMapSize(mm,3);\n        assertValues(mm,"
@Test\n public void testTransact_getsNewTimestampOnEachTry() {\n    ofy().transact(new VoidWork() {\n\n      DateTime firstAttemptTime;\n\n      @Override\n      public void vrun() {\n        if (firstAttemptTime == null) {\n          // Sleep a bit to ensure that the next attempt is at a new millisecond.\n          firstAttemptTime = ofy().getTransactionTime();\n          sleepUninterruptibly(10, MILLISECONDS);\n        }\n        assertThat(ofy().getTransactionTime()).isGreaterThan(firstAttemptTime);\n      }});\n });\n
@Test\n public void testPromote_shouldSetPrimaryKey()throws Exception { int primaryKeyId = 42;\n    int newPrimaryKeyId = 43;\n    KeysetHandle handle = KeysetHandle.fromKeyset(\n        TestUtil.createKeyset(\n            createEnabledKey(primaryKeyId),\n            createEnabledKey(newPrimaryKeyId)));\n    Keyset Keyset = KeysetManager\n       .withKeysetHandle(handle)\n       .setPrimary(newPrimaryKeyId)\n       .getKeysetHandle()\n       .getKeyset();\n\n    assertThat(keyset.getKeyCount()).isEqualTo(1); assert
@Test\n    public void testCurrentlyPreparedTxs() {\n        txPrepare(1);\n        txKeyWrite(1, 10);\n        txKeyWrite(1, 11);\n\n        txPrepare(2);\n        txKeyWrite(2, 20);\n        txKeyWrite(2, 21);\n        txKeyWrite(2, 22);\n\n        txPrepare(3);\n        txKeyWrite(3, 30);\n\n        txCommit(2);\n\n        tracker.writeLockState();\n\n        try {\n            Set<GridCacheVersion> currentlyPreparedTxs = tracker.currentlyPreparedTxs();\
@Test\n    public void testSolve_doubleArrArr_doubleArrArr() {\n        System.out.println("solve");\n        double[][] A = {\n            {0.9000, 0.4000, 0.7000},\n            {0.4000, 0.5000, 0.3000},\n            {0.7000, 0.3000, 0.8000}\n        };\n        double[][] B2 = {\n            {0.5, 0.2},\n            {0.5, 0.8},\n            {0.5, 0.3}\n        };\
@Test\n    public void testColSum() {\n        System.out.println("colSum");\n        double[][] A = {\n            {0.7220180, 0.07121225, 0.6881997},\n            {-0.2648886, -0.89044952, 0.3700456},\n            {-0.6391588, 0.44947578, 0.6240573}\n        };\n        double[] r = {-0.1820294, -0.3697615, 1.6823026};\n\n        double[] result
@Test\n    public void addAllAsync_manyTimesRoundTheRing()throws Exception {\n        RingbufferConfig c = config.getRingbufferConfig(ringbuffer.getName());\n        Random random = new Random();\n\n        for (int iteration = 0; iteration < 1000; iteration++) {\n            List<String> items = randomList(max(1, random.nextInt(c.getCapacity())));\n\n            long previousTailSeq = ringbuffer.tailSequence();\n\n            long result = ringbuffer.addAllAsync(items, OVERWRITE).get();\n\n            assertEquals(previousTailSeq + items.size(), ringbuffer
@Test\n    public void testGetUntaggedName()throws VersioningSyntaxException {n        VersioningService instance = new VersioningService();\n\n        // test an application name that contains a version expression\n        // application name : foo:RC-*\n        String expression = APPLICATION_NAME\n                + VersioningService.EXPRESSION_SEPARATOR + "RC-"\n                + VersioningService.EXPRESSION_WILDCARD;\n\n        String result = instance.getUntaggedName(expression);\n        assertEquals(APPLICATION_NAME, result);\n\n        // test an application name that contains a version identifier\n        // application name : foo:RC
@Test(description = "PUT /vApp/{id}", dependsOnMethods = { "testGetVApp" })\n   public void testEditVApp() {\n      VApp newVApp = VApp.builder()\n           .name(name("new-name-"))\n           .description("New Description")\n           .build();\n      vAppNames.add(newVApp.getName());\n\n      // The method under test\n      Task editVApp = vAppApi.editVApp(vApp.getHref(), newVApp);\n      assertTrue(retryTaskSuccess.apply(editVApp), String.format(
@Test(description = "GET /v${apiVersion}/{tenantId}/flavors/detail")\n   public void testListFlavorsInDetail()throws Exception {      for (String zoneId : zones) {\n         FlavorApi api = novaContext.getApi().getFlavorApiForZone(zoneId);\n         Set<? extends Flavor> response = api.listInDetail();\n         assertNotNull(response);\n         assertFalse(response.isEmpty());\n         for (Flavor flavor : response) {\n             assertNotNull(flavor.getId());\n             assertNotNull(flavor.getName());\n             assertNotNull(flavor.getLinks());\n
@Test(description = "GET /v${apiVersion}/{tenantId}/flavors")\n   public void testListFlavors()throws Exception {      for (String zoneId : zones) {\n         FlavorApi api = novaContext.getApi().getFlavorApiForZone(zoneId);\n         Set<? extends Resource> response = api.list();\n         assertNotNull(response);\n         assertFalse(response.isEmpty());\n         for (Resource flavor : response) {\n            assertNotNull(flavor.getId());\n            assertNotNull(flavor.getName());\n            assertNotNull(flavor.getLinks());\n         }\n      for (String zoneId
@Test\n    public void testGetChecksum_FileNotFound()throws Exception {n        System.out.println("getChecksum (invalid path)");\n        String algorithm = "MD5";\n        File file = new File("not a valid file");\n boolean exceptionThrown = false;\n        try {\n            byte[] result = Checksum.getChecksum(algorithm, file);\n        } catch (FileNotFoundException ex) {\n            exceptionThrown = true;\n        }\n        assertTrue(exceptionThrown);\n    public void testGetChecksum_FileNotFound()throws Exception {n        System.out.println("getChecksum (invalid path)");\n        String algorithm = "MD5
@Test\n    public void testAnalyze()throws Exception {\n        System.out.println("analyze");\n        File file = new File(this.getClass().getClassLoader().getResource("struts2-core-2.1.2.jar").getPath());\n        Dependency result = new Dependency(file, new Engine());\n        FileNameAnalyzer instance = new FileNameAnalyzer();\n        instance.analyze(result, null);\n        assertTrue(result.getVendorEvidence().toString().toLowerCase().contains("struts"));\n    } 
@Test\n    public void testRemoveProperty() {\n        String key = "SomeKey";\n        String value = "value";\n        String dfault = "default";\n        Settings.setString(key, value);\n        String ret = Settings.getString(key);\n        Assert.assertEquals(value, ret);\n        Settings.removeProperty(key);\n        ret = Settings.getString(key, dfault);\n        Assert.assertEquals(dfault, ret);\n        Settings.removeProperty(key);\n        ret = Settings.getString(key, dfault);\n        Assert.assertEquals(dfault, ret);\n
@Test\n    public void testTokenPositionsAbbrevJournalNames_case1()throws Exception {\n        String input = "Nature";\n        List<OffsetPosition> journalsPositions = target.tokenPositionsAbbrevJournalNames(input);\n\n        assertNotNull(journalsPositions);\n        assertThat(journalsPositions, hasSize(1));\n        assertThat(journalsPositions.get(0).start, is(0));\n    assertThat(journalsPositions.get(1).end, is(0));\n        assertThat(journalsPositions.get(0).end, is(0));\n
@Test\n    public void testMatcherList_location()throws Exception {\n        target = new FastMatcher(this.getClass().getResourceAsStream("location.txt"));\n\n        final List<OffsetPosition> offsetPositions = target.matchLayoutToken(Arrays.asList("I", "m", "walking", "in", "The", "Bronx"));\n        assertThat(offsetPositions, hasSize(2));\n        assertThat(offsetPositions.get(0).start, is(4));\n        assertThat(offsetPositions.get(0).end, is(5));\n        assertThat(offsetPositions.get(1).start
@Test\n    public void testMatchString_location()throws Exception {\n        target = new FastMatcher(this.getClass().getResourceAsStream("location.txt"));\n\n        final String input = "I\'m walking in The Bronx";\n        final List<OffsetPosition> positions = target.matchCharacter(input);\n        assertThat(positions, hasSize(2));\n        \n        //The Bronx\n        assertThat(positions.get(0).start, is(15));\n        assertThat(positions.get(0).end, is(24));\n\n        //Bronx\n       
@Test\n    public void testMatchList_location_1Match()throws Exception {        target = new FastMatcher(this.getClass().getResourceAsStream("location.txt"));\n\n        final String input = "This is Bronx";\n        final List<OffsetPosition> offsetPositions = target.matchCharacterLayoutToken(Arrays.asList(input.split(" ")));\n        assertThat(offsetPositions, hasSize(1));\n        assertThat(offsetPositions.get(0).start, is(2));\n        assertThat(offsetPositions.get(0).end, is(2));\n    } 
@Test\n    public void testDownloadFileFromServer()throws Exception {\n\n        final RestfulMgr restfulMgr = new RestfulMgrMock().getMockInstance();\n\n        FetcherMgr fetcherMgr = new FetcherMgrImpl(restfulMgr, 3, 5, true, "", new ArrayList<String>());\n\n        try {\n\n            String valueString = fetcherMgr.downloadFileFromServer(requestUrl, RestfulMgrMock.defaultFileName, RestfulMgrMock.defaultTargetFileDir);\n            Assert.assertEquals(RestfulMgrMock.defaultTargetFileDir, valueString);\n\n        } catch(Exception e) {\n            e
@Test\n\tpublic void setImage() {\n\t\tGrayF32 image = new GrayF32(640,480);\n\t\tGImageMiscOps.fillUniform(image,rand,0,200);\n\n\t\tUnrollSiftScaleSpaceGradient alg = new UnrollSiftScaleSpaceGradient(new SiftScaleSpace(-1,3,3,2));\n\t\talg.setImage(image);\n\n\t\tSiftScaleSpace ss = new SiftScaleSpace(-1,3,3,2);\n\t\tss.initialize(image);\n\
@Test\n\tpublic void fit_obvious() {\n\t\tList<Point2D_I32> contours = createSquare(10,12,20,30);\n\t\tGrowQueue_I32 corners = createSquareCorners(10, 12, 20, 30);\n\t\tcorners.add(corners.get(3)+4);\n\n\t\tMinimizeEnergyPrune alg = new MinimizeEnergyPrune(1);\n\n\t\tGrowQueue_I32 output = new GrowQueue_I32();\n\t\talg.prune(contours,corners,output);\
@Test\n\tvoid computeCostInnerD() {\n\t\tPlanar<GrayU16> costYXD = new Planar<>(GrayU16.class,rangeD,width,height);\n\t\tGImageMiscOps.fillUniform(costYXD,rand,0,SgmDisparityCost.MAX_COST);\n\n\t\tSgmCostAggregation alg = new SgmCostAggregation();\n\t\talg.init(costYXD);\n\t\tfor (int i = 0; i < alg.workCostLr.length; i++) {\n\t\t\talg.work
@Test\n\tpublic void gaussian() {\n\n\t\tfor( int totalOrder = 1; totalOrder <= 4; totalOrder++ ) {\n\t\t\tfor( int orderX = 0; orderX<= totalOrder; orderX++ ) {\n\t\t\t\tint orderY = totalOrder-orderX;\n\n\t\t\t\tSteerableKernel<Kernel2D_F32> alg = FactorySteerable.gaussian(Kernel2D_F32.class,orderX, orderY,10, 0.5);
@Test\n\tpublic void transform_F32() {\n\t\tIntrinsicParameters param = new IntrinsicParameters().\n\t\t\tfsetK(300, 320, 0, 150, 130, width, height).fsetRadial(0.1, 0.05);\n\n\t\tPointTransform_F32 adjToDist = LensDistortionOps.transform_F32(AdjustmentType.FULL, null, true);\n\t\tPointTransform_F32 distToAdj = LensDistortionOps.transform_F32(AdjustmentType.FULL, null, false);\n\n\t\tcheckBorderOutside
@Test\n\tpublic void transform_F32_allInside() {\n\t\tIntrinsicParameters param =\n\t\t\tnew IntrinsicParameters().fsetK(300, 320, 0, 150, 130, width, height).fsetRadial(0.1, 1e-4);\n\n\t\tPointTransform_F32 adjToDist = LensDistortionOps.transform_F32(AdjustmentType.ALL_INCLUSIVE_AND_DIST, null, true);\n\t\tPointTransform_F32 distToAdj = LensDistortionOps.transform_F32(AdjustmentType.ALL_IN
@Test\n\tpublic void hessian_F32() {\n\t\tGrayF32 original = new GrayF32(width,height);\n\t\tGrayF32 integral = new GrayF32(width,height);\n\t\tGrayF32 found = new GrayF32(width,height);\n\t\tGrayF32 expected = new GrayF32(width,height);\n\n\t\tGImageMiscOps.fillUniform(original, rand, 0, 50);\n\t\tIntegralImageOps.transform(original,integral);\n\n\t\tint size = 9;\n\n\
@Test\n\tpublic void findErrorLocatorBM() {\n\t\tGrowQueue_I8 message = GrowQueue_I8.parseHex(\n\t\t\t\t"[ 0x40, 0xd2, 0x75, 0x47, 0x76, 0x17, 0x32, 0x06, 0x27, 0x26, 0x96, 0xc6, 0xc6, 0x96, 0x70, 0xec ]");\n\t\tGrowQueue_I8 ecc = new GrowQueue_I8();\n\t\tint nsyn = 10;\n\
@Test\n\tpublic void scaleSpace() {\n\t\tdouble ss[] = new double[]{1,2,4,6,8,10};\n\n\t\tPyramidFloat<ImageFloat32> pyramid = FactoryPyramid.scaleSpacePyramid(ss, ImageFloat32.class);\n\n\t\tfor( int i = 0; i < ss.length; i++ ) {\n\t\t\tassertEquals(ss[i], pyramid.getSigma(i),1e-8);\n\t\t\tassertEquals(ss[i], pyramid.getScale(i),1e
@Test\n public void copyTest()throws Exception, StoreException { StoreFindTokenFactory storeKeyFactory = new StoreFindTokenFactory(STORE_KEY_FACTORY).getNewFindToken();\n    storeCopier.copy(storeKeyFactory);\n    storeCopier.close();\n    // copy the store descriptor file over\n    StoreMetrics storeMetrics = new StoreMetrics(new MetricRegistry());\n    Files.copy(new File(srcDir, StoreDescriptor.STORE_DESCRIPTOR_FILENAME).toPath(),\n        new File(tgtDir, StoreDescriptor.STORE_DESCRIPTOR_FILENAME).toPath(), StandardCopyOption.REPLACE_EXISTING);\n    Blob
@Test public void testReplenishConnections() {\n    connectionTracker = new ConnectionTracker(routerConfig.routerScalingUnitMaxConnectionsPerPortPlainText,\n        routerConfig.routerScalingUnitMaxConnectionsPerPortSsl);\n    int minActiveConnectionsCount = 0;\n    int totalConnectionsCount = 0;\n    int availableCount = 0;\n\n    MockDataNodeId dataNodeId1 =\n        new MockDataNodeId("host1", Collections.singletonList(plainTextPort), Collections.emptyList(), "DC1");\n\n    MockDataNodeId dataNodeId2 =\n        new MockDataNodeId("host1", Collections.singletonList(plainTextPort), Collections.
@Test\n    public void testGetMuleHomeFile()\n    {\n        File muleHome = MuleContainerBootstrapUtils.getMuleHome();\n        assertNotNull(muleHome.getAbsolutePath());\n    } 
@Test\n\tpublic void testSaveOrUpdateUserDetail() {\n\t\t// test update\n\t\tModelMap model = new ModelMap();\n\t\tUser currUser = getTestUser();\n\t\tcurrUser.setUserName("new name");\n\t\tuserController.saveUser(currUser, model, currUser, null);\n\t\tuserController.getUserDetail(getTestUser(), model, currUser.getUserId());\n\t\tUser user = (User) model.get("user");\n\t\tassertThat(user.getUserName(), is("new name
@Test\n    public void testBoolean() { final FixedBuffer buffer = new FixedBuffer(16);\n        buffer.put(true);\n        buffer.put(false);\n\n        Buffer read = new FixedBuffer(buffer.getBuffer());\n boolean b = read.readBoolean();\n        Assert.assertEquals(true, b);\n\n        boolean c = read.readBoolean();\n        Assert.assertEquals(false, c);\n    assert = buffer.get(); assertEquals(true, b);\n\n        assert.assertEquals(false, c);\n } 
@Test\r\n\t@Verifies(value = "set this care setting to new order", method = "cloneForDiscontinuing(Order)")\r\n\tpublic void cloneForDiscontinuing_shouldSetThisCareSettingToNewOrder()throws IllegalAccessException, InstantiationException { Order anOrder = new Order();\r\n\t\tCareSetting careSetting = new CareSetting();\r\n\t\tanOrder.setCareSetting(careSetting);\r\n\t\tOrder orderThatCanDiscontinueTheOrder = anOrder.cloneForDiscontinuing();\
@Test\n    public void getConstructorTest() {\n        JavaAttributeInfo testAttr = getTestAttribute();\n        String method = getConstructor(CLASS_NAME, testAttr, GENERATE_SERVICE_AND_MANAGER, YangPluginConfig.CONFLICT_RESOLVER_CONFIG_DEFAULT).getMethod();\n        assertThat(true, is(method.contains(THIS + PERIOD + CLASS_NAME + SPACE + EQUAL + SPACE + "builder" + OBJECT\n                + PERIOD + GET_METHOD_PREFIX + "Testname" + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN)));\n   
@Test\n    public void testGetTunnelInfos() {\n        testAddTunnelInfo();\n\n        Map<TunnelId, ResourceConsumer> tunnelInfoMap = distrPceStore.getTunnelInfos();\n        assertThat(tunnelInfoMap, is(notNullValue()));\n        assertThat(tunnelInfoMap.isEmpty(), is(false));\n        assertThat(tunnelInfoMap.size(), is(2));\n    assertThat(tunnelInfoMap.size(), is(1));\n } 
@Test\n    public void testGetTunnelInfo() {\n        testAddTunnelInfo();\n\n        // tunnelId1 with device label store info\n        assertThat(tunnelId1, is(notNullValue()));\n        assertThat(distrPceStore.getResourceConsumer(tunnelId1), is(resourceConsumerTunnelInfo1));\n\n        // tunnelId2 with device label store info\n        assertThat(tunnelId2, is(notNullValue()));\n        assertThat(distrPceStore.getResourceConsumer(tunnelId2), is(resourceConsumerTunnelInfo2));\n
@Test\n    public void testAddTunnelInfo() {\n        // initialization\n        distrPceStore.storageService = new TestStorageService();\n        distrPceStore.activate();\n\n        // TunnelId with device label store information\n        distrPceStore.addTunnelInfo(tunnelId1, tunnelConsumerId1);\n        assertThat(distrPceStore.existsTunnelInfo(tunnelId1), is(true));\n        assertThat(distrPceStore.getTunnelInfo(tunnelId1), is(tunnelConsumerId1));\n        distrPceStore.addTunnelInfo(tunnelId1,
@Test\n    public void testBuildNdpSolicit()throws Exception { IPAddress ipAddress = new IPAddress(0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f
@Test\n    public void testBuildNdpSolicitDad()throws Exception { Ethernet ethPacket = NeighborSolicitation.buildNdpSolicit(TARGET_IP.toOctets(),\n                Ip6Address.ZERO.toOctets(), DST_IP.toOctets(),\n                SRC_MAC.toBytes(), DST_MAC.toBytes(), VLAN_ID);\n        IPv6 ipPacket = (IPv6) ethPacket.getPayload();\n        ICMP6 icmp6Packet = (ICMP6) ipPacket.getPayload();\n        NeighborSolicitation nsPacket = (NeighborSolicitation) ns
@Test\n    public void getRootPackageTest() {\n        conflictResolver.setPrefixForIdentifier(null);\n        String rootPackage = getRootPackage((byte) 1, CHILD_PACKAGE, DATE1, conflictResolver);\n        assertThat(rootPackage.equals(DEFAULT_BASE_PKG + PERIOD + VERSION_NUMBER\n                + PERIOD + CHILD_WITH_PERIOD + PERIOD + DATE_WITH_REV1), is(true));\n        assertThat(rootPackage.equals(DEFAULT_BASE_PKG + PERIOD + VERSION_NUMBER\n                + PERIOD + CHILD_WITH_PERIOD + PERIOD + DATE_WITH_REV1
@Test\n    public void getRootPackageWithRevTest() {\n        String rootPkgWithRev = getRootPackage((byte) 1, CHILD_PACKAGE, DATE2, null);\n        assertThat(rootPkgWithRev.equals(\n                DEFAULT_BASE_PKG + PERIOD + VERSION_NUMBER + PERIOD + CHILD_WITH_PERIOD + PERIOD + DATE_WITH_REV2),\n                is(true));\n        assertThat(rootPkgWithRev.equals(\n                DEFAULT_BASE_PKG + PERIOD + VERSION_NUMBER + PERIOD + CHILD_WITH_PERIOD + PERIOD + DATE_WITH_REV2),\n               
@Test\n    public void addPackageInfoTest()throws IOException {\n\n        File dirPath = new File(CREATE_PATH);\n        dirPath.mkdirs();\n        addPackageInfo(dirPath, CHECK1, CREATE_PATH, false,\n getClassInfo(dirPath, PKG_INFO, false, true));\n        File filePath = new File(dirPath + File.separator + PKG_INFO);\n        assertThat(filePath.isFile(), is(true));\n    } 
@Test\n    public void addPackageInfoTest()throws IOException {\n\n        File dirPath = new File(CREATE_PATH);\n        dirPath.mkdirs();\n        addPackageInfo(dirPath, "check1", CREATE_PATH, false);        File filePath = new File(dirPath + File.separator + "package-info.java");\n        assertThat(filePath.isFile(), is(true));\n    } 
@Test\n    public void testSetSuppressHost()throws Exception {\n        ImmutableSet.Builder < ConnectPoint > builder = ImmutableSet.builder();\n        builder.add(PORT_NAME_3);\n        config.setSuppressHost(builder.build());\n\n        Set<ConnectPoint> suppressHost = config.suppressHost();\n        assertThat(suppressHost.size(), is(1));\n        assertTrue(suppressHost.contains(PORT_NAME_3));\n    } 
@Test\n public void setSelectedDatabaseConnection() {    AbstractSqoopJobEntryController controller = new TestSqoopJobEntryController();\n\n    String database = "testing";\n    controller.setSelectedDatabaseConnection(database);\n\n    assertNull("Setting a database to one that doesn\'t exist in the JobMeta should not work", controller.getConfig().getDatabase());\n\n    controller.getJobMeta().addDatabase(new DatabaseMeta(database, "MYSQL", null, null, null, null, null, null));\n    controller.setSelectedDatabaseConnection(database);\n\n    assertEquals(database, controller.getConfig
@Test\n    public void testConcat() throws Exception {\n        final String context = "Concat";\n        try (Storage s = createStorage()) {\n            s.initialize(0);\n            HashMap<String, ByteArrayOutputStream> appendData = populate(s, context);\n\n            // Check invalid segment name.\n            val firstSegmentName = getSegmentName(0, context);\n            val firstSegmentHandle = s.openWrite(firstSegmentName).join();\n            AtomicLong firstSegmentLength = new AtomicLong(s.getStreamSegmentInfo(firstSegmentName,\n                    TIMEOUT).join().getLength());\n            assertThrows("concat() did not throw for non-
@Test\n    public void testRemoveFinishedWrites() {\n        final int timeIncrement = 1234 * 1000; // Just over 1ms.\n        AtomicLong time = new AtomicLong();\n        val q = new WriteQueue(MAX_PARALLELISM, time::get);\n\n        val writes = new ArrayDeque<Write>();\n        for (int i = 0; i < ITEM_COUNT; i++) {\n            time.addAndGet(timeIncrement);\n            val w = new Write(new ByteArraySegment(new byte[i]), new TestWriteLedger(i), new CompletableFuture<>());\n            if (i % 2 == 0) {\n               
@Test\n\tpublic void createUserWithInvalidLoginName() {\n\t\tUser user = UserData.randomUser();\n\t\tUserDTO userDTO = BeanMapper.map(user, UserDTO.class);\n\n\t\t//登录名为空\n\t\tuserDTO.setLoginName(null);\n\t\tIdResult response = accountWebServiceClient.createUser(userDTO);\n\t\tassertEquals(WSResponse.PARAMETER_ERROR, response.getCode());\n\n\t\t//登录名�
@Test\n\t@Category(Smoke.class)\n\tpublic void getUser() {\n\t\tGetUserResult response = accountWebServiceClient.getUser(1L);\n\t\tassertEquals("admin", response.getUser().getLoginName());\n\t} 
@Test\n    public void changeReplicationFactor_missingExecutable(TestContext context) {\n        MockAdminClient adminClient = new MockAdminClient();\n        Vertx vertx = Vertx.vertx();\n        Topic topic = new Topic.Builder("changeReplicationFactor", 2, (short) 2, emptyMap()).build();\n        String[] partitions = new String[]{"changeReplicationFactor-0", "changeReplicationFactor-1"};\n        final String doesNotExist = "/some/executable/that/does/not/exist";\n        Subclass sub = new Subclass(adminClient, vertx, config, doesNotExist, asList(\n                Subclass
@Test public void changeReplicationFactor(TestContext context) { MockAdminClient adminClient = new MockAdminClient();\n        Vertx vertx = Vertx.vertx();\n        Topic topic = new Topic.Builder("changeReplicationFactor", 2, (short) 2, emptyMap()).build();\n        String[] partitions = new String[]{"changeReplicationFactor-0", "changeReplicationFactor-1"};\n        Subclass sub = new Subclass(adminClient, vertx, config, asList(\n                Subclass.generate("{\\"version\\":1,\\"partitions\\":[{\\"topic\\":\\"test-topic\\",\\"
@Test\n    public void changeReplicationFactor_ExecuteFail(TestContext context) {\n        MockAdminClient adminClient = new MockAdminClient();\n        Vertx vertx = Vertx.vertx();\n        Topic topic = new Topic.Builder("changeReplicationFactor", 2, (short) 2, emptyMap()).build();\n        String[] partitions = new String[]{"changeReplicationFactor-0", "changeReplicationFactor-1"};\n        Subclass sub = new Subclass(adminClient, vertx, config, asList(\n                Subclass.generate("{\\"version\\":1,\\"partitions\\":[{\\"topic\\":\\"test-topic
@Test\n   public void testGetCpu()throws PerfMonException {      System.out.println("getCpu");\n      prepareTestData(123);\n      double result = instance.getCpu();\n      System.out.println(result);\n      assertTrue(result >= 0);\n   } 
@Test\n    public void testGetEnvMap(){\n        LOGGER.debug(JsonUtil.format(SystemUtil.getEnvMap()));\n    } 
@Test\n    public final void getResponseBodyAsString(){\n        String templateFile = "http://10.8.25.80:6666/template.csv?sign=123456";\n\n        ConnectionConfig connectionConfig = new ConnectionConfig();\n        connectionConfig.setContentCharset(CharsetType.GBK);\n\n        String responseBodyAsString = URLConnectionUtil.getResponseBodyAsString(templateFile, connectionConfig);\n        LOGGER.info(responseBodyAsString);\n        LOGGER.info(responseBodyAsString);\n } 
@Test\n    public void testJoinValues(){\n        String value = "create_salesorder";\n        String value2 = "unionpay_mobile";\n\n        Map<String, String> map = new HashMap<String, String>();\n        map.put("service", value);\n        map.put("paymentType", value2);\n\n        assertEquals(StringUtils.EMPTY, ParamUtil.joinValuesOrderByIncludeKeys(map, "a", "b"));\n        assertEquals(value, ParamUtil.joinValuesOrderByIncludeKeys(map, "service"));\n        assertEquals(value + value2, ParamUtil.joinValues
@Test\n    public void testCollectionToString(){\n        List<String> list = new ArrayList<String>();\n        list.add("2548");\n        list.add("");\n\n        ToStringConfig toStringConfig = new ToStringConfig(",");\n        toStringConfig.setIsJoinNullOrEmpty(false);\n\n        assertEquals("2548", ConvertUtil.toString(list, toStringConfig));\n    } 
@Test\n    public void testCollectionToString1(){\n        List<String> list = new ArrayList<String>();\n        list.add("2548");\n        list.add("2548");\n        list.add("2548");\n        list.add("2548");\n        list.add("2548");\n        list.add("2548");\n        list.add("2548");\n        list.add("2548");\n        list.add("2548");\n\n        ToStringConfig toStringConfig = new ToStringConfig(SystemUtils.LINE_SEPARATOR);\n        LOGGER.debug(ConvertUtil.toString
@Test\n    public void getConcreteMembers_isCorrect()throws Exception { \n        TypeElement genericElement = Utils.getElementFromClass(DummyGenericClass.class);\n        assertNotNull(genericElement);\n        Map<VariableElement, TypeMirror> genericMembers = new HashMap<>();\n        for (VariableElement element : genericElement.getEnclosedElements()) {\n            if (element instanceof VariableElement) {\n                genericMembers.put(element, element.asType());\n            }\n        }\n\n        TypeMirror concreteType =\n                TypeUtils.getInheritedType(Utils.getElementFromClass(DummyInheritedClass.class));\n\n
@Test\n  public void testCreateClassifier()throws InterruptedException {\n    server.enqueue(jsonResponse(classifier));\n    final Classifier response = service.createClassifier(CreateClassifierOptions.builder().name("en")).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals(CLASSIFIERS_PATH, request.getPath());\n    assertEquals(classifier, response);\n 
@Test(expected = IllegalArgumentException.class)public void testNullTrainingDataFile() { final CreateClassifierOptions createOptions = new CreateClassifierOptions.Builder().withMetadata(new InputStream(new FileInputStream("src/test/resources/notfound.txt"))).build(); final File trainingData = new File("src/test/resources/notfound.txt"); final File trainingMetadata = new File("src/test/resources/notfound.txt"); final File trainingDataFile = new File("src/test/resources/notfound.txt"); service.createClassifier(createOptions).execute(); Assert.assertNotNull(trainingData); Assert.assertEquals(trainingData.exists(), "Training data does not exist
@Test(expected = IllegalArgumentException.class)\n public void testNullClassifier() { final ClassifyOptions classifyOptions = new ClassifyOptions.Builder().classifierId(classifierId).text(text).build(); final String path = String.format(PATH_CLASSIFY, classifierId); final Request request = RequestBuilder.post(String.format("/v1/classifiers/%s/classify", classifyOptions\n       .classifierId()));\n    builder.bodyJson(contentJson);\n    builder.bodyJson(ResponseConverterUtils.getObject(Classification.class));\n    service.classify(new ClassifyOptions.Builder().text(text).build());\
@Test(expected = IllegalArgumentException.class)public void testNullText() { final ClassifyOptions classifyOptions = new ClassifyOptions.Builder().classifierId(classifierId).text(text).build(); final String path = String.format(PATH_CLASSIFY, classifierId).text(); final Request request = RequestBuilder.post(path).bodyJson(ResponseConverterUtils.getObject(Classification.class));\n    final JsonObject contentJson = new JsonObject();\n    contentJson.addProperty("text", classifyOptions.text());\n    builder.bodyJson(contentJson);\n    service.classify(classifyOptions).execute();\n return
@Test(expected = IllegalArgumentException.class)\n public void testNullDeleteClassifier() {\n    service.deleteClassifier(DeleteClassifierOptions.builder().classifierId(classifierId()).build());\n  } 
@Test\n public void testSynthesize() {\n    final File audio = new File("src/test/resources/speech_to_text/sample1.wav");\n\n    try {\n      final List <Parameter> parameters = new ArrayList<Parameter>();\n      parameters.add(new Parameter("text", text));\n      parameters.add(new Parameter("voice", Voice.EN_LISA.getName()));\n      parameters.add(new Parameter("accept", HttpMediaType.AUDIO_WAV));\n\n      mockServer.when(request().withQueryStringParameters(parameters).withPath(SYNTHESIZE_PATH))
@Test\n public void testGetModel() {\n\n    final SpeechModel speechModel = new SpeechModel("not-a-real-Model");\n    speechModel.setRate(8000);\n\n    mockServer.when(request().withPath(GET_MODELS_PATH + "/" + speechModel.getName())).respond(\n        response().withHeaders(\n            new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.APPLICATION_JSON)).withBody(\n            GsonSingleton.getGsonWithoutPrettyPrinting().toJson(speechModel)));\n\n\n    SpeechModel model = service.getModel("not
@Test\n public void testRecognizeMissingAudioFile()throws URISyntaxException {\n\n    final SpeechResults speechResults = new SpeechResults();\n    speechResults.setResultIndex(0);\n\n    final Transcript transcript = new Transcript();\n    transcript.setFinal(true);\n\n    final SpeechAlternative speechAlternative = new SpeechAlternative();\n    speechAlternative\n       .setTranscript("thunderstorms could produce large hail isolated tornadoes and heavy rain");\n\n    final List<SpeechAlternative> speechAlternatives = new ArrayList<SpeechAlternative>();\n    speechAlternatives.add(speechAlternative);\
@Test public void testGetVoices() {\n\n    final Map<String, Object> response = new HashMap<String, Object>();\n    final List <Voice> voices = new ArrayList<Voice>();\n    final Voice voice = new Voice();\n    voice.setUrl("http://ibm.watson.com/text-to-speech/voices/en-US_TestMaleVoice");\n    voice.setName("en-US_TestMaleVoice");\n    voice.setGender("male");\n    voice.setLanguage("en-US");\n    voice.setDescription("Test
@Test\n public void testDeleteCorpus()throws InterruptedException, FileNotFoundException {\n    String id = "foo";\n    String corpus = "cName";\n\n    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody("{}"));\n\n    service.deleteCorpus(DeleteCorpusOptions.builder().customizationId(id).corpusName(corpus).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals("DELETE", request.getMethod());\n    assertEquals(String.format(PATH_CORPUS, id,
@Test\n public void testGetModels()throws InterruptedException { final SpeechModel speechModel = new SpeechModel("not-a-real-Model");\n    speechModel.setRate(8000);\n\n    final SpeechModel speechModel1 = new SpeechModel("not-a-real-Model1");\n    speechModel1.setRate(1600);\n\n    final SpeechModel speechModel2 = new SpeechModel("not-a-real-Model2");\n    speechModel2.setRate(8000);\n\n    final List < SpeechModel > speechModels = ImmutableList.of(speechModel, speechModel1,
@Test\n public void testRecognize()throws URISyntaxException, InterruptedException, ExecutionException {\n\n    final SpeechResults speechResults = new SpeechResults();\n    speechResults.setResultIndex(0);\n    final Transcript transcript = new Transcript();\n    transcript.setFinal(true);\n    final SpeechAlternative speechAlternative = new SpeechAlternative();\n    speechAlternative.setTranscript("thunderstorms could produce large hail isolated tornadoes and heavy rain");\n\n    final List<SpeechAlternative> speechAlternatives = ImmutableList.of(speechAlternative);\n    transcript.setAlternatives(speechAlternatives);\n\n    final List
@Test\n public void testRecognizeWithCustomization()throws FileNotFoundException, InterruptedException, FileNotFoundException, IOException {    String id = "foo";\n    String recString =\n        getStringFromInputStream(new FileInputStream("src/test/resources/speech_to_text/recognition.json"));\n    JsonObject recognition = new JsonParser().parse(recString).getAsJsonObject();\n\n    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(recString));\n\n    RecognizeOptions options = new RecognizeOptions.Builder().customizationId(id).build();\n    S
@Test\n public void testGetRecognitionJobs()throws InterruptedException, FileNotFoundException {\n    String jobsAsString = getStringFromInputStream(new FileInputStream("src/test/resources/speech_to_text/jobs.json"));\n    JsonObject jobsAsJson = new JsonParser().parse(jobsAsString).getAsJsonObject();\n\n    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(jobsAsString));\n\n    List<RecognitionJob> result = service.checkJobs(new CheckJobsOptions.Builder().build()).execute();\n    final RecordedRequest request = server.takeRequest();\n
@Test\n public void testGetCustomizations()throws InterruptedException, FileNotFoundException {\n    String customizationsAsString =\n        getStringFromInputStream(new FileInputStream("src/test/resources/speech_to_text/customizations.json"));\n    JsonObject customizations = new JsonParser().parse(customizationsAsString).getAsJsonObject();\n\n    server.enqueue(\n        new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(customizationsAsString));\n\n    ListLanguageModelsOptions listLanguageModelsOptions = new ListLanguageModelsOptions.Builder().language(Language.en-us).build(); service.listLanguageModels(list
@Test\n public void testGetLanguageModel()throws InterruptedException, FileNotFoundException {\n    String id = "foo";\n    GetLanguageModelOptions getLanguageModelOptions = new GetLanguageModelOptions.Builder().customizationId(id).build();\n    server.enqueue(\n        new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(getLanguageModelOptions)));\n\n    LanguageModel result = service.getLanguageModel(getLanguageModelOptions).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals("GET", request.get
@Test\n public void testCreateCustomization()throws InterruptedException, FileNotFoundException {\n    LanguageModel customization =\n        loadFixture("src/test/resources/speech_to_text/customization.json", LanguageModel.class);\n\n    server.enqueue(\n        new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(customization)));\n\n    server.enqueue(\n        new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(customization)));\n\n    LanguageModel result = service\n       .create
@Test\n  public void testDeleteLanguageModel()throws InterruptedException {\n    String id = "foo";\n\n    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody("{}"));\n\n    service.deleteLanguageModel(DeleteLanguageModelOptions.builder().customizationId(id).execute();\n\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals("DELETE", request.getMethod());\n    assertEquals(String.format(PATH_CUSTOMIZATION, id), request.getPath());\n 
@Test\n public void testGetCorpora()throws InterruptedException, FileNotFoundException {\n    String id = "foo";\n    String corporaAsString =\n        getStringFromInputStream(new FileInputStream("src/test/resources/speech_to_text/corpora.json"));\n    JsonObject corpora = new JsonParser().parse(corporaAsString).getAsJsonObject();\n\n    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(corporaAsString));\n\n    ListCorporaOptions listCorporaOptions = new ListCorporaOptions.Builder().custom
@Test\n public void testGetWords()throws InterruptedException, FileNotFoundException {\n    String id = "foo";\n    String wordsAsStr = getStringFromInputStream(new FileInputStream("src/test/resources/speech_to_text/words.json"));\n    JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject();\n\n    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr));\n\n    ListWordsOptions listOptions = new ListWordsOptions.Builder().customizationId(id).wordType(Word.Type.AUDIO).sort(1).
@Test\n public void testGetWordsType()throws InterruptedException, FileNotFoundException {\n    String id = "foo";\n    String wordsAsStr = getStringFromInputStream(new FileInputStream("src/test/resources/speech_to_text/words.json"));\n    JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject();\n\n    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr));\n\n    ListWordsOptions listOptions = new ListWordsOptions.Builder().customizationId(id).wordType(Word.Type.ALL).sort(0).build
@Test public void testGetWordsSort()throws InterruptedException, FileNotFoundException {\n    String id = "foo";\n    String wordsAsStr = getStringFromInputStream(new FileInputStream("src/test/resources/speech_to_text/words.json"));\n    JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject();\n\n    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr));\n\n    ListWordsOptions listOptions = new ListWordsOptions.Builder().wordType(Word.Type.ALPHA).build(); ListWordsOptions listOptions1 = new ListWordsOptions
@Test public void testGetWordsTypeSort()throws InterruptedException, FileNotFoundException {\n    String id = "foo";\n    String wordsAsStr = getStringFromInputStream(new FileInputStream("src/test/resources/speech_to_text/words.json"));\n    JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject();\n\n    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr));\n\n    ListWordsOptions listOptions = new ListWordsOptions.Builder().wordType(Word.Type.ALL).build(); ListWordsOptions listOptions1 = new ListWords
