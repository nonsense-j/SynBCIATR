@Test\n  public void getGroupFromGrpcClient() throws Exception {\n    // When security is not enabled, user and group are not set\n    mConfiguration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.NOSASL.getAuthName());\n    Assert.assertEquals("", SecurityUtils.getGroupFromGrpcClient(mConfiguration));\n\n    mConfiguration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());\n    mConfiguration.set(PropertyKey.SECURITY_GROUP_MAPPING_CLASS,\n        IdentityUserGroupsMapping.class.getName());\n    AuthenticatedClientUser.set("test_client_user");\n    Assert.assertEquals("test_client_user", SecurityUtils.getGroupFromGrpcClient(mConfiguration));\n  }
@Test\n  public void getTmpDir() {\n\n    // Test single tmp dir\n    String singleDir = "/tmp";\n    List<String> singleDirList = Arrays.asList("/tmp");\n    assertEquals(singleDir, CommonUtils.getTmpDir(singleDirList));\n    // Test multiple tmp dir\n    List<String> multiDirs = Arrays.asList("/tmp1", "/tmp2", "/tmp3");\n    Set<String> results = new HashSet<>();\n    for (int i = 0; i < 100 || results.size() != multiDirs.size(); i++) {\n      results.add(CommonUtils.getTmpDir(multiDirs));\n    }\n    assertEquals(new HashSet<>(multiDirs), results);\n  }
@Test\n  public void formatPermissionTest() {\n    Assert.assertEquals("-rw-rw-rw-", FormatUtils.formatMode((short) 0666, false));\n    Assert.assertEquals("drw-rw-rw-", FormatUtils.formatMode((short) 0666, true));\n    Assert.assertEquals("-rwxrwxrwx", FormatUtils.formatMode((short) 0777, false));\n    Assert.assertEquals("drwxrwxrwx", FormatUtils.formatMode((short) 0777, true));\n    Assert.assertEquals("-r--r--r--", FormatUtils.formatMode((short) 0444, false));\n    Assert.assertEquals("dr--r--r--", FormatUtils.formatMode((short) 0444, true));\n    Assert.assertEquals("-r-xr-xr-x", FormatUtils.formatMode((short) 0555, false));\n    Assert.assertEquals("dr-xr-xr-x", FormatUtils.formatMode((short) 0555, true));\n    Assert.assertEquals("-rwxr-xr--", FormatUtils.formatMode((short) 0754, false));\n    Assert.assertEquals("drwxr-xr--", FormatUtils.formatMode((short) 0754, true));\n  }
@Test\n  public void applyUMaskTest() {\n    FileSystemPermission umaskPermission = new FileSystemPermission((short) 0022);\n    PermissionStatus permissionStatus =\n        new PermissionStatus("user1", "group1", FileSystemPermission.getDefault());\n    permissionStatus = permissionStatus.applyUMask(umaskPermission);\n\n    Assert.assertEquals(FileSystemAction.ALL, permissionStatus.getPermission().getUserAction());\n    Assert.assertEquals(FileSystemAction.READ_EXECUTE,\n        permissionStatus.getPermission().getGroupAction());\n    Assert.assertEquals(FileSystemAction.READ_EXECUTE,\n        permissionStatus.getPermission().getOtherAction());\n    Assert.assertEquals(0755, permissionStatus.getPermission().toShort());\n  }
@Test\n  public void mount() throws Exception {\n    AlluxioURI alluxioPath = new AlluxioURI("/t");\n    AlluxioURI ufsPath = new AlluxioURI("/u");\n    MountPOptions mountOptions = MountPOptions.getDefaultInstance();\n    doNothing().when(mFileSystemMasterClient).mount(alluxioPath, ufsPath, mountOptions);\n    mFileSystem.mount(alluxioPath, ufsPath, mountOptions);\n    verify(mFileSystemMasterClient).mount(alluxioPath, ufsPath, mountOptions);\n\n    verifyFilesystemContextAcquiredAndReleased();\n  }
@Test\n  public void countBytes() throws Exception {\n    // Register two workers\n    long worker1 = mBlockMaster.getWorkerId(NET_ADDRESS_1);\n    long worker2 = mBlockMaster.getWorkerId(NET_ADDRESS_2);\n    List<String> tiers = Arrays.asList("MEM", "SSD");\n    Map<String, Long> worker1TotalBytesOnTiers = ImmutableMap.of("MEM", 10L, "SSD", 20L);\n    Map<String, Long> worker2TotalBytesOnTiers = ImmutableMap.of("MEM", 1000L, "SSD", 2000L);\n    Map<String, Long> worker1UsedBytesOnTiers = ImmutableMap.of("MEM", 1L, "SSD", 2L);\n    Map<String, Long> worker2UsedBytesOnTiers = ImmutableMap.of("MEM", 100L, "SSD", 200L);\n    mBlockMaster.workerRegister(worker1, tiers, worker1TotalBytesOnTiers, worker1UsedBytesOnTiers,\n        NO_BLOCKS_ON_TIERS, RegisterWorkerPOptions.getDefaultInstance());\n    mBlockMaster.workerRegister(worker2, tiers, worker2TotalBytesOnTiers, worker2UsedBytesOnTiers,\n        NO_BLOCKS_ON_TIERS, RegisterWorkerPOptions.getDefaultInstance());\n\n    // Check that byte counts are summed correctly.\n    assertEquals(3030, mBlockMaster.getCapacityBytes());\n    assertEquals(303L, mBlockMaster.getUsedBytes());\n    assertEquals(ImmutableMap.of("MEM", 1010L, "SSD", 2020L),\n        mBlockMaster.getTotalBytesOnTiers());\n    assertEquals(ImmutableMap.of("MEM", 101L, "SSD", 202L),\n        mBlockMaster.getUsedBytesOnTiers());\n  }
@Test\n  public void setUserFromLoginModuleTest() throws Exception {\n    Configuration.defaultInit();\n    Permission permission = Permission.defaults();\n\n    // When security is not enabled, user and group are not set\n    Configuration.set(Constants.SECURITY_AUTHENTICATION_TYPE, AuthType.NOSASL.getAuthName());\n    permission.setUserFromThriftClient();\n    verifyPermission("", "", (short) 0777, permission);\n\n    // When authentication is enabled, user and group are inferred from login module\n    Configuration.set(Constants.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());\n    Configuration.set(Constants.SECURITY_LOGIN_USERNAME, "test_login_user");\n    Configuration.set(Constants.SECURITY_GROUP_MAPPING, IdentityUserGroupsMapping.class.getName());\n    Whitebox.setInternalState(LoginUser.class, "sLoginUser", (String) null);\n\n    permission.setUserFromLoginModule();\n    verifyPermission("test_login_user", "test_login_user", (short) 0777, permission);\n  }
@Test\n  public void createBlockPath() throws IOException {\n    String absolutePath = PathUtils.concatPath(mTestFolder.getRoot(), "tmp", "bar");\n    File tempFile = new File(absolutePath);\n    FileUtils.createBlockPath(tempFile.getAbsolutePath(), mWorkerDataFolderPerms);\n    assertTrue(FileUtils.exists(tempFile.getParent()));\n  }
@Test \n  public final void testToArray() {\n    ItemList il = new ItemList(Itr.ZERO);\n    for(int i = 0; i < CAP - 1; i++) {\n      il.add(Itr.ZERO);\n    }\n    assertEquals(CAP, il.finish().length); \n  }
@Test\n    public void handleFailure()\n            throws Exception {\n\n        // Since the servers are started as single nodes thus already bootstrapped.\n        Set<String> set = new HashSet<>();\n        set.add("Key");\n        assertThat(client.handleFailure(set).get()).isEqualTo(true);\n    }
@Test\n    public void successfulPolling() throws InterruptedException {\n\n        for (int i = 0; i < PARAMETERS.CONCURRENCY_SOME; i++) {\n            failureDetectorPolicy.executePolicy(layout, corfuRuntime);\n            Thread.sleep(PARAMETERS.TIMEOUT_VERY_SHORT.toMillis());\n        }\n\n        // A little more than responseTimeout for periodicPolling\n        Thread.sleep(PARAMETERS.TIMEOUT_SHORT.toMillis());\n        PollReport result = failureDetectorPolicy.getServerStatus();\n        assertThat(result.getIsFailurePresent()).isFalse();\n\n    }
@Test\n    public void failedPolling() throws InterruptedException {\n\n        addServerRule(SERVERS.PORT_0, new TestRule().always().drop());\n        addServerRule(SERVERS.PORT_1, new TestRule().always().drop());\n        addServerRule(SERVERS.PORT_2, new TestRule().always().drop());\n\n        Set<String> expectedResult = new HashSet<>();\n        expectedResult.add(getEndpoint(SERVERS.PORT_0));\n        expectedResult.add(getEndpoint(SERVERS.PORT_1));\n        expectedResult.add(getEndpoint(SERVERS.PORT_2));\n\n        pollAndMatchExpectedResult(expectedResult);\n\n        /*\n         * Restarting the server SERVERS.PORT_0. Pings should work normally now.\n         * This is also to demonstrate that we no longer receive the failed\n         * nodes' status in the result map for SERVERS.PORT_0.\n         */\n\n        clearServerRules(SERVERS.PORT_0);\n        // Has only SERVERS.PORT_1 & SERVERS.PORT_2\n        expectedResult.remove(getEndpoint(SERVERS.PORT_0));\n\n        pollAndMatchExpectedResult(expectedResult);\n\n    }
private void pollAndMatchExpectedResult(Set<String> expectedResult)\n            throws InterruptedException {\n\n        final int pollsToDeclareFailure = 10;\n        for (int i = 0; i < pollsToDeclareFailure; i++) {\n            failureDetectorPolicy.executePolicy(layout, corfuRuntime);\n            Thread.sleep(PARAMETERS.TIMEOUT_VERY_SHORT.toMillis());\n        }\n\n        Set<String> actualResult = new HashSet<>();\n        for (int i = 0; i < PARAMETERS.NUM_ITERATIONS_LARGE; i++) {\n            Set<String> tempResult = failureDetectorPolicy.getServerStatus().getFailingNodes();\n            if (tempResult != null) {\n                tempResult.forEach(actualResult::add);\n            }\n            Thread.sleep(PARAMETERS.TIMEOUT_SHORT.toMillis());\n            if (actualResult.equals(expectedResult)) break;\n        }\n        assertThat(actualResult).isEqualTo(expectedResult);\n    }
@Test\n    public void testGetItemId() \n    {\n        assertTrue("testGetItemId 0", mv.getResourceId() >= 0);\n    }
@Test\n    public void testSetItemId()\n    {\n        int itemId = 55;\n        mv.setResourceId(itemId);\n        mv.setResourceTypeId(Constants.ITEM);\n        assertThat("testSetItemId 0", mv.getResourceId(), equalTo(itemId));\n    }
@Test\n    public void testGetFormat() throws SQLException\n    {\n        assertThat("testGetFormat 0", bs.getFormat(context), notNullValue());\n        assertThat("testGetFormat 1", bs.getFormat(context), equalTo(bitstreamFormatService.findUnknown(context)));\n    }
@Test\n    public void testGetValueId() \n    {\n        assertThat("testGetValueId 0",mv.getID(), notNullValue());\n    }
@Test\n  public void testGetErrorCode_invalidErrorObject() {\n    Mockito.when(responseException.getContent())\n        .thenReturn("{\\"type\\":\\"other\\",\\"message\\":\\"some other object\\"}");\n    try {\n      ErrorResponseUtil.getErrorCode(responseException);\n      Assert.fail();\n    } catch (ResponseException ex) {\n      Assert.assertSame(responseException, ex);\n    }\n  }
@Test\n  public void testGetErrorCode_knownErrorCode() throws ResponseException {\n    Mockito.when(responseException.getContent())\n        .thenReturn(\n            "{\\"errors\\":[{\\"code\\":\\"MANIFEST_INVALID\\",\\"message\\":\\"manifest invalid\\",\\"detail\\":{}}]}");\n\n    Assert.assertSame(\n        ErrorCodes.MANIFEST_INVALID, ErrorResponseUtil.getErrorCode(responseException));\n  }
@Test\n\tpublic void testChangeProtectionKey() throws NoPeerConnectionException, IOException, InvalidKeyException,\n\t\t\tSignatureException {\n\t\tKeyPair keypairOld = EncryptionUtil.generateRSAKeyPair();\n\t\tKeyPair keypairNew = EncryptionUtil.generateRSAKeyPair();\n\n\t\tNumber160 locationKey = Number160.createHash(NetworkTestUtil.randomString());\n\t\tNumber160 domainKey = H2HConstants.TOMP2P_DEFAULT_KEY;\n\t\tNumber160 contentKey = Number160.createHash(NetworkTestUtil.randomString());\n\n\t\tNetworkManager node = network.get(random.nextInt(networkSize));\n\n\t\t// put some initial data\n\t\tH2HSharableTestData data = new H2HSharableTestData(NetworkTestUtil.randomString());\n\t\tdata.generateVersionKey();\n\t\tdata.setBasedOnKey(Number160.ZERO);\n\t\tFuturePut putFuture1 = node.getDataManager()\n\t\t\t\t.put(locationKey, domainKey, contentKey, data, keypairOld);\n\t\tputFuture1.awaitUninterruptibly();\n\t\tAssert.assertTrue(putFuture1.isSuccess());\n\n\t\t// change content protection key\n\t\tFuturePut changeFuture = node.getDataManager().changeProtectionKey(locationKey, domainKey,\n\t\t\t\tcontentKey, data.getVersionKey(), data.getBasedOnKey(), data.getTimeToLive(), keypairOld,\n\t\t\t\tkeypairNew, data.getHash());\n\t\tchangeFuture.awaitUninterruptibly();\n\t\tAssert.assertTrue(changeFuture.isSuccess());\n\n\t\t// verify if content protection key has been changed\n\t\tData resData = node.getDataManager().get(locationKey, domainKey, contentKey, data.getVersionKey())\n\t\t\t\t.awaitUninterruptibly().getData();\n\t\tAssert.assertTrue(resData.verify(keypairNew.getPublic(), new H2HSignatureFactory()));\n\t}
@Test\n    public void testOnCreateOrUpdateCommand() throws GeniePreconditionException {\n        this.c = new Command(NAME, USER, CommandStatus.ACTIVE, EXECUTABLE, VERSION);\n        this.c.onCreateOrUpdateCommand();\n    }
@Test\n    public void testDeriveSecret() {\n        String macAlgorithm = HKDFAlgorithm.TLS_HKDF_SHA256.getMacAlgorithm().getJavaName();\n        String hashAlgorithm = DigestAlgorithm.SHA256.getJavaName();\n        byte[] prk = ArrayConverter.hexStringToByteArray("33AD0A1C607EC03B09E6CD9893680CE210ADF300AA1F2660E1B22E10F170F92A");\n        byte[] toHash = ArrayConverter.hexStringToByteArray("");\n        String labelIn = HKDFunction.DERIVED;\n\n        byte[] result = HKDFunction.deriveSecret(macAlgorithm, hashAlgorithm, prk, labelIn, toHash);\n        byte[] resultCorrect = ArrayConverter.hexStringToByteArray("6F2615A108C702C5678F54FC9DBAB69716C076189C48250CEBEAC3576C3611BA");\n        assertArrayEquals(result, resultCorrect);\n    }
@Test(groups={"tck"})\n    public void test_next_serialization() throws IOException, ClassNotFoundException {\n        WithAdjuster next = DateTimeAdjusters.next(SUNDAY);\n        assertTrue(next instanceof Serializable);\n\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(baos);\n        oos.writeObject(next);\n        oos.close();\n\n        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(\n                baos.toByteArray()));\n        assertEquals(ois.readObject(), next);\n    }
@Test(groups={"tck"})\n    public void test_parseToEngine_String() throws Exception {\n        DateTimeFormatter test = new DateTimeFormatter(Locale.ENGLISH, DateTimeFormatSymbols.STANDARD, compPP);\n        CalendricalEngine result = test.parseToBuilder("ONE30");\n        assertEquals(result.getInput().size(), 1);\n        assertEquals(result.getInput().get(0), DAY_OF_MONTH.field(30L));\n    }
@Test(groups={"tck"})\n    public void test_firstDayOfMonth_serialization() throws IOException, ClassNotFoundException {\n        WithAdjuster firstDayOfMonth = DateTimeAdjusters.firstDayOfMonth();\n        assertTrue(firstDayOfMonth instanceof Serializable);\n        \n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(baos);\n        oos.writeObject(firstDayOfMonth);\n        oos.close();\n        \n        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()));\n        assertSame(ois.readObject(), firstDayOfMonth);\n    }
@Test(expectedExceptions=NullPointerException.class, groups={"tck"})\n    public void test_print_Calendrical_null() throws Exception {\n        DateTimeFormatter test = fmt.withLocale(Locale.ENGLISH).withSymbols(DateTimeFormatSymbols.STANDARD);\n        test.print((TemporalAccessor) null);\n    }
@Test(groups={"tck"})\n    public void test_print_Calendrical() throws Exception {\n        DateTimeFormatter test = fmt.withLocale(Locale.ENGLISH).withSymbols(DateTimeFormatSymbols.STANDARD);\n        String result = test.print(LocalDate.of(2008, 6, 30));\n        assertEquals(result, "ONE30");\n    }
@Test(groups={"tck"})\n    public void test_parseBest_firstOption() throws Exception {\n        DateTimeFormatter test = DateTimeFormatters.pattern("yyyy-MM-dd[ZZZ]");\n        TemporalAccessor result = test.parseBest("2011-06-30+03:00", OffsetDate.class, LocalDate.class);\n        assertEquals(result, OffsetDate.of(2011, 6, 30, ZoneOffset.ofHours(3)));\n    }
@Test(groups={"tck"})\n    public void test_matches() {\n        LocalDate date = LocalDate.of(2008, 6, 30);\n        assertEquals(DateTimeField.of(YEAR, 2008).matches(DateTimeField.of(YEAR, 2008)), true);\n        assertEquals(DateTimeField.of(YEAR, 2008).matches(DateTimeField.of(YEAR, 2012)), false);\n        assertEquals(DateTimeField.of(YEAR, 2008).matches(DateTimeField.of(MONTH_OF_YEAR, 2008)), false);\n        assertEquals(DateTimeField.of(YEAR, 2008).matches(date), true);\n        assertEquals(DateTimeField.of(YEAR, 2012).matches(date), false);\n        assertEquals(DateTimeField.of(MONTH_OF_YEAR, 6).matches(date), true);\n        assertEquals(DateTimeField.of(MONTH_OF_YEAR, 7).matches(date), false);\n        assertEquals(DateTimeField.of(MONTH_OF_YEAR, -1).matches(date), false);\n        assertEquals(DateTimeField.of(DAY_OF_MONTH, 30).matches(date), true);\n        assertEquals(DateTimeField.of(DAY_OF_MONTH, 12).matches(date), false);\n        assertEquals(DateTimeField.of(DAY_OF_WEEK, 1).matches(date), true);\n        assertEquals(DateTimeField.of(DAY_OF_WEEK, 2).matches(date), false);\n        assertEquals(DateTimeField.of(HOUR_OF_DAY, 2).matches(date), false);\n    }
@Test(expectedExceptions=NullPointerException.class)\n    public void test_appendValueReduced_null() throws Exception {\n        builder.appendValueReduced(null, 2, 2, 2000);\n    }
@Test\n    public void test_appendValueReduced() throws Exception {\n        builder.appendValueReduced(YEAR, 2, 2, 2000);\n        DateTimeFormatter f = builder.toFormatter();\n        assertEquals(f.toString(), "ReducedValue(Year,2,2000)");\n        TemporalAccessor cal = f.parseUnresolved("12", new ParsePosition(0));\n        assertEquals(cal.get(YEAR), 2012);\n    }
@Test(groups={"tck"})\n    public void test_getAvailableGroupIds() {\n        Set<String> zoneIds = ZoneRulesProvider.getAvailableZoneIds();\n        assertEquals(zoneIds.contains("Europe/London"), true);\n        zoneIds.clear();\n        assertEquals(zoneIds.size(), 0);\n        Set<String> zoneIds2 = ZoneRulesProvider.getAvailableZoneIds();\n        assertEquals(zoneIds2.contains("Europe/London"), true);\n    }
@Test\n    public void testIsSPNegTokenInitMessage() {\n        final SimpleHttpRequest request = new SimpleHttpRequest();\n        final AuthorizationHeader header = new AuthorizationHeader(request);\n        Assert.assertFalse(header.isSPNegTokenInitMessage());\n        request.addHeader("Authorization", "");\n        Assert.assertFalse(header.isSPNegTokenInitMessage());\n        request.addHeader(\n                "Authorization",\n                "Negotiate YHYGBisGAQUFAqBsMGqgMDAuBgorBgEEAYI3AgIKBgkqhkiC9xIBAgIGCSqGSIb3EgECAgYKKwYBBAGCNwICHqI2BDROVExNU1NQAAEAAACXsgjiAwADADEAAAAJAAkAKAAAAAYBsR0AAAAPR0xZQ0VSSU5FU0FE");\n        Assert.assertTrue(header.isSPNegTokenInitMessage());\n    }
@Test\n  public void testFindByClusterStackAndVersion() {\n    Assert.assertEquals(3, hostVersionDAO.findByClusterStackAndVersion("test_cluster1", HDP_22_STACK, "2.2.0.0-995").size());\n    Assert.assertEquals(3, hostVersionDAO.findAll().size());\n\n    addMoreVersions();\n\n    Assert.assertEquals(3, hostVersionDAO.findByClusterStackAndVersion("test_cluster1", HDP_22_STACK, "2.2.0.1-996").size());\n    Assert.assertEquals(3, hostVersionDAO.findByClusterStackAndVersion("test_cluster1", HDP_22_STACK, "2.2.1.0-500").size());\n    Assert.assertEquals(9, hostVersionDAO.findAll().size());\n  }
@Test\n  public void testFindByStack() {\n    createSingleRecord();\n    Assert.assertEquals(0, repositoryVersionDAO.findByStack(BAD_STACK).size());\n    Assert.assertEquals(1, repositoryVersionDAO.findByStack(HDP_206).size());\n  }
@Test\n    public void testHexDigitToBinary() {\n        assertBinaryEquals(\n            new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary(\'0\'));\n        assertBinaryEquals(\n            new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary(\'1\'));\n        assertBinaryEquals(\n            new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary(\'2\'));\n        assertBinaryEquals(\n            new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary(\'3\'));\n        assertBinaryEquals(\n            new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary(\'4\'));\n        assertBinaryEquals(\n            new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary(\'5\'));\n        assertBinaryEquals(\n            new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary(\'6\'));\n        assertBinaryEquals(\n            new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary(\'7\'));\n        assertBinaryEquals(\n            new boolean[]{false, false, false, true}, Conversion.hexDigitToBinary(\'8\'));\n        assertBinaryEquals(\n            new boolean[]{true, false, false, true}, Conversion.hexDigitToBinary(\'9\'));\n        assertBinaryEquals(\n            new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary(\'A\'));\n        assertBinaryEquals(\n            new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary(\'a\'));\n        assertBinaryEquals(\n            new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary(\'B\'));\n        assertBinaryEquals(\n            new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary(\'b\'));\n        assertBinaryEquals(\n            new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary(\'C\'));\n        assertBinaryEquals(\n            new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary(\'c\'));\n        assertBinaryEquals(\n            new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary(\'D\'));\n        assertBinaryEquals(\n            new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary(\'d\'));\n        assertBinaryEquals(\n            new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary(\'E\'));\n        assertBinaryEquals(\n            new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary(\'e\'));\n        assertBinaryEquals(\n            new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary(\'F\'));\n        assertBinaryEquals(\n            new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary(\'f\'));\n        try {\n            Conversion.hexDigitToBinary(\'G\');\n            fail("Thrown " + IllegalArgumentException.class.getName() + " expected");\n        } catch (final IllegalArgumentException e) {\n            // OK\n        }\n    }
@Test\n\tpublic void testCreateSSLEngineFactory() throws Exception {\n\t\tConfiguration serverConfig = createInternalSslConfigWithKeyAndTrustStores();\n\n\t\t// set custom protocol and cipher suites\n\t\tserverConfig.setString(SecurityOptions.SSL_PROTOCOL, "TLSv1");\n\t\tserverConfig.setString(SecurityOptions.SSL_ALGORITHMS, "TLS_DHE_RSA_WITH_AES_128_CBC_SHA,TLS_DHE_RSA_WITH_AES_128_CBC_SHA256");\n\n\t\tfinal SSLEngineFactory serverSSLEngineFactory = SSLUtils.createInternalServerSSLEngineFactory(serverConfig);\n\t\tfinal SSLEngine sslEngine = serverSSLEngineFactory.createSSLEngine();\n\n\t\tassertEquals(1, sslEngine.getEnabledProtocols().length);\n\t\tassertEquals("TLSv1", sslEngine.getEnabledProtocols()[0]);\n\n\t\tassertEquals(2, sslEngine.getEnabledCipherSuites().length);\n\t\tassertThat(sslEngine.getEnabledCipherSuites(), arrayContainingInAnyOrder(\n\t\t\t\t"TLS_DHE_RSA_WITH_AES_128_CBC_SHA", "TLS_DHE_RSA_WITH_AES_128_CBC_SHA256"));\n\t}
@Test\n\tpublic void testGetSnapshottingSettings() throws Exception {\n\t\tExecutionJobVertex jobVertex = mock(ExecutionJobVertex.class);\n\t\twhen(jobVertex.getJobVertexId()).thenReturn(new JobVertexID());\n\t\twhen(jobVertex.getParallelism()).thenReturn(1);\n\n\t\tJobCheckpointingSettings snapshottingSettings = new JobCheckpointingSettings(\n\t\t\tCollections.singletonList(new JobVertexID()),\n\t\t\tCollections.singletonList(new JobVertexID()),\n\t\t\tCollections.singletonList(new JobVertexID()),\n\t\t\t181238123L,\n\t\t\t19191992L,\n\t\t\t191929L,\n\t\t\t123,\n\t\t\tExternalizedCheckpointSettings.none(),\n\t\t\tnull,\n\t\t\tfalse);\n\n\t\tCheckpointStatsTracker tracker = new CheckpointStatsTracker(\n\t\t\t0,\n\t\t\tCollections.singletonList(jobVertex),\n\t\t\tsnapshottingSettings,\n\t\t\tnew UnregisteredMetricsGroup());\n\n\t\tassertEquals(snapshottingSettings, tracker.getSnapshottingSettings());\n\t}
@Test\n\tpublic void testGetInputs() {\n\t\tfinal Operator<?> input1 = new OpImpl(0);\n\t\tfinal Operator<?> input2 = new OpImpl(1);\n\t\tfinal Operator<?> fixture = new OpImpl(0).withInputs(input1, input2);\n\n\t\tfinal List<Operator<?>.Output> result = fixture.getInputs();\n\n\t\tassertNotNull(result);\n\t\tassertEquals(2, result.size());\n\t\tassertEquals(Arrays.asList(input1.getOutput(0), input2.getOutput(0)), result);\n\t}
@Test\n\tpublic void testClearAndPut() throws Exception {\n\n\t\tRunnable letterInstance = () -> {};\n\n\t\tfor (int i = 0; i < CAPACITY; ++i) {\n\t\t\tAssert.assertTrue(mailbox.tryPutMail(letterInstance));\n\t\t}\n\n\t\tList<Runnable> droppedLetters = mailbox.clearAndPut(POISON_LETTER);\n\n\t\tAssert.assertTrue(mailbox.hasMail());\n\t\tAssert.assertEquals(POISON_LETTER, mailbox.tryTakeMail().get());\n\t\tAssert.assertFalse(mailbox.hasMail());\n\t\tAssert.assertEquals(CAPACITY, droppedLetters.size());\n\t}
@Test\n  public void testSleep() throws Exception {\n    for (int i = 0; i < NUM_ATTEMPTS; i++) {\n      // The value can not be negative\n      Duration expectedSleepTime = Duration.ofMillis(new Random().nextInt(100));\n      long start = System.currentTimeMillis();\n      SysUtils.sleep(expectedSleepTime);\n      long end = System.currentTimeMillis();\n      Assert.assertTrue((end - start) >= expectedSleepTime.toMillis());\n    }\n  }
@Test\n  public void testGetContainers() {\n    Resource padding = new Resource(1.0, ByteAmount.fromGigabytes(1), ByteAmount.fromGigabytes(1));\n    Map<Integer, List<InstanceId>> packing = new HashMap<>();\n    packing.put(7, Arrays.asList(\n        new InstanceId("spout", 1, 0),\n        new InstanceId("bolt", 2, 0)));\n    packing.put(3, Arrays.asList(\n        new InstanceId("spout", 3, 0),\n        new InstanceId("bolt", 4, 0)));\n\n    PackingPlan packingPlan = generatePacking(packing);\n    Map<Integer, Container> containers = PackingPlanBuilder.getContainers(\n        packingPlan, packingPlan.getMaxContainerResources(), padding,\n        new HashMap<String, TreeSet<Integer>>(), new TreeSet<Integer>());\n    assertEquals(packing.size(), containers.size());\n    for (Integer containerId : packing.keySet()) {\n      Container foundContainer = containers.get(containerId);\n      assertEquals(padding, foundContainer.getPadding());\n      assertEquals(packingPlan.getMaxContainerResources(), foundContainer.getCapacity());\n      assertEquals(2, foundContainer.getInstances().size());\n    }\n  }
@Test\n  public void testAssign() {\n    executor.assign("foo", "2", message, Context.EMPTY_CONTEXT());\n\n    // verify\n    Object var = executor.getState().get("foo");\n    assertThat(var, instanceOf(Integer.class));\n    assertThat(var, equalTo(2));\n  }
@Test\n  public void testExecuteTransformation() {\n    String actual = executor.execute("TO_UPPER(\'lowercase\')", message, String.class, Context.EMPTY_CONTEXT());\n    assertThat(actual, equalTo("LOWERCASE"));\n  }
@Test\n    public void testRemovePartition() throws Exception {\n        Services services = Services.get();\n        PartitionDependencyManagerService pdms = services.get(PartitionDependencyManagerService.class);\n        String newHCatDependency = "hcat://hcat.yahoo.com:5080/database/mydb/table/clicks/partition/datastamp=12,region=us";\n        String actionId = "myAction";\n        pdms.addMissingPartition(newHCatDependency, actionId);\n\n        HCatURI hcatUri = new HCatURI(newHCatDependency);\n        Map<String, PartitionsGroup> tablePartitionsMap = pdms.getHCatMap().get(hcatUri.getServerEndPoint() + "#" +\n                                                                            hcatUri.getDb()); // clicks\n        assertNotNull(tablePartitionsMap);\n        assertTrue(tablePartitionsMap.containsKey("clicks"));\n        PartitionsGroup missingPartitions = tablePartitionsMap.get(hcatUri.getTable());\n        assertNotNull(missingPartitions);\n\n        // remove with cascading - OFF\n        pdms.removePartition(newHCatDependency, false);\n        assertFalse(missingPartitions.getPartitionsMap().containsKey(hcatUri.getPartitionMap()));\n\n        pdms.addMissingPartition(newHCatDependency, actionId);\n        assertNotNull(missingPartitions);\n\n        // remove with cascading - ON\n        pdms.removePartition(newHCatDependency);\n        assertFalse(pdms.getHCatMap().containsKey(hcatUri.getTable()));\n    }
@Test\n    public void testParseServiceRequestPath() {\n        ServiceRequestPathInfo info = parseServiceRequestPath(null);\n\n        info = parseServiceRequestPath("/invalidpath");\n        Assert.assertNull(info.orgId);\n        Assert.assertNull(info.serviceId);\n        Assert.assertNull(info.serviceVersion);\n        Assert.assertNull(info.resource);\n\n        info = parseServiceRequestPath("/invalid/path");\n        Assert.assertNull(info.orgId);\n        Assert.assertNull(info.serviceId);\n        Assert.assertNull(info.serviceVersion);\n        Assert.assertNull(info.resource);\n\n        info = parseServiceRequestPath("/Org1/Service1/1.0");\n        Assert.assertEquals("Org1", info.orgId);\n        Assert.assertEquals("Service1", info.serviceId);\n        Assert.assertEquals("1.0", info.serviceVersion);\n        Assert.assertNull(info.resource);\n\n        info = parseServiceRequestPath("/MyOrg/Service-99/2.7");\n        Assert.assertEquals("MyOrg", info.orgId);\n        Assert.assertEquals("Service-99", info.serviceId);\n        Assert.assertEquals("2.7", info.serviceVersion);\n        Assert.assertNull(info.resource);\n\n        info = parseServiceRequestPath("/MyOrg/Service-99/2.7/resource");\n        Assert.assertEquals("MyOrg", info.orgId);\n        Assert.assertEquals("Service-99", info.serviceId);\n        Assert.assertEquals("2.7", info.serviceVersion);\n        Assert.assertEquals("/resource", info.resource);\n\n        info = parseServiceRequestPath("/MyOrg/Service-99/2.7/path/to/resource");\n        Assert.assertEquals("MyOrg", info.orgId);\n        Assert.assertEquals("Service-99", info.serviceId);\n        Assert.assertEquals("2.7", info.serviceVersion);\n        Assert.assertEquals("/path/to/resource", info.resource);\n\n        info = parseServiceRequestPath("/MyOrg/Service-99/2.7/path/to/resource?query=1234");\n        Assert.assertEquals("MyOrg", info.orgId);\n        Assert.assertEquals("Service-99", info.serviceId);\n        Assert.assertEquals("2.7", info.serviceVersion);\n        Assert.assertEquals("/path/to/resource?query=1234", info.resource);\n\n        info = parseServiceRequestPath("/MyOrg/Service-99/path/to/resource?query=1234", null, "2.7");\n        Assert.assertEquals("MyOrg", info.orgId);\n        Assert.assertEquals("Service-99", info.serviceId);\n        Assert.assertEquals("2.7", info.serviceVersion);\n        Assert.assertEquals("/path/to/resource?query=1234", info.resource);\n\n        info = parseServiceRequestPath("/MyOrg/Service-99/path/to/resource?query=1234", "application/apiman.2.7+json", null);\n        Assert.assertEquals("MyOrg", info.orgId);\n        Assert.assertEquals("Service-99", info.serviceId);\n        Assert.assertEquals("2.7", info.serviceVersion);\n        Assert.assertEquals("/path/to/resource?query=1234", info.resource);\n\n    }
@Test\n  public void testVisitation() throws Exception {\n    assertThat(getLabelsForAttribute(mapper, "srcs")).containsExactly("//p:a", "//p:b", "//p:c");\n  }
@Test\n  public void testVisitationConfigurableAttribute() throws Exception {\n    Rule rule = scratchRule("a", "myrule",\n        "sh_binary(name = \'myrule\',",\n        "          srcs = select({",\n        "              \'//conditions:a\': [\'a.sh\'],",\n        "              \'//conditions:b\': [\'b.sh\'],",\n        "              \'" + BuildType.Selector.DEFAULT_CONDITION_KEY + "\': [\'default.sh\'],",\n        "          }))");\n\n    assertThat(getLabelsForAttribute(AggregatingAttributeMapper.of(rule), "srcs"))\n        .containsExactlyElementsIn(\n            ImmutableList.of(\n                "//a:a.sh", "//a:b.sh", "//a:default.sh", "//conditions:a", "//conditions:b"));\n  }
@Test\n\tpublic void testDivideInternally() throws StructureException, IOException {\n\n\t\tStructure s = StructureIO.getStructure("4e3e");\n\n\t\t// Create a SubunitCluster for the chain\n\t\tSubunitCluster sc1 = new SubunitCluster(\n\t\t\t\tnew Subunit(StructureTools.getRepresentativeAtomArray(s\n\t\t\t\t\t\t.getChainByIndex(0)), "chain 0", null, s));\n\n\t\tSubunitClustererParameters clustererParameters = new SubunitClustererParameters();\n\t\tclustererParameters.setStructureCoverageThreshold(0.8);\n\t\tclustererParameters.setRMSDThreshold(3.0);\n\t\tclustererParameters.setMinimumSequenceLength(20);\n\n\t\t// Clusters should be merged by identity\n\t\tboolean divided = sc1.divideInternally(clustererParameters);\n\n\t\t// Divided has to be true, and Subunit length shorter than half\n\t\tassertTrue(divided);\n\t\tassertEquals(sc1.size(), 2);\n\t\tassertTrue(sc1.length() < 178);\n\t\tassertEquals(sc1.getAlignedAtomsSubunit(0).length,\n\t\t\t\tsc1.getAlignedAtomsSubunit(1).length);\n\t}
@Test\n\tpublic void testMergeStructure() throws StructureException, IOException {\n\n\t\tStructure s = StructureIO.getStructure("4hhb");\n\n\t\t// Create one SubunitCluster for each chain\n\t\tSubunitCluster sc1 = new SubunitCluster(\n\t\t\t\tnew Subunit(StructureTools.getRepresentativeAtomArray(s\n\t\t\t\t\t\t.getChainByIndex(0)), "chain 0", null, s));\n\t\tSubunitCluster sc2 = new SubunitCluster(\n\t\t\t\tnew Subunit(StructureTools.getRepresentativeAtomArray(s\n\t\t\t\t\t\t.getChainByIndex(1)), "chain 1", null, s));\n\t\tSubunitCluster sc3 = new SubunitCluster(\n\t\t\t\tnew Subunit(StructureTools.getRepresentativeAtomArray(s\n\t\t\t\t\t\t.getChainByIndex(2)), "chain 2", null, s));\n\t\tSubunitCluster sc4 = new SubunitCluster(\n\t\t\t\tnew Subunit(StructureTools.getRepresentativeAtomArray(s\n\t\t\t\t\t\t.getChainByIndex(3)), "chain 3", null, s));\n\n\t\t// Clusters 1 and 3 and 2 and 4 are identical\n\t\tSubunitClustererParameters clustererParameters = new SubunitClustererParameters();\n\t\tclustererParameters.setRMSDThreshold(3.0);\n\t\tclustererParameters.setStructureCoverageThreshold(0.9);\n\n\t\tboolean merged13 = sc1.mergeStructure(sc3,clustererParameters);\n\t\tboolean merged24 = sc2.mergeStructure(sc4,clustererParameters);\n\n\t\t// Merged have to be true, and the merged SubunitCluster is sc1\n\t\tassertTrue(merged13);\n\t\tassertTrue(merged24);\n\t\tassertEquals(sc1.size(), 2);\n\t\tassertEquals(sc2.size(), 2);\n\t\tassertEquals(sc1.length(), 141);\n\t\tassertEquals(sc2.length(), 146);\n\t\tassertEquals(sc1.getAlignedAtomsSubunit(0).length,\n\t\t\t\tsc1.getAlignedAtomsSubunit(1).length);\n\t\tassertEquals(sc2.getAlignedAtomsSubunit(0).length,\n\t\t\t\tsc2.getAlignedAtomsSubunit(1).length);\n\n\t\t// Now test for pseudosymmetry\n\t\tboolean merged = sc1.mergeStructure(sc2, clustererParameters);\n\n\t\tassertTrue(merged);\n\t\tassertEquals(sc1.size(), 4);\n\t\tassertEquals(sc1.length(), 140, 2);\n\t\tassertEquals(sc1.getAlignedAtomsSubunit(0).length,\n\t\t\t\tsc1.getAlignedAtomsSubunit(2).length);\n\n\t}
@Test\n\tpublic void testGetPercentageOfIdentity() {\n\t\tassertEquals(global.getPercentageOfIdentity(false), 1.0, 0.01);\n\t\tassertEquals(local.getPercentageOfIdentity(false), 1.0, 0.01);\n\t}
@Test\n  public void testDeploy() throws Exception {\n    HttpResponse response = deploy(WordCount.class);\n    Assert.assertEquals(200, response.getStatusLine().getStatusCode());\n  }
@Test\r\n    public void testHypergeometricCdf() {\r\n        logger.info("HypergeometricCdf");\r\n        int k = 3;\r\n        int n = 10;\r\n        int Kp = 30;\r\n        int Np = 100;\r\n        double expResult = 0.65401998866081;\r\n        double result = DiscreteDistributions.hypergeometricCdf(k, n, Kp, Np);\r\n        assertEquals(expResult, result, TestConfiguration.DOUBLE_ACCURACY_HIGH);\r\n    }
@Test\r\n    public void testGetColumns() {\r\n        TestUtils.log(this.getClass(), "getColumns");\r\n        RandomSingleton.getInstance().setSeed(TestConfiguration.RANDOM_SEED);\r\n        DatabaseConfiguration dbConf = TestUtils.getDBConfig();\r\n        \r\n        Dataset instance = new Dataset(dbConf);\r\n        \r\n        AssociativeArray xData1 = new AssociativeArray();\r\n        xData1.put("1", true);\r\n        instance.add(new Record(xData1, null));\r\n        \r\n        AssociativeArray xData2 = new AssociativeArray();\r\n        xData2.put("2", 1.0);\r\n        instance.add(new Record(xData2, null));\r\n        \r\n        AssociativeArray xData3 = new AssociativeArray();\r\n        xData3.put("3", (short)1);\r\n        instance.add(new Record(xData3, null));\r\n        \r\n        AssociativeArray xData4 = new AssociativeArray();\r\n        xData4.put("4", "s");\r\n        instance.add(new Record(xData4, null));\r\n        \r\n        Map<Object, TypeInference.DataType> expResult = new LinkedHashMap<>();\r\n        expResult.put("1", TypeInference.DataType.BOOLEAN);\r\n        expResult.put("2", TypeInference.DataType.NUMERICAL);\r\n        expResult.put("3", TypeInference.DataType.ORDINAL);\r\n        expResult.put("4", TypeInference.DataType.CATEGORICAL);\r\n        Map<Object, TypeInference.DataType> result = instance.getXDataTypes();\r\n        assertEquals(expResult, result);\r\n    }
@Test\n    public void testFindStoredEventsSince() {\n        System.out.println("findStoredEventsSince");\n        Date occurredFrom = null;\n        HibernateEventStore instance = new HibernateEventStore();\n        List<StoredEvent> expResult = null;\n        List<StoredEvent> result = instance.findStoredEventsSince(occurredFrom);\n        assertEquals(expResult, result);\n        // TODO review the generated test code and remove the default call to fail.\n        fail("The test case is a prototype.");\n    }
@Test\n    public void testPutAll_MultiMap_Simple()\n    {\n        MultiMap mm = new MultiMap();\n        \n        assertMapSize(mm,0); // Shouldn\'t have anything yet.\n        \n        MultiMap input = new MultiMap();\n        input.put("food","apple");\n        input.put("color","red");\n        input.put("amount","bushel");\n        \n        mm.putAll(input);\n        \n        assertMapSize(mm,3);\n        assertValues(mm,"food","apple");\n        assertValues(mm,"color","red");\n        assertValues(mm,"amount","bushel");\n    }
@Test\n  public void testTransact_getsNewTimestampOnEachTry() {\n    tm().transact(new Runnable() {\n\n      DateTime firstAttemptTime;\n\n      @Override\n      public void run() {\n        if (firstAttemptTime == null) {\n          // Sleep a bit to ensure that the next attempt is at a new millisecond.\n          firstAttemptTime = tm().getTransactionTime();\n          sleepUninterruptibly(10, MILLISECONDS);\n          throw new ConcurrentModificationException();\n        }\n        assertThat(tm().getTransactionTime()).isGreaterThan(firstAttemptTime);\n      }});\n  }
@Test\n  public void testSetPrimary_shouldSetPrimary() throws Exception {\n    int primaryKeyId = 42;\n    int newPrimaryKeyId = 43;\n    KeysetHandle handle = KeysetHandle.fromKeyset(\n        TestUtil.createKeyset(\n            createEnabledKey(primaryKeyId),\n            createEnabledKey(newPrimaryKeyId)));\n    Keyset keyset = KeysetManager\n        .withKeysetHandle(handle)\n        .setPrimary(newPrimaryKeyId)\n        .getKeysetHandle()\n        .getKeyset();\n\n    assertThat(keyset.getKeyCount()).isEqualTo(2);\n    assertThat(keyset.getPrimaryKeyId()).isEqualTo(newPrimaryKeyId);\n  }
@Test\n    public void testCurrentlyPreparedTxs() {\n        txPrepare(1);\n        txKeyWrite(1, 10);\n        txKeyWrite(1, 11);\n\n        txPrepare(2);\n        txKeyWrite(2, 20);\n        txKeyWrite(2, 21);\n        txKeyWrite(2, 22);\n\n        txPrepare(3);\n        txKeyWrite(3, 30);\n\n        txCommit(2);\n\n        tracker.writeLockState();\n\n        try {\n            Set<GridCacheVersion> currentlyPreparedTxs = tracker.currentlyPreparedTxs();\n\n            assertEquals(2, currentlyPreparedTxs.size());\n            assertTrue(currentlyPreparedTxs.contains(nearXidVersion(1)));\n            assertTrue(currentlyPreparedTxs.contains(nearXidVersion(3)));\n        }\n        finally {\n            tracker.writeUnlockState();\n        }\n\n        txKeyWrite(3, 31);\n        txCommit(3);\n\n        tracker.writeLockState();\n\n        try {\n            Set<GridCacheVersion> currentlyPreparedTxs = tracker.currentlyPreparedTxs();\n\n            assertEquals(1, currentlyPreparedTxs.size());\n            assertTrue(currentlyPreparedTxs.contains(nearXidVersion(1)));\n        }\n        finally {\n            tracker.writeUnlockState();\n        }\n    }
@Test\n    public void testSolve_doubleArrArr_doubleArrArr() {\n        System.out.println("solve");\n        double[][] A = {\n            {0.9000, 0.4000, 0.7000},\n            {0.4000, 0.5000, 0.3000},\n            {0.7000, 0.3000, 0.8000}\n        };\n        double[][] B2 = {\n            {0.5, 0.2},\n            {0.5, 0.8},\n            {0.5, 0.3}\n        };\n        double[][] X2 = {\n            {-0.2027027, -1.2837838},\n            {0.8783784, 2.2297297},\n            {0.4729730, 0.6621622}\n        };\n        DenseMatrix x = Math.solve(A, B2);\n        assertEquals(X2.length, x.nrows());\n        assertEquals(X2[0].length, x.ncols());\n        for (int i = 0; i < X2.length; i++) {\n            for (int j = 0; j < X2[i].length; j++) {\n                assertEquals(X2[i][j], x.get(i, j), 1E-7);\n            }\n        }\n    }
@Test\n    public void testColSums() {\n        System.out.println("colSums");\n        double[][] A = {\n            {0.7220180, 0.07121225, 0.6881997},\n            {-0.2648886, -0.89044952, 0.3700456},\n            {-0.6391588, 0.44947578, 0.6240573}\n        };\n        double[] r = {-0.1820294, -0.3697615, 1.6823026};\n\n        double[] result = Math.colSums(A);\n        for (int i = 0; i < r.length; i++) {\n            assertEquals(result[i], r[i], 1E-7);\n        }\n    }
@Test\n    public void addAllAsync_manyTimesRoundTheRing() throws Exception {\n        RingbufferConfig c = config.getRingbufferConfig(ringbuffer.getName());\n        Random random = new Random();\n\n        for (int iteration = 0; iteration < 1000; iteration++) {\n            List<String> items = randomList(max(1, random.nextInt(c.getCapacity())));\n\n            long previousTailSeq = ringbuffer.tailSequence();\n\n            long result = ringbuffer.addAllAsync(items, OVERWRITE).toCompletableFuture().get();\n\n            assertEquals(previousTailSeq + items.size(), ringbuffer.tailSequence());\n\n            if (ringbuffer.tailSequence() < c.getCapacity()) {\n                assertEquals(0, ringbuffer.headSequence());\n            } else {\n                assertEquals(ringbuffer.tailSequence() - c.getCapacity() + 1, ringbuffer.headSequence());\n            }\n            assertEquals(ringbuffer.tailSequence(), result);\n\n            long startSequence = previousTailSeq + 1;\n            for (int k = 0; k < items.size(); k++) {\n                assertEquals(items.get(k), ringbuffer.readOne(startSequence + k));\n            }\n        }\n    }
@Test\n    public void testGetUntaggedName() throws VersioningSyntaxException {\n\n        // test an application name that contains a version expression\n        // application name : foo:RC-*\n        String expression = APPLICATION_NAME\n                + VersioningService.EXPRESSION_SEPARATOR + "RC-"\n                + VersioningService.EXPRESSION_WILDCARD;\n\n        String result = VersioningService.getUntaggedName(expression);\n        assertEquals(APPLICATION_NAME, result);\n\n        // test an application name that contains a version identifier\n        // application name : foo:RC-1.0.0\n        expression = APPLICATION_NAME\n                + VersioningService.EXPRESSION_SEPARATOR + "RC-1.0.0";\n\n        result = VersioningService.getUntaggedName(expression);\n        assertEquals(APPLICATION_NAME, result);\n\n        // test an application name that is an untagged version name\n        // application name : foo\n        expression = APPLICATION_NAME;\n\n        result = VersioningService.getUntaggedName(expression);\n        assertEquals(APPLICATION_NAME, result);\n\n        // test an application name containing a critical pattern\n        // application name : foo:\n        expression = APPLICATION_NAME + VersioningService.EXPRESSION_SEPARATOR;\n\n        try {\n            result = VersioningService.getUntaggedName(expression);\n            fail("the getUntagged method did not throw a VersioningSyntaxException");\n        }\n        catch(VersioningSyntaxException e){}\n    }
@Test(description = "PUT /vApp/{id}", dependsOnMethods = { "testGetVApp" })\n   public void testEditVApp() {\n      VApp newVApp = VApp.builder().name(name("new-name-")).description("New Description").build();\n      vAppNames.add(newVApp.getName());\n\n      // The method under test\n      Task editVApp = vAppApi.editVApp(vApp.getHref(), newVApp);\n      assertTrue(retryTaskSuccess.apply(editVApp), String.format(TASK_COMPLETE_TIMELY, "editVApp"));\n\n      // Get the edited VApp\n      vApp = vAppApi.getVApp(vApp.getHref());\n\n      // Check the required fields are set\n      assertEquals(vApp.getName(), newVApp.getName(),\n               String.format(OBJ_FIELD_EQ, VAPP, "Name", newVApp.getName(), vApp.getName()));\n      assertEquals(vApp.getDescription(), newVApp.getDescription(),\n               String.format(OBJ_FIELD_EQ, VAPP, "Description", newVApp.getDescription(), vApp.getDescription()));\n   }
@Test(description = "GET /v${apiVersion}/{tenantId}/flavors/detail")\n   public void testListFlavorsInDetail() throws Exception {\n      for (String zoneId : zones) {\n         FlavorApi api = novaContext.getApi().getFlavorApiForZone(zoneId);\n         Set<? extends Flavor> response = api.listInDetail().concat().toImmutableSet();\n         assertNotNull(response);\n         assertFalse(response.isEmpty());\n         for (Flavor flavor : response) {\n             assertNotNull(flavor.getId());\n             assertNotNull(flavor.getName());\n             assertNotNull(flavor.getLinks());\n             assertTrue(flavor.getRam() > 0);\n             assertTrue(flavor.getDisk() > 0);\n             assertTrue(flavor.getVcpus() > 0);\n         }\n      }\n   }
@Test(description = "GET /v${apiVersion}/{tenantId}/flavors")\n   public void testListFlavors() throws Exception {\n      for (String zoneId : zones) {\n         FlavorApi api = novaContext.getApi().getFlavorApiForZone(zoneId);\n         Set<? extends Resource> response = api.list().concat().toImmutableSet();\n         assertNotNull(response);\n         assertFalse(response.isEmpty());\n         for (Resource flavor : response) {\n            assertNotNull(flavor.getId());\n            assertNotNull(flavor.getName());\n            assertNotNull(flavor.getLinks());\n         }\n      }\n   }
@Test\n    public void testGetChecksum_FileNotFound() throws Exception {\n        System.out.println("getChecksum (invalid path)");\n        String algorithm = "MD5";\n        File file = new File("not a valid file");\n        boolean exceptionThrown = false;\n        try {\n            byte[] result = Checksum.getChecksum(algorithm, file);\n        } catch (IOException ex) {\n            exceptionThrown = true;\n        }\n        assertTrue(exceptionThrown);\n    }
@Test\n    public void testAnalyze() throws Exception {\n        System.out.println("analyze");\n        File file = new File(this.getClass().getClassLoader().getResource("struts2-core-2.1.2.jar").getPath());\n        Dependency result = new Dependency(file);\n        FileNameAnalyzer instance = new FileNameAnalyzer();\n        instance.analyze(result, null);\n        assertTrue(result.getVendorEvidence().toString().toLowerCase().contains("struts"));\n    }
@Test\n    public void testRemoveProperty() {\n        String key = "SomeKey";\n        String value = "value";\n        String dfault = "default";\n        getSettings().setString(key, value);\n        String ret = getSettings().getString(key);\n        Assert.assertEquals(value, ret);\n        getSettings().removeProperty(key);\n        ret = getSettings().getString(key, dfault);\n        Assert.assertEquals(dfault, ret);\n    }
@Test\n    public void testInAbbrevJournalNames_case1() throws Exception {\n        String input = "Nature";\n        List<OffsetPosition> journalsPositions = target.tokenPositionsAbbrevJournalNames(input);\n\n        assertNotNull(journalsPositions);\n        assertThat(journalsPositions, hasSize(1));\n        assertThat(journalsPositions.get(0).start, is(0));\n    }
@Test\n    public void testMatcherList_location() throws Exception {\n        target = new FastMatcher(this.getClass().getResourceAsStream("location.txt"));\n        final String input = "I\'m walking in The Bronx";\n        List<LayoutToken> tokenisedInput = GrobidAnalyzer.getInstance().tokenizeWithLayoutToken(input);\n\n        final List<OffsetPosition> offsetPositions = target.matchLayoutToken(tokenisedInput);\n        assertThat(offsetPositions, hasSize(2));\n        assertThat(offsetPositions.get(0).start, is(8));\n        assertThat(offsetPositions.get(0).end, is(10));\n        assertThat(offsetPositions.get(1).start, is(10));\n        assertThat(offsetPositions.get(1).end, is(10));\n    }
@Test\n    public void testMatchString_location() throws Exception {\n        target = new FastMatcher(this.getClass().getResourceAsStream("location.txt"));\n\n        final String input = "I\'m walking in The Bronx";\n        final List<OffsetPosition> positions = target.matchCharacter(input);\n        assertThat(positions, hasSize(2));\n        \n        //The Bronx\n        assertThat(positions.get(0).start, is(15));\n        assertThat(positions.get(0).end, is(24));\n\n        //Bronx\n        assertThat(positions.get(1).start, is(19));\n        assertThat(positions.get(1).end, is(24));\n    }
@Test\n    public void testMatchList_location_1Match() throws Exception {\n        target = new FastMatcher(this.getClass().getResourceAsStream("location.txt"));\n\n        final String input = "This is Bronx";\n        List<LayoutToken> tokenisedInput = GrobidAnalyzer.getInstance().tokenizeWithLayoutToken(input);\n        final List<OffsetPosition> offsetPositions = target.matchCharacterLayoutToken(tokenisedInput);\n        assertThat(offsetPositions, hasSize(1));\n        assertThat(offsetPositions.get(0).start, is(4));\n        assertThat(offsetPositions.get(0).end, is(4));\n    }
@Test\n    public void testDownloadFileFromServer() throws Exception {\n\n        final RestfulMgr restfulMgr = new RestfulMgrMock().getMockInstance();\n\n        FetcherMgr fetcherMgr = new FetcherMgrImpl(restfulMgr, 3, 5, true, "", new ArrayList<String>());\n\n        try {\n\n            String valueString = fetcherMgr.downloadFileFromServer(requestUrl, RestfulMgrMock.defaultFileName,\n                    "./disconf");\n            Assert.assertEquals(RestfulMgrMock.defaultFileName, valueString);\n\n        } catch (Exception e) {\n            e.printStackTrace();\n            Assert.assertTrue(false);\n        }\n    }
@Test\n\tpublic void setImage() {\n\t\tGrayF32 image = new GrayF32(640,480);\n\t\tGImageMiscOps.fillUniform(image,rand,0,200);\n\n\n\t\tUnrollSiftScaleSpaceGradient alg = new UnrollSiftScaleSpaceGradient(new SiftScaleSpace(-1,3,3,2));\n\t\talg.setImage(image);\n\n\t\tSiftScaleSpace ss = new SiftScaleSpace(-1,3,3,2);\n\t\tss.initialize(image);\n\n\t\tGrayF32 derivX = new GrayF32(640,480);\n\t\tGrayF32 derivY = new GrayF32(640,480);\n\n\t\tint total = 0;\n\t\tdo {\n\t\t\tfor (int i = 0; i < ss.getNumScales(); i++, total++ ) {\n\t\t\t\tGrayF32 scaleImage = ss.getImageScale(i);\n\n\t\t\t\tderivX.reshape(scaleImage.width,scaleImage.height);\n\t\t\t\tderivY.reshape(scaleImage.width,scaleImage.height);\n\n\t\t\t\tGImageDerivativeOps.gradient(DerivativeType.THREE,scaleImage,derivX,derivY, BorderType.EXTENDED);\n\n\t\t\t\tUnrollSiftScaleSpaceGradient.ImageScale found = alg.usedScales.get(total);\n\n\t\t\t\tBoofTesting.assertEquals(derivX,found.derivX,1e-4);\n\t\t\t\tBoofTesting.assertEquals(derivY,found.derivY,1e-4);\n\t\t\t\tassertEquals(ss.computeSigmaScale(i),found.sigma,1e-4);\n\t\t\t\tassertEquals(image.width/(double)scaleImage.width,found.imageToInput,1e-4);\n\n\t\t\t}\n\n\t\t} while( ss.computeNextOctave() );\n\t}
@Test\n\tpublic void prune_obvious() {\n\t\tList<Point2D_I32> contours = createSquare(10,12,20,30);\n\t\tGrowQueue_I32 corners = createSquareCorners(10, 12, 20, 30);\n\t\tcorners.add(corners.get(3)+4);\n\n\t\tMinimizeEnergyPrune alg = new MinimizeEnergyPrune(1);\n\n\t\tGrowQueue_I32 output = new GrowQueue_I32();\n\t\talg.prune(contours, corners, output);\n\n\t\tassertEquals(4, output.size());\n\n\t\t// see if the two sets of corners are equivalent, taking in account the possibility of a rotation\n\t\tcheckMatched(corners, output);\n\n\t}
@Test\n\tvoid computeCostInnerD() {\n\t\tPlanar<GrayU16> costYXD = new Planar<>(GrayU16.class,rangeD,width,height);\n\t\tGImageMiscOps.fillUniform(costYXD,rand,0,SgmDisparityCost.MAX_COST);\n\n\t\tSgmCostAggregation alg = new SgmCostAggregation();\n\t\talg.init(costYXD);\n\t\tshort[] workCostLr = alg.workspace.get(0).workCostLr;\n\t\tfor (int i = 0; i < workCostLr.length; i++) {\n\t\t\tworkCostLr[i] = (short)rand.nextInt(SgmDisparityCost.MAX_COST);\n\t\t}\n\n\t\tGrayU16 costXD = costYXD.getBand(2);\n\n\t\tint x = rangeD + 2;  // x-value in image\n\t\tint pathI = 3;       // location along the path\n\n\t\tint idxCost = costXD.getIndex(0,x); // x=row, d=col\n\t\tint idxWork = alg.lengthD*pathI;\n\n\t\t// Compute the cost using this algorithm\n\t\talg.computeCostInnerD(costXD,idxCost,idxWork, rangeD, workCostLr);\n\n\t\t// Now compare it to a brute force solution\n\t\tfor (int d = 1; d < rangeD-1; d++) {\n\t\t\tint cost_p_d = costXD.get(d,x);\n\n\t\t\tint l0 = workArray(alg,pathI,d);\n\t\t\tint l1 = workArray(alg,pathI,d-1) + alg.penalty1;\n\t\t\tint l2 = workArray(alg,pathI,d+1) + alg.penalty1;\n\t\t\tint l3 = alg.penalty2;\n\n\t\t\tint v = min(min(min(l0,l1),l2),l3);\n\n\t\t\tint expected = cost_p_d + v;\n\t\t\tint found = workArray(alg,pathI+1,d);\n\n\t\t\tassertEquals(expected,found);\n\t\t}\n\t}
@Test\n\tpublic void gaussian() {\n\n\t\tfor( int totalOrder = 1; totalOrder <= 4; totalOrder++ ) {\n\t\t\tfor( int orderX = 0; orderX<= totalOrder; orderX++ ) {\n\t\t\t\tint orderY = totalOrder-orderX;\n\n\t\t\t\tSteerableKernel<Kernel2D_F32> alg = FactorySteerable.gaussian(Kernel2D_F32.class,orderX,orderY, -1, 10);\n\n\t\t\t\tKernel2D_F32 k = alg.compute(0.1);\n\n\t\t\t\t// make sure its not zero.\n\t\t\t\tboolean notZero = false;\n\t\t\t\tfor( int y = 0; y < k.width; y++ ) {\n\t\t\t\t\tfor( int x = 0; x < k.width; x++ ) {\n\t\t\t\t\t\tif( k.get(x,y) != 0 )\n\t\t\t\t\t\t\tnotZero=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tassertTrue(notZero);\n\t\t\t}\n\t\t}\n\t}
@Test\n\tpublic void transform_F32_fullView() {\n\t\tIntrinsicParameters param = new IntrinsicParameters().\n\t\t\t\tfsetK(300, 320, 0, 150, 130, width, height).fsetRadial(0.1, 0.05);\n\n\t\tPointTransform_F32 adjToDist = LensDistortionOps.transform_F32(AdjustmentType.FULL_VIEW, param, null, true);\n\t\tPointTransform_F32 distToAdj = LensDistortionOps.transform_F32(AdjustmentType.FULL_VIEW, param, null, false);\n\n\t\tcheckBorderOutside(adjToDist,distToAdj);\n\n\t\tparam = new IntrinsicParameters().\n\t\t\t\tfsetK(300, 320, 0, 150, 130, width, height).fsetRadial(-0.1,-0.05);\n\t\tadjToDist = LensDistortionOps.transform_F32(AdjustmentType.FULL_VIEW, param, null, true);\n\t\tdistToAdj = LensDistortionOps.transform_F32(AdjustmentType.FULL_VIEW, param, null, false);\n\t\tcheckBorderOutside(adjToDist,distToAdj);\n\t}
@Test\n\tpublic void transform_F32_shrink() {\n\t\tIntrinsicParameters param =\n\t\t\t\tnew IntrinsicParameters().fsetK(300, 320, 0, 150, 130, width, height).fsetRadial(0.1, 1e-4);\n\n\t\tPointTransform_F32 adjToDist = LensDistortionOps.transform_F32(AdjustmentType.SHRINK, param, null, true);\n\t\tPointTransform_F32 distToAdj = LensDistortionOps.transform_F32(AdjustmentType.SHRINK, param, null, false);\n\t\tcheckInside(adjToDist, distToAdj);\n\n\t\t// distort it in the other direction\n\t\tparam = new IntrinsicParameters().fsetK(300, 320, 0, 150, 130, width, height).fsetRadial(-0.1,-1e-4);\n\n\t\tadjToDist = LensDistortionOps.transform_F32(AdjustmentType.SHRINK, param, null, true);\n\t\tdistToAdj = LensDistortionOps.transform_F32(AdjustmentType.SHRINK, param, null, false);\n\n\t\tcheckInside(adjToDist, distToAdj);\n\t}
@Test\n\tpublic void hessian_F32() {\n\t\tGrayF32 original = new GrayF32(width,height);\n\t\tGrayF32 integral = new GrayF32(width,height);\n\t\tGrayF32 found = new GrayF32(width,height);\n\t\tGrayF32 expected = new GrayF32(width,height);\n\n\t\tGImageMiscOps.fillUniform(original, rand, 0, 50);\n\t\tIntegralImageOps.transform(original,integral);\n\n\t\tint size = 9;\n\n\t\tfor( int skip = 1; skip <= 4; skip++ ) {\n\t\t\tfound.reshape(width/skip,height/skip);\n\t\t\texpected.reshape(width/skip,height/skip);\n\t\t\tImplIntegralImageFeatureIntensity.hessianNaive(integral,skip,size,expected);\n\t\t\tIntegralImageFeatureIntensity.hessian(integral,skip,size,found);\n\n\t\t\tBoofTesting.assertEquals(expected,found, 1e-4f);\n\t\t}\n\t}
@Test\n\tpublic void findErrorLocatorPolynomialBM() {\n\t\tGrowQueue_I8 message = GrowQueue_I8.parseHex(\n\t\t\t\t"[ 0x40, 0xd2, 0x75, 0x47, 0x76, 0x17, 0x32, 0x06, 0x27, 0x26, 0x96, 0xc6, 0xc6, 0x96, 0x70, 0xec ]");\n\t\tGrowQueue_I8 ecc = new GrowQueue_I8();\n\t\tint nsyn = 10;\n\t\tint syndromes[] = new int[nsyn];\n\n\t\tReidSolomonCodes alg = new ReidSolomonCodes(8,primitive8);\n\t\talg.generator(nsyn);\n\t\talg.computeECC(message,ecc);\n\n\t\tmessage.data[0] = 0;\n\t\talg.computeSyndromes(message,ecc,syndromes);\n\t\tGrowQueue_I8 errorLocator = new GrowQueue_I8();\n\t\talg.findErrorLocatorPolynomialBM(syndromes,nsyn,errorLocator);\n\t\tassertEquals(2,errorLocator.size);\n\t\tassertEquals(3,errorLocator.get(0));\n\t\tassertEquals(1,errorLocator.get(1));\n\n\t\tmessage.data[6] = 10;\n\t\talg.computeSyndromes(message,ecc,syndromes);\n\t\talg.findErrorLocatorPolynomialBM(syndromes,nsyn,errorLocator);\n\t\tassertEquals(3,errorLocator.size);\n\t\tassertEquals(238,errorLocator.get(0)&0xFF);\n\t\tassertEquals(89,errorLocator.get(1));\n\t\tassertEquals(1,errorLocator.get(2));\n\t}
@Test\n\tpublic void scaleSpace() {\n\t\tdouble ss[] = new double[]{1,2,4,6,8,10};\n\n\t\tPyramidFloat<GrayF32> pyramid = FactoryPyramid.scaleSpacePyramid(ss, GrayF32.class);\n\n\t\tfor( int i = 0; i < ss.length; i++ ) {\n\t\t\tassertEquals(ss[i],pyramid.getSigma(i),1e-8);\n\t\t\tassertEquals(ss[i],pyramid.getScale(i),1e-8);\n\t\t\t// the amount of blur applied to the previous layer should be different\n\t\t\tif( i > 1)\n\t\t\t\tassertTrue(Math.abs(ss[i] - ((PyramidFloatGaussianScale)pyramid).getSigmaLayers()[i])>0.1);\n\t\t}\n\t}
@Test\n  public void copyTest() throws Exception {\n    storeCopier.copy(new StoreFindTokenFactory(STORE_KEY_FACTORY).getNewFindToken());\n    storeCopier.close();\n    // copy the store descriptor file over\n    StoreMetrics storeMetrics = new StoreMetrics(new MetricRegistry());\n    Files.copy(new File(srcDir, StoreDescriptor.STORE_DESCRIPTOR_FILENAME).toPath(),\n        new File(tgtDir, StoreDescriptor.STORE_DESCRIPTOR_FILENAME).toPath(), StandardCopyOption.REPLACE_EXISTING);\n    BlobStore tgt =\n        new BlobStore(STORE_ID, storeConfig, null, null, DISK_IO_SCHEDULER, StoreTestUtils.DEFAULT_DISK_SPACE_ALLOCATOR,\n            storeMetrics, storeMetrics, tgtDir.getAbsolutePath(), STORE_CAPACITY, STORE_KEY_FACTORY, null, null, time);\n    tgt.start();\n    try {\n      // should not be able to get expired or deleted ids\n      StoreKey[] failKeys = {expiredId, deletedId};\n      for (StoreKey key : failKeys) {\n        try {\n          tgt.get(Collections.singletonList(key), EnumSet.allOf(StoreGetOptions.class));\n          fail("Should have failed to get " + key);\n        } catch (StoreException e) {\n          assertEquals("Unexpected StoreErrorCode", StoreErrorCodes.ID_Not_Found, e.getErrorCode());\n        }\n      }\n      // should be able to get the put id\n      StoreInfo storeInfo = tgt.get(Collections.singletonList(putId), EnumSet.noneOf(StoreGetOptions.class));\n      MessageInfo messageInfo = storeInfo.getMessageReadSetInfo().get(0);\n      assertEquals("Size does not match", putData.length, messageInfo.getSize());\n      assertEquals("Size does not match", putData.length, storeInfo.getMessageReadSet().sizeInBytes(0));\n      assertFalse("Should not be deleted or expired", messageInfo.isDeleted() || messageInfo.isExpired());\n      ByteBufferChannel channel = new ByteBufferChannel(ByteBuffer.allocate(putData.length));\n      storeInfo.getMessageReadSet().writeTo(0, channel, 0, putData.length);\n      assertArrayEquals("Data put does not match data copied", putData, channel.getBuffer().array());\n    } finally {\n      tgt.shutdown();\n    }\n  }
@Test\n  public void testReplenishConnections() {\n    connectionTracker = new ConnectionTracker(routerConfig.routerScalingUnitMaxConnectionsPerPortPlainText,\n        routerConfig.routerScalingUnitMaxConnectionsPerPortSsl);\n    // When no connections were ever made to a host:port, connectionTracker should return null, but\n    // initiate connections.\n    int minActiveConnectionsCount = 0;\n    int totalConnectionsCount = 0;\n    int availableCount = 0;\n\n    MockDataNodeId dataNodeId1 =\n        new MockDataNodeId("host1", Collections.singletonList(plainTextPort), Collections.emptyList(), "DC1");\n    MockDataNodeId dataNodeId2 =\n        new MockDataNodeId("host2", Arrays.asList(plainTextPort, sslPort), Collections.emptyList(), "DC1");\n    dataNodeId2.setSslEnabledDataCenters(Collections.singletonList("DC1"));\n    connectionTracker.setMinimumActiveConnectionsPercentage(dataNodeId1, 50);\n    minActiveConnectionsCount += 50 * routerConfig.routerScalingUnitMaxConnectionsPerPortPlainText / 100;\n    connectionTracker.setMinimumActiveConnectionsPercentage(dataNodeId2, 200);\n    minActiveConnectionsCount += routerConfig.routerScalingUnitMaxConnectionsPerPortSsl;\n\n    // call replenishConnections to warm up connections\n    assertCounts(totalConnectionsCount, availableCount);\n    connectionTracker.replenishConnections(this::mockNewConnection, Integer.MAX_VALUE);\n    totalConnectionsCount += minActiveConnectionsCount;\n    assertCounts(totalConnectionsCount, availableCount);\n    List<String> newConnections = getNewlyEstablishedConnections();\n    newConnections.forEach(connectionTracker::checkInConnection);\n    availableCount += minActiveConnectionsCount;\n    assertCounts(totalConnectionsCount, availableCount);\n    Assert.assertTrue(connectionTracker.mayCreateNewConnection("host1", plainTextPort, dataNodeId1));\n    Assert.assertFalse(connectionTracker.mayCreateNewConnection("host2", sslPort, dataNodeId2));\n\n    // remove 2 connections\n    newConnections.stream().limit(2).forEach(connectionTracker::removeConnection);\n    totalConnectionsCount -= 2;\n    availableCount -= 2;\n    assertCounts(totalConnectionsCount, availableCount);\n\n    // replenish connections again\n    connectionTracker.replenishConnections(this::mockNewConnection, Integer.MAX_VALUE);\n    totalConnectionsCount += 2;\n    assertCounts(totalConnectionsCount, availableCount);\n    newConnections = getNewlyEstablishedConnections();\n    newConnections.forEach(connectionTracker::checkInConnection);\n    availableCount += 2;\n    assertCounts(totalConnectionsCount, availableCount);\n\n    // check out connections\n    String conn1 = connectionTracker.checkOutConnection("host1", plainTextPort, dataNodeId1);\n    Assert.assertNotNull(conn1);\n    String conn2 = connectionTracker.checkOutConnection("host2", sslPort, dataNodeId2);\n    Assert.assertNotNull(conn2);\n    availableCount -= 2;\n    assertCounts(totalConnectionsCount, availableCount);\n\n    // destroy one and return the other and then replenish\n    connectionTracker.removeConnection(conn1);\n    connectionTracker.checkInConnection(conn2);\n    totalConnectionsCount -= 1;\n    availableCount += 1;\n    assertCounts(totalConnectionsCount, availableCount);\n    connectionTracker.replenishConnections(this::mockNewConnection, Integer.MAX_VALUE);\n    totalConnectionsCount += 1;\n    assertCounts(totalConnectionsCount, availableCount);\n\n    // check out and destroy all host2 connections\n    String connId;\n    while ((connId = connectionTracker.checkOutConnection("host2", sslPort, dataNodeId2)) != null) {\n      connectionTracker.removeConnection(connId);\n    }\n    totalConnectionsCount -= 2;\n    availableCount -= 2;\n    assertCounts(totalConnectionsCount, availableCount);\n\n    // Replenish connection with rate limit of 1 connection per host per call.\n    connectionTracker.replenishConnections(this::mockNewConnection, 1);\n    totalConnectionsCount += 1;\n    assertCounts(totalConnectionsCount, availableCount);\n    connectionTracker.replenishConnections(this::mockNewConnection, 1);\n    totalConnectionsCount += 1;\n    assertCounts(totalConnectionsCount, availableCount);\n  }
@Test\n    public void testGetMuleHomeFile()\n    {\n        File muleHome = MuleContainerBootstrapUtils.getMuleHome();\n        assertNotNull(muleHome.getAbsolutePath());\n    }
@Test\n\tpublic void testSaveOrUpdateUserDetail() {\n\t\t// test update\n\t\tModelMap model = new ModelMap();\n\t\tUser currUser = getTestUser();\n\t\tcurrUser.setUserName("new name");\n\t\tuserController.saveUser(currUser, model, currUser);\n\t\tuserController.getUserDetail(getTestUser(), model, currUser.getUserId());\n\t\tUser user = (User) model.get("user");\n\t\tassertThat(user.getUserName(), is("new name"));\n\t\tassertThat(user.getPassword(), is(currUser.getPassword()));\n\n\t\tUser admin = getAdminUser();\n\t\tUser temp = new User("temp1", "temp1", "temp1", "temp@nhn.com", Role.USER);\n\t\tuserController.saveUser(admin, model, temp);\n\t\ttemp = new User("temp2", "temp2", "temp2", "temp@nhn.com", Role.USER);\n\t\tuserController.saveUser(admin, model, temp);\n\t\tmodel.clear();\n\t\tcurrUser.setFollowersStr("temp1, temp2");\n\t\tuserController.saveUser(currUser, model, currUser);\n\t\tuserController.getUserDetail(getTestUser(), model, currUser.getUserId());\n\t\tuser = (User) model.get("user");\n\t\tassertThat(user.getFollowers().size(), is(2));\n\t\tassertThat(user.getFollowers().get(0).getUserId(), is("temp1"));\n\t}
@Test\n    public void testBoolean() {\n        Buffer buffer = new FixedBuffer(16);\n        buffer.putBoolean(true);\n        buffer.putBoolean(false);\n\n        Buffer read = new FixedBuffer(buffer.getBuffer());\n        boolean b = read.readBoolean();\n        Assert.assertEquals(true, b);\n\n        boolean c = read.readBoolean();\n        Assert.assertEquals(false, c);\n    }
@Test\r\n\t@Verifies(value = "set this care setting to new order", method = "cloneForDiscontinuing(Order)")\r\n\tpublic void cloneForDiscontinuing_shouldSetThisCareSettingToNewOrder() throws Exception {\r\n\t\tOrder anOrder = new Order();\r\n\t\tCareSetting careSetting = new CareSetting();\r\n\t\tanOrder.setCareSetting(careSetting);\r\n\t\t\r\n\t\tOrder orderThatCanDiscontinueTheOrder = anOrder.cloneForDiscontinuing();\r\n\t\t\r\n\t\tassertEquals(anOrder.getCareSetting(), orderThatCanDiscontinueTheOrder.getCareSetting());\r\n\t}
@Test\n    public void getConstructorTest() {\n        JavaAttributeInfo testAttr = getTestAttribute();\n        YangPluginConfig pluginConfig = new YangPluginConfig();\n        String method = getConstructor(CLASS_NAME, testAttr, GENERATE_SERVICE_AND_MANAGER, pluginConfig);\n        assertThat(true, is(method.contains(THIS + PERIOD + CLASS_NAME + SPACE + EQUAL + SPACE + "builder" + OBJECT\n                + PERIOD + GET_METHOD_PREFIX + "Testname" + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN)));\n    }
@Test\n    public void testGetTunnelInfos() {\n        testAddTunnelInfo();\n\n        Map<TunnelId, ResourceConsumer> tunnelInfoMap = distrPceStore.getTunnelInfos();\n        assertThat(tunnelInfoMap, is(notNullValue()));\n        assertThat(tunnelInfoMap.isEmpty(), is(false));\n        assertThat(tunnelInfoMap.size(), is(2));\n    }
@Test\n    public void testGetTunnelInfo() {\n        testAddTunnelInfo();\n\n        // tunnelId1 with device label store info\n        assertThat(tunnelId1, is(notNullValue()));\n        assertThat(distrPceStore.getTunnelInfo(tunnelId1), is(tunnelConsumerId1));\n\n        // tunnelId2 with device label store info\n        assertThat(tunnelId2, is(notNullValue()));\n        assertThat(distrPceStore.getTunnelInfo(tunnelId2), is(tunnelConsumerId2));\n    }
@Test\n    public void testAddTunnelInfo() {\n        // initialization\n        distrPceStore.storageService = new TestStorageService();\n        distrPceStore.activate();\n\n        // TunnelId with device label store information\n        distrPceStore.addTunnelInfo(tunnelId1, tunnelConsumerId1);\n        assertThat(distrPceStore.existsTunnelInfo(tunnelId1), is(true));\n        assertThat(distrPceStore.getTunnelInfo(tunnelId1), is(tunnelConsumerId1));\n        distrPceStore.addTunnelInfo(tunnelId2, tunnelConsumerId2);\n        assertThat(distrPceStore.existsTunnelInfo(tunnelId2), is(true));\n        assertThat(distrPceStore.getTunnelInfo(tunnelId2), is(tunnelConsumerId2));\n    }
@Test\n    public void testBuildNdpSolicit() throws Exception {\n        final Ethernet ethPacket = NeighborSolicitation.buildNdpSolicit(TARGET_IP,\n                SRC_IP, DST_IP, SRC_MAC, DST_MAC, VLAN_ID);\n\n        assertTrue(ethPacket.getDestinationMAC().equals(DST_MAC));\n        assertTrue(ethPacket.getSourceMAC().equals(SRC_MAC));\n        assertTrue(ethPacket.getEtherType() == Ethernet.TYPE_IPV6);\n        assertTrue(ethPacket.getVlanID() == VLAN_ID.id());\n\n        final IPv6 ipPacket = (IPv6) ethPacket.getPayload();\n\n        assertArrayEquals(ipPacket.getSourceAddress(), SRC_IP.toOctets());\n        assertArrayEquals(ipPacket.getDestinationAddress(), DST_IP.toOctets());\n\n        final ICMP6 icmp6Packet = (ICMP6) ipPacket.getPayload();\n        final NeighborSolicitation nsPacket = (NeighborSolicitation) icmp6Packet.getPayload();\n\n        assertArrayEquals(nsPacket.getTargetAddress(), TARGET_IP.toOctets());\n\n        assertEquals("Non-DAD NS should have 1 option", 1, nsPacket.getOptions().size());\n        assertEquals("The option should be SRC_LL_ADDR type", TYPE_SOURCE_LL_ADDRESS,\n                nsPacket.getOptions().stream().findFirst().get().type());\n    }
@Test\n    public void testBuildNdpSolicitDad() throws Exception {\n        Ethernet ethPacket = NeighborSolicitation.buildNdpSolicit(TARGET_IP,\n                Ip6Address.ZERO, DST_IP, SRC_MAC, DST_MAC, VLAN_ID);\n        IPv6 ipPacket = (IPv6) ethPacket.getPayload();\n        ICMP6 icmp6Packet = (ICMP6) ipPacket.getPayload();\n        NeighborSolicitation nsPacket = (NeighborSolicitation) icmp6Packet.getPayload();\n\n        assertEquals("DAD NS should have no option", 0, nsPacket.getOptions().size());\n    }
@Test\n    public void getRootPackageTest() throws ParseException {\n        conflictResolver.setPrefixForIdentifier(null);\n        Date date = simpleDateFormat.parse(DATE1);\n        String rootPackage = getRootPackage((byte) 1, CHILD_PACKAGE, date, conflictResolver);\n        assertThat(rootPackage.equals(DEFAULT_BASE_PKG + PERIOD + VERSION_NUMBER\n                + PERIOD + CHILD_WITH_PERIOD + PERIOD + DATE_WITH_REV1), is(true));\n    }
@Test\n    public void getRootPackageWithRevTest() throws ParseException {\n        Date date = simpleDateFormat.parse(DATE2);\n        String rootPkgWithRev = getRootPackage((byte) 1, CHILD_PACKAGE, date, null);\n        assertThat(rootPkgWithRev.equals(\n                DEFAULT_BASE_PKG + PERIOD + VERSION_NUMBER + PERIOD + CHILD_WITH_PERIOD + PERIOD + DATE_WITH_REV2),\n                is(true));\n    }
@Test\n    public void addPackageInfoTest() throws IOException {\n\n        File dirPath = new File(CREATE_PATH);\n        dirPath.mkdirs();\n        addPackageInfo(dirPath, CHECK1, CREATE_PATH, false, getStubPluginConfig());\n        File filePath = new File(dirPath + File.separator + PKG_INFO);\n        assertThat(filePath.isFile(), is(true));\n    }
@Test\n    public void addPackageInfoTest() throws IOException {\n\n        File dirPath = new File(CREATE_PATH);\n        dirPath.mkdirs();\n        addPackageInfo(dirPath, CHECK1, CREATE_PATH, false);\n        File filePath = new File(dirPath + File.separator + PKG_INFO);\n        assertThat(filePath.isFile(), is(true));\n    }
@Test\n    public void testSetSuppressHost() throws Exception {\n        ImmutableSet.Builder<ConnectPoint> builder = ImmutableSet.builder();\n        builder.add(PORT_3);\n        config.setSuppressHost(builder.build());\n\n        Set<ConnectPoint> suppressHost = config.suppressHost();\n        assertNotNull("suppressHost should not be null", suppressHost);\n        assertThat(suppressHost.size(), is(1));\n        assertTrue(suppressHost.contains(PORT_3));\n    }
@Test\n  public void setSelectedDatabaseConnection() throws KettleDatabaseException {\n    AbstractSqoopJobEntryController controller = new TestSqoopJobEntryController();\n\n    String connect = "jdbc:bogus://bogus";\n    String username = "username";\n    String password = "password";\n    controller.getConfig().setConnect(connect);\n    controller.getConfig().setUsername(username);\n    controller.getConfig().setPassword(password);\n\n    String connectAdvanced = "jdbc:advanced://bogus";\n    String usernameAdvanced = "advanced_user";\n    String passwordAdvanced = "super password!";\n    controller.getConfig().setConnectFromAdvanced(connectAdvanced);\n    controller.getConfig().setUsernameFromAdvanced(usernameAdvanced);\n    controller.getConfig().setPasswordFromAdvanced(passwordAdvanced);\n\n    DatabaseItem test = new DatabaseItem("test");\n    DatabaseMeta database = new DatabaseMeta(test.getName(), "MYSQL", null, null, null, null, null, null);\n    controller.getJobMeta().addDatabase(database);\n    controller.setSelectedDatabaseConnection(test);\n\n    assertEquals(test, controller.getSelectedDatabaseConnection());\n    assertEquals(test.getName(), controller.getConfig().getDatabase());\n    assertEquals(database.getURL(), controller.getConfig().getConnect());\n    assertEquals(database.getUsername(), controller.getConfig().getUsername());\n    assertEquals(database.getPassword(), controller.getConfig().getPassword());\n\n    assertEquals(connectAdvanced, controller.getConfig().getConnectFromAdvanced());\n    assertEquals(usernameAdvanced, controller.getConfig().getUsernameFromAdvanced());\n    assertEquals(passwordAdvanced, controller.getConfig().getPasswordFromAdvanced());\n\n    controller.setSelectedDatabaseConnection(controller.USE_ADVANCED_OPTIONS);\n    assertEquals(controller.USE_ADVANCED_OPTIONS, controller.getSelectedDatabaseConnection());\n    assertNull(controller.getConfig().getDatabase());\n    assertEquals(connectAdvanced, controller.getConfig().getConnect());\n    assertEquals(usernameAdvanced, controller.getConfig().getUsername());\n    assertEquals(passwordAdvanced, controller.getConfig().getPassword());\n    assertEquals(connectAdvanced, controller.getConfig().getConnectFromAdvanced());\n    assertEquals(usernameAdvanced, controller.getConfig().getUsernameFromAdvanced());\n    assertEquals(passwordAdvanced, controller.getConfig().getPasswordFromAdvanced());\n\n    controller.setSelectedDatabaseConnection(test);\n    assertEquals(test, controller.getSelectedDatabaseConnection());\n    assertEquals(test.getName(), controller.getConfig().getDatabase());\n    assertEquals(database.getURL(), controller.getConfig().getConnect());\n    assertEquals(database.getUsername(), controller.getConfig().getUsername());\n    assertEquals(database.getPassword(), controller.getConfig().getPassword());\n\n    assertEquals(connectAdvanced, controller.getConfig().getConnectFromAdvanced());\n    assertEquals(usernameAdvanced, controller.getConfig().getUsernameFromAdvanced());\n    assertEquals(passwordAdvanced, controller.getConfig().getPasswordFromAdvanced());\n  }
@Test\n    public void testConcat() throws Exception {\n        final String context = "Concat";\n        try (Storage s = createStorage()) {\n            s.initialize(DEFAULT_EPOCH);\n            HashMap<String, ByteArrayOutputStream> appendData = populate(s, context);\n\n            // Check invalid segment name.\n            val firstSegmentName = getSegmentName(0, context);\n            val firstSegmentHandle = s.openWrite(firstSegmentName).join();\n            AtomicLong firstSegmentLength = new AtomicLong(s.getStreamSegmentInfo(firstSegmentName,\n                    TIMEOUT).join().getLength());\n            assertThrows("concat() did not throw for non-existent target segment name.",\n                    () -> s.concat(createHandle("foo1", false, DEFAULT_EPOCH), 0, firstSegmentName, TIMEOUT),\n                    ex -> ex instanceof StreamSegmentNotExistsException);\n\n            assertThrows("concat() did not throw for invalid source StreamSegment name.",\n                    () -> s.concat(firstSegmentHandle, firstSegmentLength.get(), "foo2", TIMEOUT),\n                    ex -> ex instanceof StreamSegmentNotExistsException);\n\n            ArrayList<String> concatOrder = new ArrayList<>();\n            concatOrder.add(firstSegmentName);\n            for (String sourceSegment : appendData.keySet()) {\n                if (sourceSegment.equals(firstSegmentName)) {\n                    // FirstSegment is where we\'ll be concatenating to.\n                    continue;\n                }\n\n                assertThrows("Concat allowed when source segment is not sealed.",\n                        () -> s.concat(firstSegmentHandle, firstSegmentLength.get(), sourceSegment, TIMEOUT),\n                        ex -> ex instanceof IllegalStateException);\n\n                // Seal the source segment and then re-try the concat\n                val sourceWriteHandle = s.openWrite(sourceSegment).join();\n                s.seal(sourceWriteHandle, TIMEOUT).join();\n                SegmentProperties preConcatTargetProps = s.getStreamSegmentInfo(firstSegmentName, TIMEOUT).join();\n                SegmentProperties sourceProps = s.getStreamSegmentInfo(sourceSegment, TIMEOUT).join();\n\n                s.concat(firstSegmentHandle, firstSegmentLength.get(), sourceSegment, TIMEOUT).join();\n                concatOrder.add(sourceSegment);\n                SegmentProperties postConcatTargetProps = s.getStreamSegmentInfo(firstSegmentName, TIMEOUT).join();\n                Assert.assertFalse("concat() did not delete source segment", s.exists(sourceSegment, TIMEOUT).join());\n\n                // Only check lengths here; we\'ll check the contents at the end.\n                Assert.assertEquals("Unexpected target StreamSegment.length after concatenation.",\n                        preConcatTargetProps.getLength() + sourceProps.getLength(), postConcatTargetProps.getLength());\n                firstSegmentLength.set(postConcatTargetProps.getLength());\n            }\n\n            // Check the contents of the first StreamSegment. We already validated that the length is correct.\n            SegmentProperties segmentProperties = s.getStreamSegmentInfo(firstSegmentName, TIMEOUT).join();\n            byte[] readBuffer = new byte[(int) segmentProperties.getLength()];\n\n            // Read the entire StreamSegment.\n            int bytesRead = s.read(firstSegmentHandle, 0, readBuffer, 0, readBuffer.length, TIMEOUT).join();\n            Assert.assertEquals("Unexpected number of bytes read.", readBuffer.length, bytesRead);\n\n            // Check, concat-by-concat, that the final data is correct.\n            int offset = 0;\n            for (String segmentName : concatOrder) {\n                byte[] concatData = appendData.get(segmentName).toByteArray();\n                AssertExtensions.assertArrayEquals("Unexpected concat data.", concatData, 0, readBuffer, offset,\n                        concatData.length);\n                offset += concatData.length;\n            }\n\n            Assert.assertEquals("Concat included more bytes than expected.", offset, readBuffer.length);\n        }\n    }
@Test\n    public void testRemoveFinishedWrites() {\n        final int timeIncrement = 1234 * 1000; // Just over 1ms.\n        AtomicLong time = new AtomicLong();\n        val q = new WriteQueue(MAX_PARALLELISM, time::get);\n\n        val writes = new ArrayDeque<Write>();\n        for (int i = 0; i < ITEM_COUNT; i++) {\n            time.addAndGet(timeIncrement);\n            val w = new Write(new ByteArraySegment(new byte[i]), new TestWriteLedger(i), new CompletableFuture<>());\n            if (i % 2 == 0) {\n                // Complete 1 out of two writes.\n                w.setEntryId(i);\n                w.complete();\n            }\n\n            q.add(w);\n            writes.addLast(w);\n        }\n\n        while (!writes.isEmpty()) {\n            val write = writes.pollFirst();\n            if (!write.isDone()) {\n                val result1 = q.removeFinishedWrites();\n                AssertExtensions.assertContainsSameElements("Unexpected value from removeFinishedWrites when there were writes left in the queue.",\n                        EnumSet.of(WriteQueue.CleanupStatus.QueueNotEmpty), result1);\n                val stats1 = q.getStatistics();\n                Assert.assertEquals("Unexpected size after removeFinishedWrites with no effect.", writes.size() + 1, stats1.getSize());\n\n                // Complete this write.\n                write.setEntryId(time.get());\n                write.complete();\n            }\n\n            // Estimate the Expected elapsed time based on the removals.\n            long expectedElapsed = write.getTimestamp();\n            int removed = 1;\n            while (!writes.isEmpty() && writes.peekFirst().isDone()) {\n                expectedElapsed += writes.pollFirst().getTimestamp();\n                removed++;\n            }\n            expectedElapsed = (time.get() * removed - expectedElapsed) / AbstractTimer.NANOS_TO_MILLIS / removed;\n\n            val result2 = q.removeFinishedWrites();\n            val expectedResult = EnumSet.of(writes.isEmpty() ? WriteQueue.CleanupStatus.QueueEmpty : WriteQueue.CleanupStatus.QueueNotEmpty);\n            AssertExtensions.assertContainsSameElements("Unexpected result from removeFinishedWrites.", expectedResult, result2);\n            val stats2 = q.getStatistics();\n            Assert.assertEquals("Unexpected size after removeFinishedWrites.", writes.size(), stats2.getSize());\n            Assert.assertEquals("Unexpected getExpectedProcessingTimeMillis after clear.", expectedElapsed, stats2.getExpectedProcessingTimeMillis());\n        }\n\n        // Verify that it does report failed writes when encountered.\n        val w3 = new Write(new ByteArraySegment(new byte[1]), new TestWriteLedger(0), new CompletableFuture<>());\n        q.add(w3);\n        w3.fail(new IntentionalException(), true);\n        val result3 = q.removeFinishedWrites();\n        AssertExtensions.assertContainsSameElements("Unexpected value from removeFinishedWrites when there were failed writes.",\n                EnumSet.of(WriteQueue.CleanupStatus.QueueEmpty, WriteQueue.CleanupStatus.WriteFailed), result3);\n\n    }
@Test\n\tpublic void createUserWithInvalidLoginName() {\n\t\tUser user = UserData.randomUser();\n\t\tUserDTO userDTO = BeanMapper.map(user, UserDTO.class);\n\n\t\t//登录名为空\n\t\tuserDTO.setLoginName(null);\n\t\tIdResult response = accountWebServiceClient.createUser(userDTO);\n\t\tassertEquals(WSResult.PARAMETER_ERROR, response.getCode());\n\n\t\t//登录名重复\n\t\tuserDTO.setLoginName("user");\n\t\tresponse = accountWebServiceClient.createUser(userDTO);\n\t\tassertEquals(WSResult.PARAMETER_ERROR, response.getCode());\n\t}
@Test\n\t@Category(Smoke.class)\n\tpublic void getUser() {\n\t\tGetUserResult response = accountWebServiceClient.getUser(1L);\n\t\tassertEquals("admin", response.getUser().getLoginName());\n\t}
@Test\n    public void changeReplicationFactor_missingExecutable(TestContext context) {\n        MockAdminClient adminClient = new MockAdminClient();\n        Vertx vertx = Vertx.vertx();\n        Topic topic = new Topic.Builder("changeReplicationFactor", 2, (short) 2, emptyMap()).build();\n        String[] partitions = new String[]{"changeReplicationFactor-0", "changeReplicationFactor-1"};\n        final String doesNotExist = "/some/executable/that/does/not/exist";\n        Subclass sub = new Subclass(adminClient, vertx, config, doesNotExist, asList(\n                Subclass.generate("{\\"version\\":1,\\"partitions\\":[{\\"topic\\":\\"test-topic\\",\\"partition\\":0,\\"replicas\\":[0],\\"log_dirs\\":[\\"any\\"]},{\\"topic\\":\\"test-topic\\",\\"partition\\":1,\\"replicas\\":[0],\\"log_dirs\\":[\\"any\\"]}]}",\n                        "{\\"version\\":1,\\"partitions\\":[{\\"topic\\":\\"test-topic\\",\\"partition\\":0,\\"replicas\\":[0],\\"log_dirs\\":[\\"any\\"]},{\\"topic\\":\\"test-topic\\",\\"partition\\":1,\\"replicas\\":[0],\\"log_dirs\\":[\\"any\\"]}]}"),\n                Subclass.executeStarted(),\n                Subclass.verifyInProgress(partitions),\n                Subclass.verifySuccess(partitions)));\n        Async async = context.async();\n        sub.changeReplicationFactor(topic).setHandler(ar -> {\n            context.assertFalse(ar.succeeded());\n            final String message = ar.cause().getMessage();\n            context.assertTrue(message.contains("lacks an executable arg[0]")\n                    && message.contains("/some/executable/that/does/not/exist"));\n            async.complete();\n        });\n    }
@Test\n    public void changeReplicationFactor(TestContext context) {\n        MockAdminClient adminClient = new MockAdminClient();\n        Vertx vertx = Vertx.vertx();\n        Topic topic = new Topic.Builder("changeReplicationFactor", 2, (short) 2, emptyMap()).build();\n        String[] partitions = new String[]{"changeReplicationFactor-0", "changeReplicationFactor-1"};\n        Subclass sub = new Subclass(adminClient, vertx, config, asList(\n                Subclass.generate("{\\"version\\":1,\\"partitions\\":[{\\"topic\\":\\"test-topic\\",\\"partition\\":0,\\"replicas\\":[0],\\"log_dirs\\":[\\"any\\"]},{\\"topic\\":\\"test-topic\\",\\"partition\\":1,\\"replicas\\":[0],\\"log_dirs\\":[\\"any\\"]}]}",\n                        "{\\"version\\":1,\\"partitions\\":[{\\"topic\\":\\"test-topic\\",\\"partition\\":0,\\"replicas\\":[0],\\"log_dirs\\":[\\"any\\"]},{\\"topic\\":\\"test-topic\\",\\"partition\\":1,\\"replicas\\":[0],\\"log_dirs\\":[\\"any\\"]}]}"),\n                Subclass.executeStarted(),\n                Subclass.verifyInProgress(partitions),\n                Subclass.verifySuccess(partitions)));\n        Async async = context.async();\n        sub.changeReplicationFactor(topic).setHandler(ar -> {\n            context.assertTrue(ar.succeeded());\n            async.complete();\n        });\n    }
@Test\n    public void changeReplicationFactor_ExecuteFail(TestContext context) {\n        MockAdminClient adminClient = new MockAdminClient();\n        Vertx vertx = Vertx.vertx();\n        Topic topic = new Topic.Builder("changeReplicationFactor", 2, (short) 2, emptyMap()).build();\n        String[] partitions = new String[]{"changeReplicationFactor-0", "changeReplicationFactor-1"};\n        Subclass sub = new Subclass(adminClient, vertx, config, asList(\n                Subclass.generate("{\\"version\\":1,\\"partitions\\":[{\\"topic\\":\\"test-topic\\",\\"partition\\":0,\\"replicas\\":[0],\\"log_dirs\\":[\\"any\\"]},{\\"topic\\":\\"test-topic\\",\\"partition\\":1,\\"replicas\\":[0],\\"log_dirs\\":[\\"any\\"]}]}",\n                        "{\\"version\\":1,\\"partitions\\":[{\\"topic\\":\\"test-topic\\",\\"partition\\":0,\\"replicas\\":[0],\\"log_dirs\\":[\\"any\\"]},{\\"topic\\":\\"test-topic\\",\\"partition\\":1,\\"replicas\\":[0],\\"log_dirs\\":[\\"any\\"]}]}"),\n                Subclass.executeFail("Bang!"),\n                Subclass.executeStarted(),\n                Subclass.verifyInProgress(partitions),\n                Subclass.verifySuccess(partitions)));\n        Async async = context.async();\n        sub.changeReplicationFactor(topic).setHandler(ar -> {\n            context.assertFalse(ar.succeeded());\n            context.assertTrue(ar.cause().getMessage().contains("Failed to reassign partitions"));\n            async.complete();\n        });\n    }
@Test\n   public void testGetCpu() throws PerfMonException\n   {\n      System.out.println("getCpu");\n      prepareTestData(123);\n      double result = instance.getCpu();\n      System.out.println(result);\n      assertTrue(result >= 0);\n   }
@Test\n    public void testGetEnvMap(){\n        LOGGER.debug(JsonUtil.format(SystemUtil.getEnvMap()));\n    }
@Test\n    public final void getResponseBodyAsString(){\n        String templateFile = "http://10.8.25.80:6666/template.csv?sign=123456";\n\n        ConnectionConfig connectionConfig = new ConnectionConfig();\n        connectionConfig.setContentCharset(CharsetType.GBK);\n\n        String responseBodyAsString = URLConnectionUtil.getResponseBodyAsString(templateFile, connectionConfig);\n        LOGGER.info(responseBodyAsString);\n    }
@Test\n    public void testJoinValues(){\n        String value = "create_salesorder";\n        String value2 = "unionpay_mobile";\n\n        Map<String, String> map = new HashMap<String, String>();\n        map.put("service", value);\n        map.put("paymentType", value2);\n\n        assertEquals(StringUtils.EMPTY, ParamUtil.joinValuesOrderByIncludeKeys(map, "a", "b"));\n        assertEquals(value, ParamUtil.joinValuesOrderByIncludeKeys(map, "service"));\n        assertEquals(value + value2, ParamUtil.joinValuesOrderByIncludeKeys(map, "service", "paymentType"));\n        assertEquals(value2 + value, ParamUtil.joinValuesOrderByIncludeKeys(map, "paymentType", "service"));\n    }
@Test\n    public void testCollectionToString(){\n        List<String> list = new ArrayList<String>();\n        list.add("2548");\n        list.add("");\n\n        ToStringConfig toStringConfig = new ToStringConfig(",");\n        toStringConfig.setIsJoinNullOrEmpty(false);\n\n        assertEquals("2548", ConvertUtil.toString(toStringConfig, list));\n    }
@Test\n    public void testCollectionToString1(){\n        List<String> list = new ArrayList<String>();\n        list.add("2548");\n        list.add("2548");\n        list.add("2548");\n        list.add("2548");\n        list.add("2548");\n        list.add("2548");\n\n        ToStringConfig toStringConfig = new ToStringConfig(SystemUtils.LINE_SEPARATOR);\n        LOGGER.debug(ConvertUtil.toString(toStringConfig, list));\n    }
@Test\n    public void getConcreteMembers_isCorrect() throws Exception {\n        Element genericElement = Utils.getElementFromClass(DummyGenericClass.class);\n        assertNotNull(genericElement);\n        Map<Element, TypeMirror> genericMembers = new HashMap<>();\n        for (Element element : genericElement.getEnclosedElements()) {\n            if (element instanceof VariableElement) {\n                genericMembers.put(element, element.asType());\n            }\n        }\n\n        TypeMirror concreteType =\n                TypeUtils.getInheritedType(Utils.getElementFromClass(DummyInheritedClass.class));\n\n        assertNotNull(concreteType);\n\n        TypeMirror genericType = Utils.getGenericVersionOfClass(DummyGenericClass.class);\n\n        assertNotNull(genericType);\n\n        LinkedHashMap<Element, TypeMirror> members =\n                TypeUtils.getConcreteMembers(concreteType, (TypeElement) types.asElement(genericType), genericMembers);\n\n\n        TypeMirror stringType = Utils.getTypeMirrorFromClass(String.class);\n        assertNotNull(stringType);\n\n        for (Entry<Element, TypeMirror> entry : members.entrySet()) {\n            if (entry.getKey().getSimpleName().contentEquals("testObject")) {\n\n                assertTrue(entry.getValue().toString().equals(stringType.toString()));\n\n            } else if (entry.getKey().getSimpleName().contentEquals("testList")) {\n\n                assertTrue(entry.getValue()\n                                   .toString()\n                                   .equals(types.getDeclaredType(Utils.getElementFromClass(ArrayList.class),\n                                           stringType).toString()));\n\n            } else if (entry.getKey().getSimpleName().contentEquals("testMap")) {\n\n                assertTrue(entry.getValue()\n                                   .toString()\n                                   .equals(types.getDeclaredType(Utils.getElementFromClass(HashMap.class), stringType,\n                                                                 stringType).toString()));\n\n            } else if (entry.getKey().getSimpleName().contentEquals("testSet")) {\n\n                assertTrue(entry.getValue()\n                                   .toString()\n                                   .equals(types.getDeclaredType(Utils.getElementFromClass(HashSet.class), stringType)\n                                                   .toString()));\n            } else if (entry.getKey().getSimpleName().contentEquals("testArrayMap")) {\n                TypeMirror listString = types.getDeclaredType(Utils.getElementFromClass(List.class), stringType);\n\n                assertTrue(entry.getValue()\n                        .toString()\n                        .equals(types.getDeclaredType(Utils.getElementFromClass(HashMap.class), stringType, listString)\n                                .toString()));\n            } else if (entry.getKey().getSimpleName().contentEquals("testListMap")) {\n                TypeMirror mapStringString = types.getDeclaredType(Utils.getElementFromClass(Map.class), stringType, stringType);\n                assertTrue(entry.getValue()\n                        .toString()\n                        .equals(types.getDeclaredType(Utils.getElementFromClass(ArrayList.class), mapStringString)\n                                .toString()));\n            }\n        }\n    }
@Test\n  public void testCreateClassifier() throws InterruptedException, FileNotFoundException {\n    server.enqueue(jsonResponse(classifier));\n    File metadata = new File(RESOURCE + "metadata.json");\n    File trainingData = new File(RESOURCE + "weather_data_train.csv");\n    CreateClassifierOptions createOptions = new CreateClassifierOptions.Builder()\n        .metadata(metadata)\n        .trainingData(trainingData)\n        .trainingDataFilename("weather_data_train.csv")\n        .build();\n    final Classifier response = service.createClassifier(createOptions).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals(CLASSIFIERS_PATH, request.getPath());\n    assertEquals(classifier, response);\n  }
@Test(expected = FileNotFoundException.class)\n  public void testNullTrainingDataFile() throws FileNotFoundException {\n    server.enqueue(jsonResponse(classifier));\n    File metadata = new File(RESOURCE + "metadata.json");\n    File trainingData = new File(RESOURCE + "notfound.txt");\n    CreateClassifierOptions createOptions = new CreateClassifierOptions.Builder()\n        .metadata(metadata)\n        .trainingData(trainingData)\n        .trainingDataFilename("notfound.txt")\n        .build();\n    service.createClassifier(createOptions).execute();\n  }
@Test(expected = IllegalArgumentException.class)\n  public void testNullClassifier() {\n    ClassifyOptions classifyOptions = new ClassifyOptions.Builder()\n        .text("test")\n        .build();\n    service.classify(classifyOptions);\n  }
@Test(expected = IllegalArgumentException.class)\n  public void testNullText() {\n    ClassifyOptions classifyOptions = new ClassifyOptions.Builder()\n        .classifierId(classifierId)\n        .build();\n    service.classify(classifyOptions);\n  }
@Test(expected = IllegalArgumentException.class)\n  public void testNullDeleteClassifier() {\n    DeleteClassifierOptions deleteOptions = new DeleteClassifierOptions.Builder()\n        .build();\n    service.deleteClassifier(deleteOptions);\n  }
@Test\n  public void testSynthesize() {\n    final File audio = new File("src/test/resources/speech_to_text/sample1.wav");\n\n    try {\n      final List<Parameter> parameters = new ArrayList<Parameter>();\n      parameters.add(new Parameter("text", text));\n      parameters.add(new Parameter("voice", Voice.EN_LISA.getName()));\n      parameters.add(new Parameter("accept", HttpMediaType.AUDIO_WAV));\n\n      mockServer.when(request().withQueryStringParameters(parameters).withPath(SYNTHESIZE_PATH))\n          .respond(\n              response().withHeaders(\n                  new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.AUDIO_WAV)).withBody(\n                  Files.toByteArray(audio)));\n\n      final InputStream in = service.synthesize(text, Voice.EN_LISA, HttpMediaType.AUDIO_WAV).execute();\n      Assert.assertNotNull(in);\n\n      writeInputStreamToOutputStream(in, new FileOutputStream("target/output.wav"));\n\n    } catch (final FileNotFoundException e) {\n      Assert.fail(e.getMessage());\n    } catch (final IOException e) {\n      Assert.fail(e.getMessage());\n    }\n  }
@Test\n  public void testGetModel() {\n\n    final SpeechModel speechModel = new SpeechModel("not-a-real-Model");\n    speechModel.setRate(8000);\n\n    mockServer.when(request().withPath(GET_MODELS_PATH + "/" + speechModel.getName())).respond(\n        response().withHeaders(\n            new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.APPLICATION_JSON)).withBody(\n            GsonSingleton.getGsonWithoutPrettyPrinting().toJson(speechModel)));\n\n\n    SpeechModel model = service.getModel("not-a-real-Model").execute();\n    Assert.assertNotNull(model);\n    Assert.assertEquals(model, speechModel);\n\n    model = service.getModel(speechModel.getName()).execute();\n    Assert.assertNotNull(model);\n    Assert.assertEquals(model, speechModel);\n\n    try {\n      TestUtils.assertNoExceptionsOnGetters(model);\n    } catch (final Exception e) {\n      Assert.fail(e.getMessage());\n    }\n  }
@Test\n  public void testRecognizeMissingAudioFile() throws URISyntaxException {\n\n    final SpeechResults speechResults = new SpeechResults();\n    speechResults.setResultIndex(0);\n\n    final Transcript transcript = new Transcript();\n    transcript.setFinal(true);\n\n    final SpeechAlternative speechAlternative = new SpeechAlternative();\n    speechAlternative\n        .setTranscript("thunderstorms could produce large hail isolated tornadoes and heavy rain");\n\n    final List<SpeechAlternative> speechAlternatives = new ArrayList<SpeechAlternative>();\n    speechAlternatives.add(speechAlternative);\n\n    transcript.setAlternatives(speechAlternatives);\n    final List<Transcript> transcripts = new ArrayList<Transcript>();\n    transcripts.add(transcript);\n    speechResults.setResults(transcripts);\n\n    // File audio = new File("src/test/resources/sample1.wav");\n\n    mockServer.when(\n        request().withMethod("POST").withPath(RECOGNIZE_PATH)\n            .withHeaders(new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.AUDIO_WAV)))\n        .respond(\n            response().withHeader(APPLICATION_JSON).withBody(\n                GsonSingleton.getGsonWithoutPrettyPrinting().toJson(speechResults)));\n\n    boolean didItHappen = false;\n    try {\n      service.recognize(null).execute();\n    } catch (final IllegalArgumentException e) {\n      didItHappen = true;\n    }\n    Assert.assertTrue("Check that \'IllegalArgumentException\' is thrown.", didItHappen);\n  }
@Test\n  public void testGetVoices() {\n\n    final Map<String, Object> response = new HashMap<String, Object>();\n    final List<Voice> voices = new ArrayList<Voice>();\n    final Voice voice = new Voice();\n    voice.setUrl("http://ibm.watson.com/text-to-speech/voices/en-US_TestMaleVoice");\n    voice.setName("en-US_TestMaleVoice");\n    voice.setGender("male");\n    voice.setLanguage("en-US");\n    voice.setDescription("TestMale");\n\n    final Voice voice1 = new Voice();\n    voice1.setUrl("http://ibm.watson.com/text-to-speech/voices/en-US_TestFemaleVoice");\n    voice1.setName("en-US_TestFemaleVoice");\n    voice1.setGender("female");\n    voice1.setLanguage("en-US");\n    voice1.setDescription("TestFemale");\n\n    voices.add(voice);\n    voices.add(voice1);\n\n    response.put("voices", voices);\n\n    mockServer.when(request().withPath(GET_VOICES_PATH)).respond(\n        response().withHeaders(\n            new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.APPLICATION_JSON)).withBody(\n            GsonSingleton.getGsonWithoutPrettyPrinting().toJson(response)));\n\n    final List<Voice> result = service.getVoices().execute();\n    Assert.assertNotNull(result);\n    Assert.assertFalse(result.isEmpty());\n    Assert.assertEquals(result, voices);\n  }
@Test\n  public void testDeleteCorpus() throws InterruptedException, FileNotFoundException {\n    String id = "foo";\n    String corpus = "cName";\n\n    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody("{}"));\n\n    DeleteCorpusOptions deleteOptions = new DeleteCorpusOptions.Builder()\n        .customizationId(id)\n        .corpusName(corpus)\n        .build();\n    service.deleteCorpus(deleteOptions).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals("DELETE", request.getMethod());\n    assertEquals(String.format(PATH_CORPUS, id, corpus), request.getPath());\n  }
@Test\n  public void testGetModels() throws InterruptedException {\n    final SpeechModel speechModel = new SpeechModel();\n    speechModel.setName("not-a-real-Model");\n    speechModel.setRate(8000);\n\n    final SpeechModel speechModel1 = new SpeechModel();\n    speechModel.setName("not-a-real-Model1");\n    speechModel1.setRate(1600);\n\n    final SpeechModel speechModel2 = new SpeechModel();\n    speechModel.setName("not-a-real-Model2");\n    speechModel2.setRate(8000);\n\n    final List<SpeechModel> speechModels = ImmutableList.of(speechModel, speechModel1, speechModel2);\n    final Map<String, ?> response = ImmutableMap.of("models", speechModels);\n\n    server.enqueue(\n        new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(response)));\n\n    final SpeechModels models = service.listModels().execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertNotNull(models);\n    assertFalse(models.getModels().isEmpty());\n    assertEquals(models.getModels(), response.get("models"));\n    assertEquals(PATH_MODELS, request.getPath());\n  }
@Test\n  public void testRecognize() throws URISyntaxException, InterruptedException {\n\n    final SpeechRecognitionResults speechResults = new SpeechRecognitionResults();\n    speechResults.setResultIndex(0);\n    final SpeechRecognitionResult transcript = new SpeechRecognitionResult();\n    transcript.setFinal(true);\n    final SpeechRecognitionAlternative speechAlternative = new SpeechRecognitionAlternative();\n    speechAlternative.setTranscript("thunderstorms could produce large hail isolated tornadoes and heavy rain");\n\n    final List<SpeechRecognitionAlternative> speechAlternatives = ImmutableList.of(speechAlternative);\n    transcript.setAlternatives(speechAlternatives);\n\n    final List<SpeechRecognitionResult> transcripts = ImmutableList.of(transcript);\n    speechResults.setResults(transcripts);\n\n    server.enqueue(\n        new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(speechResults)));\n\n    RecognizeOptions recognizeOptions = new RecognizeOptions.Builder()\n        .audio(SAMPLE_WAV)\n        .contentType(RecognizeOptions.ContentType.AUDIO_WAV)\n        .build();\n    final SpeechRecognitionResults result = service.recognize(recognizeOptions).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertNotNull(result);\n    assertEquals(result, speechResults);\n    assertEquals("POST", request.getMethod());\n    assertEquals(PATH_RECOGNIZE, request.getPath());\n    assertEquals(HttpMediaType.AUDIO_WAV, request.getHeader(CONTENT_TYPE));\n  }
@Test\n  public void testRecognizeWithCustomization() throws FileNotFoundException, InterruptedException {\n    String id = "foo";\n    String recString =\n        getStringFromInputStream(new FileInputStream("src/test/resources/speech_to_text/recognition.json"));\n    JsonObject recognition = new JsonParser().parse(recString).getAsJsonObject();\n\n    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(recString));\n\n    RecognizeOptions recognizeOptions = new RecognizeOptions.Builder()\n        .audio(SAMPLE_WAV)\n        .contentType(RecognizeOptions.ContentType.AUDIO_WAV)\n        .customizationId(id)\n        .build();\n    SpeechRecognitionResults result = service.recognize(recognizeOptions).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals("POST", request.getMethod());\n    assertEquals(PATH_RECOGNIZE + "?customization_id=" + id, request.getPath());\n    assertEquals(recognition, GSON.toJsonTree(result));\n  }
@Test\n  public void testCheckJobs() throws InterruptedException, FileNotFoundException {\n    String jobsAsString = getStringFromInputStream(new FileInputStream("src/test/resources/speech_to_text/jobs.json"));\n    JsonObject jobsAsJson = new JsonParser().parse(jobsAsString).getAsJsonObject();\n\n    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(jobsAsString));\n\n    RecognitionJobs result = service.checkJobs().execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals("GET", request.getMethod());\n    assertEquals(PATH_RECOGNITIONS, request.getPath());\n    assertEquals(jobsAsJson.get("recognitions"), GSON.toJsonTree(result.getRecognitions()));\n  }
@Test\n  public void testListLanguageModels() throws InterruptedException, FileNotFoundException {\n    String customizationsAsString =\n        getStringFromInputStream(new FileInputStream("src/test/resources/speech_to_text/customizations.json"));\n    JsonObject customizations = new JsonParser().parse(customizationsAsString).getAsJsonObject();\n\n    server.enqueue(\n        new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(customizationsAsString));\n\n    ListLanguageModelsOptions listOptions = new ListLanguageModelsOptions.Builder()\n        .language("en-us")\n        .build();\n    LanguageModels result = service.listLanguageModels(listOptions).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals("GET", request.getMethod());\n    assertEquals(PATH_CUSTOMIZATIONS + "?language=en-us", request.getPath());\n    assertEquals(customizations.get("customizations").getAsJsonArray().size(), result.getCustomizations().size());\n    assertEquals(customizations.get("customizations"), GSON.toJsonTree(result.getCustomizations()));\n  }
@Test\n  public void testGetLanguageModel() throws InterruptedException, FileNotFoundException {\n    String id = "foo";\n    LanguageModel model =\n        loadFixture("src/test/resources/speech_to_text/customization.json", LanguageModel.class);\n\n    server.enqueue(\n        new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(model)));\n\n    GetLanguageModelOptions getOptions = new GetLanguageModelOptions.Builder()\n        .customizationId(id)\n        .build();\n    LanguageModel result = service.getLanguageModel(getOptions).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals("GET", request.getMethod());\n    assertEquals(String.format(PATH_CUSTOMIZATION, id), request.getPath());\n    assertEquals(result.toString(), model.toString());\n  }
@Test\n  public void testCreateLanguageModel() throws InterruptedException, FileNotFoundException {\n    LanguageModel model =\n        loadFixture("src/test/resources/speech_to_text/customization.json", LanguageModel.class);\n\n    server.enqueue(\n        new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(model)));\n\n    CreateLanguageModel newModel = new CreateLanguageModel.Builder()\n        .name(model.getName())\n        .baseModelName("en-GB_BroadbandModel")\n        .description(model.getDescription())\n        .build();\n    CreateLanguageModelOptions createOptions = new CreateLanguageModelOptions.Builder()\n        .createLanguageModel(newModel)\n        .build();\n    LanguageModel result = service.createLanguageModel(createOptions).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals("POST", request.getMethod());\n    assertEquals(PATH_CUSTOMIZATIONS, request.getPath());\n    assertEquals(result.toString(), model.toString());\n  }
@Test\n  public void testDeleteLanguageModel() throws InterruptedException {\n    String id = "foo";\n\n    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody("{}"));\n\n    DeleteLanguageModelOptions deleteOptions = new DeleteLanguageModelOptions.Builder()\n        .customizationId(id)\n        .build();\n    service.deleteLanguageModel(deleteOptions).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals("DELETE", request.getMethod());\n    assertEquals(String.format(PATH_CUSTOMIZATION, id), request.getPath());\n  }
@Test\n  public void testListCorpora() throws InterruptedException, FileNotFoundException {\n    String id = "foo";\n    String corporaAsString =\n        getStringFromInputStream(new FileInputStream("src/test/resources/speech_to_text/corpora.json"));\n    JsonObject corpora = new JsonParser().parse(corporaAsString).getAsJsonObject();\n\n    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(corporaAsString));\n\n    ListCorporaOptions listOptions = new ListCorporaOptions.Builder()\n        .customizationId(id)\n        .build();\n    Corpora result = service.listCorpora(listOptions).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals("GET", request.getMethod());\n    assertEquals(String.format(PATH_CORPORA, id), request.getPath());\n    assertEquals(corpora.get("corpora"), GSON.toJsonTree(result.getCorpora()));\n  }
@Test\n  public void testListWords() throws InterruptedException, FileNotFoundException {\n    String id = "foo";\n    String wordsAsStr = getStringFromInputStream(new FileInputStream("src/test/resources/speech_to_text/words.json"));\n    JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject();\n\n    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr));\n\n    ListWordsOptions listOptions = new ListWordsOptions.Builder()\n        .customizationId(id)\n        .build();\n    Words result = service.listWords(listOptions).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals("GET", request.getMethod());\n    assertEquals(String.format(PATH_WORDS, id), request.getPath());\n    assertEquals(words.get("words"), GSON.toJsonTree(result.getWords()));\n  }
@Test\n  public void testListWordsType() throws InterruptedException, FileNotFoundException {\n    String id = "foo";\n    String wordsAsStr = getStringFromInputStream(new FileInputStream("src/test/resources/speech_to_text/words.json"));\n    JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject();\n\n    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr));\n\n    ListWordsOptions listOptions = new ListWordsOptions.Builder()\n        .customizationId(id)\n        .wordType(ListWordsOptions.WordType.ALL)\n        .build();\n    Words result = service.listWords(listOptions).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals("GET", request.getMethod());\n    assertEquals(String.format(PATH_WORDS, id) + "?word_type=all", request.getPath());\n    assertEquals(words.get("words"), GSON.toJsonTree(result.getWords()));\n  }
@Test\n  public void testListWordsSort() throws InterruptedException, FileNotFoundException {\n    String id = "foo";\n    String wordsAsStr = getStringFromInputStream(new FileInputStream("src/test/resources/speech_to_text/words.json"));\n    JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject();\n\n    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr));\n\n    ListWordsOptions listOptions = new ListWordsOptions.Builder()\n        .customizationId(id)\n        .sort(ListWordsOptions.Sort.ALPHABETICAL)\n        .build();\n    Words result = service.listWords(listOptions).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals("GET", request.getMethod());\n    assertEquals(String.format(PATH_WORDS, id) + "?sort=alphabetical", request.getPath());\n    assertEquals(words.get("words"), GSON.toJsonTree(result.getWords()));\n  }
@Test\n  public void testListWordsTypeSort() throws InterruptedException, FileNotFoundException {\n    String id = "foo";\n    String wordsAsStr = getStringFromInputStream(new FileInputStream("src/test/resources/speech_to_text/words.json"));\n    JsonObject words = new JsonParser().parse(wordsAsStr).getAsJsonObject();\n\n    server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(wordsAsStr));\n\n    ListWordsOptions listOptions = new ListWordsOptions.Builder()\n        .customizationId(id)\n        .sort(ListWordsOptions.Sort.ALPHABETICAL)\n        .wordType(ListWordsOptions.WordType.ALL)\n        .build();\n    Words result = service.listWords(listOptions).execute();\n    final RecordedRequest request = server.takeRequest();\n\n    assertEquals("GET", request.getMethod());\n    assertEquals(String.format(PATH_WORDS, id) + "?word_type=all&sort=alphabetical", request.getPath());\n    assertEquals(words.get("words"), GSON.toJsonTree(result.getWords()));\n  }
